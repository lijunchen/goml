var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var require_stdin = __commonJS({
  "<stdin>"(exports, module) {
    (async () => {
      var _a2, _b2, _c, _d, _e, _f2, _g2, _h2, _i, _j2, _k2, _l2, _m, _n2, _o, _p2, _q2, _r2, _s2, _t2;
      (function() {
        const e = document.createElement("link").relList;
        if (e && e.supports && e.supports("modulepreload")) return;
        for (const n of document.querySelectorAll('link[rel="modulepreload"]')) i(n);
        new MutationObserver((n) => {
          for (const o of n) if (o.type === "childList") for (const r of o.addedNodes) r.tagName === "LINK" && r.rel === "modulepreload" && i(r);
        }).observe(document, {
          childList: true,
          subtree: true
        });
        function t(n) {
          const o = {};
          return n.integrity && (o.integrity = n.integrity), n.referrerPolicy && (o.referrerPolicy = n.referrerPolicy), n.crossOrigin === "use-credentials" ? o.credentials = "include" : n.crossOrigin === "anonymous" ? o.credentials = "omit" : o.credentials = "same-origin", o;
        }
        function i(n) {
          if (n.ep) return;
          n.ep = true;
          const o = t(n);
          fetch(n.href, o);
        }
      })();
      function dH(s) {
        return s && s.__esModule && Object.prototype.hasOwnProperty.call(s, "default") ? s.default : s;
      }
      var eL = {
        exports: {}
      }, Em = {};
      var n4;
      function fH() {
        if (n4) return Em;
        n4 = 1;
        var s = Symbol.for("react.transitional.element"), e = Symbol.for("react.fragment");
        function t(i, n, o) {
          var r = null;
          if (o !== void 0 && (r = "" + o), n.key !== void 0 && (r = "" + n.key), "key" in n) {
            o = {};
            for (var a in n) a !== "key" && (o[a] = n[a]);
          } else o = n;
          return n = o.ref, {
            $$typeof: s,
            type: i,
            key: r,
            ref: n !== void 0 ? n : null,
            props: o
          };
        }
        return Em.Fragment = e, Em.jsx = t, Em.jsxs = t, Em;
      }
      var s4;
      function gH() {
        return s4 || (s4 = 1, eL.exports = fH()), eL.exports;
      }
      var Ei = gH(), tL = {
        exports: {}
      }, Tt = {};
      var o4;
      function mH() {
        if (o4) return Tt;
        o4 = 1;
        var s = Symbol.for("react.transitional.element"), e = Symbol.for("react.portal"), t = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), n = Symbol.for("react.profiler"), o = Symbol.for("react.consumer"), r = Symbol.for("react.context"), a = Symbol.for("react.forward_ref"), l = Symbol.for("react.suspense"), u = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), f = Symbol.iterator;
        function m(W) {
          return W === null || typeof W != "object" ? null : (W = f && W[f] || W["@@iterator"], typeof W == "function" ? W : null);
        }
        var _ = {
          isMounted: function() {
            return false;
          },
          enqueueForceUpdate: function() {
          },
          enqueueReplaceState: function() {
          },
          enqueueSetState: function() {
          }
        }, b = Object.assign, v = {};
        function y(W, ne, xe) {
          this.props = W, this.context = ne, this.refs = v, this.updater = xe || _;
        }
        y.prototype.isReactComponent = {}, y.prototype.setState = function(W, ne) {
          if (typeof W != "object" && typeof W != "function" && W != null) throw Error("takes an object of state variables to update or a function which returns an object of state variables.");
          this.updater.enqueueSetState(this, W, ne, "setState");
        }, y.prototype.forceUpdate = function(W) {
          this.updater.enqueueForceUpdate(this, W, "forceUpdate");
        };
        function x() {
        }
        x.prototype = y.prototype;
        function L(W, ne, xe) {
          this.props = W, this.context = ne, this.refs = v, this.updater = xe || _;
        }
        var D = L.prototype = new x();
        D.constructor = L, b(D, y.prototype), D.isPureReactComponent = true;
        var k = Array.isArray, T = {
          H: null,
          A: null,
          T: null,
          S: null,
          V: null
        }, M = Object.prototype.hasOwnProperty;
        function I(W, ne, xe, ye, Ae, Ve) {
          return xe = Ve.ref, {
            $$typeof: s,
            type: W,
            key: ne,
            ref: xe !== void 0 ? xe : null,
            props: Ve
          };
        }
        function R(W, ne) {
          return I(W.type, ne, void 0, void 0, void 0, W.props);
        }
        function A(W) {
          return typeof W == "object" && W !== null && W.$$typeof === s;
        }
        function Y(W) {
          var ne = {
            "=": "=0",
            ":": "=2"
          };
          return "$" + W.replace(/[=:]/g, function(xe) {
            return ne[xe];
          });
        }
        var U = /\/+/g;
        function j(W, ne) {
          return typeof W == "object" && W !== null && W.key != null ? Y("" + W.key) : ne.toString(36);
        }
        function ee() {
        }
        function K(W) {
          switch (W.status) {
            case "fulfilled":
              return W.value;
            case "rejected":
              throw W.reason;
            default:
              switch (typeof W.status == "string" ? W.then(ee, ee) : (W.status = "pending", W.then(function(ne) {
                W.status === "pending" && (W.status = "fulfilled", W.value = ne);
              }, function(ne) {
                W.status === "pending" && (W.status = "rejected", W.reason = ne);
              })), W.status) {
                case "fulfilled":
                  return W.value;
                case "rejected":
                  throw W.reason;
              }
          }
          throw W;
        }
        function te(W, ne, xe, ye, Ae) {
          var Ve = typeof W;
          (Ve === "undefined" || Ve === "boolean") && (W = null);
          var We = false;
          if (W === null) We = true;
          else switch (Ve) {
            case "bigint":
            case "string":
            case "number":
              We = true;
              break;
            case "object":
              switch (W.$$typeof) {
                case s:
                case e:
                  We = true;
                  break;
                case d:
                  return We = W._init, te(We(W._payload), ne, xe, ye, Ae);
              }
          }
          if (We) return Ae = Ae(W), We = ye === "" ? "." + j(W, 0) : ye, k(Ae) ? (xe = "", We != null && (xe = We.replace(U, "$&/") + "/"), te(Ae, ne, xe, "", function(hn) {
            return hn;
          })) : Ae != null && (A(Ae) && (Ae = R(Ae, xe + (Ae.key == null || W && W.key === Ae.key ? "" : ("" + Ae.key).replace(U, "$&/") + "/") + We)), ne.push(Ae)), 1;
          We = 0;
          var xi = ye === "" ? "." : ye + ":";
          if (k(W)) for (var ct = 0; ct < W.length; ct++) ye = W[ct], Ve = xi + j(ye, ct), We += te(ye, ne, xe, Ve, Ae);
          else if (ct = m(W), typeof ct == "function") for (W = ct.call(W), ct = 0; !(ye = W.next()).done; ) ye = ye.value, Ve = xi + j(ye, ct++), We += te(ye, ne, xe, Ve, Ae);
          else if (Ve === "object") {
            if (typeof W.then == "function") return te(K(W), ne, xe, ye, Ae);
            throw ne = String(W), Error("Objects are not valid as a React child (found: " + (ne === "[object Object]" ? "object with keys {" + Object.keys(W).join(", ") + "}" : ne) + "). If you meant to render a collection of children, use an array instead.");
          }
          return We;
        }
        function H(W, ne, xe) {
          if (W == null) return W;
          var ye = [], Ae = 0;
          return te(W, ye, "", "", function(Ve) {
            return ne.call(xe, Ve, Ae++);
          }), ye;
        }
        function se(W) {
          if (W._status === -1) {
            var ne = W._result;
            ne = ne(), ne.then(function(xe) {
              (W._status === 0 || W._status === -1) && (W._status = 1, W._result = xe);
            }, function(xe) {
              (W._status === 0 || W._status === -1) && (W._status = 2, W._result = xe);
            }), W._status === -1 && (W._status = 0, W._result = ne);
          }
          if (W._status === 1) return W._result.default;
          throw W._result;
        }
        var de = typeof reportError == "function" ? reportError : function(W) {
          if (typeof window == "object" && typeof window.ErrorEvent == "function") {
            var ne = new window.ErrorEvent("error", {
              bubbles: true,
              cancelable: true,
              message: typeof W == "object" && W !== null && typeof W.message == "string" ? String(W.message) : String(W),
              error: W
            });
            if (!window.dispatchEvent(ne)) return;
          } else if (typeof process == "object" && typeof process.emit == "function") {
            process.emit("uncaughtException", W);
            return;
          }
          console.error(W);
        };
        function fe() {
        }
        return Tt.Children = {
          map: H,
          forEach: function(W, ne, xe) {
            H(W, function() {
              ne.apply(this, arguments);
            }, xe);
          },
          count: function(W) {
            var ne = 0;
            return H(W, function() {
              ne++;
            }), ne;
          },
          toArray: function(W) {
            return H(W, function(ne) {
              return ne;
            }) || [];
          },
          only: function(W) {
            if (!A(W)) throw Error("React.Children.only expected to receive a single React element child.");
            return W;
          }
        }, Tt.Component = y, Tt.Fragment = t, Tt.Profiler = n, Tt.PureComponent = L, Tt.StrictMode = i, Tt.Suspense = l, Tt.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = T, Tt.__COMPILER_RUNTIME = {
          __proto__: null,
          c: function(W) {
            return T.H.useMemoCache(W);
          }
        }, Tt.cache = function(W) {
          return function() {
            return W.apply(null, arguments);
          };
        }, Tt.cloneElement = function(W, ne, xe) {
          if (W == null) throw Error("The argument must be a React element, but you passed " + W + ".");
          var ye = b({}, W.props), Ae = W.key, Ve = void 0;
          if (ne != null) for (We in ne.ref !== void 0 && (Ve = void 0), ne.key !== void 0 && (Ae = "" + ne.key), ne) !M.call(ne, We) || We === "key" || We === "__self" || We === "__source" || We === "ref" && ne.ref === void 0 || (ye[We] = ne[We]);
          var We = arguments.length - 2;
          if (We === 1) ye.children = xe;
          else if (1 < We) {
            for (var xi = Array(We), ct = 0; ct < We; ct++) xi[ct] = arguments[ct + 2];
            ye.children = xi;
          }
          return I(W.type, Ae, void 0, void 0, Ve, ye);
        }, Tt.createContext = function(W) {
          return W = {
            $$typeof: r,
            _currentValue: W,
            _currentValue2: W,
            _threadCount: 0,
            Provider: null,
            Consumer: null
          }, W.Provider = W, W.Consumer = {
            $$typeof: o,
            _context: W
          }, W;
        }, Tt.createElement = function(W, ne, xe) {
          var ye, Ae = {}, Ve = null;
          if (ne != null) for (ye in ne.key !== void 0 && (Ve = "" + ne.key), ne) M.call(ne, ye) && ye !== "key" && ye !== "__self" && ye !== "__source" && (Ae[ye] = ne[ye]);
          var We = arguments.length - 2;
          if (We === 1) Ae.children = xe;
          else if (1 < We) {
            for (var xi = Array(We), ct = 0; ct < We; ct++) xi[ct] = arguments[ct + 2];
            Ae.children = xi;
          }
          if (W && W.defaultProps) for (ye in We = W.defaultProps, We) Ae[ye] === void 0 && (Ae[ye] = We[ye]);
          return I(W, Ve, void 0, void 0, null, Ae);
        }, Tt.createRef = function() {
          return {
            current: null
          };
        }, Tt.forwardRef = function(W) {
          return {
            $$typeof: a,
            render: W
          };
        }, Tt.isValidElement = A, Tt.lazy = function(W) {
          return {
            $$typeof: d,
            _payload: {
              _status: -1,
              _result: W
            },
            _init: se
          };
        }, Tt.memo = function(W, ne) {
          return {
            $$typeof: u,
            type: W,
            compare: ne === void 0 ? null : ne
          };
        }, Tt.startTransition = function(W) {
          var ne = T.T, xe = {};
          T.T = xe;
          try {
            var ye = W(), Ae = T.S;
            Ae !== null && Ae(xe, ye), typeof ye == "object" && ye !== null && typeof ye.then == "function" && ye.then(fe, de);
          } catch (Ve) {
            de(Ve);
          } finally {
            T.T = ne;
          }
        }, Tt.unstable_useCacheRefresh = function() {
          return T.H.useCacheRefresh();
        }, Tt.use = function(W) {
          return T.H.use(W);
        }, Tt.useActionState = function(W, ne, xe) {
          return T.H.useActionState(W, ne, xe);
        }, Tt.useCallback = function(W, ne) {
          return T.H.useCallback(W, ne);
        }, Tt.useContext = function(W) {
          return T.H.useContext(W);
        }, Tt.useDebugValue = function() {
        }, Tt.useDeferredValue = function(W, ne) {
          return T.H.useDeferredValue(W, ne);
        }, Tt.useEffect = function(W, ne, xe) {
          var ye = T.H;
          if (typeof xe == "function") throw Error("useEffect CRUD overload is not enabled in this build of React.");
          return ye.useEffect(W, ne);
        }, Tt.useId = function() {
          return T.H.useId();
        }, Tt.useImperativeHandle = function(W, ne, xe) {
          return T.H.useImperativeHandle(W, ne, xe);
        }, Tt.useInsertionEffect = function(W, ne) {
          return T.H.useInsertionEffect(W, ne);
        }, Tt.useLayoutEffect = function(W, ne) {
          return T.H.useLayoutEffect(W, ne);
        }, Tt.useMemo = function(W, ne) {
          return T.H.useMemo(W, ne);
        }, Tt.useOptimistic = function(W, ne) {
          return T.H.useOptimistic(W, ne);
        }, Tt.useReducer = function(W, ne, xe) {
          return T.H.useReducer(W, ne, xe);
        }, Tt.useRef = function(W) {
          return T.H.useRef(W);
        }, Tt.useState = function(W) {
          return T.H.useState(W);
        }, Tt.useSyncExternalStore = function(W, ne, xe) {
          return T.H.useSyncExternalStore(W, ne, xe);
        }, Tt.useTransition = function() {
          return T.H.useTransition();
        }, Tt.version = "19.1.0", Tt;
      }
      var r4;
      function DE() {
        return r4 || (r4 = 1, tL.exports = mH()), tL.exports;
      }
      var ft = DE();
      const Tf = dH(ft);
      var iL = {
        exports: {}
      }, Tm = {}, nL = {
        exports: {}
      }, sL = {};
      var a4;
      function pH() {
        return a4 || (a4 = 1, function(s) {
          function e(H, se) {
            var de = H.length;
            H.push(se);
            e: for (; 0 < de; ) {
              var fe = de - 1 >>> 1, W = H[fe];
              if (0 < n(W, se)) H[fe] = se, H[de] = W, de = fe;
              else break e;
            }
          }
          function t(H) {
            return H.length === 0 ? null : H[0];
          }
          function i(H) {
            if (H.length === 0) return null;
            var se = H[0], de = H.pop();
            if (de !== se) {
              H[0] = de;
              e: for (var fe = 0, W = H.length, ne = W >>> 1; fe < ne; ) {
                var xe = 2 * (fe + 1) - 1, ye = H[xe], Ae = xe + 1, Ve = H[Ae];
                if (0 > n(ye, de)) Ae < W && 0 > n(Ve, ye) ? (H[fe] = Ve, H[Ae] = de, fe = Ae) : (H[fe] = ye, H[xe] = de, fe = xe);
                else if (Ae < W && 0 > n(Ve, de)) H[fe] = Ve, H[Ae] = de, fe = Ae;
                else break e;
              }
            }
            return se;
          }
          function n(H, se) {
            var de = H.sortIndex - se.sortIndex;
            return de !== 0 ? de : H.id - se.id;
          }
          if (s.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") {
            var o = performance;
            s.unstable_now = function() {
              return o.now();
            };
          } else {
            var r = Date, a = r.now();
            s.unstable_now = function() {
              return r.now() - a;
            };
          }
          var l = [], u = [], d = 1, f = null, m = 3, _ = false, b = false, v = false, y = false, x = typeof setTimeout == "function" ? setTimeout : null, L = typeof clearTimeout == "function" ? clearTimeout : null, D = typeof setImmediate < "u" ? setImmediate : null;
          function k(H) {
            for (var se = t(u); se !== null; ) {
              if (se.callback === null) i(u);
              else if (se.startTime <= H) i(u), se.sortIndex = se.expirationTime, e(l, se);
              else break;
              se = t(u);
            }
          }
          function T(H) {
            if (v = false, k(H), !b) if (t(l) !== null) b = true, M || (M = true, j());
            else {
              var se = t(u);
              se !== null && te(T, se.startTime - H);
            }
          }
          var M = false, I = -1, R = 5, A = -1;
          function Y() {
            return y ? true : !(s.unstable_now() - A < R);
          }
          function U() {
            if (y = false, M) {
              var H = s.unstable_now();
              A = H;
              var se = true;
              try {
                e: {
                  b = false, v && (v = false, L(I), I = -1), _ = true;
                  var de = m;
                  try {
                    t: {
                      for (k(H), f = t(l); f !== null && !(f.expirationTime > H && Y()); ) {
                        var fe = f.callback;
                        if (typeof fe == "function") {
                          f.callback = null, m = f.priorityLevel;
                          var W = fe(f.expirationTime <= H);
                          if (H = s.unstable_now(), typeof W == "function") {
                            f.callback = W, k(H), se = true;
                            break t;
                          }
                          f === t(l) && i(l), k(H);
                        } else i(l);
                        f = t(l);
                      }
                      if (f !== null) se = true;
                      else {
                        var ne = t(u);
                        ne !== null && te(T, ne.startTime - H), se = false;
                      }
                    }
                    break e;
                  } finally {
                    f = null, m = de, _ = false;
                  }
                  se = void 0;
                }
              } finally {
                se ? j() : M = false;
              }
            }
          }
          var j;
          if (typeof D == "function") j = function() {
            D(U);
          };
          else if (typeof MessageChannel < "u") {
            var ee = new MessageChannel(), K = ee.port2;
            ee.port1.onmessage = U, j = function() {
              K.postMessage(null);
            };
          } else j = function() {
            x(U, 0);
          };
          function te(H, se) {
            I = x(function() {
              H(s.unstable_now());
            }, se);
          }
          s.unstable_IdlePriority = 5, s.unstable_ImmediatePriority = 1, s.unstable_LowPriority = 4, s.unstable_NormalPriority = 3, s.unstable_Profiling = null, s.unstable_UserBlockingPriority = 2, s.unstable_cancelCallback = function(H) {
            H.callback = null;
          }, s.unstable_forceFrameRate = function(H) {
            0 > H || 125 < H ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : R = 0 < H ? Math.floor(1e3 / H) : 5;
          }, s.unstable_getCurrentPriorityLevel = function() {
            return m;
          }, s.unstable_next = function(H) {
            switch (m) {
              case 1:
              case 2:
              case 3:
                var se = 3;
                break;
              default:
                se = m;
            }
            var de = m;
            m = se;
            try {
              return H();
            } finally {
              m = de;
            }
          }, s.unstable_requestPaint = function() {
            y = true;
          }, s.unstable_runWithPriority = function(H, se) {
            switch (H) {
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
                break;
              default:
                H = 3;
            }
            var de = m;
            m = H;
            try {
              return se();
            } finally {
              m = de;
            }
          }, s.unstable_scheduleCallback = function(H, se, de) {
            var fe = s.unstable_now();
            switch (typeof de == "object" && de !== null ? (de = de.delay, de = typeof de == "number" && 0 < de ? fe + de : fe) : de = fe, H) {
              case 1:
                var W = -1;
                break;
              case 2:
                W = 250;
                break;
              case 5:
                W = 1073741823;
                break;
              case 4:
                W = 1e4;
                break;
              default:
                W = 5e3;
            }
            return W = de + W, H = {
              id: d++,
              callback: se,
              priorityLevel: H,
              startTime: de,
              expirationTime: W,
              sortIndex: -1
            }, de > fe ? (H.sortIndex = de, e(u, H), t(l) === null && H === t(u) && (v ? (L(I), I = -1) : v = true, te(T, de - fe))) : (H.sortIndex = W, e(l, H), b || _ || (b = true, M || (M = true, j()))), H;
          }, s.unstable_shouldYield = Y, s.unstable_wrapCallback = function(H) {
            var se = m;
            return function() {
              var de = m;
              m = se;
              try {
                return H.apply(this, arguments);
              } finally {
                m = de;
              }
            };
          };
        }(sL)), sL;
      }
      var l4;
      function _H() {
        return l4 || (l4 = 1, nL.exports = pH()), nL.exports;
      }
      var oL = {
        exports: {}
      }, ys = {};
      var c4;
      function bH() {
        if (c4) return ys;
        c4 = 1;
        var s = DE();
        function e(l) {
          var u = "https://react.dev/errors/" + l;
          if (1 < arguments.length) {
            u += "?args[]=" + encodeURIComponent(arguments[1]);
            for (var d = 2; d < arguments.length; d++) u += "&args[]=" + encodeURIComponent(arguments[d]);
          }
          return "Minified React error #" + l + "; visit " + u + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
        }
        function t() {
        }
        var i = {
          d: {
            f: t,
            r: function() {
              throw Error(e(522));
            },
            D: t,
            C: t,
            L: t,
            m: t,
            X: t,
            S: t,
            M: t
          },
          p: 0,
          findDOMNode: null
        }, n = Symbol.for("react.portal");
        function o(l, u, d) {
          var f = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
          return {
            $$typeof: n,
            key: f == null ? null : "" + f,
            children: l,
            containerInfo: u,
            implementation: d
          };
        }
        var r = s.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
        function a(l, u) {
          if (l === "font") return "";
          if (typeof u == "string") return u === "use-credentials" ? u : "";
        }
        return ys.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = i, ys.createPortal = function(l, u) {
          var d = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
          if (!u || u.nodeType !== 1 && u.nodeType !== 9 && u.nodeType !== 11) throw Error(e(299));
          return o(l, u, null, d);
        }, ys.flushSync = function(l) {
          var u = r.T, d = i.p;
          try {
            if (r.T = null, i.p = 2, l) return l();
          } finally {
            r.T = u, i.p = d, i.d.f();
          }
        }, ys.preconnect = function(l, u) {
          typeof l == "string" && (u ? (u = u.crossOrigin, u = typeof u == "string" ? u === "use-credentials" ? u : "" : void 0) : u = null, i.d.C(l, u));
        }, ys.prefetchDNS = function(l) {
          typeof l == "string" && i.d.D(l);
        }, ys.preinit = function(l, u) {
          if (typeof l == "string" && u && typeof u.as == "string") {
            var d = u.as, f = a(d, u.crossOrigin), m = typeof u.integrity == "string" ? u.integrity : void 0, _ = typeof u.fetchPriority == "string" ? u.fetchPriority : void 0;
            d === "style" ? i.d.S(l, typeof u.precedence == "string" ? u.precedence : void 0, {
              crossOrigin: f,
              integrity: m,
              fetchPriority: _
            }) : d === "script" && i.d.X(l, {
              crossOrigin: f,
              integrity: m,
              fetchPriority: _,
              nonce: typeof u.nonce == "string" ? u.nonce : void 0
            });
          }
        }, ys.preinitModule = function(l, u) {
          if (typeof l == "string") if (typeof u == "object" && u !== null) {
            if (u.as == null || u.as === "script") {
              var d = a(u.as, u.crossOrigin);
              i.d.M(l, {
                crossOrigin: d,
                integrity: typeof u.integrity == "string" ? u.integrity : void 0,
                nonce: typeof u.nonce == "string" ? u.nonce : void 0
              });
            }
          } else u == null && i.d.M(l);
        }, ys.preload = function(l, u) {
          if (typeof l == "string" && typeof u == "object" && u !== null && typeof u.as == "string") {
            var d = u.as, f = a(d, u.crossOrigin);
            i.d.L(l, d, {
              crossOrigin: f,
              integrity: typeof u.integrity == "string" ? u.integrity : void 0,
              nonce: typeof u.nonce == "string" ? u.nonce : void 0,
              type: typeof u.type == "string" ? u.type : void 0,
              fetchPriority: typeof u.fetchPriority == "string" ? u.fetchPriority : void 0,
              referrerPolicy: typeof u.referrerPolicy == "string" ? u.referrerPolicy : void 0,
              imageSrcSet: typeof u.imageSrcSet == "string" ? u.imageSrcSet : void 0,
              imageSizes: typeof u.imageSizes == "string" ? u.imageSizes : void 0,
              media: typeof u.media == "string" ? u.media : void 0
            });
          }
        }, ys.preloadModule = function(l, u) {
          if (typeof l == "string") if (u) {
            var d = a(u.as, u.crossOrigin);
            i.d.m(l, {
              as: typeof u.as == "string" && u.as !== "script" ? u.as : void 0,
              crossOrigin: d,
              integrity: typeof u.integrity == "string" ? u.integrity : void 0
            });
          } else i.d.m(l);
        }, ys.requestFormReset = function(l) {
          i.d.r(l);
        }, ys.unstable_batchedUpdates = function(l, u) {
          return l(u);
        }, ys.useFormState = function(l, u, d) {
          return r.H.useFormState(l, u, d);
        }, ys.useFormStatus = function() {
          return r.H.useHostTransitionStatus();
        }, ys.version = "19.1.0", ys;
      }
      var u4;
      function vH() {
        if (u4) return oL.exports;
        u4 = 1;
        function s() {
          if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(s);
          } catch (e) {
            console.error(e);
          }
        }
        return s(), oL.exports = bH(), oL.exports;
      }
      var h4;
      function CH() {
        if (h4) return Tm;
        h4 = 1;
        var s = _H(), e = DE(), t = vH();
        function i(c) {
          var h = "https://react.dev/errors/" + c;
          if (1 < arguments.length) {
            h += "?args[]=" + encodeURIComponent(arguments[1]);
            for (var g = 2; g < arguments.length; g++) h += "&args[]=" + encodeURIComponent(arguments[g]);
          }
          return "Minified React error #" + c + "; visit " + h + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
        }
        function n(c) {
          return !(!c || c.nodeType !== 1 && c.nodeType !== 9 && c.nodeType !== 11);
        }
        function o(c) {
          var h = c, g = c;
          if (c.alternate) for (; h.return; ) h = h.return;
          else {
            c = h;
            do
              h = c, (h.flags & 4098) !== 0 && (g = h.return), c = h.return;
            while (c);
          }
          return h.tag === 3 ? g : null;
        }
        function r(c) {
          if (c.tag === 13) {
            var h = c.memoizedState;
            if (h === null && (c = c.alternate, c !== null && (h = c.memoizedState)), h !== null) return h.dehydrated;
          }
          return null;
        }
        function a(c) {
          if (o(c) !== c) throw Error(i(188));
        }
        function l(c) {
          var h = c.alternate;
          if (!h) {
            if (h = o(c), h === null) throw Error(i(188));
            return h !== c ? null : c;
          }
          for (var g = c, p = h; ; ) {
            var w = g.return;
            if (w === null) break;
            var S = w.alternate;
            if (S === null) {
              if (p = w.return, p !== null) {
                g = p;
                continue;
              }
              break;
            }
            if (w.child === S.child) {
              for (S = w.child; S; ) {
                if (S === g) return a(w), c;
                if (S === p) return a(w), h;
                S = S.sibling;
              }
              throw Error(i(188));
            }
            if (g.return !== p.return) g = w, p = S;
            else {
              for (var N = false, O = w.child; O; ) {
                if (O === g) {
                  N = true, g = w, p = S;
                  break;
                }
                if (O === p) {
                  N = true, p = w, g = S;
                  break;
                }
                O = O.sibling;
              }
              if (!N) {
                for (O = S.child; O; ) {
                  if (O === g) {
                    N = true, g = S, p = w;
                    break;
                  }
                  if (O === p) {
                    N = true, p = S, g = w;
                    break;
                  }
                  O = O.sibling;
                }
                if (!N) throw Error(i(189));
              }
            }
            if (g.alternate !== p) throw Error(i(190));
          }
          if (g.tag !== 3) throw Error(i(188));
          return g.stateNode.current === g ? c : h;
        }
        function u(c) {
          var h = c.tag;
          if (h === 5 || h === 26 || h === 27 || h === 6) return c;
          for (c = c.child; c !== null; ) {
            if (h = u(c), h !== null) return h;
            c = c.sibling;
          }
          return null;
        }
        var d = Object.assign, f = Symbol.for("react.element"), m = Symbol.for("react.transitional.element"), _ = Symbol.for("react.portal"), b = Symbol.for("react.fragment"), v = Symbol.for("react.strict_mode"), y = Symbol.for("react.profiler"), x = Symbol.for("react.provider"), L = Symbol.for("react.consumer"), D = Symbol.for("react.context"), k = Symbol.for("react.forward_ref"), T = Symbol.for("react.suspense"), M = Symbol.for("react.suspense_list"), I = Symbol.for("react.memo"), R = Symbol.for("react.lazy"), A = Symbol.for("react.activity"), Y = Symbol.for("react.memo_cache_sentinel"), U = Symbol.iterator;
        function j(c) {
          return c === null || typeof c != "object" ? null : (c = U && c[U] || c["@@iterator"], typeof c == "function" ? c : null);
        }
        var ee = Symbol.for("react.client.reference");
        function K(c) {
          if (c == null) return null;
          if (typeof c == "function") return c.$$typeof === ee ? null : c.displayName || c.name || null;
          if (typeof c == "string") return c;
          switch (c) {
            case b:
              return "Fragment";
            case y:
              return "Profiler";
            case v:
              return "StrictMode";
            case T:
              return "Suspense";
            case M:
              return "SuspenseList";
            case A:
              return "Activity";
          }
          if (typeof c == "object") switch (c.$$typeof) {
            case _:
              return "Portal";
            case D:
              return (c.displayName || "Context") + ".Provider";
            case L:
              return (c._context.displayName || "Context") + ".Consumer";
            case k:
              var h = c.render;
              return c = c.displayName, c || (c = h.displayName || h.name || "", c = c !== "" ? "ForwardRef(" + c + ")" : "ForwardRef"), c;
            case I:
              return h = c.displayName || null, h !== null ? h : K(c.type) || "Memo";
            case R:
              h = c._payload, c = c._init;
              try {
                return K(c(h));
              } catch {
              }
          }
          return null;
        }
        var te = Array.isArray, H = e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, se = t.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, de = {
          pending: false,
          data: null,
          method: null,
          action: null
        }, fe = [], W = -1;
        function ne(c) {
          return {
            current: c
          };
        }
        function xe(c) {
          0 > W || (c.current = fe[W], fe[W] = null, W--);
        }
        function ye(c, h) {
          W++, fe[W] = c.current, c.current = h;
        }
        var Ae = ne(null), Ve = ne(null), We = ne(null), xi = ne(null);
        function ct(c, h) {
          switch (ye(We, h), ye(Ve, c), ye(Ae, null), h.nodeType) {
            case 9:
            case 11:
              c = (c = h.documentElement) && (c = c.namespaceURI) ? IR(c) : 0;
              break;
            default:
              if (c = h.tagName, h = h.namespaceURI) h = IR(h), c = MR(h, c);
              else switch (c) {
                case "svg":
                  c = 1;
                  break;
                case "math":
                  c = 2;
                  break;
                default:
                  c = 0;
              }
          }
          xe(Ae), ye(Ae, c);
        }
        function hn() {
          xe(Ae), xe(Ve), xe(We);
        }
        function qo(c) {
          c.memoizedState !== null && ye(xi, c);
          var h = Ae.current, g = MR(h, c.type);
          h !== g && (ye(Ve, c), ye(Ae, g));
        }
        function Wa(c) {
          Ve.current === c && (xe(Ae), xe(Ve)), xi.current === c && (xe(xi), Sm._currentValue = de);
        }
        var Ko = Object.prototype.hasOwnProperty, Ha = s.unstable_scheduleCallback, _o2 = s.unstable_cancelCallback, pu = s.unstable_shouldYield, _u = s.unstable_requestPaint, Bn = s.unstable_now, Xl = s.unstable_getCurrentPriorityLevel, za = s.unstable_ImmediatePriority, na = s.unstable_UserBlockingPriority, Ua = s.unstable_NormalPriority, rd = s.unstable_LowPriority, $a = s.unstable_IdlePriority, qa = s.log, jo = s.unstable_setDisableYieldValue, Qs = null, Sn = null;
        function bo(c) {
          if (typeof qa == "function" && jo(c), Sn && typeof Sn.setStrictMode == "function") try {
            Sn.setStrictMode(Qs, c);
          } catch {
          }
        }
        var dn = Math.clz32 ? Math.clz32 : Go, yr = Math.log, vs = Math.LN2;
        function Go(c) {
          return c >>>= 0, c === 0 ? 32 : 31 - (yr(c) / vs | 0) | 0;
        }
        var Xs = 256, Ri = 4194304;
        function Ln(c) {
          var h = c & 42;
          if (h !== 0) return h;
          switch (c & -c) {
            case 1:
              return 1;
            case 2:
              return 2;
            case 4:
              return 4;
            case 8:
              return 8;
            case 16:
              return 16;
            case 32:
              return 32;
            case 64:
              return 64;
            case 128:
              return 128;
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
              return c & 4194048;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
              return c & 62914560;
            case 67108864:
              return 67108864;
            case 134217728:
              return 134217728;
            case 268435456:
              return 268435456;
            case 536870912:
              return 536870912;
            case 1073741824:
              return 0;
            default:
              return c;
          }
        }
        function Sr(c, h, g) {
          var p = c.pendingLanes;
          if (p === 0) return 0;
          var w = 0, S = c.suspendedLanes, N = c.pingedLanes;
          c = c.warmLanes;
          var O = p & 134217727;
          return O !== 0 ? (p = O & ~S, p !== 0 ? w = Ln(p) : (N &= O, N !== 0 ? w = Ln(N) : g || (g = O & ~c, g !== 0 && (w = Ln(g))))) : (O = p & ~S, O !== 0 ? w = Ln(O) : N !== 0 ? w = Ln(N) : g || (g = p & ~c, g !== 0 && (w = Ln(g)))), w === 0 ? 0 : h !== 0 && h !== w && (h & S) === 0 && (S = w & -w, g = h & -h, S >= g || S === 32 && (g & 4194048) !== 0) ? h : w;
        }
        function os(c, h) {
          return (c.pendingLanes & ~(c.suspendedLanes & ~c.pingedLanes) & h) === 0;
        }
        function ei(c, h) {
          switch (c) {
            case 1:
            case 2:
            case 4:
            case 8:
            case 64:
              return h + 250;
            case 16:
            case 32:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
              return h + 5e3;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
              return -1;
            case 67108864:
            case 134217728:
            case 268435456:
            case 536870912:
            case 1073741824:
              return -1;
            default:
              return -1;
          }
        }
        function sa() {
          var c = Xs;
          return Xs <<= 1, (Xs & 4194048) === 0 && (Xs = 256), c;
        }
        function ad() {
          var c = Ri;
          return Ri <<= 1, (Ri & 62914560) === 0 && (Ri = 4194304), c;
        }
        function bu(c) {
          for (var h = [], g = 0; 31 > g; g++) h.push(c);
          return h;
        }
        function Oi(c, h) {
          c.pendingLanes |= h, h !== 268435456 && (c.suspendedLanes = 0, c.pingedLanes = 0, c.warmLanes = 0);
        }
        function oa(c, h, g, p, w, S) {
          var N = c.pendingLanes;
          c.pendingLanes = g, c.suspendedLanes = 0, c.pingedLanes = 0, c.warmLanes = 0, c.expiredLanes &= g, c.entangledLanes &= g, c.errorRecoveryDisabledLanes &= g, c.shellSuspendCounter = 0;
          var O = c.entanglements, q = c.expirationTimes, ue = c.hiddenUpdates;
          for (g = N & ~g; 0 < g; ) {
            var ve = 31 - dn(g), Le = 1 << ve;
            O[ve] = 0, q[ve] = -1;
            var ge = ue[ve];
            if (ge !== null) for (ue[ve] = null, ve = 0; ve < ge.length; ve++) {
              var pe = ge[ve];
              pe !== null && (pe.lane &= -536870913);
            }
            g &= ~Le;
          }
          p !== 0 && ld(c, p, 0), S !== 0 && w === 0 && c.tag !== 0 && (c.suspendedLanes |= S & ~(N & ~h));
        }
        function ld(c, h, g) {
          c.pendingLanes |= h, c.suspendedLanes &= ~h;
          var p = 31 - dn(h);
          c.entangledLanes |= h, c.entanglements[p] = c.entanglements[p] | 1073741824 | g & 4194090;
        }
        function vu(c, h) {
          var g = c.entangledLanes |= h;
          for (c = c.entanglements; g; ) {
            var p = 31 - dn(g), w = 1 << p;
            w & h | c[p] & h && (c[p] |= h), g &= ~w;
          }
        }
        function Ka(c) {
          switch (c) {
            case 2:
              c = 1;
              break;
            case 8:
              c = 4;
              break;
            case 32:
              c = 16;
              break;
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
              c = 128;
              break;
            case 268435456:
              c = 134217728;
              break;
            default:
              c = 0;
          }
          return c;
        }
        function nt(c) {
          return c &= -c, 2 < c ? 8 < c ? (c & 134217727) !== 0 ? 32 : 268435456 : 8 : 2;
        }
        function P() {
          var c = se.p;
          return c !== 0 ? c : (c = window.event, c === void 0 ? 32 : QR(c.type));
        }
        function F(c, h) {
          var g = se.p;
          try {
            return se.p = c, h();
          } finally {
            se.p = g;
          }
        }
        var V = Math.random().toString(36).slice(2), $ = "__reactFiber$" + V, Z = "__reactProps$" + V, ce = "__reactContainer$" + V, _e2 = "__reactEvents$" + V, Re = "__reactListeners$" + V, Fe = "__reactHandles$" + V, tt = "__reactResources$" + V, xt = "__reactMarker$" + V;
        function At(c) {
          delete c[$], delete c[Z], delete c[_e2], delete c[Re], delete c[Fe];
        }
        function fi(c) {
          var h = c[$];
          if (h) return h;
          for (var g = c.parentNode; g; ) {
            if (h = g[ce] || g[$]) {
              if (g = h.alternate, h.child !== null || g !== null && g.child !== null) for (c = PR(c); c !== null; ) {
                if (g = c[$]) return g;
                c = PR(c);
              }
              return h;
            }
            c = g, g = c.parentNode;
          }
          return null;
        }
        function Gt(c) {
          if (c = c[$] || c[ce]) {
            var h = c.tag;
            if (h === 5 || h === 6 || h === 13 || h === 26 || h === 27 || h === 3) return c;
          }
          return null;
        }
        function fn(c) {
          var h = c.tag;
          if (h === 5 || h === 26 || h === 27 || h === 6) return c.stateNode;
          throw Error(i(33));
        }
        function xn(c) {
          var h = c[tt];
          return h || (h = c[tt] = {
            hoistableStyles: /* @__PURE__ */ new Map(),
            hoistableScripts: /* @__PURE__ */ new Map()
          }), h;
        }
        function Hi(c) {
          c[xt] = true;
        }
        var je = /* @__PURE__ */ new Set(), ie = {};
        function De(c, h) {
          ze(c, h), ze(c + "Capture", h);
        }
        function ze(c, h) {
          for (ie[c] = h, c = 0; c < h.length; c++) je.add(h[c]);
        }
        var _i2 = RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), Fn = {}, kn = {};
        function Cs(c) {
          return Ko.call(kn, c) ? true : Ko.call(Fn, c) ? false : _i2.test(c) ? kn[c] = true : (Fn[c] = true, false);
        }
        function Ps(c, h, g) {
          if (Cs(h)) if (g === null) c.removeAttribute(h);
          else {
            switch (typeof g) {
              case "undefined":
              case "function":
              case "symbol":
                c.removeAttribute(h);
                return;
              case "boolean":
                var p = h.toLowerCase().slice(0, 5);
                if (p !== "data-" && p !== "aria-") {
                  c.removeAttribute(h);
                  return;
                }
            }
            c.setAttribute(h, "" + g);
          }
        }
        function ra(c, h, g) {
          if (g === null) c.removeAttribute(h);
          else {
            switch (typeof g) {
              case "undefined":
              case "function":
              case "symbol":
              case "boolean":
                c.removeAttribute(h);
                return;
            }
            c.setAttribute(h, "" + g);
          }
        }
        function Vi(c, h, g, p) {
          if (p === null) c.removeAttribute(g);
          else {
            switch (typeof p) {
              case "undefined":
              case "function":
              case "symbol":
              case "boolean":
                c.removeAttribute(g);
                return;
            }
            c.setAttributeNS(h, g, "" + p);
          }
        }
        var cd, Og;
        function ud(c) {
          if (cd === void 0) try {
            throw Error();
          } catch (g) {
            var h = g.stack.trim().match(/\n( *(at )?)/);
            cd = h && h[1] || "", Og = -1 < g.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < g.stack.indexOf("@") ? "@unknown:0:0" : "";
          }
          return `
` + cd + c + Og;
        }
        var Yw = false;
        function Zw(c, h) {
          if (!c || Yw) return "";
          Yw = true;
          var g = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          try {
            var p = {
              DetermineComponentFrameRoot: function() {
                try {
                  if (h) {
                    var Le = function() {
                      throw Error();
                    };
                    if (Object.defineProperty(Le.prototype, "props", {
                      set: function() {
                        throw Error();
                      }
                    }), typeof Reflect == "object" && Reflect.construct) {
                      try {
                        Reflect.construct(Le, []);
                      } catch (pe) {
                        var ge = pe;
                      }
                      Reflect.construct(c, [], Le);
                    } else {
                      try {
                        Le.call();
                      } catch (pe) {
                        ge = pe;
                      }
                      c.call(Le.prototype);
                    }
                  } else {
                    try {
                      throw Error();
                    } catch (pe) {
                      ge = pe;
                    }
                    (Le = c()) && typeof Le.catch == "function" && Le.catch(function() {
                    });
                  }
                } catch (pe) {
                  if (pe && ge && typeof pe.stack == "string") return [
                    pe.stack,
                    ge.stack
                  ];
                }
                return [
                  null,
                  null
                ];
              }
            };
            p.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
            var w = Object.getOwnPropertyDescriptor(p.DetermineComponentFrameRoot, "name");
            w && w.configurable && Object.defineProperty(p.DetermineComponentFrameRoot, "name", {
              value: "DetermineComponentFrameRoot"
            });
            var S = p.DetermineComponentFrameRoot(), N = S[0], O = S[1];
            if (N && O) {
              var q = N.split(`
`), ue = O.split(`
`);
              for (w = p = 0; p < q.length && !q[p].includes("DetermineComponentFrameRoot"); ) p++;
              for (; w < ue.length && !ue[w].includes("DetermineComponentFrameRoot"); ) w++;
              if (p === q.length || w === ue.length) for (p = q.length - 1, w = ue.length - 1; 1 <= p && 0 <= w && q[p] !== ue[w]; ) w--;
              for (; 1 <= p && 0 <= w; p--, w--) if (q[p] !== ue[w]) {
                if (p !== 1 || w !== 1) do
                  if (p--, w--, 0 > w || q[p] !== ue[w]) {
                    var ve = `
` + q[p].replace(" at new ", " at ");
                    return c.displayName && ve.includes("<anonymous>") && (ve = ve.replace("<anonymous>", c.displayName)), ve;
                  }
                while (1 <= p && 0 <= w);
                break;
              }
            }
          } finally {
            Yw = false, Error.prepareStackTrace = g;
          }
          return (g = c ? c.displayName || c.name : "") ? ud(g) : "";
        }
        function rV(c) {
          switch (c.tag) {
            case 26:
            case 27:
            case 5:
              return ud(c.type);
            case 16:
              return ud("Lazy");
            case 13:
              return ud("Suspense");
            case 19:
              return ud("SuspenseList");
            case 0:
            case 15:
              return Zw(c.type, false);
            case 11:
              return Zw(c.type.render, false);
            case 1:
              return Zw(c.type, true);
            case 31:
              return ud("Activity");
            default:
              return "";
          }
        }
        function xI(c) {
          try {
            var h = "";
            do
              h += rV(c), c = c.return;
            while (c);
            return h;
          } catch (g) {
            return `
Error generating stack: ` + g.message + `
` + g.stack;
          }
        }
        function Yo(c) {
          switch (typeof c) {
            case "bigint":
            case "boolean":
            case "number":
            case "string":
            case "undefined":
              return c;
            case "object":
              return c;
            default:
              return "";
          }
        }
        function kI(c) {
          var h = c.type;
          return (c = c.nodeName) && c.toLowerCase() === "input" && (h === "checkbox" || h === "radio");
        }
        function aV(c) {
          var h = kI(c) ? "checked" : "value", g = Object.getOwnPropertyDescriptor(c.constructor.prototype, h), p = "" + c[h];
          if (!c.hasOwnProperty(h) && typeof g < "u" && typeof g.get == "function" && typeof g.set == "function") {
            var w = g.get, S = g.set;
            return Object.defineProperty(c, h, {
              configurable: true,
              get: function() {
                return w.call(this);
              },
              set: function(N) {
                p = "" + N, S.call(this, N);
              }
            }), Object.defineProperty(c, h, {
              enumerable: g.enumerable
            }), {
              getValue: function() {
                return p;
              },
              setValue: function(N) {
                p = "" + N;
              },
              stopTracking: function() {
                c._valueTracker = null, delete c[h];
              }
            };
          }
        }
        function l1(c) {
          c._valueTracker || (c._valueTracker = aV(c));
        }
        function DI(c) {
          if (!c) return false;
          var h = c._valueTracker;
          if (!h) return true;
          var g = h.getValue(), p = "";
          return c && (p = kI(c) ? c.checked ? "true" : "false" : c.value), c = p, c !== g ? (h.setValue(c), true) : false;
        }
        function c1(c) {
          if (c = c || (typeof document < "u" ? document : void 0), typeof c > "u") return null;
          try {
            return c.activeElement || c.body;
          } catch {
            return c.body;
          }
        }
        var lV = /[\n"\\]/g;
        function Zo(c) {
          return c.replace(lV, function(h) {
            return "\\" + h.charCodeAt(0).toString(16) + " ";
          });
        }
        function Qw(c, h, g, p, w, S, N, O) {
          c.name = "", N != null && typeof N != "function" && typeof N != "symbol" && typeof N != "boolean" ? c.type = N : c.removeAttribute("type"), h != null ? N === "number" ? (h === 0 && c.value === "" || c.value != h) && (c.value = "" + Yo(h)) : c.value !== "" + Yo(h) && (c.value = "" + Yo(h)) : N !== "submit" && N !== "reset" || c.removeAttribute("value"), h != null ? Xw(c, N, Yo(h)) : g != null ? Xw(c, N, Yo(g)) : p != null && c.removeAttribute("value"), w == null && S != null && (c.defaultChecked = !!S), w != null && (c.checked = w && typeof w != "function" && typeof w != "symbol"), O != null && typeof O != "function" && typeof O != "symbol" && typeof O != "boolean" ? c.name = "" + Yo(O) : c.removeAttribute("name");
        }
        function EI(c, h, g, p, w, S, N, O) {
          if (S != null && typeof S != "function" && typeof S != "symbol" && typeof S != "boolean" && (c.type = S), h != null || g != null) {
            if (!(S !== "submit" && S !== "reset" || h != null)) return;
            g = g != null ? "" + Yo(g) : "", h = h != null ? "" + Yo(h) : g, O || h === c.value || (c.value = h), c.defaultValue = h;
          }
          p = p ?? w, p = typeof p != "function" && typeof p != "symbol" && !!p, c.checked = O ? c.checked : !!p, c.defaultChecked = !!p, N != null && typeof N != "function" && typeof N != "symbol" && typeof N != "boolean" && (c.name = N);
        }
        function Xw(c, h, g) {
          h === "number" && c1(c.ownerDocument) === c || c.defaultValue === "" + g || (c.defaultValue = "" + g);
        }
        function hd(c, h, g, p) {
          if (c = c.options, h) {
            h = {};
            for (var w = 0; w < g.length; w++) h["$" + g[w]] = true;
            for (g = 0; g < c.length; g++) w = h.hasOwnProperty("$" + c[g].value), c[g].selected !== w && (c[g].selected = w), w && p && (c[g].defaultSelected = true);
          } else {
            for (g = "" + Yo(g), h = null, w = 0; w < c.length; w++) {
              if (c[w].value === g) {
                c[w].selected = true, p && (c[w].defaultSelected = true);
                return;
              }
              h !== null || c[w].disabled || (h = c[w]);
            }
            h !== null && (h.selected = true);
          }
        }
        function TI(c, h, g) {
          if (h != null && (h = "" + Yo(h), h !== c.value && (c.value = h), g == null)) {
            c.defaultValue !== h && (c.defaultValue = h);
            return;
          }
          c.defaultValue = g != null ? "" + Yo(g) : "";
        }
        function NI(c, h, g, p) {
          if (h == null) {
            if (p != null) {
              if (g != null) throw Error(i(92));
              if (te(p)) {
                if (1 < p.length) throw Error(i(93));
                p = p[0];
              }
              g = p;
            }
            g == null && (g = ""), h = g;
          }
          g = Yo(h), c.defaultValue = g, p = c.textContent, p === g && p !== "" && p !== null && (c.value = p);
        }
        function dd(c, h) {
          if (h) {
            var g = c.firstChild;
            if (g && g === c.lastChild && g.nodeType === 3) {
              g.nodeValue = h;
              return;
            }
          }
          c.textContent = h;
        }
        var cV = new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));
        function II(c, h, g) {
          var p = h.indexOf("--") === 0;
          g == null || typeof g == "boolean" || g === "" ? p ? c.setProperty(h, "") : h === "float" ? c.cssFloat = "" : c[h] = "" : p ? c.setProperty(h, g) : typeof g != "number" || g === 0 || cV.has(h) ? h === "float" ? c.cssFloat = g : c[h] = ("" + g).trim() : c[h] = g + "px";
        }
        function MI(c, h, g) {
          if (h != null && typeof h != "object") throw Error(i(62));
          if (c = c.style, g != null) {
            for (var p in g) !g.hasOwnProperty(p) || h != null && h.hasOwnProperty(p) || (p.indexOf("--") === 0 ? c.setProperty(p, "") : p === "float" ? c.cssFloat = "" : c[p] = "");
            for (var w in h) p = h[w], h.hasOwnProperty(w) && g[w] !== p && II(c, w, p);
          } else for (var S in h) h.hasOwnProperty(S) && II(c, S, h[S]);
        }
        function Jw(c) {
          if (c.indexOf("-") === -1) return false;
          switch (c) {
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph":
              return false;
            default:
              return true;
          }
        }
        var uV = /* @__PURE__ */ new Map([
          [
            "acceptCharset",
            "accept-charset"
          ],
          [
            "htmlFor",
            "for"
          ],
          [
            "httpEquiv",
            "http-equiv"
          ],
          [
            "crossOrigin",
            "crossorigin"
          ],
          [
            "accentHeight",
            "accent-height"
          ],
          [
            "alignmentBaseline",
            "alignment-baseline"
          ],
          [
            "arabicForm",
            "arabic-form"
          ],
          [
            "baselineShift",
            "baseline-shift"
          ],
          [
            "capHeight",
            "cap-height"
          ],
          [
            "clipPath",
            "clip-path"
          ],
          [
            "clipRule",
            "clip-rule"
          ],
          [
            "colorInterpolation",
            "color-interpolation"
          ],
          [
            "colorInterpolationFilters",
            "color-interpolation-filters"
          ],
          [
            "colorProfile",
            "color-profile"
          ],
          [
            "colorRendering",
            "color-rendering"
          ],
          [
            "dominantBaseline",
            "dominant-baseline"
          ],
          [
            "enableBackground",
            "enable-background"
          ],
          [
            "fillOpacity",
            "fill-opacity"
          ],
          [
            "fillRule",
            "fill-rule"
          ],
          [
            "floodColor",
            "flood-color"
          ],
          [
            "floodOpacity",
            "flood-opacity"
          ],
          [
            "fontFamily",
            "font-family"
          ],
          [
            "fontSize",
            "font-size"
          ],
          [
            "fontSizeAdjust",
            "font-size-adjust"
          ],
          [
            "fontStretch",
            "font-stretch"
          ],
          [
            "fontStyle",
            "font-style"
          ],
          [
            "fontVariant",
            "font-variant"
          ],
          [
            "fontWeight",
            "font-weight"
          ],
          [
            "glyphName",
            "glyph-name"
          ],
          [
            "glyphOrientationHorizontal",
            "glyph-orientation-horizontal"
          ],
          [
            "glyphOrientationVertical",
            "glyph-orientation-vertical"
          ],
          [
            "horizAdvX",
            "horiz-adv-x"
          ],
          [
            "horizOriginX",
            "horiz-origin-x"
          ],
          [
            "imageRendering",
            "image-rendering"
          ],
          [
            "letterSpacing",
            "letter-spacing"
          ],
          [
            "lightingColor",
            "lighting-color"
          ],
          [
            "markerEnd",
            "marker-end"
          ],
          [
            "markerMid",
            "marker-mid"
          ],
          [
            "markerStart",
            "marker-start"
          ],
          [
            "overlinePosition",
            "overline-position"
          ],
          [
            "overlineThickness",
            "overline-thickness"
          ],
          [
            "paintOrder",
            "paint-order"
          ],
          [
            "panose-1",
            "panose-1"
          ],
          [
            "pointerEvents",
            "pointer-events"
          ],
          [
            "renderingIntent",
            "rendering-intent"
          ],
          [
            "shapeRendering",
            "shape-rendering"
          ],
          [
            "stopColor",
            "stop-color"
          ],
          [
            "stopOpacity",
            "stop-opacity"
          ],
          [
            "strikethroughPosition",
            "strikethrough-position"
          ],
          [
            "strikethroughThickness",
            "strikethrough-thickness"
          ],
          [
            "strokeDasharray",
            "stroke-dasharray"
          ],
          [
            "strokeDashoffset",
            "stroke-dashoffset"
          ],
          [
            "strokeLinecap",
            "stroke-linecap"
          ],
          [
            "strokeLinejoin",
            "stroke-linejoin"
          ],
          [
            "strokeMiterlimit",
            "stroke-miterlimit"
          ],
          [
            "strokeOpacity",
            "stroke-opacity"
          ],
          [
            "strokeWidth",
            "stroke-width"
          ],
          [
            "textAnchor",
            "text-anchor"
          ],
          [
            "textDecoration",
            "text-decoration"
          ],
          [
            "textRendering",
            "text-rendering"
          ],
          [
            "transformOrigin",
            "transform-origin"
          ],
          [
            "underlinePosition",
            "underline-position"
          ],
          [
            "underlineThickness",
            "underline-thickness"
          ],
          [
            "unicodeBidi",
            "unicode-bidi"
          ],
          [
            "unicodeRange",
            "unicode-range"
          ],
          [
            "unitsPerEm",
            "units-per-em"
          ],
          [
            "vAlphabetic",
            "v-alphabetic"
          ],
          [
            "vHanging",
            "v-hanging"
          ],
          [
            "vIdeographic",
            "v-ideographic"
          ],
          [
            "vMathematical",
            "v-mathematical"
          ],
          [
            "vectorEffect",
            "vector-effect"
          ],
          [
            "vertAdvY",
            "vert-adv-y"
          ],
          [
            "vertOriginX",
            "vert-origin-x"
          ],
          [
            "vertOriginY",
            "vert-origin-y"
          ],
          [
            "wordSpacing",
            "word-spacing"
          ],
          [
            "writingMode",
            "writing-mode"
          ],
          [
            "xmlnsXlink",
            "xmlns:xlink"
          ],
          [
            "xHeight",
            "x-height"
          ]
        ]), hV = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
        function u1(c) {
          return hV.test("" + c) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : c;
        }
        var ey = null;
        function ty(c) {
          return c = c.target || c.srcElement || window, c.correspondingUseElement && (c = c.correspondingUseElement), c.nodeType === 3 ? c.parentNode : c;
        }
        var fd = null, gd = null;
        function AI(c) {
          var h = Gt(c);
          if (h && (c = h.stateNode)) {
            var g = c[Z] || null;
            e: switch (c = h.stateNode, h.type) {
              case "input":
                if (Qw(c, g.value, g.defaultValue, g.defaultValue, g.checked, g.defaultChecked, g.type, g.name), h = g.name, g.type === "radio" && h != null) {
                  for (g = c; g.parentNode; ) g = g.parentNode;
                  for (g = g.querySelectorAll('input[name="' + Zo("" + h) + '"][type="radio"]'), h = 0; h < g.length; h++) {
                    var p = g[h];
                    if (p !== c && p.form === c.form) {
                      var w = p[Z] || null;
                      if (!w) throw Error(i(90));
                      Qw(p, w.value, w.defaultValue, w.defaultValue, w.checked, w.defaultChecked, w.type, w.name);
                    }
                  }
                  for (h = 0; h < g.length; h++) p = g[h], p.form === c.form && DI(p);
                }
                break e;
              case "textarea":
                TI(c, g.value, g.defaultValue);
                break e;
              case "select":
                h = g.value, h != null && hd(c, !!g.multiple, h, false);
            }
          }
        }
        var iy = false;
        function RI(c, h, g) {
          if (iy) return c(h, g);
          iy = true;
          try {
            var p = c(h);
            return p;
          } finally {
            if (iy = false, (fd !== null || gd !== null) && (Y1(), fd && (h = fd, c = gd, gd = fd = null, AI(h), c))) for (h = 0; h < c.length; h++) AI(c[h]);
          }
        }
        function Pg(c, h) {
          var g = c.stateNode;
          if (g === null) return null;
          var p = g[Z] || null;
          if (p === null) return null;
          g = p[h];
          e: switch (h) {
            case "onClick":
            case "onClickCapture":
            case "onDoubleClick":
            case "onDoubleClickCapture":
            case "onMouseDown":
            case "onMouseDownCapture":
            case "onMouseMove":
            case "onMouseMoveCapture":
            case "onMouseUp":
            case "onMouseUpCapture":
            case "onMouseEnter":
              (p = !p.disabled) || (c = c.type, p = !(c === "button" || c === "input" || c === "select" || c === "textarea")), c = !p;
              break e;
            default:
              c = false;
          }
          if (c) return null;
          if (g && typeof g != "function") throw Error(i(231, h, typeof g));
          return g;
        }
        var ja = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), ny = false;
        if (ja) try {
          var Bg = {};
          Object.defineProperty(Bg, "passive", {
            get: function() {
              ny = true;
            }
          }), window.addEventListener("test", Bg, Bg), window.removeEventListener("test", Bg, Bg);
        } catch {
          ny = false;
        }
        var Jl = null, sy = null, h1 = null;
        function OI() {
          if (h1) return h1;
          var c, h = sy, g = h.length, p, w = "value" in Jl ? Jl.value : Jl.textContent, S = w.length;
          for (c = 0; c < g && h[c] === w[c]; c++) ;
          var N = g - c;
          for (p = 1; p <= N && h[g - p] === w[S - p]; p++) ;
          return h1 = w.slice(c, 1 < p ? 1 - p : void 0);
        }
        function d1(c) {
          var h = c.keyCode;
          return "charCode" in c ? (c = c.charCode, c === 0 && h === 13 && (c = 13)) : c = h, c === 10 && (c = 13), 32 <= c || c === 13 ? c : 0;
        }
        function f1() {
          return true;
        }
        function PI() {
          return false;
        }
        function Js(c) {
          function h(g, p, w, S, N) {
            this._reactName = g, this._targetInst = w, this.type = p, this.nativeEvent = S, this.target = N, this.currentTarget = null;
            for (var O in c) c.hasOwnProperty(O) && (g = c[O], this[O] = g ? g(S) : S[O]);
            return this.isDefaultPrevented = (S.defaultPrevented != null ? S.defaultPrevented : S.returnValue === false) ? f1 : PI, this.isPropagationStopped = PI, this;
          }
          return d(h.prototype, {
            preventDefault: function() {
              this.defaultPrevented = true;
              var g = this.nativeEvent;
              g && (g.preventDefault ? g.preventDefault() : typeof g.returnValue != "unknown" && (g.returnValue = false), this.isDefaultPrevented = f1);
            },
            stopPropagation: function() {
              var g = this.nativeEvent;
              g && (g.stopPropagation ? g.stopPropagation() : typeof g.cancelBubble != "unknown" && (g.cancelBubble = true), this.isPropagationStopped = f1);
            },
            persist: function() {
            },
            isPersistent: f1
          }), h;
        }
        var Cu = {
          eventPhase: 0,
          bubbles: 0,
          cancelable: 0,
          timeStamp: function(c) {
            return c.timeStamp || Date.now();
          },
          defaultPrevented: 0,
          isTrusted: 0
        }, g1 = Js(Cu), Fg = d({}, Cu, {
          view: 0,
          detail: 0
        }), dV = Js(Fg), oy, ry, Vg, m1 = d({}, Fg, {
          screenX: 0,
          screenY: 0,
          clientX: 0,
          clientY: 0,
          pageX: 0,
          pageY: 0,
          ctrlKey: 0,
          shiftKey: 0,
          altKey: 0,
          metaKey: 0,
          getModifierState: ly,
          button: 0,
          buttons: 0,
          relatedTarget: function(c) {
            return c.relatedTarget === void 0 ? c.fromElement === c.srcElement ? c.toElement : c.fromElement : c.relatedTarget;
          },
          movementX: function(c) {
            return "movementX" in c ? c.movementX : (c !== Vg && (Vg && c.type === "mousemove" ? (oy = c.screenX - Vg.screenX, ry = c.screenY - Vg.screenY) : ry = oy = 0, Vg = c), oy);
          },
          movementY: function(c) {
            return "movementY" in c ? c.movementY : ry;
          }
        }), BI = Js(m1), fV = d({}, m1, {
          dataTransfer: 0
        }), gV = Js(fV), mV = d({}, Fg, {
          relatedTarget: 0
        }), ay = Js(mV), pV = d({}, Cu, {
          animationName: 0,
          elapsedTime: 0,
          pseudoElement: 0
        }), _V = Js(pV), bV = d({}, Cu, {
          clipboardData: function(c) {
            return "clipboardData" in c ? c.clipboardData : window.clipboardData;
          }
        }), vV = Js(bV), CV = d({}, Cu, {
          data: 0
        }), FI = Js(CV), wV = {
          Esc: "Escape",
          Spacebar: " ",
          Left: "ArrowLeft",
          Up: "ArrowUp",
          Right: "ArrowRight",
          Down: "ArrowDown",
          Del: "Delete",
          Win: "OS",
          Menu: "ContextMenu",
          Apps: "ContextMenu",
          Scroll: "ScrollLock",
          MozPrintableKey: "Unidentified"
        }, yV = {
          8: "Backspace",
          9: "Tab",
          12: "Clear",
          13: "Enter",
          16: "Shift",
          17: "Control",
          18: "Alt",
          19: "Pause",
          20: "CapsLock",
          27: "Escape",
          32: " ",
          33: "PageUp",
          34: "PageDown",
          35: "End",
          36: "Home",
          37: "ArrowLeft",
          38: "ArrowUp",
          39: "ArrowRight",
          40: "ArrowDown",
          45: "Insert",
          46: "Delete",
          112: "F1",
          113: "F2",
          114: "F3",
          115: "F4",
          116: "F5",
          117: "F6",
          118: "F7",
          119: "F8",
          120: "F9",
          121: "F10",
          122: "F11",
          123: "F12",
          144: "NumLock",
          145: "ScrollLock",
          224: "Meta"
        }, SV = {
          Alt: "altKey",
          Control: "ctrlKey",
          Meta: "metaKey",
          Shift: "shiftKey"
        };
        function LV(c) {
          var h = this.nativeEvent;
          return h.getModifierState ? h.getModifierState(c) : (c = SV[c]) ? !!h[c] : false;
        }
        function ly() {
          return LV;
        }
        var xV = d({}, Fg, {
          key: function(c) {
            if (c.key) {
              var h = wV[c.key] || c.key;
              if (h !== "Unidentified") return h;
            }
            return c.type === "keypress" ? (c = d1(c), c === 13 ? "Enter" : String.fromCharCode(c)) : c.type === "keydown" || c.type === "keyup" ? yV[c.keyCode] || "Unidentified" : "";
          },
          code: 0,
          location: 0,
          ctrlKey: 0,
          shiftKey: 0,
          altKey: 0,
          metaKey: 0,
          repeat: 0,
          locale: 0,
          getModifierState: ly,
          charCode: function(c) {
            return c.type === "keypress" ? d1(c) : 0;
          },
          keyCode: function(c) {
            return c.type === "keydown" || c.type === "keyup" ? c.keyCode : 0;
          },
          which: function(c) {
            return c.type === "keypress" ? d1(c) : c.type === "keydown" || c.type === "keyup" ? c.keyCode : 0;
          }
        }), kV = Js(xV), DV = d({}, m1, {
          pointerId: 0,
          width: 0,
          height: 0,
          pressure: 0,
          tangentialPressure: 0,
          tiltX: 0,
          tiltY: 0,
          twist: 0,
          pointerType: 0,
          isPrimary: 0
        }), VI = Js(DV), EV = d({}, Fg, {
          touches: 0,
          targetTouches: 0,
          changedTouches: 0,
          altKey: 0,
          metaKey: 0,
          ctrlKey: 0,
          shiftKey: 0,
          getModifierState: ly
        }), TV = Js(EV), NV = d({}, Cu, {
          propertyName: 0,
          elapsedTime: 0,
          pseudoElement: 0
        }), IV = Js(NV), MV = d({}, m1, {
          deltaX: function(c) {
            return "deltaX" in c ? c.deltaX : "wheelDeltaX" in c ? -c.wheelDeltaX : 0;
          },
          deltaY: function(c) {
            return "deltaY" in c ? c.deltaY : "wheelDeltaY" in c ? -c.wheelDeltaY : "wheelDelta" in c ? -c.wheelDelta : 0;
          },
          deltaZ: 0,
          deltaMode: 0
        }), AV = Js(MV), RV = d({}, Cu, {
          newState: 0,
          oldState: 0
        }), OV = Js(RV), PV = [
          9,
          13,
          27,
          32
        ], cy = ja && "CompositionEvent" in window, Wg = null;
        ja && "documentMode" in document && (Wg = document.documentMode);
        var BV = ja && "TextEvent" in window && !Wg, WI = ja && (!cy || Wg && 8 < Wg && 11 >= Wg), HI = " ", zI = false;
        function UI(c, h) {
          switch (c) {
            case "keyup":
              return PV.indexOf(h.keyCode) !== -1;
            case "keydown":
              return h.keyCode !== 229;
            case "keypress":
            case "mousedown":
            case "focusout":
              return true;
            default:
              return false;
          }
        }
        function $I(c) {
          return c = c.detail, typeof c == "object" && "data" in c ? c.data : null;
        }
        var md = false;
        function FV(c, h) {
          switch (c) {
            case "compositionend":
              return $I(h);
            case "keypress":
              return h.which !== 32 ? null : (zI = true, HI);
            case "textInput":
              return c = h.data, c === HI && zI ? null : c;
            default:
              return null;
          }
        }
        function VV(c, h) {
          if (md) return c === "compositionend" || !cy && UI(c, h) ? (c = OI(), h1 = sy = Jl = null, md = false, c) : null;
          switch (c) {
            case "paste":
              return null;
            case "keypress":
              if (!(h.ctrlKey || h.altKey || h.metaKey) || h.ctrlKey && h.altKey) {
                if (h.char && 1 < h.char.length) return h.char;
                if (h.which) return String.fromCharCode(h.which);
              }
              return null;
            case "compositionend":
              return WI && h.locale !== "ko" ? null : h.data;
            default:
              return null;
          }
        }
        var WV = {
          color: true,
          date: true,
          datetime: true,
          "datetime-local": true,
          email: true,
          month: true,
          number: true,
          password: true,
          range: true,
          search: true,
          tel: true,
          text: true,
          time: true,
          url: true,
          week: true
        };
        function qI(c) {
          var h = c && c.nodeName && c.nodeName.toLowerCase();
          return h === "input" ? !!WV[c.type] : h === "textarea";
        }
        function KI(c, h, g, p) {
          fd ? gd ? gd.push(p) : gd = [
            p
          ] : fd = p, h = tb(h, "onChange"), 0 < h.length && (g = new g1("onChange", "change", null, g, p), c.push({
            event: g,
            listeners: h
          }));
        }
        var Hg = null, zg = null;
        function HV(c) {
          kR(c, 0);
        }
        function p1(c) {
          var h = fn(c);
          if (DI(h)) return c;
        }
        function jI(c, h) {
          if (c === "change") return h;
        }
        var GI = false;
        if (ja) {
          var uy;
          if (ja) {
            var hy = "oninput" in document;
            if (!hy) {
              var YI = document.createElement("div");
              YI.setAttribute("oninput", "return;"), hy = typeof YI.oninput == "function";
            }
            uy = hy;
          } else uy = false;
          GI = uy && (!document.documentMode || 9 < document.documentMode);
        }
        function ZI() {
          Hg && (Hg.detachEvent("onpropertychange", QI), zg = Hg = null);
        }
        function QI(c) {
          if (c.propertyName === "value" && p1(zg)) {
            var h = [];
            KI(h, zg, c, ty(c)), RI(HV, h);
          }
        }
        function zV(c, h, g) {
          c === "focusin" ? (ZI(), Hg = h, zg = g, Hg.attachEvent("onpropertychange", QI)) : c === "focusout" && ZI();
        }
        function UV(c) {
          if (c === "selectionchange" || c === "keyup" || c === "keydown") return p1(zg);
        }
        function $V(c, h) {
          if (c === "click") return p1(h);
        }
        function qV(c, h) {
          if (c === "input" || c === "change") return p1(h);
        }
        function KV(c, h) {
          return c === h && (c !== 0 || 1 / c === 1 / h) || c !== c && h !== h;
        }
        var vo = typeof Object.is == "function" ? Object.is : KV;
        function Ug(c, h) {
          if (vo(c, h)) return true;
          if (typeof c != "object" || c === null || typeof h != "object" || h === null) return false;
          var g = Object.keys(c), p = Object.keys(h);
          if (g.length !== p.length) return false;
          for (p = 0; p < g.length; p++) {
            var w = g[p];
            if (!Ko.call(h, w) || !vo(c[w], h[w])) return false;
          }
          return true;
        }
        function XI(c) {
          for (; c && c.firstChild; ) c = c.firstChild;
          return c;
        }
        function JI(c, h) {
          var g = XI(c);
          c = 0;
          for (var p; g; ) {
            if (g.nodeType === 3) {
              if (p = c + g.textContent.length, c <= h && p >= h) return {
                node: g,
                offset: h - c
              };
              c = p;
            }
            e: {
              for (; g; ) {
                if (g.nextSibling) {
                  g = g.nextSibling;
                  break e;
                }
                g = g.parentNode;
              }
              g = void 0;
            }
            g = XI(g);
          }
        }
        function eM(c, h) {
          return c && h ? c === h ? true : c && c.nodeType === 3 ? false : h && h.nodeType === 3 ? eM(c, h.parentNode) : "contains" in c ? c.contains(h) : c.compareDocumentPosition ? !!(c.compareDocumentPosition(h) & 16) : false : false;
        }
        function tM(c) {
          c = c != null && c.ownerDocument != null && c.ownerDocument.defaultView != null ? c.ownerDocument.defaultView : window;
          for (var h = c1(c.document); h instanceof c.HTMLIFrameElement; ) {
            try {
              var g = typeof h.contentWindow.location.href == "string";
            } catch {
              g = false;
            }
            if (g) c = h.contentWindow;
            else break;
            h = c1(c.document);
          }
          return h;
        }
        function dy(c) {
          var h = c && c.nodeName && c.nodeName.toLowerCase();
          return h && (h === "input" && (c.type === "text" || c.type === "search" || c.type === "tel" || c.type === "url" || c.type === "password") || h === "textarea" || c.contentEditable === "true");
        }
        var jV = ja && "documentMode" in document && 11 >= document.documentMode, pd = null, fy = null, $g = null, gy = false;
        function iM(c, h, g) {
          var p = g.window === g ? g.document : g.nodeType === 9 ? g : g.ownerDocument;
          gy || pd == null || pd !== c1(p) || (p = pd, "selectionStart" in p && dy(p) ? p = {
            start: p.selectionStart,
            end: p.selectionEnd
          } : (p = (p.ownerDocument && p.ownerDocument.defaultView || window).getSelection(), p = {
            anchorNode: p.anchorNode,
            anchorOffset: p.anchorOffset,
            focusNode: p.focusNode,
            focusOffset: p.focusOffset
          }), $g && Ug($g, p) || ($g = p, p = tb(fy, "onSelect"), 0 < p.length && (h = new g1("onSelect", "select", null, h, g), c.push({
            event: h,
            listeners: p
          }), h.target = pd)));
        }
        function wu(c, h) {
          var g = {};
          return g[c.toLowerCase()] = h.toLowerCase(), g["Webkit" + c] = "webkit" + h, g["Moz" + c] = "moz" + h, g;
        }
        var _d2 = {
          animationend: wu("Animation", "AnimationEnd"),
          animationiteration: wu("Animation", "AnimationIteration"),
          animationstart: wu("Animation", "AnimationStart"),
          transitionrun: wu("Transition", "TransitionRun"),
          transitionstart: wu("Transition", "TransitionStart"),
          transitioncancel: wu("Transition", "TransitionCancel"),
          transitionend: wu("Transition", "TransitionEnd")
        }, my = {}, nM = {};
        ja && (nM = document.createElement("div").style, "AnimationEvent" in window || (delete _d2.animationend.animation, delete _d2.animationiteration.animation, delete _d2.animationstart.animation), "TransitionEvent" in window || delete _d2.transitionend.transition);
        function yu(c) {
          if (my[c]) return my[c];
          if (!_d2[c]) return c;
          var h = _d2[c], g;
          for (g in h) if (h.hasOwnProperty(g) && g in nM) return my[c] = h[g];
          return c;
        }
        var sM = yu("animationend"), oM = yu("animationiteration"), rM = yu("animationstart"), GV = yu("transitionrun"), YV = yu("transitionstart"), ZV = yu("transitioncancel"), aM = yu("transitionend"), lM = /* @__PURE__ */ new Map(), py = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
        py.push("scrollEnd");
        function Lr(c, h) {
          lM.set(c, h), De(h, [
            c
          ]);
        }
        var cM = /* @__PURE__ */ new WeakMap();
        function Qo(c, h) {
          if (typeof c == "object" && c !== null) {
            var g = cM.get(c);
            return g !== void 0 ? g : (h = {
              value: c,
              source: h,
              stack: xI(h)
            }, cM.set(c, h), h);
          }
          return {
            value: c,
            source: h,
            stack: xI(h)
          };
        }
        var Xo = [], bd = 0, _y = 0;
        function _1() {
          for (var c = bd, h = _y = bd = 0; h < c; ) {
            var g = Xo[h];
            Xo[h++] = null;
            var p = Xo[h];
            Xo[h++] = null;
            var w = Xo[h];
            Xo[h++] = null;
            var S = Xo[h];
            if (Xo[h++] = null, p !== null && w !== null) {
              var N = p.pending;
              N === null ? w.next = w : (w.next = N.next, N.next = w), p.pending = w;
            }
            S !== 0 && uM(g, w, S);
          }
        }
        function b1(c, h, g, p) {
          Xo[bd++] = c, Xo[bd++] = h, Xo[bd++] = g, Xo[bd++] = p, _y |= p, c.lanes |= p, c = c.alternate, c !== null && (c.lanes |= p);
        }
        function by(c, h, g, p) {
          return b1(c, h, g, p), v1(c);
        }
        function vd(c, h) {
          return b1(c, null, null, h), v1(c);
        }
        function uM(c, h, g) {
          c.lanes |= g;
          var p = c.alternate;
          p !== null && (p.lanes |= g);
          for (var w = false, S = c.return; S !== null; ) S.childLanes |= g, p = S.alternate, p !== null && (p.childLanes |= g), S.tag === 22 && (c = S.stateNode, c === null || c._visibility & 1 || (w = true)), c = S, S = S.return;
          return c.tag === 3 ? (S = c.stateNode, w && h !== null && (w = 31 - dn(g), c = S.hiddenUpdates, p = c[w], p === null ? c[w] = [
            h
          ] : p.push(h), h.lane = g | 536870912), S) : null;
        }
        function v1(c) {
          if (50 < mm) throw mm = 0, LS = null, Error(i(185));
          for (var h = c.return; h !== null; ) c = h, h = c.return;
          return c.tag === 3 ? c.stateNode : null;
        }
        var Cd = {};
        function QV(c, h, g, p) {
          this.tag = c, this.key = g, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = h, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = p, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
        }
        function Co(c, h, g, p) {
          return new QV(c, h, g, p);
        }
        function vy(c) {
          return c = c.prototype, !(!c || !c.isReactComponent);
        }
        function Ga(c, h) {
          var g = c.alternate;
          return g === null ? (g = Co(c.tag, h, c.key, c.mode), g.elementType = c.elementType, g.type = c.type, g.stateNode = c.stateNode, g.alternate = c, c.alternate = g) : (g.pendingProps = h, g.type = c.type, g.flags = 0, g.subtreeFlags = 0, g.deletions = null), g.flags = c.flags & 65011712, g.childLanes = c.childLanes, g.lanes = c.lanes, g.child = c.child, g.memoizedProps = c.memoizedProps, g.memoizedState = c.memoizedState, g.updateQueue = c.updateQueue, h = c.dependencies, g.dependencies = h === null ? null : {
            lanes: h.lanes,
            firstContext: h.firstContext
          }, g.sibling = c.sibling, g.index = c.index, g.ref = c.ref, g.refCleanup = c.refCleanup, g;
        }
        function hM(c, h) {
          c.flags &= 65011714;
          var g = c.alternate;
          return g === null ? (c.childLanes = 0, c.lanes = h, c.child = null, c.subtreeFlags = 0, c.memoizedProps = null, c.memoizedState = null, c.updateQueue = null, c.dependencies = null, c.stateNode = null) : (c.childLanes = g.childLanes, c.lanes = g.lanes, c.child = g.child, c.subtreeFlags = 0, c.deletions = null, c.memoizedProps = g.memoizedProps, c.memoizedState = g.memoizedState, c.updateQueue = g.updateQueue, c.type = g.type, h = g.dependencies, c.dependencies = h === null ? null : {
            lanes: h.lanes,
            firstContext: h.firstContext
          }), c;
        }
        function C1(c, h, g, p, w, S) {
          var N = 0;
          if (p = c, typeof c == "function") vy(c) && (N = 1);
          else if (typeof c == "string") N = JW(c, g, Ae.current) ? 26 : c === "html" || c === "head" || c === "body" ? 27 : 5;
          else e: switch (c) {
            case A:
              return c = Co(31, g, h, w), c.elementType = A, c.lanes = S, c;
            case b:
              return Su(g.children, w, S, h);
            case v:
              N = 8, w |= 24;
              break;
            case y:
              return c = Co(12, g, h, w | 2), c.elementType = y, c.lanes = S, c;
            case T:
              return c = Co(13, g, h, w), c.elementType = T, c.lanes = S, c;
            case M:
              return c = Co(19, g, h, w), c.elementType = M, c.lanes = S, c;
            default:
              if (typeof c == "object" && c !== null) switch (c.$$typeof) {
                case x:
                case D:
                  N = 10;
                  break e;
                case L:
                  N = 9;
                  break e;
                case k:
                  N = 11;
                  break e;
                case I:
                  N = 14;
                  break e;
                case R:
                  N = 16, p = null;
                  break e;
              }
              N = 29, g = Error(i(130, c === null ? "null" : typeof c, "")), p = null;
          }
          return h = Co(N, g, h, w), h.elementType = c, h.type = p, h.lanes = S, h;
        }
        function Su(c, h, g, p) {
          return c = Co(7, c, p, h), c.lanes = g, c;
        }
        function Cy(c, h, g) {
          return c = Co(6, c, null, h), c.lanes = g, c;
        }
        function wy(c, h, g) {
          return h = Co(4, c.children !== null ? c.children : [], c.key, h), h.lanes = g, h.stateNode = {
            containerInfo: c.containerInfo,
            pendingChildren: null,
            implementation: c.implementation
          }, h;
        }
        var wd = [], yd = 0, w1 = null, y1 = 0, Jo = [], er = 0, Lu = null, Ya = 1, Za = "";
        function xu(c, h) {
          wd[yd++] = y1, wd[yd++] = w1, w1 = c, y1 = h;
        }
        function dM(c, h, g) {
          Jo[er++] = Ya, Jo[er++] = Za, Jo[er++] = Lu, Lu = c;
          var p = Ya;
          c = Za;
          var w = 32 - dn(p) - 1;
          p &= ~(1 << w), g += 1;
          var S = 32 - dn(h) + w;
          if (30 < S) {
            var N = w - w % 5;
            S = (p & (1 << N) - 1).toString(32), p >>= N, w -= N, Ya = 1 << 32 - dn(h) + w | g << w | p, Za = S + c;
          } else Ya = 1 << S | g << w | p, Za = c;
        }
        function yy(c) {
          c.return !== null && (xu(c, 1), dM(c, 1, 0));
        }
        function Sy(c) {
          for (; c === w1; ) w1 = wd[--yd], wd[yd] = null, y1 = wd[--yd], wd[yd] = null;
          for (; c === Lu; ) Lu = Jo[--er], Jo[er] = null, Za = Jo[--er], Jo[er] = null, Ya = Jo[--er], Jo[er] = null;
        }
        var Bs = null, Ji = null, ci = false, ku = null, aa = false, Ly = Error(i(519));
        function Du(c) {
          var h = Error(i(418, ""));
          throw jg(Qo(h, c)), Ly;
        }
        function fM(c) {
          var h = c.stateNode, g = c.type, p = c.memoizedProps;
          switch (h[$] = c, h[Z] = p, g) {
            case "dialog":
              Ht("cancel", h), Ht("close", h);
              break;
            case "iframe":
            case "object":
            case "embed":
              Ht("load", h);
              break;
            case "video":
            case "audio":
              for (g = 0; g < _m2.length; g++) Ht(_m2[g], h);
              break;
            case "source":
              Ht("error", h);
              break;
            case "img":
            case "image":
            case "link":
              Ht("error", h), Ht("load", h);
              break;
            case "details":
              Ht("toggle", h);
              break;
            case "input":
              Ht("invalid", h), EI(h, p.value, p.defaultValue, p.checked, p.defaultChecked, p.type, p.name, true), l1(h);
              break;
            case "select":
              Ht("invalid", h);
              break;
            case "textarea":
              Ht("invalid", h), NI(h, p.value, p.defaultValue, p.children), l1(h);
          }
          g = p.children, typeof g != "string" && typeof g != "number" && typeof g != "bigint" || h.textContent === "" + g || p.suppressHydrationWarning === true || NR(h.textContent, g) ? (p.popover != null && (Ht("beforetoggle", h), Ht("toggle", h)), p.onScroll != null && Ht("scroll", h), p.onScrollEnd != null && Ht("scrollend", h), p.onClick != null && (h.onclick = ib), h = true) : h = false, h || Du(c);
        }
        function gM(c) {
          for (Bs = c.return; Bs; ) switch (Bs.tag) {
            case 5:
            case 13:
              aa = false;
              return;
            case 27:
            case 3:
              aa = true;
              return;
            default:
              Bs = Bs.return;
          }
        }
        function qg(c) {
          if (c !== Bs) return false;
          if (!ci) return gM(c), ci = true, false;
          var h = c.tag, g;
          if ((g = h !== 3 && h !== 27) && ((g = h === 5) && (g = c.type, g = !(g !== "form" && g !== "button") || WS(c.type, c.memoizedProps)), g = !g), g && Ji && Du(c), gM(c), h === 13) {
            if (c = c.memoizedState, c = c !== null ? c.dehydrated : null, !c) throw Error(i(317));
            e: {
              for (c = c.nextSibling, h = 0; c; ) {
                if (c.nodeType === 8) if (g = c.data, g === "/$") {
                  if (h === 0) {
                    Ji = kr(c.nextSibling);
                    break e;
                  }
                  h--;
                } else g !== "$" && g !== "$!" && g !== "$?" || h++;
                c = c.nextSibling;
              }
              Ji = null;
            }
          } else h === 27 ? (h = Ji, mc(c.type) ? (c = $S, $S = null, Ji = c) : Ji = h) : Ji = Bs ? kr(c.stateNode.nextSibling) : null;
          return true;
        }
        function Kg() {
          Ji = Bs = null, ci = false;
        }
        function mM() {
          var c = ku;
          return c !== null && (io === null ? io = c : io.push.apply(io, c), ku = null), c;
        }
        function jg(c) {
          ku === null ? ku = [
            c
          ] : ku.push(c);
        }
        var xy = ne(null), Eu = null, Qa = null;
        function ec(c, h, g) {
          ye(xy, h._currentValue), h._currentValue = g;
        }
        function Xa(c) {
          c._currentValue = xy.current, xe(xy);
        }
        function ky(c, h, g) {
          for (; c !== null; ) {
            var p = c.alternate;
            if ((c.childLanes & h) !== h ? (c.childLanes |= h, p !== null && (p.childLanes |= h)) : p !== null && (p.childLanes & h) !== h && (p.childLanes |= h), c === g) break;
            c = c.return;
          }
        }
        function Dy(c, h, g, p) {
          var w = c.child;
          for (w !== null && (w.return = c); w !== null; ) {
            var S = w.dependencies;
            if (S !== null) {
              var N = w.child;
              S = S.firstContext;
              e: for (; S !== null; ) {
                var O = S;
                S = w;
                for (var q = 0; q < h.length; q++) if (O.context === h[q]) {
                  S.lanes |= g, O = S.alternate, O !== null && (O.lanes |= g), ky(S.return, g, c), p || (N = null);
                  break e;
                }
                S = O.next;
              }
            } else if (w.tag === 18) {
              if (N = w.return, N === null) throw Error(i(341));
              N.lanes |= g, S = N.alternate, S !== null && (S.lanes |= g), ky(N, g, c), N = null;
            } else N = w.child;
            if (N !== null) N.return = w;
            else for (N = w; N !== null; ) {
              if (N === c) {
                N = null;
                break;
              }
              if (w = N.sibling, w !== null) {
                w.return = N.return, N = w;
                break;
              }
              N = N.return;
            }
            w = N;
          }
        }
        function Gg(c, h, g, p) {
          c = null;
          for (var w = h, S = false; w !== null; ) {
            if (!S) {
              if ((w.flags & 524288) !== 0) S = true;
              else if ((w.flags & 262144) !== 0) break;
            }
            if (w.tag === 10) {
              var N = w.alternate;
              if (N === null) throw Error(i(387));
              if (N = N.memoizedProps, N !== null) {
                var O = w.type;
                vo(w.pendingProps.value, N.value) || (c !== null ? c.push(O) : c = [
                  O
                ]);
              }
            } else if (w === xi.current) {
              if (N = w.alternate, N === null) throw Error(i(387));
              N.memoizedState.memoizedState !== w.memoizedState.memoizedState && (c !== null ? c.push(Sm) : c = [
                Sm
              ]);
            }
            w = w.return;
          }
          c !== null && Dy(h, c, g, p), h.flags |= 262144;
        }
        function S1(c) {
          for (c = c.firstContext; c !== null; ) {
            if (!vo(c.context._currentValue, c.memoizedValue)) return true;
            c = c.next;
          }
          return false;
        }
        function Tu(c) {
          Eu = c, Qa = null, c = c.dependencies, c !== null && (c.firstContext = null);
        }
        function ws(c) {
          return pM(Eu, c);
        }
        function L1(c, h) {
          return Eu === null && Tu(c), pM(c, h);
        }
        function pM(c, h) {
          var g = h._currentValue;
          if (h = {
            context: h,
            memoizedValue: g,
            next: null
          }, Qa === null) {
            if (c === null) throw Error(i(308));
            Qa = h, c.dependencies = {
              lanes: 0,
              firstContext: h
            }, c.flags |= 524288;
          } else Qa = Qa.next = h;
          return g;
        }
        var XV = typeof AbortController < "u" ? AbortController : function() {
          var c = [], h = this.signal = {
            aborted: false,
            addEventListener: function(g, p) {
              c.push(p);
            }
          };
          this.abort = function() {
            h.aborted = true, c.forEach(function(g) {
              return g();
            });
          };
        }, JV = s.unstable_scheduleCallback, eW = s.unstable_NormalPriority, Vn = {
          $$typeof: D,
          Consumer: null,
          Provider: null,
          _currentValue: null,
          _currentValue2: null,
          _threadCount: 0
        };
        function Ey() {
          return {
            controller: new XV(),
            data: /* @__PURE__ */ new Map(),
            refCount: 0
          };
        }
        function Yg(c) {
          c.refCount--, c.refCount === 0 && JV(eW, function() {
            c.controller.abort();
          });
        }
        var Zg = null, Ty = 0, Sd = 0, Ld = null;
        function tW(c, h) {
          if (Zg === null) {
            var g = Zg = [];
            Ty = 0, Sd = IS(), Ld = {
              status: "pending",
              value: void 0,
              then: function(p) {
                g.push(p);
              }
            };
          }
          return Ty++, h.then(_M, _M), h;
        }
        function _M() {
          if (--Ty === 0 && Zg !== null) {
            Ld !== null && (Ld.status = "fulfilled");
            var c = Zg;
            Zg = null, Sd = 0, Ld = null;
            for (var h = 0; h < c.length; h++) (0, c[h])();
          }
        }
        function iW(c, h) {
          var g = [], p = {
            status: "pending",
            value: null,
            reason: null,
            then: function(w) {
              g.push(w);
            }
          };
          return c.then(function() {
            p.status = "fulfilled", p.value = h;
            for (var w = 0; w < g.length; w++) (0, g[w])(h);
          }, function(w) {
            for (p.status = "rejected", p.reason = w, w = 0; w < g.length; w++) (0, g[w])(void 0);
          }), p;
        }
        var bM = H.S;
        H.S = function(c, h) {
          typeof h == "object" && h !== null && typeof h.then == "function" && tW(c, h), bM !== null && bM(c, h);
        };
        var Nu = ne(null);
        function Ny() {
          var c = Nu.current;
          return c !== null ? c : Pi.pooledCache;
        }
        function x1(c, h) {
          h === null ? ye(Nu, Nu.current) : ye(Nu, h.pool);
        }
        function vM() {
          var c = Ny();
          return c === null ? null : {
            parent: Vn._currentValue,
            pool: c
          };
        }
        var Qg = Error(i(460)), CM = Error(i(474)), k1 = Error(i(542)), Iy = {
          then: function() {
          }
        };
        function wM(c) {
          return c = c.status, c === "fulfilled" || c === "rejected";
        }
        function D1() {
        }
        function yM(c, h, g) {
          switch (g = c[g], g === void 0 ? c.push(h) : g !== h && (h.then(D1, D1), h = g), h.status) {
            case "fulfilled":
              return h.value;
            case "rejected":
              throw c = h.reason, LM(c), c;
            default:
              if (typeof h.status == "string") h.then(D1, D1);
              else {
                if (c = Pi, c !== null && 100 < c.shellSuspendCounter) throw Error(i(482));
                c = h, c.status = "pending", c.then(function(p) {
                  if (h.status === "pending") {
                    var w = h;
                    w.status = "fulfilled", w.value = p;
                  }
                }, function(p) {
                  if (h.status === "pending") {
                    var w = h;
                    w.status = "rejected", w.reason = p;
                  }
                });
              }
              switch (h.status) {
                case "fulfilled":
                  return h.value;
                case "rejected":
                  throw c = h.reason, LM(c), c;
              }
              throw Xg = h, Qg;
          }
        }
        var Xg = null;
        function SM() {
          if (Xg === null) throw Error(i(459));
          var c = Xg;
          return Xg = null, c;
        }
        function LM(c) {
          if (c === Qg || c === k1) throw Error(i(483));
        }
        var tc = false;
        function My(c) {
          c.updateQueue = {
            baseState: c.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: {
              pending: null,
              lanes: 0,
              hiddenCallbacks: null
            },
            callbacks: null
          };
        }
        function Ay(c, h) {
          c = c.updateQueue, h.updateQueue === c && (h.updateQueue = {
            baseState: c.baseState,
            firstBaseUpdate: c.firstBaseUpdate,
            lastBaseUpdate: c.lastBaseUpdate,
            shared: c.shared,
            callbacks: null
          });
        }
        function ic(c) {
          return {
            lane: c,
            tag: 0,
            payload: null,
            callback: null,
            next: null
          };
        }
        function nc(c, h, g) {
          var p = c.updateQueue;
          if (p === null) return null;
          if (p = p.shared, (gi & 2) !== 0) {
            var w = p.pending;
            return w === null ? h.next = h : (h.next = w.next, w.next = h), p.pending = h, h = v1(c), uM(c, null, g), h;
          }
          return b1(c, p, h, g), v1(c);
        }
        function Jg(c, h, g) {
          if (h = h.updateQueue, h !== null && (h = h.shared, (g & 4194048) !== 0)) {
            var p = h.lanes;
            p &= c.pendingLanes, g |= p, h.lanes = g, vu(c, g);
          }
        }
        function Ry(c, h) {
          var g = c.updateQueue, p = c.alternate;
          if (p !== null && (p = p.updateQueue, g === p)) {
            var w = null, S = null;
            if (g = g.firstBaseUpdate, g !== null) {
              do {
                var N = {
                  lane: g.lane,
                  tag: g.tag,
                  payload: g.payload,
                  callback: null,
                  next: null
                };
                S === null ? w = S = N : S = S.next = N, g = g.next;
              } while (g !== null);
              S === null ? w = S = h : S = S.next = h;
            } else w = S = h;
            g = {
              baseState: p.baseState,
              firstBaseUpdate: w,
              lastBaseUpdate: S,
              shared: p.shared,
              callbacks: p.callbacks
            }, c.updateQueue = g;
            return;
          }
          c = g.lastBaseUpdate, c === null ? g.firstBaseUpdate = h : c.next = h, g.lastBaseUpdate = h;
        }
        var Oy = false;
        function em() {
          if (Oy) {
            var c = Ld;
            if (c !== null) throw c;
          }
        }
        function tm(c, h, g, p) {
          Oy = false;
          var w = c.updateQueue;
          tc = false;
          var S = w.firstBaseUpdate, N = w.lastBaseUpdate, O = w.shared.pending;
          if (O !== null) {
            w.shared.pending = null;
            var q = O, ue = q.next;
            q.next = null, N === null ? S = ue : N.next = ue, N = q;
            var ve = c.alternate;
            ve !== null && (ve = ve.updateQueue, O = ve.lastBaseUpdate, O !== N && (O === null ? ve.firstBaseUpdate = ue : O.next = ue, ve.lastBaseUpdate = q));
          }
          if (S !== null) {
            var Le = w.baseState;
            N = 0, ve = ue = q = null, O = S;
            do {
              var ge = O.lane & -536870913, pe = ge !== O.lane;
              if (pe ? (ti & ge) === ge : (p & ge) === ge) {
                ge !== 0 && ge === Sd && (Oy = true), ve !== null && (ve = ve.next = {
                  lane: 0,
                  tag: O.tag,
                  payload: O.payload,
                  callback: null,
                  next: null
                });
                e: {
                  var gt = c, at = O;
                  ge = h;
                  var Ci = g;
                  switch (at.tag) {
                    case 1:
                      if (gt = at.payload, typeof gt == "function") {
                        Le = gt.call(Ci, Le, ge);
                        break e;
                      }
                      Le = gt;
                      break e;
                    case 3:
                      gt.flags = gt.flags & -65537 | 128;
                    case 0:
                      if (gt = at.payload, ge = typeof gt == "function" ? gt.call(Ci, Le, ge) : gt, ge == null) break e;
                      Le = d({}, Le, ge);
                      break e;
                    case 2:
                      tc = true;
                  }
                }
                ge = O.callback, ge !== null && (c.flags |= 64, pe && (c.flags |= 8192), pe = w.callbacks, pe === null ? w.callbacks = [
                  ge
                ] : pe.push(ge));
              } else pe = {
                lane: ge,
                tag: O.tag,
                payload: O.payload,
                callback: O.callback,
                next: null
              }, ve === null ? (ue = ve = pe, q = Le) : ve = ve.next = pe, N |= ge;
              if (O = O.next, O === null) {
                if (O = w.shared.pending, O === null) break;
                pe = O, O = pe.next, pe.next = null, w.lastBaseUpdate = pe, w.shared.pending = null;
              }
            } while (true);
            ve === null && (q = Le), w.baseState = q, w.firstBaseUpdate = ue, w.lastBaseUpdate = ve, S === null && (w.shared.lanes = 0), hc |= N, c.lanes = N, c.memoizedState = Le;
          }
        }
        function xM(c, h) {
          if (typeof c != "function") throw Error(i(191, c));
          c.call(h);
        }
        function kM(c, h) {
          var g = c.callbacks;
          if (g !== null) for (c.callbacks = null, c = 0; c < g.length; c++) xM(g[c], h);
        }
        var xd = ne(null), E1 = ne(0);
        function DM(c, h) {
          c = ol, ye(E1, c), ye(xd, h), ol = c | h.baseLanes;
        }
        function Py() {
          ye(E1, ol), ye(xd, xd.current);
        }
        function By() {
          ol = E1.current, xe(xd), xe(E1);
        }
        var sc = 0, Pt = null, bi = null, Dn = null, T1 = false, kd = false, Iu = false, N1 = 0, im = 0, Dd = null, nW = 0;
        function gn() {
          throw Error(i(321));
        }
        function Fy(c, h) {
          if (h === null) return false;
          for (var g = 0; g < h.length && g < c.length; g++) if (!vo(c[g], h[g])) return false;
          return true;
        }
        function Vy(c, h, g, p, w, S) {
          return sc = S, Pt = h, h.memoizedState = null, h.updateQueue = null, h.lanes = 0, H.H = c === null || c.memoizedState === null ? uA : hA, Iu = false, S = g(p, w), Iu = false, kd && (S = TM(h, g, p, w)), EM(c), S;
        }
        function EM(c) {
          H.H = P1;
          var h = bi !== null && bi.next !== null;
          if (sc = 0, Dn = bi = Pt = null, T1 = false, im = 0, Dd = null, h) throw Error(i(300));
          c === null || jn || (c = c.dependencies, c !== null && S1(c) && (jn = true));
        }
        function TM(c, h, g, p) {
          Pt = c;
          var w = 0;
          do {
            if (kd && (Dd = null), im = 0, kd = false, 25 <= w) throw Error(i(301));
            if (w += 1, Dn = bi = null, c.updateQueue != null) {
              var S = c.updateQueue;
              S.lastEffect = null, S.events = null, S.stores = null, S.memoCache != null && (S.memoCache.index = 0);
            }
            H.H = uW, S = h(g, p);
          } while (kd);
          return S;
        }
        function sW() {
          var c = H.H, h = c.useState()[0];
          return h = typeof h.then == "function" ? nm(h) : h, c = c.useState()[0], (bi !== null ? bi.memoizedState : null) !== c && (Pt.flags |= 1024), h;
        }
        function Wy() {
          var c = N1 !== 0;
          return N1 = 0, c;
        }
        function Hy(c, h, g) {
          h.updateQueue = c.updateQueue, h.flags &= -2053, c.lanes &= ~g;
        }
        function zy(c) {
          if (T1) {
            for (c = c.memoizedState; c !== null; ) {
              var h = c.queue;
              h !== null && (h.pending = null), c = c.next;
            }
            T1 = false;
          }
          sc = 0, Dn = bi = Pt = null, kd = false, im = N1 = 0, Dd = null;
        }
        function eo() {
          var c = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null
          };
          return Dn === null ? Pt.memoizedState = Dn = c : Dn = Dn.next = c, Dn;
        }
        function En() {
          if (bi === null) {
            var c = Pt.alternate;
            c = c !== null ? c.memoizedState : null;
          } else c = bi.next;
          var h = Dn === null ? Pt.memoizedState : Dn.next;
          if (h !== null) Dn = h, bi = c;
          else {
            if (c === null) throw Pt.alternate === null ? Error(i(467)) : Error(i(310));
            bi = c, c = {
              memoizedState: bi.memoizedState,
              baseState: bi.baseState,
              baseQueue: bi.baseQueue,
              queue: bi.queue,
              next: null
            }, Dn === null ? Pt.memoizedState = Dn = c : Dn = Dn.next = c;
          }
          return Dn;
        }
        function Uy() {
          return {
            lastEffect: null,
            events: null,
            stores: null,
            memoCache: null
          };
        }
        function nm(c) {
          var h = im;
          return im += 1, Dd === null && (Dd = []), c = yM(Dd, c, h), h = Pt, (Dn === null ? h.memoizedState : Dn.next) === null && (h = h.alternate, H.H = h === null || h.memoizedState === null ? uA : hA), c;
        }
        function I1(c) {
          if (c !== null && typeof c == "object") {
            if (typeof c.then == "function") return nm(c);
            if (c.$$typeof === D) return ws(c);
          }
          throw Error(i(438, String(c)));
        }
        function $y(c) {
          var h = null, g = Pt.updateQueue;
          if (g !== null && (h = g.memoCache), h == null) {
            var p = Pt.alternate;
            p !== null && (p = p.updateQueue, p !== null && (p = p.memoCache, p != null && (h = {
              data: p.data.map(function(w) {
                return w.slice();
              }),
              index: 0
            })));
          }
          if (h == null && (h = {
            data: [],
            index: 0
          }), g === null && (g = Uy(), Pt.updateQueue = g), g.memoCache = h, g = h.data[h.index], g === void 0) for (g = h.data[h.index] = Array(c), p = 0; p < c; p++) g[p] = Y;
          return h.index++, g;
        }
        function Ja(c, h) {
          return typeof h == "function" ? h(c) : h;
        }
        function M1(c) {
          var h = En();
          return qy(h, bi, c);
        }
        function qy(c, h, g) {
          var p = c.queue;
          if (p === null) throw Error(i(311));
          p.lastRenderedReducer = g;
          var w = c.baseQueue, S = p.pending;
          if (S !== null) {
            if (w !== null) {
              var N = w.next;
              w.next = S.next, S.next = N;
            }
            h.baseQueue = w = S, p.pending = null;
          }
          if (S = c.baseState, w === null) c.memoizedState = S;
          else {
            h = w.next;
            var O = N = null, q = null, ue = h, ve = false;
            do {
              var Le = ue.lane & -536870913;
              if (Le !== ue.lane ? (ti & Le) === Le : (sc & Le) === Le) {
                var ge = ue.revertLane;
                if (ge === 0) q !== null && (q = q.next = {
                  lane: 0,
                  revertLane: 0,
                  action: ue.action,
                  hasEagerState: ue.hasEagerState,
                  eagerState: ue.eagerState,
                  next: null
                }), Le === Sd && (ve = true);
                else if ((sc & ge) === ge) {
                  ue = ue.next, ge === Sd && (ve = true);
                  continue;
                } else Le = {
                  lane: 0,
                  revertLane: ue.revertLane,
                  action: ue.action,
                  hasEagerState: ue.hasEagerState,
                  eagerState: ue.eagerState,
                  next: null
                }, q === null ? (O = q = Le, N = S) : q = q.next = Le, Pt.lanes |= ge, hc |= ge;
                Le = ue.action, Iu && g(S, Le), S = ue.hasEagerState ? ue.eagerState : g(S, Le);
              } else ge = {
                lane: Le,
                revertLane: ue.revertLane,
                action: ue.action,
                hasEagerState: ue.hasEagerState,
                eagerState: ue.eagerState,
                next: null
              }, q === null ? (O = q = ge, N = S) : q = q.next = ge, Pt.lanes |= Le, hc |= Le;
              ue = ue.next;
            } while (ue !== null && ue !== h);
            if (q === null ? N = S : q.next = O, !vo(S, c.memoizedState) && (jn = true, ve && (g = Ld, g !== null))) throw g;
            c.memoizedState = S, c.baseState = N, c.baseQueue = q, p.lastRenderedState = S;
          }
          return w === null && (p.lanes = 0), [
            c.memoizedState,
            p.dispatch
          ];
        }
        function Ky(c) {
          var h = En(), g = h.queue;
          if (g === null) throw Error(i(311));
          g.lastRenderedReducer = c;
          var p = g.dispatch, w = g.pending, S = h.memoizedState;
          if (w !== null) {
            g.pending = null;
            var N = w = w.next;
            do
              S = c(S, N.action), N = N.next;
            while (N !== w);
            vo(S, h.memoizedState) || (jn = true), h.memoizedState = S, h.baseQueue === null && (h.baseState = S), g.lastRenderedState = S;
          }
          return [
            S,
            p
          ];
        }
        function NM(c, h, g) {
          var p = Pt, w = En(), S = ci;
          if (S) {
            if (g === void 0) throw Error(i(407));
            g = g();
          } else g = h();
          var N = !vo((bi || w).memoizedState, g);
          N && (w.memoizedState = g, jn = true), w = w.queue;
          var O = AM.bind(null, p, w, c);
          if (sm(2048, 8, O, [
            c
          ]), w.getSnapshot !== h || N || Dn !== null && Dn.memoizedState.tag & 1) {
            if (p.flags |= 2048, Ed(9, A1(), MM.bind(null, p, w, g, h), null), Pi === null) throw Error(i(349));
            S || (sc & 124) !== 0 || IM(p, h, g);
          }
          return g;
        }
        function IM(c, h, g) {
          c.flags |= 16384, c = {
            getSnapshot: h,
            value: g
          }, h = Pt.updateQueue, h === null ? (h = Uy(), Pt.updateQueue = h, h.stores = [
            c
          ]) : (g = h.stores, g === null ? h.stores = [
            c
          ] : g.push(c));
        }
        function MM(c, h, g, p) {
          h.value = g, h.getSnapshot = p, RM(h) && OM(c);
        }
        function AM(c, h, g) {
          return g(function() {
            RM(h) && OM(c);
          });
        }
        function RM(c) {
          var h = c.getSnapshot;
          c = c.value;
          try {
            var g = h();
            return !vo(c, g);
          } catch {
            return true;
          }
        }
        function OM(c) {
          var h = vd(c, 2);
          h !== null && xo(h, c, 2);
        }
        function jy(c) {
          var h = eo();
          if (typeof c == "function") {
            var g = c;
            if (c = g(), Iu) {
              bo(true);
              try {
                g();
              } finally {
                bo(false);
              }
            }
          }
          return h.memoizedState = h.baseState = c, h.queue = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: Ja,
            lastRenderedState: c
          }, h;
        }
        function PM(c, h, g, p) {
          return c.baseState = g, qy(c, bi, typeof p == "function" ? p : Ja);
        }
        function oW(c, h, g, p, w) {
          if (O1(c)) throw Error(i(485));
          if (c = h.action, c !== null) {
            var S = {
              payload: w,
              action: c,
              next: null,
              isTransition: true,
              status: "pending",
              value: null,
              reason: null,
              listeners: [],
              then: function(N) {
                S.listeners.push(N);
              }
            };
            H.T !== null ? g(true) : S.isTransition = false, p(S), g = h.pending, g === null ? (S.next = h.pending = S, BM(h, S)) : (S.next = g.next, h.pending = g.next = S);
          }
        }
        function BM(c, h) {
          var g = h.action, p = h.payload, w = c.state;
          if (h.isTransition) {
            var S = H.T, N = {};
            H.T = N;
            try {
              var O = g(w, p), q = H.S;
              q !== null && q(N, O), FM(c, h, O);
            } catch (ue) {
              Gy(c, h, ue);
            } finally {
              H.T = S;
            }
          } else try {
            S = g(w, p), FM(c, h, S);
          } catch (ue) {
            Gy(c, h, ue);
          }
        }
        function FM(c, h, g) {
          g !== null && typeof g == "object" && typeof g.then == "function" ? g.then(function(p) {
            VM(c, h, p);
          }, function(p) {
            return Gy(c, h, p);
          }) : VM(c, h, g);
        }
        function VM(c, h, g) {
          h.status = "fulfilled", h.value = g, WM(h), c.state = g, h = c.pending, h !== null && (g = h.next, g === h ? c.pending = null : (g = g.next, h.next = g, BM(c, g)));
        }
        function Gy(c, h, g) {
          var p = c.pending;
          if (c.pending = null, p !== null) {
            p = p.next;
            do
              h.status = "rejected", h.reason = g, WM(h), h = h.next;
            while (h !== p);
          }
          c.action = null;
        }
        function WM(c) {
          c = c.listeners;
          for (var h = 0; h < c.length; h++) (0, c[h])();
        }
        function HM(c, h) {
          return h;
        }
        function zM(c, h) {
          if (ci) {
            var g = Pi.formState;
            if (g !== null) {
              e: {
                var p = Pt;
                if (ci) {
                  if (Ji) {
                    t: {
                      for (var w = Ji, S = aa; w.nodeType !== 8; ) {
                        if (!S) {
                          w = null;
                          break t;
                        }
                        if (w = kr(w.nextSibling), w === null) {
                          w = null;
                          break t;
                        }
                      }
                      S = w.data, w = S === "F!" || S === "F" ? w : null;
                    }
                    if (w) {
                      Ji = kr(w.nextSibling), p = w.data === "F!";
                      break e;
                    }
                  }
                  Du(p);
                }
                p = false;
              }
              p && (h = g[0]);
            }
          }
          return g = eo(), g.memoizedState = g.baseState = h, p = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: HM,
            lastRenderedState: h
          }, g.queue = p, g = aA.bind(null, Pt, p), p.dispatch = g, p = jy(false), S = Jy.bind(null, Pt, false, p.queue), p = eo(), w = {
            state: h,
            dispatch: null,
            action: c,
            pending: null
          }, p.queue = w, g = oW.bind(null, Pt, w, S, g), w.dispatch = g, p.memoizedState = c, [
            h,
            g,
            false
          ];
        }
        function UM(c) {
          var h = En();
          return $M(h, bi, c);
        }
        function $M(c, h, g) {
          if (h = qy(c, h, HM)[0], c = M1(Ja)[0], typeof h == "object" && h !== null && typeof h.then == "function") try {
            var p = nm(h);
          } catch (N) {
            throw N === Qg ? k1 : N;
          }
          else p = h;
          h = En();
          var w = h.queue, S = w.dispatch;
          return g !== h.memoizedState && (Pt.flags |= 2048, Ed(9, A1(), rW.bind(null, w, g), null)), [
            p,
            S,
            c
          ];
        }
        function rW(c, h) {
          c.action = h;
        }
        function qM(c) {
          var h = En(), g = bi;
          if (g !== null) return $M(h, g, c);
          En(), h = h.memoizedState, g = En();
          var p = g.queue.dispatch;
          return g.memoizedState = c, [
            h,
            p,
            false
          ];
        }
        function Ed(c, h, g, p) {
          return c = {
            tag: c,
            create: g,
            deps: p,
            inst: h,
            next: null
          }, h = Pt.updateQueue, h === null && (h = Uy(), Pt.updateQueue = h), g = h.lastEffect, g === null ? h.lastEffect = c.next = c : (p = g.next, g.next = c, c.next = p, h.lastEffect = c), c;
        }
        function A1() {
          return {
            destroy: void 0,
            resource: void 0
          };
        }
        function KM() {
          return En().memoizedState;
        }
        function R1(c, h, g, p) {
          var w = eo();
          p = p === void 0 ? null : p, Pt.flags |= c, w.memoizedState = Ed(1 | h, A1(), g, p);
        }
        function sm(c, h, g, p) {
          var w = En();
          p = p === void 0 ? null : p;
          var S = w.memoizedState.inst;
          bi !== null && p !== null && Fy(p, bi.memoizedState.deps) ? w.memoizedState = Ed(h, S, g, p) : (Pt.flags |= c, w.memoizedState = Ed(1 | h, S, g, p));
        }
        function jM(c, h) {
          R1(8390656, 8, c, h);
        }
        function GM(c, h) {
          sm(2048, 8, c, h);
        }
        function YM(c, h) {
          return sm(4, 2, c, h);
        }
        function ZM(c, h) {
          return sm(4, 4, c, h);
        }
        function QM(c, h) {
          if (typeof h == "function") {
            c = c();
            var g = h(c);
            return function() {
              typeof g == "function" ? g() : h(null);
            };
          }
          if (h != null) return c = c(), h.current = c, function() {
            h.current = null;
          };
        }
        function XM(c, h, g) {
          g = g != null ? g.concat([
            c
          ]) : null, sm(4, 4, QM.bind(null, h, c), g);
        }
        function Yy() {
        }
        function JM(c, h) {
          var g = En();
          h = h === void 0 ? null : h;
          var p = g.memoizedState;
          return h !== null && Fy(h, p[1]) ? p[0] : (g.memoizedState = [
            c,
            h
          ], c);
        }
        function eA(c, h) {
          var g = En();
          h = h === void 0 ? null : h;
          var p = g.memoizedState;
          if (h !== null && Fy(h, p[1])) return p[0];
          if (p = c(), Iu) {
            bo(true);
            try {
              c();
            } finally {
              bo(false);
            }
          }
          return g.memoizedState = [
            p,
            h
          ], p;
        }
        function Zy(c, h, g) {
          return g === void 0 || (sc & 1073741824) !== 0 ? c.memoizedState = h : (c.memoizedState = g, c = nR(), Pt.lanes |= c, hc |= c, g);
        }
        function tA(c, h, g, p) {
          return vo(g, h) ? g : xd.current !== null ? (c = Zy(c, g, p), vo(c, h) || (jn = true), c) : (sc & 42) === 0 ? (jn = true, c.memoizedState = g) : (c = nR(), Pt.lanes |= c, hc |= c, h);
        }
        function iA(c, h, g, p, w) {
          var S = se.p;
          se.p = S !== 0 && 8 > S ? S : 8;
          var N = H.T, O = {};
          H.T = O, Jy(c, false, h, g);
          try {
            var q = w(), ue = H.S;
            if (ue !== null && ue(O, q), q !== null && typeof q == "object" && typeof q.then == "function") {
              var ve = iW(q, p);
              om(c, h, ve, Lo(c));
            } else om(c, h, p, Lo(c));
          } catch (Le) {
            om(c, h, {
              then: function() {
              },
              status: "rejected",
              reason: Le
            }, Lo());
          } finally {
            se.p = S, H.T = N;
          }
        }
        function aW() {
        }
        function Qy(c, h, g, p) {
          if (c.tag !== 5) throw Error(i(476));
          var w = nA(c).queue;
          iA(c, w, h, de, g === null ? aW : function() {
            return sA(c), g(p);
          });
        }
        function nA(c) {
          var h = c.memoizedState;
          if (h !== null) return h;
          h = {
            memoizedState: de,
            baseState: de,
            baseQueue: null,
            queue: {
              pending: null,
              lanes: 0,
              dispatch: null,
              lastRenderedReducer: Ja,
              lastRenderedState: de
            },
            next: null
          };
          var g = {};
          return h.next = {
            memoizedState: g,
            baseState: g,
            baseQueue: null,
            queue: {
              pending: null,
              lanes: 0,
              dispatch: null,
              lastRenderedReducer: Ja,
              lastRenderedState: g
            },
            next: null
          }, c.memoizedState = h, c = c.alternate, c !== null && (c.memoizedState = h), h;
        }
        function sA(c) {
          var h = nA(c).next.queue;
          om(c, h, {}, Lo());
        }
        function Xy() {
          return ws(Sm);
        }
        function oA() {
          return En().memoizedState;
        }
        function rA() {
          return En().memoizedState;
        }
        function lW(c) {
          for (var h = c.return; h !== null; ) {
            switch (h.tag) {
              case 24:
              case 3:
                var g = Lo();
                c = ic(g);
                var p = nc(h, c, g);
                p !== null && (xo(p, h, g), Jg(p, h, g)), h = {
                  cache: Ey()
                }, c.payload = h;
                return;
            }
            h = h.return;
          }
        }
        function cW(c, h, g) {
          var p = Lo();
          g = {
            lane: p,
            revertLane: 0,
            action: g,
            hasEagerState: false,
            eagerState: null,
            next: null
          }, O1(c) ? lA(h, g) : (g = by(c, h, g, p), g !== null && (xo(g, c, p), cA(g, h, p)));
        }
        function aA(c, h, g) {
          var p = Lo();
          om(c, h, g, p);
        }
        function om(c, h, g, p) {
          var w = {
            lane: p,
            revertLane: 0,
            action: g,
            hasEagerState: false,
            eagerState: null,
            next: null
          };
          if (O1(c)) lA(h, w);
          else {
            var S = c.alternate;
            if (c.lanes === 0 && (S === null || S.lanes === 0) && (S = h.lastRenderedReducer, S !== null)) try {
              var N = h.lastRenderedState, O = S(N, g);
              if (w.hasEagerState = true, w.eagerState = O, vo(O, N)) return b1(c, h, w, 0), Pi === null && _1(), false;
            } catch {
            } finally {
            }
            if (g = by(c, h, w, p), g !== null) return xo(g, c, p), cA(g, h, p), true;
          }
          return false;
        }
        function Jy(c, h, g, p) {
          if (p = {
            lane: 2,
            revertLane: IS(),
            action: p,
            hasEagerState: false,
            eagerState: null,
            next: null
          }, O1(c)) {
            if (h) throw Error(i(479));
          } else h = by(c, g, p, 2), h !== null && xo(h, c, 2);
        }
        function O1(c) {
          var h = c.alternate;
          return c === Pt || h !== null && h === Pt;
        }
        function lA(c, h) {
          kd = T1 = true;
          var g = c.pending;
          g === null ? h.next = h : (h.next = g.next, g.next = h), c.pending = h;
        }
        function cA(c, h, g) {
          if ((g & 4194048) !== 0) {
            var p = h.lanes;
            p &= c.pendingLanes, g |= p, h.lanes = g, vu(c, g);
          }
        }
        var P1 = {
          readContext: ws,
          use: I1,
          useCallback: gn,
          useContext: gn,
          useEffect: gn,
          useImperativeHandle: gn,
          useLayoutEffect: gn,
          useInsertionEffect: gn,
          useMemo: gn,
          useReducer: gn,
          useRef: gn,
          useState: gn,
          useDebugValue: gn,
          useDeferredValue: gn,
          useTransition: gn,
          useSyncExternalStore: gn,
          useId: gn,
          useHostTransitionStatus: gn,
          useFormState: gn,
          useActionState: gn,
          useOptimistic: gn,
          useMemoCache: gn,
          useCacheRefresh: gn
        }, uA = {
          readContext: ws,
          use: I1,
          useCallback: function(c, h) {
            return eo().memoizedState = [
              c,
              h === void 0 ? null : h
            ], c;
          },
          useContext: ws,
          useEffect: jM,
          useImperativeHandle: function(c, h, g) {
            g = g != null ? g.concat([
              c
            ]) : null, R1(4194308, 4, QM.bind(null, h, c), g);
          },
          useLayoutEffect: function(c, h) {
            return R1(4194308, 4, c, h);
          },
          useInsertionEffect: function(c, h) {
            R1(4, 2, c, h);
          },
          useMemo: function(c, h) {
            var g = eo();
            h = h === void 0 ? null : h;
            var p = c();
            if (Iu) {
              bo(true);
              try {
                c();
              } finally {
                bo(false);
              }
            }
            return g.memoizedState = [
              p,
              h
            ], p;
          },
          useReducer: function(c, h, g) {
            var p = eo();
            if (g !== void 0) {
              var w = g(h);
              if (Iu) {
                bo(true);
                try {
                  g(h);
                } finally {
                  bo(false);
                }
              }
            } else w = h;
            return p.memoizedState = p.baseState = w, c = {
              pending: null,
              lanes: 0,
              dispatch: null,
              lastRenderedReducer: c,
              lastRenderedState: w
            }, p.queue = c, c = c.dispatch = cW.bind(null, Pt, c), [
              p.memoizedState,
              c
            ];
          },
          useRef: function(c) {
            var h = eo();
            return c = {
              current: c
            }, h.memoizedState = c;
          },
          useState: function(c) {
            c = jy(c);
            var h = c.queue, g = aA.bind(null, Pt, h);
            return h.dispatch = g, [
              c.memoizedState,
              g
            ];
          },
          useDebugValue: Yy,
          useDeferredValue: function(c, h) {
            var g = eo();
            return Zy(g, c, h);
          },
          useTransition: function() {
            var c = jy(false);
            return c = iA.bind(null, Pt, c.queue, true, false), eo().memoizedState = c, [
              false,
              c
            ];
          },
          useSyncExternalStore: function(c, h, g) {
            var p = Pt, w = eo();
            if (ci) {
              if (g === void 0) throw Error(i(407));
              g = g();
            } else {
              if (g = h(), Pi === null) throw Error(i(349));
              (ti & 124) !== 0 || IM(p, h, g);
            }
            w.memoizedState = g;
            var S = {
              value: g,
              getSnapshot: h
            };
            return w.queue = S, jM(AM.bind(null, p, S, c), [
              c
            ]), p.flags |= 2048, Ed(9, A1(), MM.bind(null, p, S, g, h), null), g;
          },
          useId: function() {
            var c = eo(), h = Pi.identifierPrefix;
            if (ci) {
              var g = Za, p = Ya;
              g = (p & ~(1 << 32 - dn(p) - 1)).toString(32) + g, h = "\xAB" + h + "R" + g, g = N1++, 0 < g && (h += "H" + g.toString(32)), h += "\xBB";
            } else g = nW++, h = "\xAB" + h + "r" + g.toString(32) + "\xBB";
            return c.memoizedState = h;
          },
          useHostTransitionStatus: Xy,
          useFormState: zM,
          useActionState: zM,
          useOptimistic: function(c) {
            var h = eo();
            h.memoizedState = h.baseState = c;
            var g = {
              pending: null,
              lanes: 0,
              dispatch: null,
              lastRenderedReducer: null,
              lastRenderedState: null
            };
            return h.queue = g, h = Jy.bind(null, Pt, true, g), g.dispatch = h, [
              c,
              h
            ];
          },
          useMemoCache: $y,
          useCacheRefresh: function() {
            return eo().memoizedState = lW.bind(null, Pt);
          }
        }, hA = {
          readContext: ws,
          use: I1,
          useCallback: JM,
          useContext: ws,
          useEffect: GM,
          useImperativeHandle: XM,
          useInsertionEffect: YM,
          useLayoutEffect: ZM,
          useMemo: eA,
          useReducer: M1,
          useRef: KM,
          useState: function() {
            return M1(Ja);
          },
          useDebugValue: Yy,
          useDeferredValue: function(c, h) {
            var g = En();
            return tA(g, bi.memoizedState, c, h);
          },
          useTransition: function() {
            var c = M1(Ja)[0], h = En().memoizedState;
            return [
              typeof c == "boolean" ? c : nm(c),
              h
            ];
          },
          useSyncExternalStore: NM,
          useId: oA,
          useHostTransitionStatus: Xy,
          useFormState: UM,
          useActionState: UM,
          useOptimistic: function(c, h) {
            var g = En();
            return PM(g, bi, c, h);
          },
          useMemoCache: $y,
          useCacheRefresh: rA
        }, uW = {
          readContext: ws,
          use: I1,
          useCallback: JM,
          useContext: ws,
          useEffect: GM,
          useImperativeHandle: XM,
          useInsertionEffect: YM,
          useLayoutEffect: ZM,
          useMemo: eA,
          useReducer: Ky,
          useRef: KM,
          useState: function() {
            return Ky(Ja);
          },
          useDebugValue: Yy,
          useDeferredValue: function(c, h) {
            var g = En();
            return bi === null ? Zy(g, c, h) : tA(g, bi.memoizedState, c, h);
          },
          useTransition: function() {
            var c = Ky(Ja)[0], h = En().memoizedState;
            return [
              typeof c == "boolean" ? c : nm(c),
              h
            ];
          },
          useSyncExternalStore: NM,
          useId: oA,
          useHostTransitionStatus: Xy,
          useFormState: qM,
          useActionState: qM,
          useOptimistic: function(c, h) {
            var g = En();
            return bi !== null ? PM(g, bi, c, h) : (g.baseState = c, [
              c,
              g.queue.dispatch
            ]);
          },
          useMemoCache: $y,
          useCacheRefresh: rA
        }, Td = null, rm = 0;
        function B1(c) {
          var h = rm;
          return rm += 1, Td === null && (Td = []), yM(Td, c, h);
        }
        function am(c, h) {
          h = h.props.ref, c.ref = h !== void 0 ? h : null;
        }
        function F1(c, h) {
          throw h.$$typeof === f ? Error(i(525)) : (c = Object.prototype.toString.call(h), Error(i(31, c === "[object Object]" ? "object with keys {" + Object.keys(h).join(", ") + "}" : c)));
        }
        function dA(c) {
          var h = c._init;
          return h(c._payload);
        }
        function fA(c) {
          function h(oe, J) {
            if (c) {
              var ae = oe.deletions;
              ae === null ? (oe.deletions = [
                J
              ], oe.flags |= 16) : ae.push(J);
            }
          }
          function g(oe, J) {
            if (!c) return null;
            for (; J !== null; ) h(oe, J), J = J.sibling;
            return null;
          }
          function p(oe) {
            for (var J = /* @__PURE__ */ new Map(); oe !== null; ) oe.key !== null ? J.set(oe.key, oe) : J.set(oe.index, oe), oe = oe.sibling;
            return J;
          }
          function w(oe, J) {
            return oe = Ga(oe, J), oe.index = 0, oe.sibling = null, oe;
          }
          function S(oe, J, ae) {
            return oe.index = ae, c ? (ae = oe.alternate, ae !== null ? (ae = ae.index, ae < J ? (oe.flags |= 67108866, J) : ae) : (oe.flags |= 67108866, J)) : (oe.flags |= 1048576, J);
          }
          function N(oe) {
            return c && oe.alternate === null && (oe.flags |= 67108866), oe;
          }
          function O(oe, J, ae, Se) {
            return J === null || J.tag !== 6 ? (J = Cy(ae, oe.mode, Se), J.return = oe, J) : (J = w(J, ae), J.return = oe, J);
          }
          function q(oe, J, ae, Se) {
            var Ke = ae.type;
            return Ke === b ? ve(oe, J, ae.props.children, Se, ae.key) : J !== null && (J.elementType === Ke || typeof Ke == "object" && Ke !== null && Ke.$$typeof === R && dA(Ke) === J.type) ? (J = w(J, ae.props), am(J, ae), J.return = oe, J) : (J = C1(ae.type, ae.key, ae.props, null, oe.mode, Se), am(J, ae), J.return = oe, J);
          }
          function ue(oe, J, ae, Se) {
            return J === null || J.tag !== 4 || J.stateNode.containerInfo !== ae.containerInfo || J.stateNode.implementation !== ae.implementation ? (J = wy(ae, oe.mode, Se), J.return = oe, J) : (J = w(J, ae.children || []), J.return = oe, J);
          }
          function ve(oe, J, ae, Se, Ke) {
            return J === null || J.tag !== 7 ? (J = Su(ae, oe.mode, Se, Ke), J.return = oe, J) : (J = w(J, ae), J.return = oe, J);
          }
          function Le(oe, J, ae) {
            if (typeof J == "string" && J !== "" || typeof J == "number" || typeof J == "bigint") return J = Cy("" + J, oe.mode, ae), J.return = oe, J;
            if (typeof J == "object" && J !== null) {
              switch (J.$$typeof) {
                case m:
                  return ae = C1(J.type, J.key, J.props, null, oe.mode, ae), am(ae, J), ae.return = oe, ae;
                case _:
                  return J = wy(J, oe.mode, ae), J.return = oe, J;
                case R:
                  var Se = J._init;
                  return J = Se(J._payload), Le(oe, J, ae);
              }
              if (te(J) || j(J)) return J = Su(J, oe.mode, ae, null), J.return = oe, J;
              if (typeof J.then == "function") return Le(oe, B1(J), ae);
              if (J.$$typeof === D) return Le(oe, L1(oe, J), ae);
              F1(oe, J);
            }
            return null;
          }
          function ge(oe, J, ae, Se) {
            var Ke = J !== null ? J.key : null;
            if (typeof ae == "string" && ae !== "" || typeof ae == "number" || typeof ae == "bigint") return Ke !== null ? null : O(oe, J, "" + ae, Se);
            if (typeof ae == "object" && ae !== null) {
              switch (ae.$$typeof) {
                case m:
                  return ae.key === Ke ? q(oe, J, ae, Se) : null;
                case _:
                  return ae.key === Ke ? ue(oe, J, ae, Se) : null;
                case R:
                  return Ke = ae._init, ae = Ke(ae._payload), ge(oe, J, ae, Se);
              }
              if (te(ae) || j(ae)) return Ke !== null ? null : ve(oe, J, ae, Se, null);
              if (typeof ae.then == "function") return ge(oe, J, B1(ae), Se);
              if (ae.$$typeof === D) return ge(oe, J, L1(oe, ae), Se);
              F1(oe, ae);
            }
            return null;
          }
          function pe(oe, J, ae, Se, Ke) {
            if (typeof Se == "string" && Se !== "" || typeof Se == "number" || typeof Se == "bigint") return oe = oe.get(ae) || null, O(J, oe, "" + Se, Ke);
            if (typeof Se == "object" && Se !== null) {
              switch (Se.$$typeof) {
                case m:
                  return oe = oe.get(Se.key === null ? ae : Se.key) || null, q(J, oe, Se, Ke);
                case _:
                  return oe = oe.get(Se.key === null ? ae : Se.key) || null, ue(J, oe, Se, Ke);
                case R:
                  var Vt = Se._init;
                  return Se = Vt(Se._payload), pe(oe, J, ae, Se, Ke);
              }
              if (te(Se) || j(Se)) return oe = oe.get(ae) || null, ve(J, oe, Se, Ke, null);
              if (typeof Se.then == "function") return pe(oe, J, ae, B1(Se), Ke);
              if (Se.$$typeof === D) return pe(oe, J, ae, L1(J, Se), Ke);
              F1(J, Se);
            }
            return null;
          }
          function gt(oe, J, ae, Se) {
            for (var Ke = null, Vt = null, Xe = J, ut = J = 0, Yn = null; Xe !== null && ut < ae.length; ut++) {
              Xe.index > ut ? (Yn = Xe, Xe = null) : Yn = Xe.sibling;
              var ri = ge(oe, Xe, ae[ut], Se);
              if (ri === null) {
                Xe === null && (Xe = Yn);
                break;
              }
              c && Xe && ri.alternate === null && h(oe, Xe), J = S(ri, J, ut), Vt === null ? Ke = ri : Vt.sibling = ri, Vt = ri, Xe = Yn;
            }
            if (ut === ae.length) return g(oe, Xe), ci && xu(oe, ut), Ke;
            if (Xe === null) {
              for (; ut < ae.length; ut++) Xe = Le(oe, ae[ut], Se), Xe !== null && (J = S(Xe, J, ut), Vt === null ? Ke = Xe : Vt.sibling = Xe, Vt = Xe);
              return ci && xu(oe, ut), Ke;
            }
            for (Xe = p(Xe); ut < ae.length; ut++) Yn = pe(Xe, oe, ut, ae[ut], Se), Yn !== null && (c && Yn.alternate !== null && Xe.delete(Yn.key === null ? ut : Yn.key), J = S(Yn, J, ut), Vt === null ? Ke = Yn : Vt.sibling = Yn, Vt = Yn);
            return c && Xe.forEach(function(Cc) {
              return h(oe, Cc);
            }), ci && xu(oe, ut), Ke;
          }
          function at(oe, J, ae, Se) {
            if (ae == null) throw Error(i(151));
            for (var Ke = null, Vt = null, Xe = J, ut = J = 0, Yn = null, ri = ae.next(); Xe !== null && !ri.done; ut++, ri = ae.next()) {
              Xe.index > ut ? (Yn = Xe, Xe = null) : Yn = Xe.sibling;
              var Cc = ge(oe, Xe, ri.value, Se);
              if (Cc === null) {
                Xe === null && (Xe = Yn);
                break;
              }
              c && Xe && Cc.alternate === null && h(oe, Xe), J = S(Cc, J, ut), Vt === null ? Ke = Cc : Vt.sibling = Cc, Vt = Cc, Xe = Yn;
            }
            if (ri.done) return g(oe, Xe), ci && xu(oe, ut), Ke;
            if (Xe === null) {
              for (; !ri.done; ut++, ri = ae.next()) ri = Le(oe, ri.value, Se), ri !== null && (J = S(ri, J, ut), Vt === null ? Ke = ri : Vt.sibling = ri, Vt = ri);
              return ci && xu(oe, ut), Ke;
            }
            for (Xe = p(Xe); !ri.done; ut++, ri = ae.next()) ri = pe(Xe, oe, ut, ri.value, Se), ri !== null && (c && ri.alternate !== null && Xe.delete(ri.key === null ? ut : ri.key), J = S(ri, J, ut), Vt === null ? Ke = ri : Vt.sibling = ri, Vt = ri);
            return c && Xe.forEach(function(hH) {
              return h(oe, hH);
            }), ci && xu(oe, ut), Ke;
          }
          function Ci(oe, J, ae, Se) {
            if (typeof ae == "object" && ae !== null && ae.type === b && ae.key === null && (ae = ae.props.children), typeof ae == "object" && ae !== null) {
              switch (ae.$$typeof) {
                case m:
                  e: {
                    for (var Ke = ae.key; J !== null; ) {
                      if (J.key === Ke) {
                        if (Ke = ae.type, Ke === b) {
                          if (J.tag === 7) {
                            g(oe, J.sibling), Se = w(J, ae.props.children), Se.return = oe, oe = Se;
                            break e;
                          }
                        } else if (J.elementType === Ke || typeof Ke == "object" && Ke !== null && Ke.$$typeof === R && dA(Ke) === J.type) {
                          g(oe, J.sibling), Se = w(J, ae.props), am(Se, ae), Se.return = oe, oe = Se;
                          break e;
                        }
                        g(oe, J);
                        break;
                      } else h(oe, J);
                      J = J.sibling;
                    }
                    ae.type === b ? (Se = Su(ae.props.children, oe.mode, Se, ae.key), Se.return = oe, oe = Se) : (Se = C1(ae.type, ae.key, ae.props, null, oe.mode, Se), am(Se, ae), Se.return = oe, oe = Se);
                  }
                  return N(oe);
                case _:
                  e: {
                    for (Ke = ae.key; J !== null; ) {
                      if (J.key === Ke) if (J.tag === 4 && J.stateNode.containerInfo === ae.containerInfo && J.stateNode.implementation === ae.implementation) {
                        g(oe, J.sibling), Se = w(J, ae.children || []), Se.return = oe, oe = Se;
                        break e;
                      } else {
                        g(oe, J);
                        break;
                      }
                      else h(oe, J);
                      J = J.sibling;
                    }
                    Se = wy(ae, oe.mode, Se), Se.return = oe, oe = Se;
                  }
                  return N(oe);
                case R:
                  return Ke = ae._init, ae = Ke(ae._payload), Ci(oe, J, ae, Se);
              }
              if (te(ae)) return gt(oe, J, ae, Se);
              if (j(ae)) {
                if (Ke = j(ae), typeof Ke != "function") throw Error(i(150));
                return ae = Ke.call(ae), at(oe, J, ae, Se);
              }
              if (typeof ae.then == "function") return Ci(oe, J, B1(ae), Se);
              if (ae.$$typeof === D) return Ci(oe, J, L1(oe, ae), Se);
              F1(oe, ae);
            }
            return typeof ae == "string" && ae !== "" || typeof ae == "number" || typeof ae == "bigint" ? (ae = "" + ae, J !== null && J.tag === 6 ? (g(oe, J.sibling), Se = w(J, ae), Se.return = oe, oe = Se) : (g(oe, J), Se = Cy(ae, oe.mode, Se), Se.return = oe, oe = Se), N(oe)) : g(oe, J);
          }
          return function(oe, J, ae, Se) {
            try {
              rm = 0;
              var Ke = Ci(oe, J, ae, Se);
              return Td = null, Ke;
            } catch (Xe) {
              if (Xe === Qg || Xe === k1) throw Xe;
              var Vt = Co(29, Xe, null, oe.mode);
              return Vt.lanes = Se, Vt.return = oe, Vt;
            } finally {
            }
          };
        }
        var Nd = fA(true), gA = fA(false), tr = ne(null), la = null;
        function oc(c) {
          var h = c.alternate;
          ye(Wn, Wn.current & 1), ye(tr, c), la === null && (h === null || xd.current !== null || h.memoizedState !== null) && (la = c);
        }
        function mA(c) {
          if (c.tag === 22) {
            if (ye(Wn, Wn.current), ye(tr, c), la === null) {
              var h = c.alternate;
              h !== null && h.memoizedState !== null && (la = c);
            }
          } else rc();
        }
        function rc() {
          ye(Wn, Wn.current), ye(tr, tr.current);
        }
        function el(c) {
          xe(tr), la === c && (la = null), xe(Wn);
        }
        var Wn = ne(0);
        function V1(c) {
          for (var h = c; h !== null; ) {
            if (h.tag === 13) {
              var g = h.memoizedState;
              if (g !== null && (g = g.dehydrated, g === null || g.data === "$?" || US(g))) return h;
            } else if (h.tag === 19 && h.memoizedProps.revealOrder !== void 0) {
              if ((h.flags & 128) !== 0) return h;
            } else if (h.child !== null) {
              h.child.return = h, h = h.child;
              continue;
            }
            if (h === c) break;
            for (; h.sibling === null; ) {
              if (h.return === null || h.return === c) return null;
              h = h.return;
            }
            h.sibling.return = h.return, h = h.sibling;
          }
          return null;
        }
        function eS(c, h, g, p) {
          h = c.memoizedState, g = g(p, h), g = g == null ? h : d({}, h, g), c.memoizedState = g, c.lanes === 0 && (c.updateQueue.baseState = g);
        }
        var tS = {
          enqueueSetState: function(c, h, g) {
            c = c._reactInternals;
            var p = Lo(), w = ic(p);
            w.payload = h, g != null && (w.callback = g), h = nc(c, w, p), h !== null && (xo(h, c, p), Jg(h, c, p));
          },
          enqueueReplaceState: function(c, h, g) {
            c = c._reactInternals;
            var p = Lo(), w = ic(p);
            w.tag = 1, w.payload = h, g != null && (w.callback = g), h = nc(c, w, p), h !== null && (xo(h, c, p), Jg(h, c, p));
          },
          enqueueForceUpdate: function(c, h) {
            c = c._reactInternals;
            var g = Lo(), p = ic(g);
            p.tag = 2, h != null && (p.callback = h), h = nc(c, p, g), h !== null && (xo(h, c, g), Jg(h, c, g));
          }
        };
        function pA(c, h, g, p, w, S, N) {
          return c = c.stateNode, typeof c.shouldComponentUpdate == "function" ? c.shouldComponentUpdate(p, S, N) : h.prototype && h.prototype.isPureReactComponent ? !Ug(g, p) || !Ug(w, S) : true;
        }
        function _A(c, h, g, p) {
          c = h.state, typeof h.componentWillReceiveProps == "function" && h.componentWillReceiveProps(g, p), typeof h.UNSAFE_componentWillReceiveProps == "function" && h.UNSAFE_componentWillReceiveProps(g, p), h.state !== c && tS.enqueueReplaceState(h, h.state, null);
        }
        function Mu(c, h) {
          var g = h;
          if ("ref" in h) {
            g = {};
            for (var p in h) p !== "ref" && (g[p] = h[p]);
          }
          if (c = c.defaultProps) {
            g === h && (g = d({}, g));
            for (var w in c) g[w] === void 0 && (g[w] = c[w]);
          }
          return g;
        }
        var W1 = typeof reportError == "function" ? reportError : function(c) {
          if (typeof window == "object" && typeof window.ErrorEvent == "function") {
            var h = new window.ErrorEvent("error", {
              bubbles: true,
              cancelable: true,
              message: typeof c == "object" && c !== null && typeof c.message == "string" ? String(c.message) : String(c),
              error: c
            });
            if (!window.dispatchEvent(h)) return;
          } else if (typeof process == "object" && typeof process.emit == "function") {
            process.emit("uncaughtException", c);
            return;
          }
          console.error(c);
        };
        function bA(c) {
          W1(c);
        }
        function vA(c) {
          console.error(c);
        }
        function CA(c) {
          W1(c);
        }
        function H1(c, h) {
          try {
            var g = c.onUncaughtError;
            g(h.value, {
              componentStack: h.stack
            });
          } catch (p) {
            setTimeout(function() {
              throw p;
            });
          }
        }
        function wA(c, h, g) {
          try {
            var p = c.onCaughtError;
            p(g.value, {
              componentStack: g.stack,
              errorBoundary: h.tag === 1 ? h.stateNode : null
            });
          } catch (w) {
            setTimeout(function() {
              throw w;
            });
          }
        }
        function iS(c, h, g) {
          return g = ic(g), g.tag = 3, g.payload = {
            element: null
          }, g.callback = function() {
            H1(c, h);
          }, g;
        }
        function yA(c) {
          return c = ic(c), c.tag = 3, c;
        }
        function SA(c, h, g, p) {
          var w = g.type.getDerivedStateFromError;
          if (typeof w == "function") {
            var S = p.value;
            c.payload = function() {
              return w(S);
            }, c.callback = function() {
              wA(h, g, p);
            };
          }
          var N = g.stateNode;
          N !== null && typeof N.componentDidCatch == "function" && (c.callback = function() {
            wA(h, g, p), typeof w != "function" && (dc === null ? dc = /* @__PURE__ */ new Set([
              this
            ]) : dc.add(this));
            var O = p.stack;
            this.componentDidCatch(p.value, {
              componentStack: O !== null ? O : ""
            });
          });
        }
        function hW(c, h, g, p, w) {
          if (g.flags |= 32768, p !== null && typeof p == "object" && typeof p.then == "function") {
            if (h = g.alternate, h !== null && Gg(h, g, w, true), g = tr.current, g !== null) {
              switch (g.tag) {
                case 13:
                  return la === null ? kS() : g.alternate === null && en === 0 && (en = 3), g.flags &= -257, g.flags |= 65536, g.lanes = w, p === Iy ? g.flags |= 16384 : (h = g.updateQueue, h === null ? g.updateQueue = /* @__PURE__ */ new Set([
                    p
                  ]) : h.add(p), ES(c, p, w)), false;
                case 22:
                  return g.flags |= 65536, p === Iy ? g.flags |= 16384 : (h = g.updateQueue, h === null ? (h = {
                    transitions: null,
                    markerInstances: null,
                    retryQueue: /* @__PURE__ */ new Set([
                      p
                    ])
                  }, g.updateQueue = h) : (g = h.retryQueue, g === null ? h.retryQueue = /* @__PURE__ */ new Set([
                    p
                  ]) : g.add(p)), ES(c, p, w)), false;
              }
              throw Error(i(435, g.tag));
            }
            return ES(c, p, w), kS(), false;
          }
          if (ci) return h = tr.current, h !== null ? ((h.flags & 65536) === 0 && (h.flags |= 256), h.flags |= 65536, h.lanes = w, p !== Ly && (c = Error(i(422), {
            cause: p
          }), jg(Qo(c, g)))) : (p !== Ly && (h = Error(i(423), {
            cause: p
          }), jg(Qo(h, g))), c = c.current.alternate, c.flags |= 65536, w &= -w, c.lanes |= w, p = Qo(p, g), w = iS(c.stateNode, p, w), Ry(c, w), en !== 4 && (en = 2)), false;
          var S = Error(i(520), {
            cause: p
          });
          if (S = Qo(S, g), gm === null ? gm = [
            S
          ] : gm.push(S), en !== 4 && (en = 2), h === null) return true;
          p = Qo(p, g), g = h;
          do {
            switch (g.tag) {
              case 3:
                return g.flags |= 65536, c = w & -w, g.lanes |= c, c = iS(g.stateNode, p, c), Ry(g, c), false;
              case 1:
                if (h = g.type, S = g.stateNode, (g.flags & 128) === 0 && (typeof h.getDerivedStateFromError == "function" || S !== null && typeof S.componentDidCatch == "function" && (dc === null || !dc.has(S)))) return g.flags |= 65536, w &= -w, g.lanes |= w, w = yA(w), SA(w, c, g, p), Ry(g, w), false;
            }
            g = g.return;
          } while (g !== null);
          return false;
        }
        var LA = Error(i(461)), jn = false;
        function rs(c, h, g, p) {
          h.child = c === null ? gA(h, null, g, p) : Nd(h, c.child, g, p);
        }
        function xA(c, h, g, p, w) {
          g = g.render;
          var S = h.ref;
          if ("ref" in p) {
            var N = {};
            for (var O in p) O !== "ref" && (N[O] = p[O]);
          } else N = p;
          return Tu(h), p = Vy(c, h, g, N, S, w), O = Wy(), c !== null && !jn ? (Hy(c, h, w), tl(c, h, w)) : (ci && O && yy(h), h.flags |= 1, rs(c, h, p, w), h.child);
        }
        function kA(c, h, g, p, w) {
          if (c === null) {
            var S = g.type;
            return typeof S == "function" && !vy(S) && S.defaultProps === void 0 && g.compare === null ? (h.tag = 15, h.type = S, DA(c, h, S, p, w)) : (c = C1(g.type, null, p, h, h.mode, w), c.ref = h.ref, c.return = h, h.child = c);
          }
          if (S = c.child, !uS(c, w)) {
            var N = S.memoizedProps;
            if (g = g.compare, g = g !== null ? g : Ug, g(N, p) && c.ref === h.ref) return tl(c, h, w);
          }
          return h.flags |= 1, c = Ga(S, p), c.ref = h.ref, c.return = h, h.child = c;
        }
        function DA(c, h, g, p, w) {
          if (c !== null) {
            var S = c.memoizedProps;
            if (Ug(S, p) && c.ref === h.ref) if (jn = false, h.pendingProps = p = S, uS(c, w)) (c.flags & 131072) !== 0 && (jn = true);
            else return h.lanes = c.lanes, tl(c, h, w);
          }
          return nS(c, h, g, p, w);
        }
        function EA(c, h, g) {
          var p = h.pendingProps, w = p.children, S = c !== null ? c.memoizedState : null;
          if (p.mode === "hidden") {
            if ((h.flags & 128) !== 0) {
              if (p = S !== null ? S.baseLanes | g : g, c !== null) {
                for (w = h.child = c.child, S = 0; w !== null; ) S = S | w.lanes | w.childLanes, w = w.sibling;
                h.childLanes = S & ~p;
              } else h.childLanes = 0, h.child = null;
              return TA(c, h, p, g);
            }
            if ((g & 536870912) !== 0) h.memoizedState = {
              baseLanes: 0,
              cachePool: null
            }, c !== null && x1(h, S !== null ? S.cachePool : null), S !== null ? DM(h, S) : Py(), mA(h);
            else return h.lanes = h.childLanes = 536870912, TA(c, h, S !== null ? S.baseLanes | g : g, g);
          } else S !== null ? (x1(h, S.cachePool), DM(h, S), rc(), h.memoizedState = null) : (c !== null && x1(h, null), Py(), rc());
          return rs(c, h, w, g), h.child;
        }
        function TA(c, h, g, p) {
          var w = Ny();
          return w = w === null ? null : {
            parent: Vn._currentValue,
            pool: w
          }, h.memoizedState = {
            baseLanes: g,
            cachePool: w
          }, c !== null && x1(h, null), Py(), mA(h), c !== null && Gg(c, h, p, true), null;
        }
        function z1(c, h) {
          var g = h.ref;
          if (g === null) c !== null && c.ref !== null && (h.flags |= 4194816);
          else {
            if (typeof g != "function" && typeof g != "object") throw Error(i(284));
            (c === null || c.ref !== g) && (h.flags |= 4194816);
          }
        }
        function nS(c, h, g, p, w) {
          return Tu(h), g = Vy(c, h, g, p, void 0, w), p = Wy(), c !== null && !jn ? (Hy(c, h, w), tl(c, h, w)) : (ci && p && yy(h), h.flags |= 1, rs(c, h, g, w), h.child);
        }
        function NA(c, h, g, p, w, S) {
          return Tu(h), h.updateQueue = null, g = TM(h, p, g, w), EM(c), p = Wy(), c !== null && !jn ? (Hy(c, h, S), tl(c, h, S)) : (ci && p && yy(h), h.flags |= 1, rs(c, h, g, S), h.child);
        }
        function IA(c, h, g, p, w) {
          if (Tu(h), h.stateNode === null) {
            var S = Cd, N = g.contextType;
            typeof N == "object" && N !== null && (S = ws(N)), S = new g(p, S), h.memoizedState = S.state !== null && S.state !== void 0 ? S.state : null, S.updater = tS, h.stateNode = S, S._reactInternals = h, S = h.stateNode, S.props = p, S.state = h.memoizedState, S.refs = {}, My(h), N = g.contextType, S.context = typeof N == "object" && N !== null ? ws(N) : Cd, S.state = h.memoizedState, N = g.getDerivedStateFromProps, typeof N == "function" && (eS(h, g, N, p), S.state = h.memoizedState), typeof g.getDerivedStateFromProps == "function" || typeof S.getSnapshotBeforeUpdate == "function" || typeof S.UNSAFE_componentWillMount != "function" && typeof S.componentWillMount != "function" || (N = S.state, typeof S.componentWillMount == "function" && S.componentWillMount(), typeof S.UNSAFE_componentWillMount == "function" && S.UNSAFE_componentWillMount(), N !== S.state && tS.enqueueReplaceState(S, S.state, null), tm(h, p, S, w), em(), S.state = h.memoizedState), typeof S.componentDidMount == "function" && (h.flags |= 4194308), p = true;
          } else if (c === null) {
            S = h.stateNode;
            var O = h.memoizedProps, q = Mu(g, O);
            S.props = q;
            var ue = S.context, ve = g.contextType;
            N = Cd, typeof ve == "object" && ve !== null && (N = ws(ve));
            var Le = g.getDerivedStateFromProps;
            ve = typeof Le == "function" || typeof S.getSnapshotBeforeUpdate == "function", O = h.pendingProps !== O, ve || typeof S.UNSAFE_componentWillReceiveProps != "function" && typeof S.componentWillReceiveProps != "function" || (O || ue !== N) && _A(h, S, p, N), tc = false;
            var ge = h.memoizedState;
            S.state = ge, tm(h, p, S, w), em(), ue = h.memoizedState, O || ge !== ue || tc ? (typeof Le == "function" && (eS(h, g, Le, p), ue = h.memoizedState), (q = tc || pA(h, g, q, p, ge, ue, N)) ? (ve || typeof S.UNSAFE_componentWillMount != "function" && typeof S.componentWillMount != "function" || (typeof S.componentWillMount == "function" && S.componentWillMount(), typeof S.UNSAFE_componentWillMount == "function" && S.UNSAFE_componentWillMount()), typeof S.componentDidMount == "function" && (h.flags |= 4194308)) : (typeof S.componentDidMount == "function" && (h.flags |= 4194308), h.memoizedProps = p, h.memoizedState = ue), S.props = p, S.state = ue, S.context = N, p = q) : (typeof S.componentDidMount == "function" && (h.flags |= 4194308), p = false);
          } else {
            S = h.stateNode, Ay(c, h), N = h.memoizedProps, ve = Mu(g, N), S.props = ve, Le = h.pendingProps, ge = S.context, ue = g.contextType, q = Cd, typeof ue == "object" && ue !== null && (q = ws(ue)), O = g.getDerivedStateFromProps, (ue = typeof O == "function" || typeof S.getSnapshotBeforeUpdate == "function") || typeof S.UNSAFE_componentWillReceiveProps != "function" && typeof S.componentWillReceiveProps != "function" || (N !== Le || ge !== q) && _A(h, S, p, q), tc = false, ge = h.memoizedState, S.state = ge, tm(h, p, S, w), em();
            var pe = h.memoizedState;
            N !== Le || ge !== pe || tc || c !== null && c.dependencies !== null && S1(c.dependencies) ? (typeof O == "function" && (eS(h, g, O, p), pe = h.memoizedState), (ve = tc || pA(h, g, ve, p, ge, pe, q) || c !== null && c.dependencies !== null && S1(c.dependencies)) ? (ue || typeof S.UNSAFE_componentWillUpdate != "function" && typeof S.componentWillUpdate != "function" || (typeof S.componentWillUpdate == "function" && S.componentWillUpdate(p, pe, q), typeof S.UNSAFE_componentWillUpdate == "function" && S.UNSAFE_componentWillUpdate(p, pe, q)), typeof S.componentDidUpdate == "function" && (h.flags |= 4), typeof S.getSnapshotBeforeUpdate == "function" && (h.flags |= 1024)) : (typeof S.componentDidUpdate != "function" || N === c.memoizedProps && ge === c.memoizedState || (h.flags |= 4), typeof S.getSnapshotBeforeUpdate != "function" || N === c.memoizedProps && ge === c.memoizedState || (h.flags |= 1024), h.memoizedProps = p, h.memoizedState = pe), S.props = p, S.state = pe, S.context = q, p = ve) : (typeof S.componentDidUpdate != "function" || N === c.memoizedProps && ge === c.memoizedState || (h.flags |= 4), typeof S.getSnapshotBeforeUpdate != "function" || N === c.memoizedProps && ge === c.memoizedState || (h.flags |= 1024), p = false);
          }
          return S = p, z1(c, h), p = (h.flags & 128) !== 0, S || p ? (S = h.stateNode, g = p && typeof g.getDerivedStateFromError != "function" ? null : S.render(), h.flags |= 1, c !== null && p ? (h.child = Nd(h, c.child, null, w), h.child = Nd(h, null, g, w)) : rs(c, h, g, w), h.memoizedState = S.state, c = h.child) : c = tl(c, h, w), c;
        }
        function MA(c, h, g, p) {
          return Kg(), h.flags |= 256, rs(c, h, g, p), h.child;
        }
        var sS = {
          dehydrated: null,
          treeContext: null,
          retryLane: 0,
          hydrationErrors: null
        };
        function oS(c) {
          return {
            baseLanes: c,
            cachePool: vM()
          };
        }
        function rS(c, h, g) {
          return c = c !== null ? c.childLanes & ~g : 0, h && (c |= ir), c;
        }
        function AA(c, h, g) {
          var p = h.pendingProps, w = false, S = (h.flags & 128) !== 0, N;
          if ((N = S) || (N = c !== null && c.memoizedState === null ? false : (Wn.current & 2) !== 0), N && (w = true, h.flags &= -129), N = (h.flags & 32) !== 0, h.flags &= -33, c === null) {
            if (ci) {
              if (w ? oc(h) : rc(), ci) {
                var O = Ji, q;
                if (q = O) {
                  e: {
                    for (q = O, O = aa; q.nodeType !== 8; ) {
                      if (!O) {
                        O = null;
                        break e;
                      }
                      if (q = kr(q.nextSibling), q === null) {
                        O = null;
                        break e;
                      }
                    }
                    O = q;
                  }
                  O !== null ? (h.memoizedState = {
                    dehydrated: O,
                    treeContext: Lu !== null ? {
                      id: Ya,
                      overflow: Za
                    } : null,
                    retryLane: 536870912,
                    hydrationErrors: null
                  }, q = Co(18, null, null, 0), q.stateNode = O, q.return = h, h.child = q, Bs = h, Ji = null, q = true) : q = false;
                }
                q || Du(h);
              }
              if (O = h.memoizedState, O !== null && (O = O.dehydrated, O !== null)) return US(O) ? h.lanes = 32 : h.lanes = 536870912, null;
              el(h);
            }
            return O = p.children, p = p.fallback, w ? (rc(), w = h.mode, O = U1({
              mode: "hidden",
              children: O
            }, w), p = Su(p, w, g, null), O.return = h, p.return = h, O.sibling = p, h.child = O, w = h.child, w.memoizedState = oS(g), w.childLanes = rS(c, N, g), h.memoizedState = sS, p) : (oc(h), aS(h, O));
          }
          if (q = c.memoizedState, q !== null && (O = q.dehydrated, O !== null)) {
            if (S) h.flags & 256 ? (oc(h), h.flags &= -257, h = lS(c, h, g)) : h.memoizedState !== null ? (rc(), h.child = c.child, h.flags |= 128, h = null) : (rc(), w = p.fallback, O = h.mode, p = U1({
              mode: "visible",
              children: p.children
            }, O), w = Su(w, O, g, null), w.flags |= 2, p.return = h, w.return = h, p.sibling = w, h.child = p, Nd(h, c.child, null, g), p = h.child, p.memoizedState = oS(g), p.childLanes = rS(c, N, g), h.memoizedState = sS, h = w);
            else if (oc(h), US(O)) {
              if (N = O.nextSibling && O.nextSibling.dataset, N) var ue = N.dgst;
              N = ue, p = Error(i(419)), p.stack = "", p.digest = N, jg({
                value: p,
                source: null,
                stack: null
              }), h = lS(c, h, g);
            } else if (jn || Gg(c, h, g, false), N = (g & c.childLanes) !== 0, jn || N) {
              if (N = Pi, N !== null && (p = g & -g, p = (p & 42) !== 0 ? 1 : Ka(p), p = (p & (N.suspendedLanes | g)) !== 0 ? 0 : p, p !== 0 && p !== q.retryLane)) throw q.retryLane = p, vd(c, p), xo(N, c, p), LA;
              O.data === "$?" || kS(), h = lS(c, h, g);
            } else O.data === "$?" ? (h.flags |= 192, h.child = c.child, h = null) : (c = q.treeContext, Ji = kr(O.nextSibling), Bs = h, ci = true, ku = null, aa = false, c !== null && (Jo[er++] = Ya, Jo[er++] = Za, Jo[er++] = Lu, Ya = c.id, Za = c.overflow, Lu = h), h = aS(h, p.children), h.flags |= 4096);
            return h;
          }
          return w ? (rc(), w = p.fallback, O = h.mode, q = c.child, ue = q.sibling, p = Ga(q, {
            mode: "hidden",
            children: p.children
          }), p.subtreeFlags = q.subtreeFlags & 65011712, ue !== null ? w = Ga(ue, w) : (w = Su(w, O, g, null), w.flags |= 2), w.return = h, p.return = h, p.sibling = w, h.child = p, p = w, w = h.child, O = c.child.memoizedState, O === null ? O = oS(g) : (q = O.cachePool, q !== null ? (ue = Vn._currentValue, q = q.parent !== ue ? {
            parent: ue,
            pool: ue
          } : q) : q = vM(), O = {
            baseLanes: O.baseLanes | g,
            cachePool: q
          }), w.memoizedState = O, w.childLanes = rS(c, N, g), h.memoizedState = sS, p) : (oc(h), g = c.child, c = g.sibling, g = Ga(g, {
            mode: "visible",
            children: p.children
          }), g.return = h, g.sibling = null, c !== null && (N = h.deletions, N === null ? (h.deletions = [
            c
          ], h.flags |= 16) : N.push(c)), h.child = g, h.memoizedState = null, g);
        }
        function aS(c, h) {
          return h = U1({
            mode: "visible",
            children: h
          }, c.mode), h.return = c, c.child = h;
        }
        function U1(c, h) {
          return c = Co(22, c, null, h), c.lanes = 0, c.stateNode = {
            _visibility: 1,
            _pendingMarkers: null,
            _retryCache: null,
            _transitions: null
          }, c;
        }
        function lS(c, h, g) {
          return Nd(h, c.child, null, g), c = aS(h, h.pendingProps.children), c.flags |= 2, h.memoizedState = null, c;
        }
        function RA(c, h, g) {
          c.lanes |= h;
          var p = c.alternate;
          p !== null && (p.lanes |= h), ky(c.return, h, g);
        }
        function cS(c, h, g, p, w) {
          var S = c.memoizedState;
          S === null ? c.memoizedState = {
            isBackwards: h,
            rendering: null,
            renderingStartTime: 0,
            last: p,
            tail: g,
            tailMode: w
          } : (S.isBackwards = h, S.rendering = null, S.renderingStartTime = 0, S.last = p, S.tail = g, S.tailMode = w);
        }
        function OA(c, h, g) {
          var p = h.pendingProps, w = p.revealOrder, S = p.tail;
          if (rs(c, h, p.children, g), p = Wn.current, (p & 2) !== 0) p = p & 1 | 2, h.flags |= 128;
          else {
            if (c !== null && (c.flags & 128) !== 0) e: for (c = h.child; c !== null; ) {
              if (c.tag === 13) c.memoizedState !== null && RA(c, g, h);
              else if (c.tag === 19) RA(c, g, h);
              else if (c.child !== null) {
                c.child.return = c, c = c.child;
                continue;
              }
              if (c === h) break e;
              for (; c.sibling === null; ) {
                if (c.return === null || c.return === h) break e;
                c = c.return;
              }
              c.sibling.return = c.return, c = c.sibling;
            }
            p &= 1;
          }
          switch (ye(Wn, p), w) {
            case "forwards":
              for (g = h.child, w = null; g !== null; ) c = g.alternate, c !== null && V1(c) === null && (w = g), g = g.sibling;
              g = w, g === null ? (w = h.child, h.child = null) : (w = g.sibling, g.sibling = null), cS(h, false, w, g, S);
              break;
            case "backwards":
              for (g = null, w = h.child, h.child = null; w !== null; ) {
                if (c = w.alternate, c !== null && V1(c) === null) {
                  h.child = w;
                  break;
                }
                c = w.sibling, w.sibling = g, g = w, w = c;
              }
              cS(h, true, g, null, S);
              break;
            case "together":
              cS(h, false, null, null, void 0);
              break;
            default:
              h.memoizedState = null;
          }
          return h.child;
        }
        function tl(c, h, g) {
          if (c !== null && (h.dependencies = c.dependencies), hc |= h.lanes, (g & h.childLanes) === 0) if (c !== null) {
            if (Gg(c, h, g, false), (g & h.childLanes) === 0) return null;
          } else return null;
          if (c !== null && h.child !== c.child) throw Error(i(153));
          if (h.child !== null) {
            for (c = h.child, g = Ga(c, c.pendingProps), h.child = g, g.return = h; c.sibling !== null; ) c = c.sibling, g = g.sibling = Ga(c, c.pendingProps), g.return = h;
            g.sibling = null;
          }
          return h.child;
        }
        function uS(c, h) {
          return (c.lanes & h) !== 0 ? true : (c = c.dependencies, !!(c !== null && S1(c)));
        }
        function dW(c, h, g) {
          switch (h.tag) {
            case 3:
              ct(h, h.stateNode.containerInfo), ec(h, Vn, c.memoizedState.cache), Kg();
              break;
            case 27:
            case 5:
              qo(h);
              break;
            case 4:
              ct(h, h.stateNode.containerInfo);
              break;
            case 10:
              ec(h, h.type, h.memoizedProps.value);
              break;
            case 13:
              var p = h.memoizedState;
              if (p !== null) return p.dehydrated !== null ? (oc(h), h.flags |= 128, null) : (g & h.child.childLanes) !== 0 ? AA(c, h, g) : (oc(h), c = tl(c, h, g), c !== null ? c.sibling : null);
              oc(h);
              break;
            case 19:
              var w = (c.flags & 128) !== 0;
              if (p = (g & h.childLanes) !== 0, p || (Gg(c, h, g, false), p = (g & h.childLanes) !== 0), w) {
                if (p) return OA(c, h, g);
                h.flags |= 128;
              }
              if (w = h.memoizedState, w !== null && (w.rendering = null, w.tail = null, w.lastEffect = null), ye(Wn, Wn.current), p) break;
              return null;
            case 22:
            case 23:
              return h.lanes = 0, EA(c, h, g);
            case 24:
              ec(h, Vn, c.memoizedState.cache);
          }
          return tl(c, h, g);
        }
        function PA(c, h, g) {
          if (c !== null) if (c.memoizedProps !== h.pendingProps) jn = true;
          else {
            if (!uS(c, g) && (h.flags & 128) === 0) return jn = false, dW(c, h, g);
            jn = (c.flags & 131072) !== 0;
          }
          else jn = false, ci && (h.flags & 1048576) !== 0 && dM(h, y1, h.index);
          switch (h.lanes = 0, h.tag) {
            case 16:
              e: {
                c = h.pendingProps;
                var p = h.elementType, w = p._init;
                if (p = w(p._payload), h.type = p, typeof p == "function") vy(p) ? (c = Mu(p, c), h.tag = 1, h = IA(null, h, p, c, g)) : (h.tag = 0, h = nS(null, h, p, c, g));
                else {
                  if (p != null) {
                    if (w = p.$$typeof, w === k) {
                      h.tag = 11, h = xA(null, h, p, c, g);
                      break e;
                    } else if (w === I) {
                      h.tag = 14, h = kA(null, h, p, c, g);
                      break e;
                    }
                  }
                  throw h = K(p) || p, Error(i(306, h, ""));
                }
              }
              return h;
            case 0:
              return nS(c, h, h.type, h.pendingProps, g);
            case 1:
              return p = h.type, w = Mu(p, h.pendingProps), IA(c, h, p, w, g);
            case 3:
              e: {
                if (ct(h, h.stateNode.containerInfo), c === null) throw Error(i(387));
                p = h.pendingProps;
                var S = h.memoizedState;
                w = S.element, Ay(c, h), tm(h, p, null, g);
                var N = h.memoizedState;
                if (p = N.cache, ec(h, Vn, p), p !== S.cache && Dy(h, [
                  Vn
                ], g, true), em(), p = N.element, S.isDehydrated) if (S = {
                  element: p,
                  isDehydrated: false,
                  cache: N.cache
                }, h.updateQueue.baseState = S, h.memoizedState = S, h.flags & 256) {
                  h = MA(c, h, p, g);
                  break e;
                } else if (p !== w) {
                  w = Qo(Error(i(424)), h), jg(w), h = MA(c, h, p, g);
                  break e;
                } else {
                  switch (c = h.stateNode.containerInfo, c.nodeType) {
                    case 9:
                      c = c.body;
                      break;
                    default:
                      c = c.nodeName === "HTML" ? c.ownerDocument.body : c;
                  }
                  for (Ji = kr(c.firstChild), Bs = h, ci = true, ku = null, aa = true, g = gA(h, null, p, g), h.child = g; g; ) g.flags = g.flags & -3 | 4096, g = g.sibling;
                }
                else {
                  if (Kg(), p === w) {
                    h = tl(c, h, g);
                    break e;
                  }
                  rs(c, h, p, g);
                }
                h = h.child;
              }
              return h;
            case 26:
              return z1(c, h), c === null ? (g = WR(h.type, null, h.pendingProps, null)) ? h.memoizedState = g : ci || (g = h.type, c = h.pendingProps, p = nb(We.current).createElement(g), p[$] = h, p[Z] = c, ls(p, g, c), Hi(p), h.stateNode = p) : h.memoizedState = WR(h.type, c.memoizedProps, h.pendingProps, c.memoizedState), null;
            case 27:
              return qo(h), c === null && ci && (p = h.stateNode = BR(h.type, h.pendingProps, We.current), Bs = h, aa = true, w = Ji, mc(h.type) ? ($S = w, Ji = kr(p.firstChild)) : Ji = w), rs(c, h, h.pendingProps.children, g), z1(c, h), c === null && (h.flags |= 4194304), h.child;
            case 5:
              return c === null && ci && ((w = p = Ji) && (p = WW(p, h.type, h.pendingProps, aa), p !== null ? (h.stateNode = p, Bs = h, Ji = kr(p.firstChild), aa = false, w = true) : w = false), w || Du(h)), qo(h), w = h.type, S = h.pendingProps, N = c !== null ? c.memoizedProps : null, p = S.children, WS(w, S) ? p = null : N !== null && WS(w, N) && (h.flags |= 32), h.memoizedState !== null && (w = Vy(c, h, sW, null, null, g), Sm._currentValue = w), z1(c, h), rs(c, h, p, g), h.child;
            case 6:
              return c === null && ci && ((c = g = Ji) && (g = HW(g, h.pendingProps, aa), g !== null ? (h.stateNode = g, Bs = h, Ji = null, c = true) : c = false), c || Du(h)), null;
            case 13:
              return AA(c, h, g);
            case 4:
              return ct(h, h.stateNode.containerInfo), p = h.pendingProps, c === null ? h.child = Nd(h, null, p, g) : rs(c, h, p, g), h.child;
            case 11:
              return xA(c, h, h.type, h.pendingProps, g);
            case 7:
              return rs(c, h, h.pendingProps, g), h.child;
            case 8:
              return rs(c, h, h.pendingProps.children, g), h.child;
            case 12:
              return rs(c, h, h.pendingProps.children, g), h.child;
            case 10:
              return p = h.pendingProps, ec(h, h.type, p.value), rs(c, h, p.children, g), h.child;
            case 9:
              return w = h.type._context, p = h.pendingProps.children, Tu(h), w = ws(w), p = p(w), h.flags |= 1, rs(c, h, p, g), h.child;
            case 14:
              return kA(c, h, h.type, h.pendingProps, g);
            case 15:
              return DA(c, h, h.type, h.pendingProps, g);
            case 19:
              return OA(c, h, g);
            case 31:
              return p = h.pendingProps, g = h.mode, p = {
                mode: p.mode,
                children: p.children
              }, c === null ? (g = U1(p, g), g.ref = h.ref, h.child = g, g.return = h, h = g) : (g = Ga(c.child, p), g.ref = h.ref, h.child = g, g.return = h, h = g), h;
            case 22:
              return EA(c, h, g);
            case 24:
              return Tu(h), p = ws(Vn), c === null ? (w = Ny(), w === null && (w = Pi, S = Ey(), w.pooledCache = S, S.refCount++, S !== null && (w.pooledCacheLanes |= g), w = S), h.memoizedState = {
                parent: p,
                cache: w
              }, My(h), ec(h, Vn, w)) : ((c.lanes & g) !== 0 && (Ay(c, h), tm(h, null, null, g), em()), w = c.memoizedState, S = h.memoizedState, w.parent !== p ? (w = {
                parent: p,
                cache: p
              }, h.memoizedState = w, h.lanes === 0 && (h.memoizedState = h.updateQueue.baseState = w), ec(h, Vn, p)) : (p = S.cache, ec(h, Vn, p), p !== w.cache && Dy(h, [
                Vn
              ], g, true))), rs(c, h, h.pendingProps.children, g), h.child;
            case 29:
              throw h.pendingProps;
          }
          throw Error(i(156, h.tag));
        }
        function il(c) {
          c.flags |= 4;
        }
        function BA(c, h) {
          if (h.type !== "stylesheet" || (h.state.loading & 4) !== 0) c.flags &= -16777217;
          else if (c.flags |= 16777216, !qR(h)) {
            if (h = tr.current, h !== null && ((ti & 4194048) === ti ? la !== null : (ti & 62914560) !== ti && (ti & 536870912) === 0 || h !== la)) throw Xg = Iy, CM;
            c.flags |= 8192;
          }
        }
        function $1(c, h) {
          h !== null && (c.flags |= 4), c.flags & 16384 && (h = c.tag !== 22 ? ad() : 536870912, c.lanes |= h, Rd |= h);
        }
        function lm(c, h) {
          if (!ci) switch (c.tailMode) {
            case "hidden":
              h = c.tail;
              for (var g = null; h !== null; ) h.alternate !== null && (g = h), h = h.sibling;
              g === null ? c.tail = null : g.sibling = null;
              break;
            case "collapsed":
              g = c.tail;
              for (var p = null; g !== null; ) g.alternate !== null && (p = g), g = g.sibling;
              p === null ? h || c.tail === null ? c.tail = null : c.tail.sibling = null : p.sibling = null;
          }
        }
        function $i(c) {
          var h = c.alternate !== null && c.alternate.child === c.child, g = 0, p = 0;
          if (h) for (var w = c.child; w !== null; ) g |= w.lanes | w.childLanes, p |= w.subtreeFlags & 65011712, p |= w.flags & 65011712, w.return = c, w = w.sibling;
          else for (w = c.child; w !== null; ) g |= w.lanes | w.childLanes, p |= w.subtreeFlags, p |= w.flags, w.return = c, w = w.sibling;
          return c.subtreeFlags |= p, c.childLanes = g, h;
        }
        function fW(c, h, g) {
          var p = h.pendingProps;
          switch (Sy(h), h.tag) {
            case 31:
            case 16:
            case 15:
            case 0:
            case 11:
            case 7:
            case 8:
            case 12:
            case 9:
            case 14:
              return $i(h), null;
            case 1:
              return $i(h), null;
            case 3:
              return g = h.stateNode, p = null, c !== null && (p = c.memoizedState.cache), h.memoizedState.cache !== p && (h.flags |= 2048), Xa(Vn), hn(), g.pendingContext && (g.context = g.pendingContext, g.pendingContext = null), (c === null || c.child === null) && (qg(h) ? il(h) : c === null || c.memoizedState.isDehydrated && (h.flags & 256) === 0 || (h.flags |= 1024, mM())), $i(h), null;
            case 26:
              return g = h.memoizedState, c === null ? (il(h), g !== null ? ($i(h), BA(h, g)) : ($i(h), h.flags &= -16777217)) : g ? g !== c.memoizedState ? (il(h), $i(h), BA(h, g)) : ($i(h), h.flags &= -16777217) : (c.memoizedProps !== p && il(h), $i(h), h.flags &= -16777217), null;
            case 27:
              Wa(h), g = We.current;
              var w = h.type;
              if (c !== null && h.stateNode != null) c.memoizedProps !== p && il(h);
              else {
                if (!p) {
                  if (h.stateNode === null) throw Error(i(166));
                  return $i(h), null;
                }
                c = Ae.current, qg(h) ? fM(h) : (c = BR(w, p, g), h.stateNode = c, il(h));
              }
              return $i(h), null;
            case 5:
              if (Wa(h), g = h.type, c !== null && h.stateNode != null) c.memoizedProps !== p && il(h);
              else {
                if (!p) {
                  if (h.stateNode === null) throw Error(i(166));
                  return $i(h), null;
                }
                if (c = Ae.current, qg(h)) fM(h);
                else {
                  switch (w = nb(We.current), c) {
                    case 1:
                      c = w.createElementNS("http://www.w3.org/2000/svg", g);
                      break;
                    case 2:
                      c = w.createElementNS("http://www.w3.org/1998/Math/MathML", g);
                      break;
                    default:
                      switch (g) {
                        case "svg":
                          c = w.createElementNS("http://www.w3.org/2000/svg", g);
                          break;
                        case "math":
                          c = w.createElementNS("http://www.w3.org/1998/Math/MathML", g);
                          break;
                        case "script":
                          c = w.createElement("div"), c.innerHTML = "<script><\/script>", c = c.removeChild(c.firstChild);
                          break;
                        case "select":
                          c = typeof p.is == "string" ? w.createElement("select", {
                            is: p.is
                          }) : w.createElement("select"), p.multiple ? c.multiple = true : p.size && (c.size = p.size);
                          break;
                        default:
                          c = typeof p.is == "string" ? w.createElement(g, {
                            is: p.is
                          }) : w.createElement(g);
                      }
                  }
                  c[$] = h, c[Z] = p;
                  e: for (w = h.child; w !== null; ) {
                    if (w.tag === 5 || w.tag === 6) c.appendChild(w.stateNode);
                    else if (w.tag !== 4 && w.tag !== 27 && w.child !== null) {
                      w.child.return = w, w = w.child;
                      continue;
                    }
                    if (w === h) break e;
                    for (; w.sibling === null; ) {
                      if (w.return === null || w.return === h) break e;
                      w = w.return;
                    }
                    w.sibling.return = w.return, w = w.sibling;
                  }
                  h.stateNode = c;
                  e: switch (ls(c, g, p), g) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      c = !!p.autoFocus;
                      break e;
                    case "img":
                      c = true;
                      break e;
                    default:
                      c = false;
                  }
                  c && il(h);
                }
              }
              return $i(h), h.flags &= -16777217, null;
            case 6:
              if (c && h.stateNode != null) c.memoizedProps !== p && il(h);
              else {
                if (typeof p != "string" && h.stateNode === null) throw Error(i(166));
                if (c = We.current, qg(h)) {
                  if (c = h.stateNode, g = h.memoizedProps, p = null, w = Bs, w !== null) switch (w.tag) {
                    case 27:
                    case 5:
                      p = w.memoizedProps;
                  }
                  c[$] = h, c = !!(c.nodeValue === g || p !== null && p.suppressHydrationWarning === true || NR(c.nodeValue, g)), c || Du(h);
                } else c = nb(c).createTextNode(p), c[$] = h, h.stateNode = c;
              }
              return $i(h), null;
            case 13:
              if (p = h.memoizedState, c === null || c.memoizedState !== null && c.memoizedState.dehydrated !== null) {
                if (w = qg(h), p !== null && p.dehydrated !== null) {
                  if (c === null) {
                    if (!w) throw Error(i(318));
                    if (w = h.memoizedState, w = w !== null ? w.dehydrated : null, !w) throw Error(i(317));
                    w[$] = h;
                  } else Kg(), (h.flags & 128) === 0 && (h.memoizedState = null), h.flags |= 4;
                  $i(h), w = false;
                } else w = mM(), c !== null && c.memoizedState !== null && (c.memoizedState.hydrationErrors = w), w = true;
                if (!w) return h.flags & 256 ? (el(h), h) : (el(h), null);
              }
              if (el(h), (h.flags & 128) !== 0) return h.lanes = g, h;
              if (g = p !== null, c = c !== null && c.memoizedState !== null, g) {
                p = h.child, w = null, p.alternate !== null && p.alternate.memoizedState !== null && p.alternate.memoizedState.cachePool !== null && (w = p.alternate.memoizedState.cachePool.pool);
                var S = null;
                p.memoizedState !== null && p.memoizedState.cachePool !== null && (S = p.memoizedState.cachePool.pool), S !== w && (p.flags |= 2048);
              }
              return g !== c && g && (h.child.flags |= 8192), $1(h, h.updateQueue), $i(h), null;
            case 4:
              return hn(), c === null && OS(h.stateNode.containerInfo), $i(h), null;
            case 10:
              return Xa(h.type), $i(h), null;
            case 19:
              if (xe(Wn), w = h.memoizedState, w === null) return $i(h), null;
              if (p = (h.flags & 128) !== 0, S = w.rendering, S === null) if (p) lm(w, false);
              else {
                if (en !== 0 || c !== null && (c.flags & 128) !== 0) for (c = h.child; c !== null; ) {
                  if (S = V1(c), S !== null) {
                    for (h.flags |= 128, lm(w, false), c = S.updateQueue, h.updateQueue = c, $1(h, c), h.subtreeFlags = 0, c = g, g = h.child; g !== null; ) hM(g, c), g = g.sibling;
                    return ye(Wn, Wn.current & 1 | 2), h.child;
                  }
                  c = c.sibling;
                }
                w.tail !== null && Bn() > j1 && (h.flags |= 128, p = true, lm(w, false), h.lanes = 4194304);
              }
              else {
                if (!p) if (c = V1(S), c !== null) {
                  if (h.flags |= 128, p = true, c = c.updateQueue, h.updateQueue = c, $1(h, c), lm(w, true), w.tail === null && w.tailMode === "hidden" && !S.alternate && !ci) return $i(h), null;
                } else 2 * Bn() - w.renderingStartTime > j1 && g !== 536870912 && (h.flags |= 128, p = true, lm(w, false), h.lanes = 4194304);
                w.isBackwards ? (S.sibling = h.child, h.child = S) : (c = w.last, c !== null ? c.sibling = S : h.child = S, w.last = S);
              }
              return w.tail !== null ? (h = w.tail, w.rendering = h, w.tail = h.sibling, w.renderingStartTime = Bn(), h.sibling = null, c = Wn.current, ye(Wn, p ? c & 1 | 2 : c & 1), h) : ($i(h), null);
            case 22:
            case 23:
              return el(h), By(), p = h.memoizedState !== null, c !== null ? c.memoizedState !== null !== p && (h.flags |= 8192) : p && (h.flags |= 8192), p ? (g & 536870912) !== 0 && (h.flags & 128) === 0 && ($i(h), h.subtreeFlags & 6 && (h.flags |= 8192)) : $i(h), g = h.updateQueue, g !== null && $1(h, g.retryQueue), g = null, c !== null && c.memoizedState !== null && c.memoizedState.cachePool !== null && (g = c.memoizedState.cachePool.pool), p = null, h.memoizedState !== null && h.memoizedState.cachePool !== null && (p = h.memoizedState.cachePool.pool), p !== g && (h.flags |= 2048), c !== null && xe(Nu), null;
            case 24:
              return g = null, c !== null && (g = c.memoizedState.cache), h.memoizedState.cache !== g && (h.flags |= 2048), Xa(Vn), $i(h), null;
            case 25:
              return null;
            case 30:
              return null;
          }
          throw Error(i(156, h.tag));
        }
        function gW(c, h) {
          switch (Sy(h), h.tag) {
            case 1:
              return c = h.flags, c & 65536 ? (h.flags = c & -65537 | 128, h) : null;
            case 3:
              return Xa(Vn), hn(), c = h.flags, (c & 65536) !== 0 && (c & 128) === 0 ? (h.flags = c & -65537 | 128, h) : null;
            case 26:
            case 27:
            case 5:
              return Wa(h), null;
            case 13:
              if (el(h), c = h.memoizedState, c !== null && c.dehydrated !== null) {
                if (h.alternate === null) throw Error(i(340));
                Kg();
              }
              return c = h.flags, c & 65536 ? (h.flags = c & -65537 | 128, h) : null;
            case 19:
              return xe(Wn), null;
            case 4:
              return hn(), null;
            case 10:
              return Xa(h.type), null;
            case 22:
            case 23:
              return el(h), By(), c !== null && xe(Nu), c = h.flags, c & 65536 ? (h.flags = c & -65537 | 128, h) : null;
            case 24:
              return Xa(Vn), null;
            case 25:
              return null;
            default:
              return null;
          }
        }
        function FA(c, h) {
          switch (Sy(h), h.tag) {
            case 3:
              Xa(Vn), hn();
              break;
            case 26:
            case 27:
            case 5:
              Wa(h);
              break;
            case 4:
              hn();
              break;
            case 13:
              el(h);
              break;
            case 19:
              xe(Wn);
              break;
            case 10:
              Xa(h.type);
              break;
            case 22:
            case 23:
              el(h), By(), c !== null && xe(Nu);
              break;
            case 24:
              Xa(Vn);
          }
        }
        function cm(c, h) {
          try {
            var g = h.updateQueue, p = g !== null ? g.lastEffect : null;
            if (p !== null) {
              var w = p.next;
              g = w;
              do {
                if ((g.tag & c) === c) {
                  p = void 0;
                  var S = g.create, N = g.inst;
                  p = S(), N.destroy = p;
                }
                g = g.next;
              } while (g !== w);
            }
          } catch (O) {
            ki(h, h.return, O);
          }
        }
        function ac(c, h, g) {
          try {
            var p = h.updateQueue, w = p !== null ? p.lastEffect : null;
            if (w !== null) {
              var S = w.next;
              p = S;
              do {
                if ((p.tag & c) === c) {
                  var N = p.inst, O = N.destroy;
                  if (O !== void 0) {
                    N.destroy = void 0, w = h;
                    var q = g, ue = O;
                    try {
                      ue();
                    } catch (ve) {
                      ki(w, q, ve);
                    }
                  }
                }
                p = p.next;
              } while (p !== S);
            }
          } catch (ve) {
            ki(h, h.return, ve);
          }
        }
        function VA(c) {
          var h = c.updateQueue;
          if (h !== null) {
            var g = c.stateNode;
            try {
              kM(h, g);
            } catch (p) {
              ki(c, c.return, p);
            }
          }
        }
        function WA(c, h, g) {
          g.props = Mu(c.type, c.memoizedProps), g.state = c.memoizedState;
          try {
            g.componentWillUnmount();
          } catch (p) {
            ki(c, h, p);
          }
        }
        function um(c, h) {
          try {
            var g = c.ref;
            if (g !== null) {
              switch (c.tag) {
                case 26:
                case 27:
                case 5:
                  var p = c.stateNode;
                  break;
                case 30:
                  p = c.stateNode;
                  break;
                default:
                  p = c.stateNode;
              }
              typeof g == "function" ? c.refCleanup = g(p) : g.current = p;
            }
          } catch (w) {
            ki(c, h, w);
          }
        }
        function ca(c, h) {
          var g = c.ref, p = c.refCleanup;
          if (g !== null) if (typeof p == "function") try {
            p();
          } catch (w) {
            ki(c, h, w);
          } finally {
            c.refCleanup = null, c = c.alternate, c != null && (c.refCleanup = null);
          }
          else if (typeof g == "function") try {
            g(null);
          } catch (w) {
            ki(c, h, w);
          }
          else g.current = null;
        }
        function HA(c) {
          var h = c.type, g = c.memoizedProps, p = c.stateNode;
          try {
            e: switch (h) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                g.autoFocus && p.focus();
                break e;
              case "img":
                g.src ? p.src = g.src : g.srcSet && (p.srcset = g.srcSet);
            }
          } catch (w) {
            ki(c, c.return, w);
          }
        }
        function hS(c, h, g) {
          try {
            var p = c.stateNode;
            OW(p, c.type, g, h), p[Z] = h;
          } catch (w) {
            ki(c, c.return, w);
          }
        }
        function zA(c) {
          return c.tag === 5 || c.tag === 3 || c.tag === 26 || c.tag === 27 && mc(c.type) || c.tag === 4;
        }
        function dS(c) {
          e: for (; ; ) {
            for (; c.sibling === null; ) {
              if (c.return === null || zA(c.return)) return null;
              c = c.return;
            }
            for (c.sibling.return = c.return, c = c.sibling; c.tag !== 5 && c.tag !== 6 && c.tag !== 18; ) {
              if (c.tag === 27 && mc(c.type) || c.flags & 2 || c.child === null || c.tag === 4) continue e;
              c.child.return = c, c = c.child;
            }
            if (!(c.flags & 2)) return c.stateNode;
          }
        }
        function fS(c, h, g) {
          var p = c.tag;
          if (p === 5 || p === 6) c = c.stateNode, h ? (g.nodeType === 9 ? g.body : g.nodeName === "HTML" ? g.ownerDocument.body : g).insertBefore(c, h) : (h = g.nodeType === 9 ? g.body : g.nodeName === "HTML" ? g.ownerDocument.body : g, h.appendChild(c), g = g._reactRootContainer, g != null || h.onclick !== null || (h.onclick = ib));
          else if (p !== 4 && (p === 27 && mc(c.type) && (g = c.stateNode, h = null), c = c.child, c !== null)) for (fS(c, h, g), c = c.sibling; c !== null; ) fS(c, h, g), c = c.sibling;
        }
        function q1(c, h, g) {
          var p = c.tag;
          if (p === 5 || p === 6) c = c.stateNode, h ? g.insertBefore(c, h) : g.appendChild(c);
          else if (p !== 4 && (p === 27 && mc(c.type) && (g = c.stateNode), c = c.child, c !== null)) for (q1(c, h, g), c = c.sibling; c !== null; ) q1(c, h, g), c = c.sibling;
        }
        function UA(c) {
          var h = c.stateNode, g = c.memoizedProps;
          try {
            for (var p = c.type, w = h.attributes; w.length; ) h.removeAttributeNode(w[0]);
            ls(h, p, g), h[$] = c, h[Z] = g;
          } catch (S) {
            ki(c, c.return, S);
          }
        }
        var nl = false, mn = false, gS = false, $A = typeof WeakSet == "function" ? WeakSet : Set, Gn = null;
        function mW(c, h) {
          if (c = c.containerInfo, FS = cb, c = tM(c), dy(c)) {
            if ("selectionStart" in c) var g = {
              start: c.selectionStart,
              end: c.selectionEnd
            };
            else e: {
              g = (g = c.ownerDocument) && g.defaultView || window;
              var p = g.getSelection && g.getSelection();
              if (p && p.rangeCount !== 0) {
                g = p.anchorNode;
                var w = p.anchorOffset, S = p.focusNode;
                p = p.focusOffset;
                try {
                  g.nodeType, S.nodeType;
                } catch {
                  g = null;
                  break e;
                }
                var N = 0, O = -1, q = -1, ue = 0, ve = 0, Le = c, ge = null;
                t: for (; ; ) {
                  for (var pe; Le !== g || w !== 0 && Le.nodeType !== 3 || (O = N + w), Le !== S || p !== 0 && Le.nodeType !== 3 || (q = N + p), Le.nodeType === 3 && (N += Le.nodeValue.length), (pe = Le.firstChild) !== null; ) ge = Le, Le = pe;
                  for (; ; ) {
                    if (Le === c) break t;
                    if (ge === g && ++ue === w && (O = N), ge === S && ++ve === p && (q = N), (pe = Le.nextSibling) !== null) break;
                    Le = ge, ge = Le.parentNode;
                  }
                  Le = pe;
                }
                g = O === -1 || q === -1 ? null : {
                  start: O,
                  end: q
                };
              } else g = null;
            }
            g = g || {
              start: 0,
              end: 0
            };
          } else g = null;
          for (VS = {
            focusedElem: c,
            selectionRange: g
          }, cb = false, Gn = h; Gn !== null; ) if (h = Gn, c = h.child, (h.subtreeFlags & 1024) !== 0 && c !== null) c.return = h, Gn = c;
          else for (; Gn !== null; ) {
            switch (h = Gn, S = h.alternate, c = h.flags, h.tag) {
              case 0:
                break;
              case 11:
              case 15:
                break;
              case 1:
                if ((c & 1024) !== 0 && S !== null) {
                  c = void 0, g = h, w = S.memoizedProps, S = S.memoizedState, p = g.stateNode;
                  try {
                    var gt = Mu(g.type, w, g.elementType === g.type);
                    c = p.getSnapshotBeforeUpdate(gt, S), p.__reactInternalSnapshotBeforeUpdate = c;
                  } catch (at) {
                    ki(g, g.return, at);
                  }
                }
                break;
              case 3:
                if ((c & 1024) !== 0) {
                  if (c = h.stateNode.containerInfo, g = c.nodeType, g === 9) zS(c);
                  else if (g === 1) switch (c.nodeName) {
                    case "HEAD":
                    case "HTML":
                    case "BODY":
                      zS(c);
                      break;
                    default:
                      c.textContent = "";
                  }
                }
                break;
              case 5:
              case 26:
              case 27:
              case 6:
              case 4:
              case 17:
                break;
              default:
                if ((c & 1024) !== 0) throw Error(i(163));
            }
            if (c = h.sibling, c !== null) {
              c.return = h.return, Gn = c;
              break;
            }
            Gn = h.return;
          }
        }
        function qA(c, h, g) {
          var p = g.flags;
          switch (g.tag) {
            case 0:
            case 11:
            case 15:
              lc(c, g), p & 4 && cm(5, g);
              break;
            case 1:
              if (lc(c, g), p & 4) if (c = g.stateNode, h === null) try {
                c.componentDidMount();
              } catch (N) {
                ki(g, g.return, N);
              }
              else {
                var w = Mu(g.type, h.memoizedProps);
                h = h.memoizedState;
                try {
                  c.componentDidUpdate(w, h, c.__reactInternalSnapshotBeforeUpdate);
                } catch (N) {
                  ki(g, g.return, N);
                }
              }
              p & 64 && VA(g), p & 512 && um(g, g.return);
              break;
            case 3:
              if (lc(c, g), p & 64 && (c = g.updateQueue, c !== null)) {
                if (h = null, g.child !== null) switch (g.child.tag) {
                  case 27:
                  case 5:
                    h = g.child.stateNode;
                    break;
                  case 1:
                    h = g.child.stateNode;
                }
                try {
                  kM(c, h);
                } catch (N) {
                  ki(g, g.return, N);
                }
              }
              break;
            case 27:
              h === null && p & 4 && UA(g);
            case 26:
            case 5:
              lc(c, g), h === null && p & 4 && HA(g), p & 512 && um(g, g.return);
              break;
            case 12:
              lc(c, g);
              break;
            case 13:
              lc(c, g), p & 4 && GA(c, g), p & 64 && (c = g.memoizedState, c !== null && (c = c.dehydrated, c !== null && (g = LW.bind(null, g), zW(c, g))));
              break;
            case 22:
              if (p = g.memoizedState !== null || nl, !p) {
                h = h !== null && h.memoizedState !== null || mn, w = nl;
                var S = mn;
                nl = p, (mn = h) && !S ? cc(c, g, (g.subtreeFlags & 8772) !== 0) : lc(c, g), nl = w, mn = S;
              }
              break;
            case 30:
              break;
            default:
              lc(c, g);
          }
        }
        function KA(c) {
          var h = c.alternate;
          h !== null && (c.alternate = null, KA(h)), c.child = null, c.deletions = null, c.sibling = null, c.tag === 5 && (h = c.stateNode, h !== null && At(h)), c.stateNode = null, c.return = null, c.dependencies = null, c.memoizedProps = null, c.memoizedState = null, c.pendingProps = null, c.stateNode = null, c.updateQueue = null;
        }
        var zi = null, to = false;
        function sl(c, h, g) {
          for (g = g.child; g !== null; ) jA(c, h, g), g = g.sibling;
        }
        function jA(c, h, g) {
          if (Sn && typeof Sn.onCommitFiberUnmount == "function") try {
            Sn.onCommitFiberUnmount(Qs, g);
          } catch {
          }
          switch (g.tag) {
            case 26:
              mn || ca(g, h), sl(c, h, g), g.memoizedState ? g.memoizedState.count-- : g.stateNode && (g = g.stateNode, g.parentNode.removeChild(g));
              break;
            case 27:
              mn || ca(g, h);
              var p = zi, w = to;
              mc(g.type) && (zi = g.stateNode, to = false), sl(c, h, g), vm(g.stateNode), zi = p, to = w;
              break;
            case 5:
              mn || ca(g, h);
            case 6:
              if (p = zi, w = to, zi = null, sl(c, h, g), zi = p, to = w, zi !== null) if (to) try {
                (zi.nodeType === 9 ? zi.body : zi.nodeName === "HTML" ? zi.ownerDocument.body : zi).removeChild(g.stateNode);
              } catch (S) {
                ki(g, h, S);
              }
              else try {
                zi.removeChild(g.stateNode);
              } catch (S) {
                ki(g, h, S);
              }
              break;
            case 18:
              zi !== null && (to ? (c = zi, OR(c.nodeType === 9 ? c.body : c.nodeName === "HTML" ? c.ownerDocument.body : c, g.stateNode), Dm(c)) : OR(zi, g.stateNode));
              break;
            case 4:
              p = zi, w = to, zi = g.stateNode.containerInfo, to = true, sl(c, h, g), zi = p, to = w;
              break;
            case 0:
            case 11:
            case 14:
            case 15:
              mn || ac(2, g, h), mn || ac(4, g, h), sl(c, h, g);
              break;
            case 1:
              mn || (ca(g, h), p = g.stateNode, typeof p.componentWillUnmount == "function" && WA(g, h, p)), sl(c, h, g);
              break;
            case 21:
              sl(c, h, g);
              break;
            case 22:
              mn = (p = mn) || g.memoizedState !== null, sl(c, h, g), mn = p;
              break;
            default:
              sl(c, h, g);
          }
        }
        function GA(c, h) {
          if (h.memoizedState === null && (c = h.alternate, c !== null && (c = c.memoizedState, c !== null && (c = c.dehydrated, c !== null)))) try {
            Dm(c);
          } catch (g) {
            ki(h, h.return, g);
          }
        }
        function pW(c) {
          switch (c.tag) {
            case 13:
            case 19:
              var h = c.stateNode;
              return h === null && (h = c.stateNode = new $A()), h;
            case 22:
              return c = c.stateNode, h = c._retryCache, h === null && (h = c._retryCache = new $A()), h;
            default:
              throw Error(i(435, c.tag));
          }
        }
        function mS(c, h) {
          var g = pW(c);
          h.forEach(function(p) {
            var w = xW.bind(null, c, p);
            g.has(p) || (g.add(p), p.then(w, w));
          });
        }
        function wo(c, h) {
          var g = h.deletions;
          if (g !== null) for (var p = 0; p < g.length; p++) {
            var w = g[p], S = c, N = h, O = N;
            e: for (; O !== null; ) {
              switch (O.tag) {
                case 27:
                  if (mc(O.type)) {
                    zi = O.stateNode, to = false;
                    break e;
                  }
                  break;
                case 5:
                  zi = O.stateNode, to = false;
                  break e;
                case 3:
                case 4:
                  zi = O.stateNode.containerInfo, to = true;
                  break e;
              }
              O = O.return;
            }
            if (zi === null) throw Error(i(160));
            jA(S, N, w), zi = null, to = false, S = w.alternate, S !== null && (S.return = null), w.return = null;
          }
          if (h.subtreeFlags & 13878) for (h = h.child; h !== null; ) YA(h, c), h = h.sibling;
        }
        var xr = null;
        function YA(c, h) {
          var g = c.alternate, p = c.flags;
          switch (c.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
              wo(h, c), yo(c), p & 4 && (ac(3, c, c.return), cm(3, c), ac(5, c, c.return));
              break;
            case 1:
              wo(h, c), yo(c), p & 512 && (mn || g === null || ca(g, g.return)), p & 64 && nl && (c = c.updateQueue, c !== null && (p = c.callbacks, p !== null && (g = c.shared.hiddenCallbacks, c.shared.hiddenCallbacks = g === null ? p : g.concat(p))));
              break;
            case 26:
              var w = xr;
              if (wo(h, c), yo(c), p & 512 && (mn || g === null || ca(g, g.return)), p & 4) {
                var S = g !== null ? g.memoizedState : null;
                if (p = c.memoizedState, g === null) if (p === null) if (c.stateNode === null) {
                  e: {
                    p = c.type, g = c.memoizedProps, w = w.ownerDocument || w;
                    t: switch (p) {
                      case "title":
                        S = w.getElementsByTagName("title")[0], (!S || S[xt] || S[$] || S.namespaceURI === "http://www.w3.org/2000/svg" || S.hasAttribute("itemprop")) && (S = w.createElement(p), w.head.insertBefore(S, w.querySelector("head > title"))), ls(S, p, g), S[$] = c, Hi(S), p = S;
                        break e;
                      case "link":
                        var N = UR("link", "href", w).get(p + (g.href || ""));
                        if (N) {
                          for (var O = 0; O < N.length; O++) if (S = N[O], S.getAttribute("href") === (g.href == null || g.href === "" ? null : g.href) && S.getAttribute("rel") === (g.rel == null ? null : g.rel) && S.getAttribute("title") === (g.title == null ? null : g.title) && S.getAttribute("crossorigin") === (g.crossOrigin == null ? null : g.crossOrigin)) {
                            N.splice(O, 1);
                            break t;
                          }
                        }
                        S = w.createElement(p), ls(S, p, g), w.head.appendChild(S);
                        break;
                      case "meta":
                        if (N = UR("meta", "content", w).get(p + (g.content || ""))) {
                          for (O = 0; O < N.length; O++) if (S = N[O], S.getAttribute("content") === (g.content == null ? null : "" + g.content) && S.getAttribute("name") === (g.name == null ? null : g.name) && S.getAttribute("property") === (g.property == null ? null : g.property) && S.getAttribute("http-equiv") === (g.httpEquiv == null ? null : g.httpEquiv) && S.getAttribute("charset") === (g.charSet == null ? null : g.charSet)) {
                            N.splice(O, 1);
                            break t;
                          }
                        }
                        S = w.createElement(p), ls(S, p, g), w.head.appendChild(S);
                        break;
                      default:
                        throw Error(i(468, p));
                    }
                    S[$] = c, Hi(S), p = S;
                  }
                  c.stateNode = p;
                } else $R(w, c.type, c.stateNode);
                else c.stateNode = zR(w, p, c.memoizedProps);
                else S !== p ? (S === null ? g.stateNode !== null && (g = g.stateNode, g.parentNode.removeChild(g)) : S.count--, p === null ? $R(w, c.type, c.stateNode) : zR(w, p, c.memoizedProps)) : p === null && c.stateNode !== null && hS(c, c.memoizedProps, g.memoizedProps);
              }
              break;
            case 27:
              wo(h, c), yo(c), p & 512 && (mn || g === null || ca(g, g.return)), g !== null && p & 4 && hS(c, c.memoizedProps, g.memoizedProps);
              break;
            case 5:
              if (wo(h, c), yo(c), p & 512 && (mn || g === null || ca(g, g.return)), c.flags & 32) {
                w = c.stateNode;
                try {
                  dd(w, "");
                } catch (pe) {
                  ki(c, c.return, pe);
                }
              }
              p & 4 && c.stateNode != null && (w = c.memoizedProps, hS(c, w, g !== null ? g.memoizedProps : w)), p & 1024 && (gS = true);
              break;
            case 6:
              if (wo(h, c), yo(c), p & 4) {
                if (c.stateNode === null) throw Error(i(162));
                p = c.memoizedProps, g = c.stateNode;
                try {
                  g.nodeValue = p;
                } catch (pe) {
                  ki(c, c.return, pe);
                }
              }
              break;
            case 3:
              if (rb = null, w = xr, xr = sb(h.containerInfo), wo(h, c), xr = w, yo(c), p & 4 && g !== null && g.memoizedState.isDehydrated) try {
                Dm(h.containerInfo);
              } catch (pe) {
                ki(c, c.return, pe);
              }
              gS && (gS = false, ZA(c));
              break;
            case 4:
              p = xr, xr = sb(c.stateNode.containerInfo), wo(h, c), yo(c), xr = p;
              break;
            case 12:
              wo(h, c), yo(c);
              break;
            case 13:
              wo(h, c), yo(c), c.child.flags & 8192 && c.memoizedState !== null != (g !== null && g.memoizedState !== null) && (wS = Bn()), p & 4 && (p = c.updateQueue, p !== null && (c.updateQueue = null, mS(c, p)));
              break;
            case 22:
              w = c.memoizedState !== null;
              var q = g !== null && g.memoizedState !== null, ue = nl, ve = mn;
              if (nl = ue || w, mn = ve || q, wo(h, c), mn = ve, nl = ue, yo(c), p & 8192) e: for (h = c.stateNode, h._visibility = w ? h._visibility & -2 : h._visibility | 1, w && (g === null || q || nl || mn || Au(c)), g = null, h = c; ; ) {
                if (h.tag === 5 || h.tag === 26) {
                  if (g === null) {
                    q = g = h;
                    try {
                      if (S = q.stateNode, w) N = S.style, typeof N.setProperty == "function" ? N.setProperty("display", "none", "important") : N.display = "none";
                      else {
                        O = q.stateNode;
                        var Le = q.memoizedProps.style, ge = Le != null && Le.hasOwnProperty("display") ? Le.display : null;
                        O.style.display = ge == null || typeof ge == "boolean" ? "" : ("" + ge).trim();
                      }
                    } catch (pe) {
                      ki(q, q.return, pe);
                    }
                  }
                } else if (h.tag === 6) {
                  if (g === null) {
                    q = h;
                    try {
                      q.stateNode.nodeValue = w ? "" : q.memoizedProps;
                    } catch (pe) {
                      ki(q, q.return, pe);
                    }
                  }
                } else if ((h.tag !== 22 && h.tag !== 23 || h.memoizedState === null || h === c) && h.child !== null) {
                  h.child.return = h, h = h.child;
                  continue;
                }
                if (h === c) break e;
                for (; h.sibling === null; ) {
                  if (h.return === null || h.return === c) break e;
                  g === h && (g = null), h = h.return;
                }
                g === h && (g = null), h.sibling.return = h.return, h = h.sibling;
              }
              p & 4 && (p = c.updateQueue, p !== null && (g = p.retryQueue, g !== null && (p.retryQueue = null, mS(c, g))));
              break;
            case 19:
              wo(h, c), yo(c), p & 4 && (p = c.updateQueue, p !== null && (c.updateQueue = null, mS(c, p)));
              break;
            case 30:
              break;
            case 21:
              break;
            default:
              wo(h, c), yo(c);
          }
        }
        function yo(c) {
          var h = c.flags;
          if (h & 2) {
            try {
              for (var g, p = c.return; p !== null; ) {
                if (zA(p)) {
                  g = p;
                  break;
                }
                p = p.return;
              }
              if (g == null) throw Error(i(160));
              switch (g.tag) {
                case 27:
                  var w = g.stateNode, S = dS(c);
                  q1(c, S, w);
                  break;
                case 5:
                  var N = g.stateNode;
                  g.flags & 32 && (dd(N, ""), g.flags &= -33);
                  var O = dS(c);
                  q1(c, O, N);
                  break;
                case 3:
                case 4:
                  var q = g.stateNode.containerInfo, ue = dS(c);
                  fS(c, ue, q);
                  break;
                default:
                  throw Error(i(161));
              }
            } catch (ve) {
              ki(c, c.return, ve);
            }
            c.flags &= -3;
          }
          h & 4096 && (c.flags &= -4097);
        }
        function ZA(c) {
          if (c.subtreeFlags & 1024) for (c = c.child; c !== null; ) {
            var h = c;
            ZA(h), h.tag === 5 && h.flags & 1024 && h.stateNode.reset(), c = c.sibling;
          }
        }
        function lc(c, h) {
          if (h.subtreeFlags & 8772) for (h = h.child; h !== null; ) qA(c, h.alternate, h), h = h.sibling;
        }
        function Au(c) {
          for (c = c.child; c !== null; ) {
            var h = c;
            switch (h.tag) {
              case 0:
              case 11:
              case 14:
              case 15:
                ac(4, h, h.return), Au(h);
                break;
              case 1:
                ca(h, h.return);
                var g = h.stateNode;
                typeof g.componentWillUnmount == "function" && WA(h, h.return, g), Au(h);
                break;
              case 27:
                vm(h.stateNode);
              case 26:
              case 5:
                ca(h, h.return), Au(h);
                break;
              case 22:
                h.memoizedState === null && Au(h);
                break;
              case 30:
                Au(h);
                break;
              default:
                Au(h);
            }
            c = c.sibling;
          }
        }
        function cc(c, h, g) {
          for (g = g && (h.subtreeFlags & 8772) !== 0, h = h.child; h !== null; ) {
            var p = h.alternate, w = c, S = h, N = S.flags;
            switch (S.tag) {
              case 0:
              case 11:
              case 15:
                cc(w, S, g), cm(4, S);
                break;
              case 1:
                if (cc(w, S, g), p = S, w = p.stateNode, typeof w.componentDidMount == "function") try {
                  w.componentDidMount();
                } catch (ue) {
                  ki(p, p.return, ue);
                }
                if (p = S, w = p.updateQueue, w !== null) {
                  var O = p.stateNode;
                  try {
                    var q = w.shared.hiddenCallbacks;
                    if (q !== null) for (w.shared.hiddenCallbacks = null, w = 0; w < q.length; w++) xM(q[w], O);
                  } catch (ue) {
                    ki(p, p.return, ue);
                  }
                }
                g && N & 64 && VA(S), um(S, S.return);
                break;
              case 27:
                UA(S);
              case 26:
              case 5:
                cc(w, S, g), g && p === null && N & 4 && HA(S), um(S, S.return);
                break;
              case 12:
                cc(w, S, g);
                break;
              case 13:
                cc(w, S, g), g && N & 4 && GA(w, S);
                break;
              case 22:
                S.memoizedState === null && cc(w, S, g), um(S, S.return);
                break;
              case 30:
                break;
              default:
                cc(w, S, g);
            }
            h = h.sibling;
          }
        }
        function pS(c, h) {
          var g = null;
          c !== null && c.memoizedState !== null && c.memoizedState.cachePool !== null && (g = c.memoizedState.cachePool.pool), c = null, h.memoizedState !== null && h.memoizedState.cachePool !== null && (c = h.memoizedState.cachePool.pool), c !== g && (c != null && c.refCount++, g != null && Yg(g));
        }
        function _S(c, h) {
          c = null, h.alternate !== null && (c = h.alternate.memoizedState.cache), h = h.memoizedState.cache, h !== c && (h.refCount++, c != null && Yg(c));
        }
        function ua(c, h, g, p) {
          if (h.subtreeFlags & 10256) for (h = h.child; h !== null; ) QA(c, h, g, p), h = h.sibling;
        }
        function QA(c, h, g, p) {
          var w = h.flags;
          switch (h.tag) {
            case 0:
            case 11:
            case 15:
              ua(c, h, g, p), w & 2048 && cm(9, h);
              break;
            case 1:
              ua(c, h, g, p);
              break;
            case 3:
              ua(c, h, g, p), w & 2048 && (c = null, h.alternate !== null && (c = h.alternate.memoizedState.cache), h = h.memoizedState.cache, h !== c && (h.refCount++, c != null && Yg(c)));
              break;
            case 12:
              if (w & 2048) {
                ua(c, h, g, p), c = h.stateNode;
                try {
                  var S = h.memoizedProps, N = S.id, O = S.onPostCommit;
                  typeof O == "function" && O(N, h.alternate === null ? "mount" : "update", c.passiveEffectDuration, -0);
                } catch (q) {
                  ki(h, h.return, q);
                }
              } else ua(c, h, g, p);
              break;
            case 13:
              ua(c, h, g, p);
              break;
            case 23:
              break;
            case 22:
              S = h.stateNode, N = h.alternate, h.memoizedState !== null ? S._visibility & 2 ? ua(c, h, g, p) : hm(c, h) : S._visibility & 2 ? ua(c, h, g, p) : (S._visibility |= 2, Id(c, h, g, p, (h.subtreeFlags & 10256) !== 0)), w & 2048 && pS(N, h);
              break;
            case 24:
              ua(c, h, g, p), w & 2048 && _S(h.alternate, h);
              break;
            default:
              ua(c, h, g, p);
          }
        }
        function Id(c, h, g, p, w) {
          for (w = w && (h.subtreeFlags & 10256) !== 0, h = h.child; h !== null; ) {
            var S = c, N = h, O = g, q = p, ue = N.flags;
            switch (N.tag) {
              case 0:
              case 11:
              case 15:
                Id(S, N, O, q, w), cm(8, N);
                break;
              case 23:
                break;
              case 22:
                var ve = N.stateNode;
                N.memoizedState !== null ? ve._visibility & 2 ? Id(S, N, O, q, w) : hm(S, N) : (ve._visibility |= 2, Id(S, N, O, q, w)), w && ue & 2048 && pS(N.alternate, N);
                break;
              case 24:
                Id(S, N, O, q, w), w && ue & 2048 && _S(N.alternate, N);
                break;
              default:
                Id(S, N, O, q, w);
            }
            h = h.sibling;
          }
        }
        function hm(c, h) {
          if (h.subtreeFlags & 10256) for (h = h.child; h !== null; ) {
            var g = c, p = h, w = p.flags;
            switch (p.tag) {
              case 22:
                hm(g, p), w & 2048 && pS(p.alternate, p);
                break;
              case 24:
                hm(g, p), w & 2048 && _S(p.alternate, p);
                break;
              default:
                hm(g, p);
            }
            h = h.sibling;
          }
        }
        var dm = 8192;
        function Md(c) {
          if (c.subtreeFlags & dm) for (c = c.child; c !== null; ) XA(c), c = c.sibling;
        }
        function XA(c) {
          switch (c.tag) {
            case 26:
              Md(c), c.flags & dm && c.memoizedState !== null && tH(xr, c.memoizedState, c.memoizedProps);
              break;
            case 5:
              Md(c);
              break;
            case 3:
            case 4:
              var h = xr;
              xr = sb(c.stateNode.containerInfo), Md(c), xr = h;
              break;
            case 22:
              c.memoizedState === null && (h = c.alternate, h !== null && h.memoizedState !== null ? (h = dm, dm = 16777216, Md(c), dm = h) : Md(c));
              break;
            default:
              Md(c);
          }
        }
        function JA(c) {
          var h = c.alternate;
          if (h !== null && (c = h.child, c !== null)) {
            h.child = null;
            do
              h = c.sibling, c.sibling = null, c = h;
            while (c !== null);
          }
        }
        function fm(c) {
          var h = c.deletions;
          if ((c.flags & 16) !== 0) {
            if (h !== null) for (var g = 0; g < h.length; g++) {
              var p = h[g];
              Gn = p, tR(p, c);
            }
            JA(c);
          }
          if (c.subtreeFlags & 10256) for (c = c.child; c !== null; ) eR(c), c = c.sibling;
        }
        function eR(c) {
          switch (c.tag) {
            case 0:
            case 11:
            case 15:
              fm(c), c.flags & 2048 && ac(9, c, c.return);
              break;
            case 3:
              fm(c);
              break;
            case 12:
              fm(c);
              break;
            case 22:
              var h = c.stateNode;
              c.memoizedState !== null && h._visibility & 2 && (c.return === null || c.return.tag !== 13) ? (h._visibility &= -3, K1(c)) : fm(c);
              break;
            default:
              fm(c);
          }
        }
        function K1(c) {
          var h = c.deletions;
          if ((c.flags & 16) !== 0) {
            if (h !== null) for (var g = 0; g < h.length; g++) {
              var p = h[g];
              Gn = p, tR(p, c);
            }
            JA(c);
          }
          for (c = c.child; c !== null; ) {
            switch (h = c, h.tag) {
              case 0:
              case 11:
              case 15:
                ac(8, h, h.return), K1(h);
                break;
              case 22:
                g = h.stateNode, g._visibility & 2 && (g._visibility &= -3, K1(h));
                break;
              default:
                K1(h);
            }
            c = c.sibling;
          }
        }
        function tR(c, h) {
          for (; Gn !== null; ) {
            var g = Gn;
            switch (g.tag) {
              case 0:
              case 11:
              case 15:
                ac(8, g, h);
                break;
              case 23:
              case 22:
                if (g.memoizedState !== null && g.memoizedState.cachePool !== null) {
                  var p = g.memoizedState.cachePool.pool;
                  p != null && p.refCount++;
                }
                break;
              case 24:
                Yg(g.memoizedState.cache);
            }
            if (p = g.child, p !== null) p.return = g, Gn = p;
            else e: for (g = c; Gn !== null; ) {
              p = Gn;
              var w = p.sibling, S = p.return;
              if (KA(p), p === g) {
                Gn = null;
                break e;
              }
              if (w !== null) {
                w.return = S, Gn = w;
                break e;
              }
              Gn = S;
            }
          }
        }
        var _W = {
          getCacheForType: function(c) {
            var h = ws(Vn), g = h.data.get(c);
            return g === void 0 && (g = c(), h.data.set(c, g)), g;
          }
        }, bW = typeof WeakMap == "function" ? WeakMap : Map, gi = 0, Pi = null, Wt = null, ti = 0, mi = 0, So = null, uc = false, Ad = false, bS = false, ol = 0, en = 0, hc = 0, Ru = 0, vS = 0, ir = 0, Rd = 0, gm = null, io = null, CS = false, wS = 0, j1 = 1 / 0, G1 = null, dc = null, as = 0, fc = null, Od = null, Pd = 0, yS = 0, SS = null, iR = null, mm = 0, LS = null;
        function Lo() {
          if ((gi & 2) !== 0 && ti !== 0) return ti & -ti;
          if (H.T !== null) {
            var c = Sd;
            return c !== 0 ? c : IS();
          }
          return P();
        }
        function nR() {
          ir === 0 && (ir = (ti & 536870912) === 0 || ci ? sa() : 536870912);
          var c = tr.current;
          return c !== null && (c.flags |= 32), ir;
        }
        function xo(c, h, g) {
          (c === Pi && (mi === 2 || mi === 9) || c.cancelPendingCommit !== null) && (Bd(c, 0), gc(c, ti, ir, false)), Oi(c, g), ((gi & 2) === 0 || c !== Pi) && (c === Pi && ((gi & 2) === 0 && (Ru |= g), en === 4 && gc(c, ti, ir, false)), ha(c));
        }
        function sR(c, h, g) {
          if ((gi & 6) !== 0) throw Error(i(327));
          var p = !g && (h & 124) === 0 && (h & c.expiredLanes) === 0 || os(c, h), w = p ? wW(c, h) : DS(c, h, true), S = p;
          do {
            if (w === 0) {
              Ad && !p && gc(c, h, 0, false);
              break;
            } else {
              if (g = c.current.alternate, S && !vW(g)) {
                w = DS(c, h, false), S = false;
                continue;
              }
              if (w === 2) {
                if (S = h, c.errorRecoveryDisabledLanes & S) var N = 0;
                else N = c.pendingLanes & -536870913, N = N !== 0 ? N : N & 536870912 ? 536870912 : 0;
                if (N !== 0) {
                  h = N;
                  e: {
                    var O = c;
                    w = gm;
                    var q = O.current.memoizedState.isDehydrated;
                    if (q && (Bd(O, N).flags |= 256), N = DS(O, N, false), N !== 2) {
                      if (bS && !q) {
                        O.errorRecoveryDisabledLanes |= S, Ru |= S, w = 4;
                        break e;
                      }
                      S = io, io = w, S !== null && (io === null ? io = S : io.push.apply(io, S));
                    }
                    w = N;
                  }
                  if (S = false, w !== 2) continue;
                }
              }
              if (w === 1) {
                Bd(c, 0), gc(c, h, 0, true);
                break;
              }
              e: {
                switch (p = c, S = w, S) {
                  case 0:
                  case 1:
                    throw Error(i(345));
                  case 4:
                    if ((h & 4194048) !== h) break;
                  case 6:
                    gc(p, h, ir, !uc);
                    break e;
                  case 2:
                    io = null;
                    break;
                  case 3:
                  case 5:
                    break;
                  default:
                    throw Error(i(329));
                }
                if ((h & 62914560) === h && (w = wS + 300 - Bn(), 10 < w)) {
                  if (gc(p, h, ir, !uc), Sr(p, 0, true) !== 0) break e;
                  p.timeoutHandle = AR(oR.bind(null, p, g, io, G1, CS, h, ir, Ru, Rd, uc, S, 2, -0, 0), w);
                  break e;
                }
                oR(p, g, io, G1, CS, h, ir, Ru, Rd, uc, S, 0, -0, 0);
              }
            }
            break;
          } while (true);
          ha(c);
        }
        function oR(c, h, g, p, w, S, N, O, q, ue, ve, Le, ge, pe) {
          if (c.timeoutHandle = -1, Le = h.subtreeFlags, (Le & 8192 || (Le & 16785408) === 16785408) && (ym = {
            stylesheets: null,
            count: 0,
            unsuspend: eH
          }, XA(h), Le = iH(), Le !== null)) {
            c.cancelPendingCommit = Le(dR.bind(null, c, h, S, g, p, w, N, O, q, ve, 1, ge, pe)), gc(c, S, N, !ue);
            return;
          }
          dR(c, h, S, g, p, w, N, O, q);
        }
        function vW(c) {
          for (var h = c; ; ) {
            var g = h.tag;
            if ((g === 0 || g === 11 || g === 15) && h.flags & 16384 && (g = h.updateQueue, g !== null && (g = g.stores, g !== null))) for (var p = 0; p < g.length; p++) {
              var w = g[p], S = w.getSnapshot;
              w = w.value;
              try {
                if (!vo(S(), w)) return false;
              } catch {
                return false;
              }
            }
            if (g = h.child, h.subtreeFlags & 16384 && g !== null) g.return = h, h = g;
            else {
              if (h === c) break;
              for (; h.sibling === null; ) {
                if (h.return === null || h.return === c) return true;
                h = h.return;
              }
              h.sibling.return = h.return, h = h.sibling;
            }
          }
          return true;
        }
        function gc(c, h, g, p) {
          h &= ~vS, h &= ~Ru, c.suspendedLanes |= h, c.pingedLanes &= ~h, p && (c.warmLanes |= h), p = c.expirationTimes;
          for (var w = h; 0 < w; ) {
            var S = 31 - dn(w), N = 1 << S;
            p[S] = -1, w &= ~N;
          }
          g !== 0 && ld(c, g, h);
        }
        function Y1() {
          return (gi & 6) === 0 ? (pm(0), false) : true;
        }
        function xS() {
          if (Wt !== null) {
            if (mi === 0) var c = Wt.return;
            else c = Wt, Qa = Eu = null, zy(c), Td = null, rm = 0, c = Wt;
            for (; c !== null; ) FA(c.alternate, c), c = c.return;
            Wt = null;
          }
        }
        function Bd(c, h) {
          var g = c.timeoutHandle;
          g !== -1 && (c.timeoutHandle = -1, BW(g)), g = c.cancelPendingCommit, g !== null && (c.cancelPendingCommit = null, g()), xS(), Pi = c, Wt = g = Ga(c.current, null), ti = h, mi = 0, So = null, uc = false, Ad = os(c, h), bS = false, Rd = ir = vS = Ru = hc = en = 0, io = gm = null, CS = false, (h & 8) !== 0 && (h |= h & 32);
          var p = c.entangledLanes;
          if (p !== 0) for (c = c.entanglements, p &= h; 0 < p; ) {
            var w = 31 - dn(p), S = 1 << w;
            h |= c[w], p &= ~S;
          }
          return ol = h, _1(), g;
        }
        function rR(c, h) {
          Pt = null, H.H = P1, h === Qg || h === k1 ? (h = SM(), mi = 3) : h === CM ? (h = SM(), mi = 4) : mi = h === LA ? 8 : h !== null && typeof h == "object" && typeof h.then == "function" ? 6 : 1, So = h, Wt === null && (en = 1, H1(c, Qo(h, c.current)));
        }
        function aR() {
          var c = H.H;
          return H.H = P1, c === null ? P1 : c;
        }
        function lR() {
          var c = H.A;
          return H.A = _W, c;
        }
        function kS() {
          en = 4, uc || (ti & 4194048) !== ti && tr.current !== null || (Ad = true), (hc & 134217727) === 0 && (Ru & 134217727) === 0 || Pi === null || gc(Pi, ti, ir, false);
        }
        function DS(c, h, g) {
          var p = gi;
          gi |= 2;
          var w = aR(), S = lR();
          (Pi !== c || ti !== h) && (G1 = null, Bd(c, h)), h = false;
          var N = en;
          e: do
            try {
              if (mi !== 0 && Wt !== null) {
                var O = Wt, q = So;
                switch (mi) {
                  case 8:
                    xS(), N = 6;
                    break e;
                  case 3:
                  case 2:
                  case 9:
                  case 6:
                    tr.current === null && (h = true);
                    var ue = mi;
                    if (mi = 0, So = null, Fd(c, O, q, ue), g && Ad) {
                      N = 0;
                      break e;
                    }
                    break;
                  default:
                    ue = mi, mi = 0, So = null, Fd(c, O, q, ue);
                }
              }
              CW(), N = en;
              break;
            } catch (ve) {
              rR(c, ve);
            }
          while (true);
          return h && c.shellSuspendCounter++, Qa = Eu = null, gi = p, H.H = w, H.A = S, Wt === null && (Pi = null, ti = 0, _1()), N;
        }
        function CW() {
          for (; Wt !== null; ) cR(Wt);
        }
        function wW(c, h) {
          var g = gi;
          gi |= 2;
          var p = aR(), w = lR();
          Pi !== c || ti !== h ? (G1 = null, j1 = Bn() + 500, Bd(c, h)) : Ad = os(c, h);
          e: do
            try {
              if (mi !== 0 && Wt !== null) {
                h = Wt;
                var S = So;
                t: switch (mi) {
                  case 1:
                    mi = 0, So = null, Fd(c, h, S, 1);
                    break;
                  case 2:
                  case 9:
                    if (wM(S)) {
                      mi = 0, So = null, uR(h);
                      break;
                    }
                    h = function() {
                      mi !== 2 && mi !== 9 || Pi !== c || (mi = 7), ha(c);
                    }, S.then(h, h);
                    break e;
                  case 3:
                    mi = 7;
                    break e;
                  case 4:
                    mi = 5;
                    break e;
                  case 7:
                    wM(S) ? (mi = 0, So = null, uR(h)) : (mi = 0, So = null, Fd(c, h, S, 7));
                    break;
                  case 5:
                    var N = null;
                    switch (Wt.tag) {
                      case 26:
                        N = Wt.memoizedState;
                      case 5:
                      case 27:
                        var O = Wt;
                        if (!N || qR(N)) {
                          mi = 0, So = null;
                          var q = O.sibling;
                          if (q !== null) Wt = q;
                          else {
                            var ue = O.return;
                            ue !== null ? (Wt = ue, Z1(ue)) : Wt = null;
                          }
                          break t;
                        }
                    }
                    mi = 0, So = null, Fd(c, h, S, 5);
                    break;
                  case 6:
                    mi = 0, So = null, Fd(c, h, S, 6);
                    break;
                  case 8:
                    xS(), en = 6;
                    break e;
                  default:
                    throw Error(i(462));
                }
              }
              yW();
              break;
            } catch (ve) {
              rR(c, ve);
            }
          while (true);
          return Qa = Eu = null, H.H = p, H.A = w, gi = g, Wt !== null ? 0 : (Pi = null, ti = 0, _1(), en);
        }
        function yW() {
          for (; Wt !== null && !pu(); ) cR(Wt);
        }
        function cR(c) {
          var h = PA(c.alternate, c, ol);
          c.memoizedProps = c.pendingProps, h === null ? Z1(c) : Wt = h;
        }
        function uR(c) {
          var h = c, g = h.alternate;
          switch (h.tag) {
            case 15:
            case 0:
              h = NA(g, h, h.pendingProps, h.type, void 0, ti);
              break;
            case 11:
              h = NA(g, h, h.pendingProps, h.type.render, h.ref, ti);
              break;
            case 5:
              zy(h);
            default:
              FA(g, h), h = Wt = hM(h, ol), h = PA(g, h, ol);
          }
          c.memoizedProps = c.pendingProps, h === null ? Z1(c) : Wt = h;
        }
        function Fd(c, h, g, p) {
          Qa = Eu = null, zy(h), Td = null, rm = 0;
          var w = h.return;
          try {
            if (hW(c, w, h, g, ti)) {
              en = 1, H1(c, Qo(g, c.current)), Wt = null;
              return;
            }
          } catch (S) {
            if (w !== null) throw Wt = w, S;
            en = 1, H1(c, Qo(g, c.current)), Wt = null;
            return;
          }
          h.flags & 32768 ? (ci || p === 1 ? c = true : Ad || (ti & 536870912) !== 0 ? c = false : (uc = c = true, (p === 2 || p === 9 || p === 3 || p === 6) && (p = tr.current, p !== null && p.tag === 13 && (p.flags |= 16384))), hR(h, c)) : Z1(h);
        }
        function Z1(c) {
          var h = c;
          do {
            if ((h.flags & 32768) !== 0) {
              hR(h, uc);
              return;
            }
            c = h.return;
            var g = fW(h.alternate, h, ol);
            if (g !== null) {
              Wt = g;
              return;
            }
            if (h = h.sibling, h !== null) {
              Wt = h;
              return;
            }
            Wt = h = c;
          } while (h !== null);
          en === 0 && (en = 5);
        }
        function hR(c, h) {
          do {
            var g = gW(c.alternate, c);
            if (g !== null) {
              g.flags &= 32767, Wt = g;
              return;
            }
            if (g = c.return, g !== null && (g.flags |= 32768, g.subtreeFlags = 0, g.deletions = null), !h && (c = c.sibling, c !== null)) {
              Wt = c;
              return;
            }
            Wt = c = g;
          } while (c !== null);
          en = 6, Wt = null;
        }
        function dR(c, h, g, p, w, S, N, O, q) {
          c.cancelPendingCommit = null;
          do
            Q1();
          while (as !== 0);
          if ((gi & 6) !== 0) throw Error(i(327));
          if (h !== null) {
            if (h === c.current) throw Error(i(177));
            if (S = h.lanes | h.childLanes, S |= _y, oa(c, g, S, N, O, q), c === Pi && (Wt = Pi = null, ti = 0), Od = h, fc = c, Pd = g, yS = S, SS = w, iR = p, (h.subtreeFlags & 10256) !== 0 || (h.flags & 10256) !== 0 ? (c.callbackNode = null, c.callbackPriority = 0, kW(Ua, function() {
              return _R(), null;
            })) : (c.callbackNode = null, c.callbackPriority = 0), p = (h.flags & 13878) !== 0, (h.subtreeFlags & 13878) !== 0 || p) {
              p = H.T, H.T = null, w = se.p, se.p = 2, N = gi, gi |= 4;
              try {
                mW(c, h, g);
              } finally {
                gi = N, se.p = w, H.T = p;
              }
            }
            as = 1, fR(), gR(), mR();
          }
        }
        function fR() {
          if (as === 1) {
            as = 0;
            var c = fc, h = Od, g = (h.flags & 13878) !== 0;
            if ((h.subtreeFlags & 13878) !== 0 || g) {
              g = H.T, H.T = null;
              var p = se.p;
              se.p = 2;
              var w = gi;
              gi |= 4;
              try {
                YA(h, c);
                var S = VS, N = tM(c.containerInfo), O = S.focusedElem, q = S.selectionRange;
                if (N !== O && O && O.ownerDocument && eM(O.ownerDocument.documentElement, O)) {
                  if (q !== null && dy(O)) {
                    var ue = q.start, ve = q.end;
                    if (ve === void 0 && (ve = ue), "selectionStart" in O) O.selectionStart = ue, O.selectionEnd = Math.min(ve, O.value.length);
                    else {
                      var Le = O.ownerDocument || document, ge = Le && Le.defaultView || window;
                      if (ge.getSelection) {
                        var pe = ge.getSelection(), gt = O.textContent.length, at = Math.min(q.start, gt), Ci = q.end === void 0 ? at : Math.min(q.end, gt);
                        !pe.extend && at > Ci && (N = Ci, Ci = at, at = N);
                        var oe = JI(O, at), J = JI(O, Ci);
                        if (oe && J && (pe.rangeCount !== 1 || pe.anchorNode !== oe.node || pe.anchorOffset !== oe.offset || pe.focusNode !== J.node || pe.focusOffset !== J.offset)) {
                          var ae = Le.createRange();
                          ae.setStart(oe.node, oe.offset), pe.removeAllRanges(), at > Ci ? (pe.addRange(ae), pe.extend(J.node, J.offset)) : (ae.setEnd(J.node, J.offset), pe.addRange(ae));
                        }
                      }
                    }
                  }
                  for (Le = [], pe = O; pe = pe.parentNode; ) pe.nodeType === 1 && Le.push({
                    element: pe,
                    left: pe.scrollLeft,
                    top: pe.scrollTop
                  });
                  for (typeof O.focus == "function" && O.focus(), O = 0; O < Le.length; O++) {
                    var Se = Le[O];
                    Se.element.scrollLeft = Se.left, Se.element.scrollTop = Se.top;
                  }
                }
                cb = !!FS, VS = FS = null;
              } finally {
                gi = w, se.p = p, H.T = g;
              }
            }
            c.current = h, as = 2;
          }
        }
        function gR() {
          if (as === 2) {
            as = 0;
            var c = fc, h = Od, g = (h.flags & 8772) !== 0;
            if ((h.subtreeFlags & 8772) !== 0 || g) {
              g = H.T, H.T = null;
              var p = se.p;
              se.p = 2;
              var w = gi;
              gi |= 4;
              try {
                qA(c, h.alternate, h);
              } finally {
                gi = w, se.p = p, H.T = g;
              }
            }
            as = 3;
          }
        }
        function mR() {
          if (as === 4 || as === 3) {
            as = 0, _u();
            var c = fc, h = Od, g = Pd, p = iR;
            (h.subtreeFlags & 10256) !== 0 || (h.flags & 10256) !== 0 ? as = 5 : (as = 0, Od = fc = null, pR(c, c.pendingLanes));
            var w = c.pendingLanes;
            if (w === 0 && (dc = null), nt(g), h = h.stateNode, Sn && typeof Sn.onCommitFiberRoot == "function") try {
              Sn.onCommitFiberRoot(Qs, h, void 0, (h.current.flags & 128) === 128);
            } catch {
            }
            if (p !== null) {
              h = H.T, w = se.p, se.p = 2, H.T = null;
              try {
                for (var S = c.onRecoverableError, N = 0; N < p.length; N++) {
                  var O = p[N];
                  S(O.value, {
                    componentStack: O.stack
                  });
                }
              } finally {
                H.T = h, se.p = w;
              }
            }
            (Pd & 3) !== 0 && Q1(), ha(c), w = c.pendingLanes, (g & 4194090) !== 0 && (w & 42) !== 0 ? c === LS ? mm++ : (mm = 0, LS = c) : mm = 0, pm(0);
          }
        }
        function pR(c, h) {
          (c.pooledCacheLanes &= h) === 0 && (h = c.pooledCache, h != null && (c.pooledCache = null, Yg(h)));
        }
        function Q1(c) {
          return fR(), gR(), mR(), _R();
        }
        function _R() {
          if (as !== 5) return false;
          var c = fc, h = yS;
          yS = 0;
          var g = nt(Pd), p = H.T, w = se.p;
          try {
            se.p = 32 > g ? 32 : g, H.T = null, g = SS, SS = null;
            var S = fc, N = Pd;
            if (as = 0, Od = fc = null, Pd = 0, (gi & 6) !== 0) throw Error(i(331));
            var O = gi;
            if (gi |= 4, eR(S.current), QA(S, S.current, N, g), gi = O, pm(0, false), Sn && typeof Sn.onPostCommitFiberRoot == "function") try {
              Sn.onPostCommitFiberRoot(Qs, S);
            } catch {
            }
            return true;
          } finally {
            se.p = w, H.T = p, pR(c, h);
          }
        }
        function bR(c, h, g) {
          h = Qo(g, h), h = iS(c.stateNode, h, 2), c = nc(c, h, 2), c !== null && (Oi(c, 2), ha(c));
        }
        function ki(c, h, g) {
          if (c.tag === 3) bR(c, c, g);
          else for (; h !== null; ) {
            if (h.tag === 3) {
              bR(h, c, g);
              break;
            } else if (h.tag === 1) {
              var p = h.stateNode;
              if (typeof h.type.getDerivedStateFromError == "function" || typeof p.componentDidCatch == "function" && (dc === null || !dc.has(p))) {
                c = Qo(g, c), g = yA(2), p = nc(h, g, 2), p !== null && (SA(g, p, h, c), Oi(p, 2), ha(p));
                break;
              }
            }
            h = h.return;
          }
        }
        function ES(c, h, g) {
          var p = c.pingCache;
          if (p === null) {
            p = c.pingCache = new bW();
            var w = /* @__PURE__ */ new Set();
            p.set(h, w);
          } else w = p.get(h), w === void 0 && (w = /* @__PURE__ */ new Set(), p.set(h, w));
          w.has(g) || (bS = true, w.add(g), c = SW.bind(null, c, h, g), h.then(c, c));
        }
        function SW(c, h, g) {
          var p = c.pingCache;
          p !== null && p.delete(h), c.pingedLanes |= c.suspendedLanes & g, c.warmLanes &= ~g, Pi === c && (ti & g) === g && (en === 4 || en === 3 && (ti & 62914560) === ti && 300 > Bn() - wS ? (gi & 2) === 0 && Bd(c, 0) : vS |= g, Rd === ti && (Rd = 0)), ha(c);
        }
        function vR(c, h) {
          h === 0 && (h = ad()), c = vd(c, h), c !== null && (Oi(c, h), ha(c));
        }
        function LW(c) {
          var h = c.memoizedState, g = 0;
          h !== null && (g = h.retryLane), vR(c, g);
        }
        function xW(c, h) {
          var g = 0;
          switch (c.tag) {
            case 13:
              var p = c.stateNode, w = c.memoizedState;
              w !== null && (g = w.retryLane);
              break;
            case 19:
              p = c.stateNode;
              break;
            case 22:
              p = c.stateNode._retryCache;
              break;
            default:
              throw Error(i(314));
          }
          p !== null && p.delete(h), vR(c, g);
        }
        function kW(c, h) {
          return Ha(c, h);
        }
        var X1 = null, Vd = null, TS = false, J1 = false, NS = false, Ou = 0;
        function ha(c) {
          c !== Vd && c.next === null && (Vd === null ? X1 = Vd = c : Vd = Vd.next = c), J1 = true, TS || (TS = true, EW());
        }
        function pm(c, h) {
          if (!NS && J1) {
            NS = true;
            do
              for (var g = false, p = X1; p !== null; ) {
                if (c !== 0) {
                  var w = p.pendingLanes;
                  if (w === 0) var S = 0;
                  else {
                    var N = p.suspendedLanes, O = p.pingedLanes;
                    S = (1 << 31 - dn(42 | c) + 1) - 1, S &= w & ~(N & ~O), S = S & 201326741 ? S & 201326741 | 1 : S ? S | 2 : 0;
                  }
                  S !== 0 && (g = true, SR(p, S));
                } else S = ti, S = Sr(p, p === Pi ? S : 0, p.cancelPendingCommit !== null || p.timeoutHandle !== -1), (S & 3) === 0 || os(p, S) || (g = true, SR(p, S));
                p = p.next;
              }
            while (g);
            NS = false;
          }
        }
        function DW() {
          CR();
        }
        function CR() {
          J1 = TS = false;
          var c = 0;
          Ou !== 0 && (PW() && (c = Ou), Ou = 0);
          for (var h = Bn(), g = null, p = X1; p !== null; ) {
            var w = p.next, S = wR(p, h);
            S === 0 ? (p.next = null, g === null ? X1 = w : g.next = w, w === null && (Vd = g)) : (g = p, (c !== 0 || (S & 3) !== 0) && (J1 = true)), p = w;
          }
          pm(c);
        }
        function wR(c, h) {
          for (var g = c.suspendedLanes, p = c.pingedLanes, w = c.expirationTimes, S = c.pendingLanes & -62914561; 0 < S; ) {
            var N = 31 - dn(S), O = 1 << N, q = w[N];
            q === -1 ? ((O & g) === 0 || (O & p) !== 0) && (w[N] = ei(O, h)) : q <= h && (c.expiredLanes |= O), S &= ~O;
          }
          if (h = Pi, g = ti, g = Sr(c, c === h ? g : 0, c.cancelPendingCommit !== null || c.timeoutHandle !== -1), p = c.callbackNode, g === 0 || c === h && (mi === 2 || mi === 9) || c.cancelPendingCommit !== null) return p !== null && p !== null && _o2(p), c.callbackNode = null, c.callbackPriority = 0;
          if ((g & 3) === 0 || os(c, g)) {
            if (h = g & -g, h === c.callbackPriority) return h;
            switch (p !== null && _o2(p), nt(g)) {
              case 2:
              case 8:
                g = na;
                break;
              case 32:
                g = Ua;
                break;
              case 268435456:
                g = $a;
                break;
              default:
                g = Ua;
            }
            return p = yR.bind(null, c), g = Ha(g, p), c.callbackPriority = h, c.callbackNode = g, h;
          }
          return p !== null && p !== null && _o2(p), c.callbackPriority = 2, c.callbackNode = null, 2;
        }
        function yR(c, h) {
          if (as !== 0 && as !== 5) return c.callbackNode = null, c.callbackPriority = 0, null;
          var g = c.callbackNode;
          if (Q1() && c.callbackNode !== g) return null;
          var p = ti;
          return p = Sr(c, c === Pi ? p : 0, c.cancelPendingCommit !== null || c.timeoutHandle !== -1), p === 0 ? null : (sR(c, p, h), wR(c, Bn()), c.callbackNode != null && c.callbackNode === g ? yR.bind(null, c) : null);
        }
        function SR(c, h) {
          if (Q1()) return null;
          sR(c, h, true);
        }
        function EW() {
          FW(function() {
            (gi & 6) !== 0 ? Ha(za, DW) : CR();
          });
        }
        function IS() {
          return Ou === 0 && (Ou = sa()), Ou;
        }
        function LR(c) {
          return c == null || typeof c == "symbol" || typeof c == "boolean" ? null : typeof c == "function" ? c : u1("" + c);
        }
        function xR(c, h) {
          var g = h.ownerDocument.createElement("input");
          return g.name = h.name, g.value = h.value, c.id && g.setAttribute("form", c.id), h.parentNode.insertBefore(g, h), c = new FormData(c), g.parentNode.removeChild(g), c;
        }
        function TW(c, h, g, p, w) {
          if (h === "submit" && g && g.stateNode === w) {
            var S = LR((w[Z] || null).action), N = p.submitter;
            N && (h = (h = N[Z] || null) ? LR(h.formAction) : N.getAttribute("formAction"), h !== null && (S = h, N = null));
            var O = new g1("action", "action", null, p, w);
            c.push({
              event: O,
              listeners: [
                {
                  instance: null,
                  listener: function() {
                    if (p.defaultPrevented) {
                      if (Ou !== 0) {
                        var q = N ? xR(w, N) : new FormData(w);
                        Qy(g, {
                          pending: true,
                          data: q,
                          method: w.method,
                          action: S
                        }, null, q);
                      }
                    } else typeof S == "function" && (O.preventDefault(), q = N ? xR(w, N) : new FormData(w), Qy(g, {
                      pending: true,
                      data: q,
                      method: w.method,
                      action: S
                    }, S, q));
                  },
                  currentTarget: w
                }
              ]
            });
          }
        }
        for (var MS = 0; MS < py.length; MS++) {
          var AS = py[MS], NW = AS.toLowerCase(), IW = AS[0].toUpperCase() + AS.slice(1);
          Lr(NW, "on" + IW);
        }
        Lr(sM, "onAnimationEnd"), Lr(oM, "onAnimationIteration"), Lr(rM, "onAnimationStart"), Lr("dblclick", "onDoubleClick"), Lr("focusin", "onFocus"), Lr("focusout", "onBlur"), Lr(GV, "onTransitionRun"), Lr(YV, "onTransitionStart"), Lr(ZV, "onTransitionCancel"), Lr(aM, "onTransitionEnd"), ze("onMouseEnter", [
          "mouseout",
          "mouseover"
        ]), ze("onMouseLeave", [
          "mouseout",
          "mouseover"
        ]), ze("onPointerEnter", [
          "pointerout",
          "pointerover"
        ]), ze("onPointerLeave", [
          "pointerout",
          "pointerover"
        ]), De("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), De("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), De("onBeforeInput", [
          "compositionend",
          "keypress",
          "textInput",
          "paste"
        ]), De("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), De("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), De("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
        var _m2 = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), MW = new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(_m2));
        function kR(c, h) {
          h = (h & 4) !== 0;
          for (var g = 0; g < c.length; g++) {
            var p = c[g], w = p.event;
            p = p.listeners;
            e: {
              var S = void 0;
              if (h) for (var N = p.length - 1; 0 <= N; N--) {
                var O = p[N], q = O.instance, ue = O.currentTarget;
                if (O = O.listener, q !== S && w.isPropagationStopped()) break e;
                S = O, w.currentTarget = ue;
                try {
                  S(w);
                } catch (ve) {
                  W1(ve);
                }
                w.currentTarget = null, S = q;
              }
              else for (N = 0; N < p.length; N++) {
                if (O = p[N], q = O.instance, ue = O.currentTarget, O = O.listener, q !== S && w.isPropagationStopped()) break e;
                S = O, w.currentTarget = ue;
                try {
                  S(w);
                } catch (ve) {
                  W1(ve);
                }
                w.currentTarget = null, S = q;
              }
            }
          }
        }
        function Ht(c, h) {
          var g = h[_e2];
          g === void 0 && (g = h[_e2] = /* @__PURE__ */ new Set());
          var p = c + "__bubble";
          g.has(p) || (DR(h, c, 2, false), g.add(p));
        }
        function RS(c, h, g) {
          var p = 0;
          h && (p |= 4), DR(g, c, p, h);
        }
        var eb = "_reactListening" + Math.random().toString(36).slice(2);
        function OS(c) {
          if (!c[eb]) {
            c[eb] = true, je.forEach(function(g) {
              g !== "selectionchange" && (MW.has(g) || RS(g, false, c), RS(g, true, c));
            });
            var h = c.nodeType === 9 ? c : c.ownerDocument;
            h === null || h[eb] || (h[eb] = true, RS("selectionchange", false, h));
          }
        }
        function DR(c, h, g, p) {
          switch (QR(h)) {
            case 2:
              var w = oH;
              break;
            case 8:
              w = rH;
              break;
            default:
              w = YS;
          }
          g = w.bind(null, h, g, c), w = void 0, !ny || h !== "touchstart" && h !== "touchmove" && h !== "wheel" || (w = true), p ? w !== void 0 ? c.addEventListener(h, g, {
            capture: true,
            passive: w
          }) : c.addEventListener(h, g, true) : w !== void 0 ? c.addEventListener(h, g, {
            passive: w
          }) : c.addEventListener(h, g, false);
        }
        function PS(c, h, g, p, w) {
          var S = p;
          if ((h & 1) === 0 && (h & 2) === 0 && p !== null) e: for (; ; ) {
            if (p === null) return;
            var N = p.tag;
            if (N === 3 || N === 4) {
              var O = p.stateNode.containerInfo;
              if (O === w) break;
              if (N === 4) for (N = p.return; N !== null; ) {
                var q = N.tag;
                if ((q === 3 || q === 4) && N.stateNode.containerInfo === w) return;
                N = N.return;
              }
              for (; O !== null; ) {
                if (N = fi(O), N === null) return;
                if (q = N.tag, q === 5 || q === 6 || q === 26 || q === 27) {
                  p = S = N;
                  continue e;
                }
                O = O.parentNode;
              }
            }
            p = p.return;
          }
          RI(function() {
            var ue = S, ve = ty(g), Le = [];
            e: {
              var ge = lM.get(c);
              if (ge !== void 0) {
                var pe = g1, gt = c;
                switch (c) {
                  case "keypress":
                    if (d1(g) === 0) break e;
                  case "keydown":
                  case "keyup":
                    pe = kV;
                    break;
                  case "focusin":
                    gt = "focus", pe = ay;
                    break;
                  case "focusout":
                    gt = "blur", pe = ay;
                    break;
                  case "beforeblur":
                  case "afterblur":
                    pe = ay;
                    break;
                  case "click":
                    if (g.button === 2) break e;
                  case "auxclick":
                  case "dblclick":
                  case "mousedown":
                  case "mousemove":
                  case "mouseup":
                  case "mouseout":
                  case "mouseover":
                  case "contextmenu":
                    pe = BI;
                    break;
                  case "drag":
                  case "dragend":
                  case "dragenter":
                  case "dragexit":
                  case "dragleave":
                  case "dragover":
                  case "dragstart":
                  case "drop":
                    pe = gV;
                    break;
                  case "touchcancel":
                  case "touchend":
                  case "touchmove":
                  case "touchstart":
                    pe = TV;
                    break;
                  case sM:
                  case oM:
                  case rM:
                    pe = _V;
                    break;
                  case aM:
                    pe = IV;
                    break;
                  case "scroll":
                  case "scrollend":
                    pe = dV;
                    break;
                  case "wheel":
                    pe = AV;
                    break;
                  case "copy":
                  case "cut":
                  case "paste":
                    pe = vV;
                    break;
                  case "gotpointercapture":
                  case "lostpointercapture":
                  case "pointercancel":
                  case "pointerdown":
                  case "pointermove":
                  case "pointerout":
                  case "pointerover":
                  case "pointerup":
                    pe = VI;
                    break;
                  case "toggle":
                  case "beforetoggle":
                    pe = OV;
                }
                var at = (h & 4) !== 0, Ci = !at && (c === "scroll" || c === "scrollend"), oe = at ? ge !== null ? ge + "Capture" : null : ge;
                at = [];
                for (var J = ue, ae; J !== null; ) {
                  var Se = J;
                  if (ae = Se.stateNode, Se = Se.tag, Se !== 5 && Se !== 26 && Se !== 27 || ae === null || oe === null || (Se = Pg(J, oe), Se != null && at.push(bm(J, Se, ae))), Ci) break;
                  J = J.return;
                }
                0 < at.length && (ge = new pe(ge, gt, null, g, ve), Le.push({
                  event: ge,
                  listeners: at
                }));
              }
            }
            if ((h & 7) === 0) {
              e: {
                if (ge = c === "mouseover" || c === "pointerover", pe = c === "mouseout" || c === "pointerout", ge && g !== ey && (gt = g.relatedTarget || g.fromElement) && (fi(gt) || gt[ce])) break e;
                if ((pe || ge) && (ge = ve.window === ve ? ve : (ge = ve.ownerDocument) ? ge.defaultView || ge.parentWindow : window, pe ? (gt = g.relatedTarget || g.toElement, pe = ue, gt = gt ? fi(gt) : null, gt !== null && (Ci = o(gt), at = gt.tag, gt !== Ci || at !== 5 && at !== 27 && at !== 6) && (gt = null)) : (pe = null, gt = ue), pe !== gt)) {
                  if (at = BI, Se = "onMouseLeave", oe = "onMouseEnter", J = "mouse", (c === "pointerout" || c === "pointerover") && (at = VI, Se = "onPointerLeave", oe = "onPointerEnter", J = "pointer"), Ci = pe == null ? ge : fn(pe), ae = gt == null ? ge : fn(gt), ge = new at(Se, J + "leave", pe, g, ve), ge.target = Ci, ge.relatedTarget = ae, Se = null, fi(ve) === ue && (at = new at(oe, J + "enter", gt, g, ve), at.target = ae, at.relatedTarget = Ci, Se = at), Ci = Se, pe && gt) t: {
                    for (at = pe, oe = gt, J = 0, ae = at; ae; ae = Wd(ae)) J++;
                    for (ae = 0, Se = oe; Se; Se = Wd(Se)) ae++;
                    for (; 0 < J - ae; ) at = Wd(at), J--;
                    for (; 0 < ae - J; ) oe = Wd(oe), ae--;
                    for (; J--; ) {
                      if (at === oe || oe !== null && at === oe.alternate) break t;
                      at = Wd(at), oe = Wd(oe);
                    }
                    at = null;
                  }
                  else at = null;
                  pe !== null && ER(Le, ge, pe, at, false), gt !== null && Ci !== null && ER(Le, Ci, gt, at, true);
                }
              }
              e: {
                if (ge = ue ? fn(ue) : window, pe = ge.nodeName && ge.nodeName.toLowerCase(), pe === "select" || pe === "input" && ge.type === "file") var Ke = jI;
                else if (qI(ge)) if (GI) Ke = qV;
                else {
                  Ke = UV;
                  var Vt = zV;
                }
                else pe = ge.nodeName, !pe || pe.toLowerCase() !== "input" || ge.type !== "checkbox" && ge.type !== "radio" ? ue && Jw(ue.elementType) && (Ke = jI) : Ke = $V;
                if (Ke && (Ke = Ke(c, ue))) {
                  KI(Le, Ke, g, ve);
                  break e;
                }
                Vt && Vt(c, ge, ue), c === "focusout" && ue && ge.type === "number" && ue.memoizedProps.value != null && Xw(ge, "number", ge.value);
              }
              switch (Vt = ue ? fn(ue) : window, c) {
                case "focusin":
                  (qI(Vt) || Vt.contentEditable === "true") && (pd = Vt, fy = ue, $g = null);
                  break;
                case "focusout":
                  $g = fy = pd = null;
                  break;
                case "mousedown":
                  gy = true;
                  break;
                case "contextmenu":
                case "mouseup":
                case "dragend":
                  gy = false, iM(Le, g, ve);
                  break;
                case "selectionchange":
                  if (jV) break;
                case "keydown":
                case "keyup":
                  iM(Le, g, ve);
              }
              var Xe;
              if (cy) e: {
                switch (c) {
                  case "compositionstart":
                    var ut = "onCompositionStart";
                    break e;
                  case "compositionend":
                    ut = "onCompositionEnd";
                    break e;
                  case "compositionupdate":
                    ut = "onCompositionUpdate";
                    break e;
                }
                ut = void 0;
              }
              else md ? UI(c, g) && (ut = "onCompositionEnd") : c === "keydown" && g.keyCode === 229 && (ut = "onCompositionStart");
              ut && (WI && g.locale !== "ko" && (md || ut !== "onCompositionStart" ? ut === "onCompositionEnd" && md && (Xe = OI()) : (Jl = ve, sy = "value" in Jl ? Jl.value : Jl.textContent, md = true)), Vt = tb(ue, ut), 0 < Vt.length && (ut = new FI(ut, c, null, g, ve), Le.push({
                event: ut,
                listeners: Vt
              }), Xe ? ut.data = Xe : (Xe = $I(g), Xe !== null && (ut.data = Xe)))), (Xe = BV ? FV(c, g) : VV(c, g)) && (ut = tb(ue, "onBeforeInput"), 0 < ut.length && (Vt = new FI("onBeforeInput", "beforeinput", null, g, ve), Le.push({
                event: Vt,
                listeners: ut
              }), Vt.data = Xe)), TW(Le, c, ue, g, ve);
            }
            kR(Le, h);
          });
        }
        function bm(c, h, g) {
          return {
            instance: c,
            listener: h,
            currentTarget: g
          };
        }
        function tb(c, h) {
          for (var g = h + "Capture", p = []; c !== null; ) {
            var w = c, S = w.stateNode;
            if (w = w.tag, w !== 5 && w !== 26 && w !== 27 || S === null || (w = Pg(c, g), w != null && p.unshift(bm(c, w, S)), w = Pg(c, h), w != null && p.push(bm(c, w, S))), c.tag === 3) return p;
            c = c.return;
          }
          return [];
        }
        function Wd(c) {
          if (c === null) return null;
          do
            c = c.return;
          while (c && c.tag !== 5 && c.tag !== 27);
          return c || null;
        }
        function ER(c, h, g, p, w) {
          for (var S = h._reactName, N = []; g !== null && g !== p; ) {
            var O = g, q = O.alternate, ue = O.stateNode;
            if (O = O.tag, q !== null && q === p) break;
            O !== 5 && O !== 26 && O !== 27 || ue === null || (q = ue, w ? (ue = Pg(g, S), ue != null && N.unshift(bm(g, ue, q))) : w || (ue = Pg(g, S), ue != null && N.push(bm(g, ue, q)))), g = g.return;
          }
          N.length !== 0 && c.push({
            event: h,
            listeners: N
          });
        }
        var AW = /\r\n?/g, RW = /\u0000|\uFFFD/g;
        function TR(c) {
          return (typeof c == "string" ? c : "" + c).replace(AW, `
`).replace(RW, "");
        }
        function NR(c, h) {
          return h = TR(h), TR(c) === h;
        }
        function ib() {
        }
        function vi(c, h, g, p, w, S) {
          switch (g) {
            case "children":
              typeof p == "string" ? h === "body" || h === "textarea" && p === "" || dd(c, p) : (typeof p == "number" || typeof p == "bigint") && h !== "body" && dd(c, "" + p);
              break;
            case "className":
              ra(c, "class", p);
              break;
            case "tabIndex":
              ra(c, "tabindex", p);
              break;
            case "dir":
            case "role":
            case "viewBox":
            case "width":
            case "height":
              ra(c, g, p);
              break;
            case "style":
              MI(c, p, S);
              break;
            case "data":
              if (h !== "object") {
                ra(c, "data", p);
                break;
              }
            case "src":
            case "href":
              if (p === "" && (h !== "a" || g !== "href")) {
                c.removeAttribute(g);
                break;
              }
              if (p == null || typeof p == "function" || typeof p == "symbol" || typeof p == "boolean") {
                c.removeAttribute(g);
                break;
              }
              p = u1("" + p), c.setAttribute(g, p);
              break;
            case "action":
            case "formAction":
              if (typeof p == "function") {
                c.setAttribute(g, "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");
                break;
              } else typeof S == "function" && (g === "formAction" ? (h !== "input" && vi(c, h, "name", w.name, w, null), vi(c, h, "formEncType", w.formEncType, w, null), vi(c, h, "formMethod", w.formMethod, w, null), vi(c, h, "formTarget", w.formTarget, w, null)) : (vi(c, h, "encType", w.encType, w, null), vi(c, h, "method", w.method, w, null), vi(c, h, "target", w.target, w, null)));
              if (p == null || typeof p == "symbol" || typeof p == "boolean") {
                c.removeAttribute(g);
                break;
              }
              p = u1("" + p), c.setAttribute(g, p);
              break;
            case "onClick":
              p != null && (c.onclick = ib);
              break;
            case "onScroll":
              p != null && Ht("scroll", c);
              break;
            case "onScrollEnd":
              p != null && Ht("scrollend", c);
              break;
            case "dangerouslySetInnerHTML":
              if (p != null) {
                if (typeof p != "object" || !("__html" in p)) throw Error(i(61));
                if (g = p.__html, g != null) {
                  if (w.children != null) throw Error(i(60));
                  c.innerHTML = g;
                }
              }
              break;
            case "multiple":
              c.multiple = p && typeof p != "function" && typeof p != "symbol";
              break;
            case "muted":
              c.muted = p && typeof p != "function" && typeof p != "symbol";
              break;
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
            case "defaultValue":
            case "defaultChecked":
            case "innerHTML":
            case "ref":
              break;
            case "autoFocus":
              break;
            case "xlinkHref":
              if (p == null || typeof p == "function" || typeof p == "boolean" || typeof p == "symbol") {
                c.removeAttribute("xlink:href");
                break;
              }
              g = u1("" + p), c.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", g);
              break;
            case "contentEditable":
            case "spellCheck":
            case "draggable":
            case "value":
            case "autoReverse":
            case "externalResourcesRequired":
            case "focusable":
            case "preserveAlpha":
              p != null && typeof p != "function" && typeof p != "symbol" ? c.setAttribute(g, "" + p) : c.removeAttribute(g);
              break;
            case "inert":
            case "allowFullScreen":
            case "async":
            case "autoPlay":
            case "controls":
            case "default":
            case "defer":
            case "disabled":
            case "disablePictureInPicture":
            case "disableRemotePlayback":
            case "formNoValidate":
            case "hidden":
            case "loop":
            case "noModule":
            case "noValidate":
            case "open":
            case "playsInline":
            case "readOnly":
            case "required":
            case "reversed":
            case "scoped":
            case "seamless":
            case "itemScope":
              p && typeof p != "function" && typeof p != "symbol" ? c.setAttribute(g, "") : c.removeAttribute(g);
              break;
            case "capture":
            case "download":
              p === true ? c.setAttribute(g, "") : p !== false && p != null && typeof p != "function" && typeof p != "symbol" ? c.setAttribute(g, p) : c.removeAttribute(g);
              break;
            case "cols":
            case "rows":
            case "size":
            case "span":
              p != null && typeof p != "function" && typeof p != "symbol" && !isNaN(p) && 1 <= p ? c.setAttribute(g, p) : c.removeAttribute(g);
              break;
            case "rowSpan":
            case "start":
              p == null || typeof p == "function" || typeof p == "symbol" || isNaN(p) ? c.removeAttribute(g) : c.setAttribute(g, p);
              break;
            case "popover":
              Ht("beforetoggle", c), Ht("toggle", c), Ps(c, "popover", p);
              break;
            case "xlinkActuate":
              Vi(c, "http://www.w3.org/1999/xlink", "xlink:actuate", p);
              break;
            case "xlinkArcrole":
              Vi(c, "http://www.w3.org/1999/xlink", "xlink:arcrole", p);
              break;
            case "xlinkRole":
              Vi(c, "http://www.w3.org/1999/xlink", "xlink:role", p);
              break;
            case "xlinkShow":
              Vi(c, "http://www.w3.org/1999/xlink", "xlink:show", p);
              break;
            case "xlinkTitle":
              Vi(c, "http://www.w3.org/1999/xlink", "xlink:title", p);
              break;
            case "xlinkType":
              Vi(c, "http://www.w3.org/1999/xlink", "xlink:type", p);
              break;
            case "xmlBase":
              Vi(c, "http://www.w3.org/XML/1998/namespace", "xml:base", p);
              break;
            case "xmlLang":
              Vi(c, "http://www.w3.org/XML/1998/namespace", "xml:lang", p);
              break;
            case "xmlSpace":
              Vi(c, "http://www.w3.org/XML/1998/namespace", "xml:space", p);
              break;
            case "is":
              Ps(c, "is", p);
              break;
            case "innerText":
            case "textContent":
              break;
            default:
              (!(2 < g.length) || g[0] !== "o" && g[0] !== "O" || g[1] !== "n" && g[1] !== "N") && (g = uV.get(g) || g, Ps(c, g, p));
          }
        }
        function BS(c, h, g, p, w, S) {
          switch (g) {
            case "style":
              MI(c, p, S);
              break;
            case "dangerouslySetInnerHTML":
              if (p != null) {
                if (typeof p != "object" || !("__html" in p)) throw Error(i(61));
                if (g = p.__html, g != null) {
                  if (w.children != null) throw Error(i(60));
                  c.innerHTML = g;
                }
              }
              break;
            case "children":
              typeof p == "string" ? dd(c, p) : (typeof p == "number" || typeof p == "bigint") && dd(c, "" + p);
              break;
            case "onScroll":
              p != null && Ht("scroll", c);
              break;
            case "onScrollEnd":
              p != null && Ht("scrollend", c);
              break;
            case "onClick":
              p != null && (c.onclick = ib);
              break;
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
            case "innerHTML":
            case "ref":
              break;
            case "innerText":
            case "textContent":
              break;
            default:
              if (!ie.hasOwnProperty(g)) e: {
                if (g[0] === "o" && g[1] === "n" && (w = g.endsWith("Capture"), h = g.slice(2, w ? g.length - 7 : void 0), S = c[Z] || null, S = S != null ? S[g] : null, typeof S == "function" && c.removeEventListener(h, S, w), typeof p == "function")) {
                  typeof S != "function" && S !== null && (g in c ? c[g] = null : c.hasAttribute(g) && c.removeAttribute(g)), c.addEventListener(h, p, w);
                  break e;
                }
                g in c ? c[g] = p : p === true ? c.setAttribute(g, "") : Ps(c, g, p);
              }
          }
        }
        function ls(c, h, g) {
          switch (h) {
            case "div":
            case "span":
            case "svg":
            case "path":
            case "a":
            case "g":
            case "p":
            case "li":
              break;
            case "img":
              Ht("error", c), Ht("load", c);
              var p = false, w = false, S;
              for (S in g) if (g.hasOwnProperty(S)) {
                var N = g[S];
                if (N != null) switch (S) {
                  case "src":
                    p = true;
                    break;
                  case "srcSet":
                    w = true;
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw Error(i(137, h));
                  default:
                    vi(c, h, S, N, g, null);
                }
              }
              w && vi(c, h, "srcSet", g.srcSet, g, null), p && vi(c, h, "src", g.src, g, null);
              return;
            case "input":
              Ht("invalid", c);
              var O = S = N = w = null, q = null, ue = null;
              for (p in g) if (g.hasOwnProperty(p)) {
                var ve = g[p];
                if (ve != null) switch (p) {
                  case "name":
                    w = ve;
                    break;
                  case "type":
                    N = ve;
                    break;
                  case "checked":
                    q = ve;
                    break;
                  case "defaultChecked":
                    ue = ve;
                    break;
                  case "value":
                    S = ve;
                    break;
                  case "defaultValue":
                    O = ve;
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    if (ve != null) throw Error(i(137, h));
                    break;
                  default:
                    vi(c, h, p, ve, g, null);
                }
              }
              EI(c, S, O, q, ue, N, w, false), l1(c);
              return;
            case "select":
              Ht("invalid", c), p = N = S = null;
              for (w in g) if (g.hasOwnProperty(w) && (O = g[w], O != null)) switch (w) {
                case "value":
                  S = O;
                  break;
                case "defaultValue":
                  N = O;
                  break;
                case "multiple":
                  p = O;
                default:
                  vi(c, h, w, O, g, null);
              }
              h = S, g = N, c.multiple = !!p, h != null ? hd(c, !!p, h, false) : g != null && hd(c, !!p, g, true);
              return;
            case "textarea":
              Ht("invalid", c), S = w = p = null;
              for (N in g) if (g.hasOwnProperty(N) && (O = g[N], O != null)) switch (N) {
                case "value":
                  p = O;
                  break;
                case "defaultValue":
                  w = O;
                  break;
                case "children":
                  S = O;
                  break;
                case "dangerouslySetInnerHTML":
                  if (O != null) throw Error(i(91));
                  break;
                default:
                  vi(c, h, N, O, g, null);
              }
              NI(c, p, w, S), l1(c);
              return;
            case "option":
              for (q in g) if (g.hasOwnProperty(q) && (p = g[q], p != null)) switch (q) {
                case "selected":
                  c.selected = p && typeof p != "function" && typeof p != "symbol";
                  break;
                default:
                  vi(c, h, q, p, g, null);
              }
              return;
            case "dialog":
              Ht("beforetoggle", c), Ht("toggle", c), Ht("cancel", c), Ht("close", c);
              break;
            case "iframe":
            case "object":
              Ht("load", c);
              break;
            case "video":
            case "audio":
              for (p = 0; p < _m2.length; p++) Ht(_m2[p], c);
              break;
            case "image":
              Ht("error", c), Ht("load", c);
              break;
            case "details":
              Ht("toggle", c);
              break;
            case "embed":
            case "source":
            case "link":
              Ht("error", c), Ht("load", c);
            case "area":
            case "base":
            case "br":
            case "col":
            case "hr":
            case "keygen":
            case "meta":
            case "param":
            case "track":
            case "wbr":
            case "menuitem":
              for (ue in g) if (g.hasOwnProperty(ue) && (p = g[ue], p != null)) switch (ue) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(i(137, h));
                default:
                  vi(c, h, ue, p, g, null);
              }
              return;
            default:
              if (Jw(h)) {
                for (ve in g) g.hasOwnProperty(ve) && (p = g[ve], p !== void 0 && BS(c, h, ve, p, g, void 0));
                return;
              }
          }
          for (O in g) g.hasOwnProperty(O) && (p = g[O], p != null && vi(c, h, O, p, g, null));
        }
        function OW(c, h, g, p) {
          switch (h) {
            case "div":
            case "span":
            case "svg":
            case "path":
            case "a":
            case "g":
            case "p":
            case "li":
              break;
            case "input":
              var w = null, S = null, N = null, O = null, q = null, ue = null, ve = null;
              for (pe in g) {
                var Le = g[pe];
                if (g.hasOwnProperty(pe) && Le != null) switch (pe) {
                  case "checked":
                    break;
                  case "value":
                    break;
                  case "defaultValue":
                    q = Le;
                  default:
                    p.hasOwnProperty(pe) || vi(c, h, pe, null, p, Le);
                }
              }
              for (var ge in p) {
                var pe = p[ge];
                if (Le = g[ge], p.hasOwnProperty(ge) && (pe != null || Le != null)) switch (ge) {
                  case "type":
                    S = pe;
                    break;
                  case "name":
                    w = pe;
                    break;
                  case "checked":
                    ue = pe;
                    break;
                  case "defaultChecked":
                    ve = pe;
                    break;
                  case "value":
                    N = pe;
                    break;
                  case "defaultValue":
                    O = pe;
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    if (pe != null) throw Error(i(137, h));
                    break;
                  default:
                    pe !== Le && vi(c, h, ge, pe, p, Le);
                }
              }
              Qw(c, N, O, q, ue, ve, S, w);
              return;
            case "select":
              pe = N = O = ge = null;
              for (S in g) if (q = g[S], g.hasOwnProperty(S) && q != null) switch (S) {
                case "value":
                  break;
                case "multiple":
                  pe = q;
                default:
                  p.hasOwnProperty(S) || vi(c, h, S, null, p, q);
              }
              for (w in p) if (S = p[w], q = g[w], p.hasOwnProperty(w) && (S != null || q != null)) switch (w) {
                case "value":
                  ge = S;
                  break;
                case "defaultValue":
                  O = S;
                  break;
                case "multiple":
                  N = S;
                default:
                  S !== q && vi(c, h, w, S, p, q);
              }
              h = O, g = N, p = pe, ge != null ? hd(c, !!g, ge, false) : !!p != !!g && (h != null ? hd(c, !!g, h, true) : hd(c, !!g, g ? [] : "", false));
              return;
            case "textarea":
              pe = ge = null;
              for (O in g) if (w = g[O], g.hasOwnProperty(O) && w != null && !p.hasOwnProperty(O)) switch (O) {
                case "value":
                  break;
                case "children":
                  break;
                default:
                  vi(c, h, O, null, p, w);
              }
              for (N in p) if (w = p[N], S = g[N], p.hasOwnProperty(N) && (w != null || S != null)) switch (N) {
                case "value":
                  ge = w;
                  break;
                case "defaultValue":
                  pe = w;
                  break;
                case "children":
                  break;
                case "dangerouslySetInnerHTML":
                  if (w != null) throw Error(i(91));
                  break;
                default:
                  w !== S && vi(c, h, N, w, p, S);
              }
              TI(c, ge, pe);
              return;
            case "option":
              for (var gt in g) if (ge = g[gt], g.hasOwnProperty(gt) && ge != null && !p.hasOwnProperty(gt)) switch (gt) {
                case "selected":
                  c.selected = false;
                  break;
                default:
                  vi(c, h, gt, null, p, ge);
              }
              for (q in p) if (ge = p[q], pe = g[q], p.hasOwnProperty(q) && ge !== pe && (ge != null || pe != null)) switch (q) {
                case "selected":
                  c.selected = ge && typeof ge != "function" && typeof ge != "symbol";
                  break;
                default:
                  vi(c, h, q, ge, p, pe);
              }
              return;
            case "img":
            case "link":
            case "area":
            case "base":
            case "br":
            case "col":
            case "embed":
            case "hr":
            case "keygen":
            case "meta":
            case "param":
            case "source":
            case "track":
            case "wbr":
            case "menuitem":
              for (var at in g) ge = g[at], g.hasOwnProperty(at) && ge != null && !p.hasOwnProperty(at) && vi(c, h, at, null, p, ge);
              for (ue in p) if (ge = p[ue], pe = g[ue], p.hasOwnProperty(ue) && ge !== pe && (ge != null || pe != null)) switch (ue) {
                case "children":
                case "dangerouslySetInnerHTML":
                  if (ge != null) throw Error(i(137, h));
                  break;
                default:
                  vi(c, h, ue, ge, p, pe);
              }
              return;
            default:
              if (Jw(h)) {
                for (var Ci in g) ge = g[Ci], g.hasOwnProperty(Ci) && ge !== void 0 && !p.hasOwnProperty(Ci) && BS(c, h, Ci, void 0, p, ge);
                for (ve in p) ge = p[ve], pe = g[ve], !p.hasOwnProperty(ve) || ge === pe || ge === void 0 && pe === void 0 || BS(c, h, ve, ge, p, pe);
                return;
              }
          }
          for (var oe in g) ge = g[oe], g.hasOwnProperty(oe) && ge != null && !p.hasOwnProperty(oe) && vi(c, h, oe, null, p, ge);
          for (Le in p) ge = p[Le], pe = g[Le], !p.hasOwnProperty(Le) || ge === pe || ge == null && pe == null || vi(c, h, Le, ge, p, pe);
        }
        var FS = null, VS = null;
        function nb(c) {
          return c.nodeType === 9 ? c : c.ownerDocument;
        }
        function IR(c) {
          switch (c) {
            case "http://www.w3.org/2000/svg":
              return 1;
            case "http://www.w3.org/1998/Math/MathML":
              return 2;
            default:
              return 0;
          }
        }
        function MR(c, h) {
          if (c === 0) switch (h) {
            case "svg":
              return 1;
            case "math":
              return 2;
            default:
              return 0;
          }
          return c === 1 && h === "foreignObject" ? 0 : c;
        }
        function WS(c, h) {
          return c === "textarea" || c === "noscript" || typeof h.children == "string" || typeof h.children == "number" || typeof h.children == "bigint" || typeof h.dangerouslySetInnerHTML == "object" && h.dangerouslySetInnerHTML !== null && h.dangerouslySetInnerHTML.__html != null;
        }
        var HS = null;
        function PW() {
          var c = window.event;
          return c && c.type === "popstate" ? c === HS ? false : (HS = c, true) : (HS = null, false);
        }
        var AR = typeof setTimeout == "function" ? setTimeout : void 0, BW = typeof clearTimeout == "function" ? clearTimeout : void 0, RR = typeof Promise == "function" ? Promise : void 0, FW = typeof queueMicrotask == "function" ? queueMicrotask : typeof RR < "u" ? function(c) {
          return RR.resolve(null).then(c).catch(VW);
        } : AR;
        function VW(c) {
          setTimeout(function() {
            throw c;
          });
        }
        function mc(c) {
          return c === "head";
        }
        function OR(c, h) {
          var g = h, p = 0, w = 0;
          do {
            var S = g.nextSibling;
            if (c.removeChild(g), S && S.nodeType === 8) if (g = S.data, g === "/$") {
              if (0 < p && 8 > p) {
                g = p;
                var N = c.ownerDocument;
                if (g & 1 && vm(N.documentElement), g & 2 && vm(N.body), g & 4) for (g = N.head, vm(g), N = g.firstChild; N; ) {
                  var O = N.nextSibling, q = N.nodeName;
                  N[xt] || q === "SCRIPT" || q === "STYLE" || q === "LINK" && N.rel.toLowerCase() === "stylesheet" || g.removeChild(N), N = O;
                }
              }
              if (w === 0) {
                c.removeChild(S), Dm(h);
                return;
              }
              w--;
            } else g === "$" || g === "$?" || g === "$!" ? w++ : p = g.charCodeAt(0) - 48;
            else p = 0;
            g = S;
          } while (g);
          Dm(h);
        }
        function zS(c) {
          var h = c.firstChild;
          for (h && h.nodeType === 10 && (h = h.nextSibling); h; ) {
            var g = h;
            switch (h = h.nextSibling, g.nodeName) {
              case "HTML":
              case "HEAD":
              case "BODY":
                zS(g), At(g);
                continue;
              case "SCRIPT":
              case "STYLE":
                continue;
              case "LINK":
                if (g.rel.toLowerCase() === "stylesheet") continue;
            }
            c.removeChild(g);
          }
        }
        function WW(c, h, g, p) {
          for (; c.nodeType === 1; ) {
            var w = g;
            if (c.nodeName.toLowerCase() !== h.toLowerCase()) {
              if (!p && (c.nodeName !== "INPUT" || c.type !== "hidden")) break;
            } else if (p) {
              if (!c[xt]) switch (h) {
                case "meta":
                  if (!c.hasAttribute("itemprop")) break;
                  return c;
                case "link":
                  if (S = c.getAttribute("rel"), S === "stylesheet" && c.hasAttribute("data-precedence")) break;
                  if (S !== w.rel || c.getAttribute("href") !== (w.href == null || w.href === "" ? null : w.href) || c.getAttribute("crossorigin") !== (w.crossOrigin == null ? null : w.crossOrigin) || c.getAttribute("title") !== (w.title == null ? null : w.title)) break;
                  return c;
                case "style":
                  if (c.hasAttribute("data-precedence")) break;
                  return c;
                case "script":
                  if (S = c.getAttribute("src"), (S !== (w.src == null ? null : w.src) || c.getAttribute("type") !== (w.type == null ? null : w.type) || c.getAttribute("crossorigin") !== (w.crossOrigin == null ? null : w.crossOrigin)) && S && c.hasAttribute("async") && !c.hasAttribute("itemprop")) break;
                  return c;
                default:
                  return c;
              }
            } else if (h === "input" && c.type === "hidden") {
              var S = w.name == null ? null : "" + w.name;
              if (w.type === "hidden" && c.getAttribute("name") === S) return c;
            } else return c;
            if (c = kr(c.nextSibling), c === null) break;
          }
          return null;
        }
        function HW(c, h, g) {
          if (h === "") return null;
          for (; c.nodeType !== 3; ) if ((c.nodeType !== 1 || c.nodeName !== "INPUT" || c.type !== "hidden") && !g || (c = kr(c.nextSibling), c === null)) return null;
          return c;
        }
        function US(c) {
          return c.data === "$!" || c.data === "$?" && c.ownerDocument.readyState === "complete";
        }
        function zW(c, h) {
          var g = c.ownerDocument;
          if (c.data !== "$?" || g.readyState === "complete") h();
          else {
            var p = function() {
              h(), g.removeEventListener("DOMContentLoaded", p);
            };
            g.addEventListener("DOMContentLoaded", p), c._reactRetry = p;
          }
        }
        function kr(c) {
          for (; c != null; c = c.nextSibling) {
            var h = c.nodeType;
            if (h === 1 || h === 3) break;
            if (h === 8) {
              if (h = c.data, h === "$" || h === "$!" || h === "$?" || h === "F!" || h === "F") break;
              if (h === "/$") return null;
            }
          }
          return c;
        }
        var $S = null;
        function PR(c) {
          c = c.previousSibling;
          for (var h = 0; c; ) {
            if (c.nodeType === 8) {
              var g = c.data;
              if (g === "$" || g === "$!" || g === "$?") {
                if (h === 0) return c;
                h--;
              } else g === "/$" && h++;
            }
            c = c.previousSibling;
          }
          return null;
        }
        function BR(c, h, g) {
          switch (h = nb(g), c) {
            case "html":
              if (c = h.documentElement, !c) throw Error(i(452));
              return c;
            case "head":
              if (c = h.head, !c) throw Error(i(453));
              return c;
            case "body":
              if (c = h.body, !c) throw Error(i(454));
              return c;
            default:
              throw Error(i(451));
          }
        }
        function vm(c) {
          for (var h = c.attributes; h.length; ) c.removeAttributeNode(h[0]);
          At(c);
        }
        var nr = /* @__PURE__ */ new Map(), FR = /* @__PURE__ */ new Set();
        function sb(c) {
          return typeof c.getRootNode == "function" ? c.getRootNode() : c.nodeType === 9 ? c : c.ownerDocument;
        }
        var rl = se.d;
        se.d = {
          f: UW,
          r: $W,
          D: qW,
          C: KW,
          L: jW,
          m: GW,
          X: ZW,
          S: YW,
          M: QW
        };
        function UW() {
          var c = rl.f(), h = Y1();
          return c || h;
        }
        function $W(c) {
          var h = Gt(c);
          h !== null && h.tag === 5 && h.type === "form" ? sA(h) : rl.r(c);
        }
        var Hd = typeof document > "u" ? null : document;
        function VR(c, h, g) {
          var p = Hd;
          if (p && typeof h == "string" && h) {
            var w = Zo(h);
            w = 'link[rel="' + c + '"][href="' + w + '"]', typeof g == "string" && (w += '[crossorigin="' + g + '"]'), FR.has(w) || (FR.add(w), c = {
              rel: c,
              crossOrigin: g,
              href: h
            }, p.querySelector(w) === null && (h = p.createElement("link"), ls(h, "link", c), Hi(h), p.head.appendChild(h)));
          }
        }
        function qW(c) {
          rl.D(c), VR("dns-prefetch", c, null);
        }
        function KW(c, h) {
          rl.C(c, h), VR("preconnect", c, h);
        }
        function jW(c, h, g) {
          rl.L(c, h, g);
          var p = Hd;
          if (p && c && h) {
            var w = 'link[rel="preload"][as="' + Zo(h) + '"]';
            h === "image" && g && g.imageSrcSet ? (w += '[imagesrcset="' + Zo(g.imageSrcSet) + '"]', typeof g.imageSizes == "string" && (w += '[imagesizes="' + Zo(g.imageSizes) + '"]')) : w += '[href="' + Zo(c) + '"]';
            var S = w;
            switch (h) {
              case "style":
                S = zd(c);
                break;
              case "script":
                S = Ud(c);
            }
            nr.has(S) || (c = d({
              rel: "preload",
              href: h === "image" && g && g.imageSrcSet ? void 0 : c,
              as: h
            }, g), nr.set(S, c), p.querySelector(w) !== null || h === "style" && p.querySelector(Cm(S)) || h === "script" && p.querySelector(wm(S)) || (h = p.createElement("link"), ls(h, "link", c), Hi(h), p.head.appendChild(h)));
          }
        }
        function GW(c, h) {
          rl.m(c, h);
          var g = Hd;
          if (g && c) {
            var p = h && typeof h.as == "string" ? h.as : "script", w = 'link[rel="modulepreload"][as="' + Zo(p) + '"][href="' + Zo(c) + '"]', S = w;
            switch (p) {
              case "audioworklet":
              case "paintworklet":
              case "serviceworker":
              case "sharedworker":
              case "worker":
              case "script":
                S = Ud(c);
            }
            if (!nr.has(S) && (c = d({
              rel: "modulepreload",
              href: c
            }, h), nr.set(S, c), g.querySelector(w) === null)) {
              switch (p) {
                case "audioworklet":
                case "paintworklet":
                case "serviceworker":
                case "sharedworker":
                case "worker":
                case "script":
                  if (g.querySelector(wm(S))) return;
              }
              p = g.createElement("link"), ls(p, "link", c), Hi(p), g.head.appendChild(p);
            }
          }
        }
        function YW(c, h, g) {
          rl.S(c, h, g);
          var p = Hd;
          if (p && c) {
            var w = xn(p).hoistableStyles, S = zd(c);
            h = h || "default";
            var N = w.get(S);
            if (!N) {
              var O = {
                loading: 0,
                preload: null
              };
              if (N = p.querySelector(Cm(S))) O.loading = 5;
              else {
                c = d({
                  rel: "stylesheet",
                  href: c,
                  "data-precedence": h
                }, g), (g = nr.get(S)) && qS(c, g);
                var q = N = p.createElement("link");
                Hi(q), ls(q, "link", c), q._p = new Promise(function(ue, ve) {
                  q.onload = ue, q.onerror = ve;
                }), q.addEventListener("load", function() {
                  O.loading |= 1;
                }), q.addEventListener("error", function() {
                  O.loading |= 2;
                }), O.loading |= 4, ob(N, h, p);
              }
              N = {
                type: "stylesheet",
                instance: N,
                count: 1,
                state: O
              }, w.set(S, N);
            }
          }
        }
        function ZW(c, h) {
          rl.X(c, h);
          var g = Hd;
          if (g && c) {
            var p = xn(g).hoistableScripts, w = Ud(c), S = p.get(w);
            S || (S = g.querySelector(wm(w)), S || (c = d({
              src: c,
              async: true
            }, h), (h = nr.get(w)) && KS(c, h), S = g.createElement("script"), Hi(S), ls(S, "link", c), g.head.appendChild(S)), S = {
              type: "script",
              instance: S,
              count: 1,
              state: null
            }, p.set(w, S));
          }
        }
        function QW(c, h) {
          rl.M(c, h);
          var g = Hd;
          if (g && c) {
            var p = xn(g).hoistableScripts, w = Ud(c), S = p.get(w);
            S || (S = g.querySelector(wm(w)), S || (c = d({
              src: c,
              async: true,
              type: "module"
            }, h), (h = nr.get(w)) && KS(c, h), S = g.createElement("script"), Hi(S), ls(S, "link", c), g.head.appendChild(S)), S = {
              type: "script",
              instance: S,
              count: 1,
              state: null
            }, p.set(w, S));
          }
        }
        function WR(c, h, g, p) {
          var w = (w = We.current) ? sb(w) : null;
          if (!w) throw Error(i(446));
          switch (c) {
            case "meta":
            case "title":
              return null;
            case "style":
              return typeof g.precedence == "string" && typeof g.href == "string" ? (h = zd(g.href), g = xn(w).hoistableStyles, p = g.get(h), p || (p = {
                type: "style",
                instance: null,
                count: 0,
                state: null
              }, g.set(h, p)), p) : {
                type: "void",
                instance: null,
                count: 0,
                state: null
              };
            case "link":
              if (g.rel === "stylesheet" && typeof g.href == "string" && typeof g.precedence == "string") {
                c = zd(g.href);
                var S = xn(w).hoistableStyles, N = S.get(c);
                if (N || (w = w.ownerDocument || w, N = {
                  type: "stylesheet",
                  instance: null,
                  count: 0,
                  state: {
                    loading: 0,
                    preload: null
                  }
                }, S.set(c, N), (S = w.querySelector(Cm(c))) && !S._p && (N.instance = S, N.state.loading = 5), nr.has(c) || (g = {
                  rel: "preload",
                  as: "style",
                  href: g.href,
                  crossOrigin: g.crossOrigin,
                  integrity: g.integrity,
                  media: g.media,
                  hrefLang: g.hrefLang,
                  referrerPolicy: g.referrerPolicy
                }, nr.set(c, g), S || XW(w, c, g, N.state))), h && p === null) throw Error(i(528, ""));
                return N;
              }
              if (h && p !== null) throw Error(i(529, ""));
              return null;
            case "script":
              return h = g.async, g = g.src, typeof g == "string" && h && typeof h != "function" && typeof h != "symbol" ? (h = Ud(g), g = xn(w).hoistableScripts, p = g.get(h), p || (p = {
                type: "script",
                instance: null,
                count: 0,
                state: null
              }, g.set(h, p)), p) : {
                type: "void",
                instance: null,
                count: 0,
                state: null
              };
            default:
              throw Error(i(444, c));
          }
        }
        function zd(c) {
          return 'href="' + Zo(c) + '"';
        }
        function Cm(c) {
          return 'link[rel="stylesheet"][' + c + "]";
        }
        function HR(c) {
          return d({}, c, {
            "data-precedence": c.precedence,
            precedence: null
          });
        }
        function XW(c, h, g, p) {
          c.querySelector('link[rel="preload"][as="style"][' + h + "]") ? p.loading = 1 : (h = c.createElement("link"), p.preload = h, h.addEventListener("load", function() {
            return p.loading |= 1;
          }), h.addEventListener("error", function() {
            return p.loading |= 2;
          }), ls(h, "link", g), Hi(h), c.head.appendChild(h));
        }
        function Ud(c) {
          return '[src="' + Zo(c) + '"]';
        }
        function wm(c) {
          return "script[async]" + c;
        }
        function zR(c, h, g) {
          if (h.count++, h.instance === null) switch (h.type) {
            case "style":
              var p = c.querySelector('style[data-href~="' + Zo(g.href) + '"]');
              if (p) return h.instance = p, Hi(p), p;
              var w = d({}, g, {
                "data-href": g.href,
                "data-precedence": g.precedence,
                href: null,
                precedence: null
              });
              return p = (c.ownerDocument || c).createElement("style"), Hi(p), ls(p, "style", w), ob(p, g.precedence, c), h.instance = p;
            case "stylesheet":
              w = zd(g.href);
              var S = c.querySelector(Cm(w));
              if (S) return h.state.loading |= 4, h.instance = S, Hi(S), S;
              p = HR(g), (w = nr.get(w)) && qS(p, w), S = (c.ownerDocument || c).createElement("link"), Hi(S);
              var N = S;
              return N._p = new Promise(function(O, q) {
                N.onload = O, N.onerror = q;
              }), ls(S, "link", p), h.state.loading |= 4, ob(S, g.precedence, c), h.instance = S;
            case "script":
              return S = Ud(g.src), (w = c.querySelector(wm(S))) ? (h.instance = w, Hi(w), w) : (p = g, (w = nr.get(S)) && (p = d({}, g), KS(p, w)), c = c.ownerDocument || c, w = c.createElement("script"), Hi(w), ls(w, "link", p), c.head.appendChild(w), h.instance = w);
            case "void":
              return null;
            default:
              throw Error(i(443, h.type));
          }
          else h.type === "stylesheet" && (h.state.loading & 4) === 0 && (p = h.instance, h.state.loading |= 4, ob(p, g.precedence, c));
          return h.instance;
        }
        function ob(c, h, g) {
          for (var p = g.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'), w = p.length ? p[p.length - 1] : null, S = w, N = 0; N < p.length; N++) {
            var O = p[N];
            if (O.dataset.precedence === h) S = O;
            else if (S !== w) break;
          }
          S ? S.parentNode.insertBefore(c, S.nextSibling) : (h = g.nodeType === 9 ? g.head : g, h.insertBefore(c, h.firstChild));
        }
        function qS(c, h) {
          c.crossOrigin == null && (c.crossOrigin = h.crossOrigin), c.referrerPolicy == null && (c.referrerPolicy = h.referrerPolicy), c.title == null && (c.title = h.title);
        }
        function KS(c, h) {
          c.crossOrigin == null && (c.crossOrigin = h.crossOrigin), c.referrerPolicy == null && (c.referrerPolicy = h.referrerPolicy), c.integrity == null && (c.integrity = h.integrity);
        }
        var rb = null;
        function UR(c, h, g) {
          if (rb === null) {
            var p = /* @__PURE__ */ new Map(), w = rb = /* @__PURE__ */ new Map();
            w.set(g, p);
          } else w = rb, p = w.get(g), p || (p = /* @__PURE__ */ new Map(), w.set(g, p));
          if (p.has(c)) return p;
          for (p.set(c, null), g = g.getElementsByTagName(c), w = 0; w < g.length; w++) {
            var S = g[w];
            if (!(S[xt] || S[$] || c === "link" && S.getAttribute("rel") === "stylesheet") && S.namespaceURI !== "http://www.w3.org/2000/svg") {
              var N = S.getAttribute(h) || "";
              N = c + N;
              var O = p.get(N);
              O ? O.push(S) : p.set(N, [
                S
              ]);
            }
          }
          return p;
        }
        function $R(c, h, g) {
          c = c.ownerDocument || c, c.head.insertBefore(g, h === "title" ? c.querySelector("head > title") : null);
        }
        function JW(c, h, g) {
          if (g === 1 || h.itemProp != null) return false;
          switch (c) {
            case "meta":
            case "title":
              return true;
            case "style":
              if (typeof h.precedence != "string" || typeof h.href != "string" || h.href === "") break;
              return true;
            case "link":
              if (typeof h.rel != "string" || typeof h.href != "string" || h.href === "" || h.onLoad || h.onError) break;
              switch (h.rel) {
                case "stylesheet":
                  return c = h.disabled, typeof h.precedence == "string" && c == null;
                default:
                  return true;
              }
            case "script":
              if (h.async && typeof h.async != "function" && typeof h.async != "symbol" && !h.onLoad && !h.onError && h.src && typeof h.src == "string") return true;
          }
          return false;
        }
        function qR(c) {
          return !(c.type === "stylesheet" && (c.state.loading & 3) === 0);
        }
        var ym = null;
        function eH() {
        }
        function tH(c, h, g) {
          if (ym === null) throw Error(i(475));
          var p = ym;
          if (h.type === "stylesheet" && (typeof g.media != "string" || matchMedia(g.media).matches !== false) && (h.state.loading & 4) === 0) {
            if (h.instance === null) {
              var w = zd(g.href), S = c.querySelector(Cm(w));
              if (S) {
                c = S._p, c !== null && typeof c == "object" && typeof c.then == "function" && (p.count++, p = ab.bind(p), c.then(p, p)), h.state.loading |= 4, h.instance = S, Hi(S);
                return;
              }
              S = c.ownerDocument || c, g = HR(g), (w = nr.get(w)) && qS(g, w), S = S.createElement("link"), Hi(S);
              var N = S;
              N._p = new Promise(function(O, q) {
                N.onload = O, N.onerror = q;
              }), ls(S, "link", g), h.instance = S;
            }
            p.stylesheets === null && (p.stylesheets = /* @__PURE__ */ new Map()), p.stylesheets.set(h, c), (c = h.state.preload) && (h.state.loading & 3) === 0 && (p.count++, h = ab.bind(p), c.addEventListener("load", h), c.addEventListener("error", h));
          }
        }
        function iH() {
          if (ym === null) throw Error(i(475));
          var c = ym;
          return c.stylesheets && c.count === 0 && jS(c, c.stylesheets), 0 < c.count ? function(h) {
            var g = setTimeout(function() {
              if (c.stylesheets && jS(c, c.stylesheets), c.unsuspend) {
                var p = c.unsuspend;
                c.unsuspend = null, p();
              }
            }, 6e4);
            return c.unsuspend = h, function() {
              c.unsuspend = null, clearTimeout(g);
            };
          } : null;
        }
        function ab() {
          if (this.count--, this.count === 0) {
            if (this.stylesheets) jS(this, this.stylesheets);
            else if (this.unsuspend) {
              var c = this.unsuspend;
              this.unsuspend = null, c();
            }
          }
        }
        var lb = null;
        function jS(c, h) {
          c.stylesheets = null, c.unsuspend !== null && (c.count++, lb = /* @__PURE__ */ new Map(), h.forEach(nH, c), lb = null, ab.call(c));
        }
        function nH(c, h) {
          if (!(h.state.loading & 4)) {
            var g = lb.get(c);
            if (g) var p = g.get(null);
            else {
              g = /* @__PURE__ */ new Map(), lb.set(c, g);
              for (var w = c.querySelectorAll("link[data-precedence],style[data-precedence]"), S = 0; S < w.length; S++) {
                var N = w[S];
                (N.nodeName === "LINK" || N.getAttribute("media") !== "not all") && (g.set(N.dataset.precedence, N), p = N);
              }
              p && g.set(null, p);
            }
            w = h.instance, N = w.getAttribute("data-precedence"), S = g.get(N) || p, S === p && g.set(null, w), g.set(N, w), this.count++, p = ab.bind(this), w.addEventListener("load", p), w.addEventListener("error", p), S ? S.parentNode.insertBefore(w, S.nextSibling) : (c = c.nodeType === 9 ? c.head : c, c.insertBefore(w, c.firstChild)), h.state.loading |= 4;
          }
        }
        var Sm = {
          $$typeof: D,
          Provider: null,
          Consumer: null,
          _currentValue: de,
          _currentValue2: de,
          _threadCount: 0
        };
        function sH(c, h, g, p, w, S, N, O) {
          this.tag = 1, this.containerInfo = c, this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = bu(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = bu(0), this.hiddenUpdates = bu(null), this.identifierPrefix = p, this.onUncaughtError = w, this.onCaughtError = S, this.onRecoverableError = N, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = O, this.incompleteTransitions = /* @__PURE__ */ new Map();
        }
        function KR(c, h, g, p, w, S, N, O, q, ue, ve, Le) {
          return c = new sH(c, h, g, N, O, q, ue, Le), h = 1, S === true && (h |= 24), S = Co(3, null, null, h), c.current = S, S.stateNode = c, h = Ey(), h.refCount++, c.pooledCache = h, h.refCount++, S.memoizedState = {
            element: p,
            isDehydrated: g,
            cache: h
          }, My(S), c;
        }
        function jR(c) {
          return c ? (c = Cd, c) : Cd;
        }
        function GR(c, h, g, p, w, S) {
          w = jR(w), p.context === null ? p.context = w : p.pendingContext = w, p = ic(h), p.payload = {
            element: g
          }, S = S === void 0 ? null : S, S !== null && (p.callback = S), g = nc(c, p, h), g !== null && (xo(g, c, h), Jg(g, c, h));
        }
        function YR(c, h) {
          if (c = c.memoizedState, c !== null && c.dehydrated !== null) {
            var g = c.retryLane;
            c.retryLane = g !== 0 && g < h ? g : h;
          }
        }
        function GS(c, h) {
          YR(c, h), (c = c.alternate) && YR(c, h);
        }
        function ZR(c) {
          if (c.tag === 13) {
            var h = vd(c, 67108864);
            h !== null && xo(h, c, 67108864), GS(c, 67108864);
          }
        }
        var cb = true;
        function oH(c, h, g, p) {
          var w = H.T;
          H.T = null;
          var S = se.p;
          try {
            se.p = 2, YS(c, h, g, p);
          } finally {
            se.p = S, H.T = w;
          }
        }
        function rH(c, h, g, p) {
          var w = H.T;
          H.T = null;
          var S = se.p;
          try {
            se.p = 8, YS(c, h, g, p);
          } finally {
            se.p = S, H.T = w;
          }
        }
        function YS(c, h, g, p) {
          if (cb) {
            var w = ZS(p);
            if (w === null) PS(c, h, p, ub, g), XR(c, p);
            else if (lH(w, c, h, g, p)) p.stopPropagation();
            else if (XR(c, p), h & 4 && -1 < aH.indexOf(c)) {
              for (; w !== null; ) {
                var S = Gt(w);
                if (S !== null) switch (S.tag) {
                  case 3:
                    if (S = S.stateNode, S.current.memoizedState.isDehydrated) {
                      var N = Ln(S.pendingLanes);
                      if (N !== 0) {
                        var O = S;
                        for (O.pendingLanes |= 2, O.entangledLanes |= 2; N; ) {
                          var q = 1 << 31 - dn(N);
                          O.entanglements[1] |= q, N &= ~q;
                        }
                        ha(S), (gi & 6) === 0 && (j1 = Bn() + 500, pm(0));
                      }
                    }
                    break;
                  case 13:
                    O = vd(S, 2), O !== null && xo(O, S, 2), Y1(), GS(S, 2);
                }
                if (S = ZS(p), S === null && PS(c, h, p, ub, g), S === w) break;
                w = S;
              }
              w !== null && p.stopPropagation();
            } else PS(c, h, p, null, g);
          }
        }
        function ZS(c) {
          return c = ty(c), QS(c);
        }
        var ub = null;
        function QS(c) {
          if (ub = null, c = fi(c), c !== null) {
            var h = o(c);
            if (h === null) c = null;
            else {
              var g = h.tag;
              if (g === 13) {
                if (c = r(h), c !== null) return c;
                c = null;
              } else if (g === 3) {
                if (h.stateNode.current.memoizedState.isDehydrated) return h.tag === 3 ? h.stateNode.containerInfo : null;
                c = null;
              } else h !== c && (c = null);
            }
          }
          return ub = c, null;
        }
        function QR(c) {
          switch (c) {
            case "beforetoggle":
            case "cancel":
            case "click":
            case "close":
            case "contextmenu":
            case "copy":
            case "cut":
            case "auxclick":
            case "dblclick":
            case "dragend":
            case "dragstart":
            case "drop":
            case "focusin":
            case "focusout":
            case "input":
            case "invalid":
            case "keydown":
            case "keypress":
            case "keyup":
            case "mousedown":
            case "mouseup":
            case "paste":
            case "pause":
            case "play":
            case "pointercancel":
            case "pointerdown":
            case "pointerup":
            case "ratechange":
            case "reset":
            case "resize":
            case "seeked":
            case "submit":
            case "toggle":
            case "touchcancel":
            case "touchend":
            case "touchstart":
            case "volumechange":
            case "change":
            case "selectionchange":
            case "textInput":
            case "compositionstart":
            case "compositionend":
            case "compositionupdate":
            case "beforeblur":
            case "afterblur":
            case "beforeinput":
            case "blur":
            case "fullscreenchange":
            case "focus":
            case "hashchange":
            case "popstate":
            case "select":
            case "selectstart":
              return 2;
            case "drag":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "mousemove":
            case "mouseout":
            case "mouseover":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "scroll":
            case "touchmove":
            case "wheel":
            case "mouseenter":
            case "mouseleave":
            case "pointerenter":
            case "pointerleave":
              return 8;
            case "message":
              switch (Xl()) {
                case za:
                  return 2;
                case na:
                  return 8;
                case Ua:
                case rd:
                  return 32;
                case $a:
                  return 268435456;
                default:
                  return 32;
              }
            default:
              return 32;
          }
        }
        var XS = false, pc = null, _c2 = null, bc = null, Lm = /* @__PURE__ */ new Map(), xm = /* @__PURE__ */ new Map(), vc = [], aH = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");
        function XR(c, h) {
          switch (c) {
            case "focusin":
            case "focusout":
              pc = null;
              break;
            case "dragenter":
            case "dragleave":
              _c2 = null;
              break;
            case "mouseover":
            case "mouseout":
              bc = null;
              break;
            case "pointerover":
            case "pointerout":
              Lm.delete(h.pointerId);
              break;
            case "gotpointercapture":
            case "lostpointercapture":
              xm.delete(h.pointerId);
          }
        }
        function km(c, h, g, p, w, S) {
          return c === null || c.nativeEvent !== S ? (c = {
            blockedOn: h,
            domEventName: g,
            eventSystemFlags: p,
            nativeEvent: S,
            targetContainers: [
              w
            ]
          }, h !== null && (h = Gt(h), h !== null && ZR(h)), c) : (c.eventSystemFlags |= p, h = c.targetContainers, w !== null && h.indexOf(w) === -1 && h.push(w), c);
        }
        function lH(c, h, g, p, w) {
          switch (h) {
            case "focusin":
              return pc = km(pc, c, h, g, p, w), true;
            case "dragenter":
              return _c2 = km(_c2, c, h, g, p, w), true;
            case "mouseover":
              return bc = km(bc, c, h, g, p, w), true;
            case "pointerover":
              var S = w.pointerId;
              return Lm.set(S, km(Lm.get(S) || null, c, h, g, p, w)), true;
            case "gotpointercapture":
              return S = w.pointerId, xm.set(S, km(xm.get(S) || null, c, h, g, p, w)), true;
          }
          return false;
        }
        function JR(c) {
          var h = fi(c.target);
          if (h !== null) {
            var g = o(h);
            if (g !== null) {
              if (h = g.tag, h === 13) {
                if (h = r(g), h !== null) {
                  c.blockedOn = h, F(c.priority, function() {
                    if (g.tag === 13) {
                      var p = Lo();
                      p = Ka(p);
                      var w = vd(g, p);
                      w !== null && xo(w, g, p), GS(g, p);
                    }
                  });
                  return;
                }
              } else if (h === 3 && g.stateNode.current.memoizedState.isDehydrated) {
                c.blockedOn = g.tag === 3 ? g.stateNode.containerInfo : null;
                return;
              }
            }
          }
          c.blockedOn = null;
        }
        function hb(c) {
          if (c.blockedOn !== null) return false;
          for (var h = c.targetContainers; 0 < h.length; ) {
            var g = ZS(c.nativeEvent);
            if (g === null) {
              g = c.nativeEvent;
              var p = new g.constructor(g.type, g);
              ey = p, g.target.dispatchEvent(p), ey = null;
            } else return h = Gt(g), h !== null && ZR(h), c.blockedOn = g, false;
            h.shift();
          }
          return true;
        }
        function e4(c, h, g) {
          hb(c) && g.delete(h);
        }
        function cH() {
          XS = false, pc !== null && hb(pc) && (pc = null), _c2 !== null && hb(_c2) && (_c2 = null), bc !== null && hb(bc) && (bc = null), Lm.forEach(e4), xm.forEach(e4);
        }
        function db(c, h) {
          c.blockedOn === h && (c.blockedOn = null, XS || (XS = true, s.unstable_scheduleCallback(s.unstable_NormalPriority, cH)));
        }
        var fb = null;
        function t4(c) {
          fb !== c && (fb = c, s.unstable_scheduleCallback(s.unstable_NormalPriority, function() {
            fb === c && (fb = null);
            for (var h = 0; h < c.length; h += 3) {
              var g = c[h], p = c[h + 1], w = c[h + 2];
              if (typeof p != "function") {
                if (QS(p || g) === null) continue;
                break;
              }
              var S = Gt(g);
              S !== null && (c.splice(h, 3), h -= 3, Qy(S, {
                pending: true,
                data: w,
                method: g.method,
                action: p
              }, p, w));
            }
          }));
        }
        function Dm(c) {
          function h(q) {
            return db(q, c);
          }
          pc !== null && db(pc, c), _c2 !== null && db(_c2, c), bc !== null && db(bc, c), Lm.forEach(h), xm.forEach(h);
          for (var g = 0; g < vc.length; g++) {
            var p = vc[g];
            p.blockedOn === c && (p.blockedOn = null);
          }
          for (; 0 < vc.length && (g = vc[0], g.blockedOn === null); ) JR(g), g.blockedOn === null && vc.shift();
          if (g = (c.ownerDocument || c).$$reactFormReplay, g != null) for (p = 0; p < g.length; p += 3) {
            var w = g[p], S = g[p + 1], N = w[Z] || null;
            if (typeof S == "function") N || t4(g);
            else if (N) {
              var O = null;
              if (S && S.hasAttribute("formAction")) {
                if (w = S, N = S[Z] || null) O = N.formAction;
                else if (QS(w) !== null) continue;
              } else O = N.action;
              typeof O == "function" ? g[p + 1] = O : (g.splice(p, 3), p -= 3), t4(g);
            }
          }
        }
        function JS(c) {
          this._internalRoot = c;
        }
        gb.prototype.render = JS.prototype.render = function(c) {
          var h = this._internalRoot;
          if (h === null) throw Error(i(409));
          var g = h.current, p = Lo();
          GR(g, p, c, h, null, null);
        }, gb.prototype.unmount = JS.prototype.unmount = function() {
          var c = this._internalRoot;
          if (c !== null) {
            this._internalRoot = null;
            var h = c.containerInfo;
            GR(c.current, 2, null, c, null, null), Y1(), h[ce] = null;
          }
        };
        function gb(c) {
          this._internalRoot = c;
        }
        gb.prototype.unstable_scheduleHydration = function(c) {
          if (c) {
            var h = P();
            c = {
              blockedOn: null,
              target: c,
              priority: h
            };
            for (var g = 0; g < vc.length && h !== 0 && h < vc[g].priority; g++) ;
            vc.splice(g, 0, c), g === 0 && JR(c);
          }
        };
        var i4 = e.version;
        if (i4 !== "19.1.0") throw Error(i(527, i4, "19.1.0"));
        se.findDOMNode = function(c) {
          var h = c._reactInternals;
          if (h === void 0) throw typeof c.render == "function" ? Error(i(188)) : (c = Object.keys(c).join(","), Error(i(268, c)));
          return c = l(h), c = c !== null ? u(c) : null, c = c === null ? null : c.stateNode, c;
        };
        var uH = {
          bundleType: 0,
          version: "19.1.0",
          rendererPackageName: "react-dom",
          currentDispatcherRef: H,
          reconcilerVersion: "19.1.0"
        };
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
          var mb = __REACT_DEVTOOLS_GLOBAL_HOOK__;
          if (!mb.isDisabled && mb.supportsFiber) try {
            Qs = mb.inject(uH), Sn = mb;
          } catch {
          }
        }
        return Tm.createRoot = function(c, h) {
          if (!n(c)) throw Error(i(299));
          var g = false, p = "", w = bA, S = vA, N = CA, O = null;
          return h != null && (h.unstable_strictMode === true && (g = true), h.identifierPrefix !== void 0 && (p = h.identifierPrefix), h.onUncaughtError !== void 0 && (w = h.onUncaughtError), h.onCaughtError !== void 0 && (S = h.onCaughtError), h.onRecoverableError !== void 0 && (N = h.onRecoverableError), h.unstable_transitionCallbacks !== void 0 && (O = h.unstable_transitionCallbacks)), h = KR(c, 1, false, null, null, g, p, w, S, N, O, null), c[ce] = h.current, OS(c), new JS(h);
        }, Tm.hydrateRoot = function(c, h, g) {
          if (!n(c)) throw Error(i(299));
          var p = false, w = "", S = bA, N = vA, O = CA, q = null, ue = null;
          return g != null && (g.unstable_strictMode === true && (p = true), g.identifierPrefix !== void 0 && (w = g.identifierPrefix), g.onUncaughtError !== void 0 && (S = g.onUncaughtError), g.onCaughtError !== void 0 && (N = g.onCaughtError), g.onRecoverableError !== void 0 && (O = g.onRecoverableError), g.unstable_transitionCallbacks !== void 0 && (q = g.unstable_transitionCallbacks), g.formState !== void 0 && (ue = g.formState)), h = KR(c, 1, true, h, g ?? null, p, w, S, N, O, q, ue), h.context = jR(null), g = h.current, p = Lo(), p = Ka(p), w = ic(p), w.callback = null, nc(g, w, p), g = p, h.current.lanes = g, Oi(h, g), ha(h), c[ce] = h.current, OS(c), new gb(h);
        }, Tm.version = "19.1.0", Tm;
      }
      var d4;
      function wH() {
        if (d4) return iL.exports;
        d4 = 1;
        function s() {
          if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(s);
          } catch (e) {
            console.error(e);
          }
        }
        return s(), iL.exports = CH(), iL.exports;
      }
      var yH = wH();
      const SH = "modulepreload", LH = function(s) {
        return "/goml/" + s;
      }, f4 = {}, Be = function(e, t, i) {
        let n = Promise.resolve();
        if (t && t.length > 0) {
          document.getElementsByTagName("link");
          const r = document.querySelector("meta[property=csp-nonce]"), a = (r == null ? void 0 : r.nonce) || (r == null ? void 0 : r.getAttribute("nonce"));
          n = Promise.allSettled(t.map((l) => {
            if (l = LH(l), l in f4) return;
            f4[l] = true;
            const u = l.endsWith(".css"), d = u ? '[rel="stylesheet"]' : "";
            if (document.querySelector(`link[href="${l}"]${d}`)) return;
            const f = document.createElement("link");
            if (f.rel = u ? "stylesheet" : SH, u || (f.as = "script"), f.crossOrigin = "", f.href = l, a && f.setAttribute("nonce", a), document.head.appendChild(f), u) return new Promise((m, _) => {
              f.addEventListener("load", m), f.addEventListener("error", () => _(new Error(`Unable to preload CSS for ${l}`)));
            });
          }));
        }
        function o(r) {
          const a = new Event("vite:preloadError", {
            cancelable: true
          });
          if (a.payload = r, window.dispatchEvent(a), !a.defaultPrevented) throw r;
        }
        return n.then((r) => {
          for (const a of r || []) a.status === "rejected" && o(a.reason);
          return e().catch(o);
        });
      };
      function xH(s, e, t) {
        return e in s ? Object.defineProperty(s, e, {
          value: t,
          enumerable: true,
          configurable: true,
          writable: true
        }) : s[e] = t, s;
      }
      function g4(s, e) {
        var t = Object.keys(s);
        if (Object.getOwnPropertySymbols) {
          var i = Object.getOwnPropertySymbols(s);
          e && (i = i.filter(function(n) {
            return Object.getOwnPropertyDescriptor(s, n).enumerable;
          })), t.push.apply(t, i);
        }
        return t;
      }
      function m4(s) {
        for (var e = 1; e < arguments.length; e++) {
          var t = arguments[e] != null ? arguments[e] : {};
          e % 2 ? g4(Object(t), true).forEach(function(i) {
            xH(s, i, t[i]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(s, Object.getOwnPropertyDescriptors(t)) : g4(Object(t)).forEach(function(i) {
            Object.defineProperty(s, i, Object.getOwnPropertyDescriptor(t, i));
          });
        }
        return s;
      }
      function kH(s, e) {
        if (s == null) return {};
        var t = {}, i = Object.keys(s), n, o;
        for (o = 0; o < i.length; o++) n = i[o], !(e.indexOf(n) >= 0) && (t[n] = s[n]);
        return t;
      }
      function DH(s, e) {
        if (s == null) return {};
        var t = kH(s, e), i, n;
        if (Object.getOwnPropertySymbols) {
          var o = Object.getOwnPropertySymbols(s);
          for (n = 0; n < o.length; n++) i = o[n], !(e.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(s, i) && (t[i] = s[i]);
        }
        return t;
      }
      function EH(s, e) {
        return TH(s) || NH(s, e) || IH(s, e) || MH();
      }
      function TH(s) {
        if (Array.isArray(s)) return s;
      }
      function NH(s, e) {
        if (!(typeof Symbol > "u" || !(Symbol.iterator in Object(s)))) {
          var t = [], i = true, n = false, o = void 0;
          try {
            for (var r = s[Symbol.iterator](), a; !(i = (a = r.next()).done) && (t.push(a.value), !(e && t.length === e)); i = true) ;
          } catch (l) {
            n = true, o = l;
          } finally {
            try {
              !i && r.return != null && r.return();
            } finally {
              if (n) throw o;
            }
          }
          return t;
        }
      }
      function IH(s, e) {
        if (s) {
          if (typeof s == "string") return p4(s, e);
          var t = Object.prototype.toString.call(s).slice(8, -1);
          if (t === "Object" && s.constructor && (t = s.constructor.name), t === "Map" || t === "Set") return Array.from(s);
          if (t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)) return p4(s, e);
        }
      }
      function p4(s, e) {
        (e == null || e > s.length) && (e = s.length);
        for (var t = 0, i = new Array(e); t < e; t++) i[t] = s[t];
        return i;
      }
      function MH() {
        throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
      }
      function AH(s, e, t) {
        return e in s ? Object.defineProperty(s, e, {
          value: t,
          enumerable: true,
          configurable: true,
          writable: true
        }) : s[e] = t, s;
      }
      function _4(s, e) {
        var t = Object.keys(s);
        if (Object.getOwnPropertySymbols) {
          var i = Object.getOwnPropertySymbols(s);
          e && (i = i.filter(function(n) {
            return Object.getOwnPropertyDescriptor(s, n).enumerable;
          })), t.push.apply(t, i);
        }
        return t;
      }
      function b4(s) {
        for (var e = 1; e < arguments.length; e++) {
          var t = arguments[e] != null ? arguments[e] : {};
          e % 2 ? _4(Object(t), true).forEach(function(i) {
            AH(s, i, t[i]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(s, Object.getOwnPropertyDescriptors(t)) : _4(Object(t)).forEach(function(i) {
            Object.defineProperty(s, i, Object.getOwnPropertyDescriptor(t, i));
          });
        }
        return s;
      }
      function RH() {
        for (var s = arguments.length, e = new Array(s), t = 0; t < s; t++) e[t] = arguments[t];
        return function(i) {
          return e.reduceRight(function(n, o) {
            return o(n);
          }, i);
        };
      }
      function Xm(s) {
        return function e() {
          for (var t = this, i = arguments.length, n = new Array(i), o = 0; o < i; o++) n[o] = arguments[o];
          return n.length >= s.length ? s.apply(this, n) : function() {
            for (var r = arguments.length, a = new Array(r), l = 0; l < r; l++) a[l] = arguments[l];
            return e.apply(t, [].concat(n, a));
          };
        };
      }
      function z0(s) {
        return {}.toString.call(s).includes("Object");
      }
      function OH(s) {
        return !Object.keys(s).length;
      }
      function $p(s) {
        return typeof s == "function";
      }
      function PH(s, e) {
        return Object.prototype.hasOwnProperty.call(s, e);
      }
      function BH(s, e) {
        return z0(e) || Yc("changeType"), Object.keys(e).some(function(t) {
          return !PH(s, t);
        }) && Yc("changeField"), e;
      }
      function FH(s) {
        $p(s) || Yc("selectorType");
      }
      function VH(s) {
        $p(s) || z0(s) || Yc("handlerType"), z0(s) && Object.values(s).some(function(e) {
          return !$p(e);
        }) && Yc("handlersType");
      }
      function WH(s) {
        s || Yc("initialIsRequired"), z0(s) || Yc("initialType"), OH(s) && Yc("initialContent");
      }
      function HH(s, e) {
        throw new Error(s[e] || s.default);
      }
      var zH = {
        initialIsRequired: "initial state is required",
        initialType: "initial state should be an object",
        initialContent: "initial state shouldn't be an empty object",
        handlerType: "handler should be an object or a function",
        handlersType: "all handlers should be a functions",
        selectorType: "selector should be a function",
        changeType: "provided value of changes should be an object",
        changeField: 'it seams you want to change a field in the state which is not specified in the "initial" state',
        default: "an unknown error accured in `state-local` package"
      }, Yc = Xm(HH)(zH), pb = {
        changes: BH,
        selector: FH,
        handler: VH,
        initial: WH
      };
      function UH(s) {
        var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        pb.initial(s), pb.handler(e);
        var t = {
          current: s
        }, i = Xm(KH)(t, e), n = Xm(qH)(t), o = Xm(pb.changes)(s), r = Xm($H)(t);
        function a() {
          var u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : function(d) {
            return d;
          };
          return pb.selector(u), u(t.current);
        }
        function l(u) {
          RH(i, n, o, r)(u);
        }
        return [
          a,
          l
        ];
      }
      function $H(s, e) {
        return $p(e) ? e(s.current) : e;
      }
      function qH(s, e) {
        return s.current = b4(b4({}, s.current), e), e;
      }
      function KH(s, e, t) {
        return $p(e) ? e(s.current) : Object.keys(t).forEach(function(i) {
          var n;
          return (n = e[i]) === null || n === void 0 ? void 0 : n.call(e, s.current[i]);
        }), t;
      }
      var jH = {
        create: UH
      }, GH = {
        paths: {
          vs: "https://cdn.jsdelivr.net/npm/monaco-editor@0.52.2/min/vs"
        }
      };
      function YH(s) {
        return function e() {
          for (var t = this, i = arguments.length, n = new Array(i), o = 0; o < i; o++) n[o] = arguments[o];
          return n.length >= s.length ? s.apply(this, n) : function() {
            for (var r = arguments.length, a = new Array(r), l = 0; l < r; l++) a[l] = arguments[l];
            return e.apply(t, [].concat(n, a));
          };
        };
      }
      function ZH(s) {
        return {}.toString.call(s).includes("Object");
      }
      function QH(s) {
        return s || v4("configIsRequired"), ZH(s) || v4("configType"), s.urls ? (XH(), {
          paths: {
            vs: s.urls.monacoBase
          }
        }) : s;
      }
      function XH() {
        console.warn(F7.deprecation);
      }
      function JH(s, e) {
        throw new Error(s[e] || s.default);
      }
      var F7 = {
        configIsRequired: "the configuration object is required",
        configType: "the configuration object should be an object",
        default: "an unknown error accured in `@monaco-editor/loader` package",
        deprecation: `Deprecation warning!
    You are using deprecated way of configuration.

    Instead of using
      monaco.config({ urls: { monacoBase: '...' } })
    use
      monaco.config({ paths: { vs: '...' } })

    For more please check the link https://github.com/suren-atoyan/monaco-loader#config
  `
      }, v4 = YH(JH)(F7), ez = {
        config: QH
      }, tz = function() {
        for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];
        return function(n) {
          return t.reduceRight(function(o, r) {
            return r(o);
          }, n);
        };
      };
      function V7(s, e) {
        return Object.keys(e).forEach(function(t) {
          e[t] instanceof Object && s[t] && Object.assign(e[t], V7(s[t], e[t]));
        }), m4(m4({}, s), e);
      }
      var iz = {
        type: "cancelation",
        msg: "operation is manually canceled"
      };
      function rL(s) {
        var e = false, t = new Promise(function(i, n) {
          s.then(function(o) {
            return e ? n(iz) : i(o);
          }), s.catch(n);
        });
        return t.cancel = function() {
          return e = true;
        }, t;
      }
      var nz = jH.create({
        config: GH,
        isInitialized: false,
        resolve: null,
        reject: null,
        monaco: null
      }), W7 = EH(nz, 2), A_ = W7[0], RC = W7[1];
      function sz(s) {
        var e = ez.config(s), t = e.monaco, i = DH(e, [
          "monaco"
        ]);
        RC(function(n) {
          return {
            config: V7(n.config, i),
            monaco: t
          };
        });
      }
      function oz() {
        var s = A_(function(e) {
          var t = e.monaco, i = e.isInitialized, n = e.resolve;
          return {
            monaco: t,
            isInitialized: i,
            resolve: n
          };
        });
        if (!s.isInitialized) {
          if (RC({
            isInitialized: true
          }), s.monaco) return s.resolve(s.monaco), rL(aL);
          if (window.monaco && window.monaco.editor) return H7(window.monaco), s.resolve(window.monaco), rL(aL);
          tz(rz, lz)(cz);
        }
        return rL(aL);
      }
      function rz(s) {
        return document.body.appendChild(s);
      }
      function az(s) {
        var e = document.createElement("script");
        return s && (e.src = s), e;
      }
      function lz(s) {
        var e = A_(function(i) {
          var n = i.config, o = i.reject;
          return {
            config: n,
            reject: o
          };
        }), t = az("".concat(e.config.paths.vs, "/loader.js"));
        return t.onload = function() {
          return s();
        }, t.onerror = e.reject, t;
      }
      function cz() {
        var s = A_(function(t) {
          var i = t.config, n = t.resolve, o = t.reject;
          return {
            config: i,
            resolve: n,
            reject: o
          };
        }), e = window.require;
        e.config(s.config), e([
          "vs/editor/editor.main"
        ], function(t) {
          H7(t), s.resolve(t);
        }, function(t) {
          s.reject(t);
        });
      }
      function H7(s) {
        A_().monaco || RC({
          monaco: s
        });
      }
      function uz() {
        return A_(function(s) {
          var e = s.monaco;
          return e;
        });
      }
      var aL = new Promise(function(s, e) {
        return RC({
          resolve: s,
          reject: e
        });
      }), U0 = {
        config: sz,
        init: oz,
        __getMonacoInstance: uz
      }, hz = {
        wrapper: {
          display: "flex",
          position: "relative",
          textAlign: "initial"
        },
        fullWidth: {
          width: "100%"
        },
        hide: {
          display: "none"
        }
      }, lL = hz, dz = {
        container: {
          display: "flex",
          height: "100%",
          width: "100%",
          justifyContent: "center",
          alignItems: "center"
        }
      }, fz = dz;
      function gz({ children: s }) {
        return Tf.createElement("div", {
          style: fz.container
        }, s);
      }
      var mz = gz, pz = mz;
      function _z({ width: s, height: e, isEditorReady: t, loading: i, _ref: n, className: o, wrapperProps: r }) {
        return Tf.createElement("section", {
          style: {
            ...lL.wrapper,
            width: s,
            height: e
          },
          ...r
        }, !t && Tf.createElement(pz, null, i), Tf.createElement("div", {
          ref: n,
          style: {
            ...lL.fullWidth,
            ...!t && lL.hide
          },
          className: o
        }));
      }
      var bz = _z, z7 = ft.memo(bz);
      function vz(s) {
        ft.useEffect(s, []);
      }
      var EE = vz;
      function Cz(s, e, t = true) {
        let i = ft.useRef(true);
        ft.useEffect(i.current || !t ? () => {
          i.current = false;
        } : s, e);
      }
      var Io = Cz;
      function fp() {
      }
      function rf(s, e, t, i) {
        return wz(s, i) || yz(s, e, t, i);
      }
      function wz(s, e) {
        return s.editor.getModel(U7(s, e));
      }
      function yz(s, e, t, i) {
        return s.editor.createModel(e, t, i ? U7(s, i) : void 0);
      }
      function U7(s, e) {
        return s.Uri.parse(e);
      }
      function Sz({ original: s, modified: e, language: t, originalLanguage: i, modifiedLanguage: n, originalModelPath: o, modifiedModelPath: r, keepCurrentOriginalModel: a = false, keepCurrentModifiedModel: l = false, theme: u = "light", loading: d = "Loading...", options: f = {}, height: m = "100%", width: _ = "100%", className: b, wrapperProps: v = {}, beforeMount: y = fp, onMount: x = fp }) {
        let [L, D] = ft.useState(false), [k, T] = ft.useState(true), M = ft.useRef(null), I = ft.useRef(null), R = ft.useRef(null), A = ft.useRef(x), Y = ft.useRef(y), U = ft.useRef(false);
        EE(() => {
          let te = U0.init();
          return te.then((H) => (I.current = H) && T(false)).catch((H) => (H == null ? void 0 : H.type) !== "cancelation" && console.error("Monaco initialization: error:", H)), () => M.current ? K() : te.cancel();
        }), Io(() => {
          if (M.current && I.current) {
            let te = M.current.getOriginalEditor(), H = rf(I.current, s || "", i || t || "text", o || "");
            H !== te.getModel() && te.setModel(H);
          }
        }, [
          o
        ], L), Io(() => {
          if (M.current && I.current) {
            let te = M.current.getModifiedEditor(), H = rf(I.current, e || "", n || t || "text", r || "");
            H !== te.getModel() && te.setModel(H);
          }
        }, [
          r
        ], L), Io(() => {
          let te = M.current.getModifiedEditor();
          te.getOption(I.current.editor.EditorOption.readOnly) ? te.setValue(e || "") : e !== te.getValue() && (te.executeEdits("", [
            {
              range: te.getModel().getFullModelRange(),
              text: e || "",
              forceMoveMarkers: true
            }
          ]), te.pushUndoStop());
        }, [
          e
        ], L), Io(() => {
          var _a3, _b3;
          (_b3 = (_a3 = M.current) == null ? void 0 : _a3.getModel()) == null ? void 0 : _b3.original.setValue(s || "");
        }, [
          s
        ], L), Io(() => {
          let { original: te, modified: H } = M.current.getModel();
          I.current.editor.setModelLanguage(te, i || t || "text"), I.current.editor.setModelLanguage(H, n || t || "text");
        }, [
          t,
          i,
          n
        ], L), Io(() => {
          var _a3;
          (_a3 = I.current) == null ? void 0 : _a3.editor.setTheme(u);
        }, [
          u
        ], L), Io(() => {
          var _a3;
          (_a3 = M.current) == null ? void 0 : _a3.updateOptions(f);
        }, [
          f
        ], L);
        let j = ft.useCallback(() => {
          var _a3;
          if (!I.current) return;
          Y.current(I.current);
          let te = rf(I.current, s || "", i || t || "text", o || ""), H = rf(I.current, e || "", n || t || "text", r || "");
          (_a3 = M.current) == null ? void 0 : _a3.setModel({
            original: te,
            modified: H
          });
        }, [
          t,
          e,
          n,
          s,
          i,
          o,
          r
        ]), ee = ft.useCallback(() => {
          var _a3;
          !U.current && R.current && (M.current = I.current.editor.createDiffEditor(R.current, {
            automaticLayout: true,
            ...f
          }), j(), (_a3 = I.current) == null ? void 0 : _a3.editor.setTheme(u), D(true), U.current = true);
        }, [
          f,
          u,
          j
        ]);
        ft.useEffect(() => {
          L && A.current(M.current, I.current);
        }, [
          L
        ]), ft.useEffect(() => {
          !k && !L && ee();
        }, [
          k,
          L,
          ee
        ]);
        function K() {
          var _a3, _b3, _c2, _d2;
          let te = (_a3 = M.current) == null ? void 0 : _a3.getModel();
          a || ((_b3 = te == null ? void 0 : te.original) == null ? void 0 : _b3.dispose()), l || ((_c2 = te == null ? void 0 : te.modified) == null ? void 0 : _c2.dispose()), (_d2 = M.current) == null ? void 0 : _d2.dispose();
        }
        return Tf.createElement(z7, {
          width: _,
          height: m,
          isEditorReady: L,
          loading: d,
          _ref: R,
          className: b,
          wrapperProps: v
        });
      }
      var Lz = Sz;
      ft.memo(Lz);
      function xz() {
        let [s, e] = ft.useState(U0.__getMonacoInstance());
        return EE(() => {
          let t;
          return s || (t = U0.init(), t.then((i) => {
            e(i);
          })), () => t == null ? void 0 : t.cancel();
        }), s;
      }
      var kz = xz;
      function Dz(s) {
        let e = ft.useRef();
        return ft.useEffect(() => {
          e.current = s;
        }, [
          s
        ]), e.current;
      }
      var Ez = Dz, _b = /* @__PURE__ */ new Map();
      function Tz({ defaultValue: s, defaultLanguage: e, defaultPath: t, value: i, language: n, path: o, theme: r = "light", line: a, loading: l = "Loading...", options: u = {}, overrideServices: d = {}, saveViewState: f = true, keepCurrentModel: m = false, width: _ = "100%", height: b = "100%", className: v, wrapperProps: y = {}, beforeMount: x = fp, onMount: L = fp, onChange: D, onValidate: k = fp }) {
        let [T, M] = ft.useState(false), [I, R] = ft.useState(true), A = ft.useRef(null), Y = ft.useRef(null), U = ft.useRef(null), j = ft.useRef(L), ee = ft.useRef(x), K = ft.useRef(), te = ft.useRef(i), H = Ez(o), se = ft.useRef(false), de = ft.useRef(false);
        EE(() => {
          let ne = U0.init();
          return ne.then((xe) => (A.current = xe) && R(false)).catch((xe) => (xe == null ? void 0 : xe.type) !== "cancelation" && console.error("Monaco initialization: error:", xe)), () => Y.current ? W() : ne.cancel();
        }), Io(() => {
          var _a3, _b3, _c2, _d2;
          let ne = rf(A.current, s || i || "", e || n || "", o || t || "");
          ne !== ((_a3 = Y.current) == null ? void 0 : _a3.getModel()) && (f && _b.set(H, (_b3 = Y.current) == null ? void 0 : _b3.saveViewState()), (_c2 = Y.current) == null ? void 0 : _c2.setModel(ne), f && ((_d2 = Y.current) == null ? void 0 : _d2.restoreViewState(_b.get(o))));
        }, [
          o
        ], T), Io(() => {
          var _a3;
          (_a3 = Y.current) == null ? void 0 : _a3.updateOptions(u);
        }, [
          u
        ], T), Io(() => {
          !Y.current || i === void 0 || (Y.current.getOption(A.current.editor.EditorOption.readOnly) ? Y.current.setValue(i) : i !== Y.current.getValue() && (de.current = true, Y.current.executeEdits("", [
            {
              range: Y.current.getModel().getFullModelRange(),
              text: i,
              forceMoveMarkers: true
            }
          ]), Y.current.pushUndoStop(), de.current = false));
        }, [
          i
        ], T), Io(() => {
          var _a3, _b3;
          let ne = (_a3 = Y.current) == null ? void 0 : _a3.getModel();
          ne && n && ((_b3 = A.current) == null ? void 0 : _b3.editor.setModelLanguage(ne, n));
        }, [
          n
        ], T), Io(() => {
          var _a3;
          a !== void 0 && ((_a3 = Y.current) == null ? void 0 : _a3.revealLine(a));
        }, [
          a
        ], T), Io(() => {
          var _a3;
          (_a3 = A.current) == null ? void 0 : _a3.editor.setTheme(r);
        }, [
          r
        ], T);
        let fe = ft.useCallback(() => {
          var _a3;
          if (!(!U.current || !A.current) && !se.current) {
            ee.current(A.current);
            let ne = o || t, xe = rf(A.current, i || s || "", e || n || "", ne || "");
            Y.current = (_a3 = A.current) == null ? void 0 : _a3.editor.create(U.current, {
              model: xe,
              automaticLayout: true,
              ...u
            }, d), f && Y.current.restoreViewState(_b.get(ne)), A.current.editor.setTheme(r), a !== void 0 && Y.current.revealLine(a), M(true), se.current = true;
          }
        }, [
          s,
          e,
          t,
          i,
          n,
          o,
          u,
          d,
          f,
          r,
          a
        ]);
        ft.useEffect(() => {
          T && j.current(Y.current, A.current);
        }, [
          T
        ]), ft.useEffect(() => {
          !I && !T && fe();
        }, [
          I,
          T,
          fe
        ]), te.current = i, ft.useEffect(() => {
          var _a3, _b3;
          T && D && ((_a3 = K.current) == null ? void 0 : _a3.dispose(), K.current = (_b3 = Y.current) == null ? void 0 : _b3.onDidChangeModelContent((ne) => {
            de.current || D(Y.current.getValue(), ne);
          }));
        }, [
          T,
          D
        ]), ft.useEffect(() => {
          if (T) {
            let ne = A.current.editor.onDidChangeMarkers((xe) => {
              var _a3;
              let ye = (_a3 = Y.current.getModel()) == null ? void 0 : _a3.uri;
              if (ye && xe.find((Ae) => Ae.path === ye.path)) {
                let Ae = A.current.editor.getModelMarkers({
                  resource: ye
                });
                k == null ? void 0 : k(Ae);
              }
            });
            return () => {
              ne == null ? void 0 : ne.dispose();
            };
          }
          return () => {
          };
        }, [
          T,
          k
        ]);
        function W() {
          var _a3, _b3;
          (_a3 = K.current) == null ? void 0 : _a3.dispose(), m ? f && _b.set(o, Y.current.saveViewState()) : (_b3 = Y.current.getModel()) == null ? void 0 : _b3.dispose(), Y.current.dispose();
        }
        return Tf.createElement(z7, {
          width: _,
          height: b,
          isEditorReady: T,
          loading: l,
          _ref: U,
          className: v,
          wrapperProps: y
        });
      }
      var Nz = Tz, Iz = ft.memo(Nz), C4 = Iz;
      const Mz = "/goml/assets/wasm_app_bg-B9DaJqFE.wasm", Az = async (s = {}, e) => {
        let t;
        if (e.startsWith("data:")) {
          const i = e.replace(/^data:.*?base64,/, "");
          let n;
          if (typeof Buffer == "function" && typeof Buffer.from == "function") n = Buffer.from(i, "base64");
          else if (typeof atob == "function") {
            const o = atob(i);
            n = new Uint8Array(o.length);
            for (let r = 0; r < o.length; r++) n[r] = o.charCodeAt(r);
          } else throw new Error("Cannot decode base64-encoded data URL");
          t = await WebAssembly.instantiate(n, s);
        } else {
          const i = await fetch(e), n = i.headers.get("Content-Type") || "";
          if ("instantiateStreaming" in WebAssembly && n.startsWith("application/wasm")) t = await WebAssembly.instantiateStreaming(i, s);
          else {
            const o = await i.arrayBuffer();
            t = await WebAssembly.instantiate(o, s);
          }
        }
        return t.instance.exports;
      };
      URL = globalThis.URL;
      const Rs = await Az({}, Mz), Rz = Rs.memory, Oz = Rs.execute, Pz = Rs.compile_to_core, Bz = Rs.compile_to_mono, Fz = Rs.compile_to_anf, Vz = Rs.compile_to_go, Wz = Rs.get_cst, Hz = Rs.get_ast, zz = Rs.get_tast, Uz = Rs.hover, $z = Rs.dot_completions, qz = Rs.colon_colon_completions, Kz = Rs.__wbindgen_add_to_stack_pointer, jz = Rs.__wbindgen_export_0, Gz = Rs.__wbindgen_export_1, Yz = Rs.__wbindgen_export_2, Zz = Object.freeze(Object.defineProperty({
        __proto__: null,
        __wbindgen_add_to_stack_pointer: Kz,
        __wbindgen_export_0: jz,
        __wbindgen_export_1: Gz,
        __wbindgen_export_2: Yz,
        colon_colon_completions: qz,
        compile_to_anf: Fz,
        compile_to_core: Pz,
        compile_to_go: Vz,
        compile_to_mono: Bz,
        dot_completions: $z,
        execute: Oz,
        get_ast: Hz,
        get_cst: Wz,
        get_tast: zz,
        hover: Uz,
        memory: Rz
      }, Symbol.toStringTag, {
        value: "Module"
      }));
      let Ue;
      function Qz(s) {
        Ue = s;
      }
      let Ho = 0, bb = null;
      function h0() {
        return (bb === null || bb.byteLength === 0) && (bb = new Uint8Array(Ue.memory.buffer)), bb;
      }
      const Xz = typeof TextEncoder > "u" ? (0, module.require)("util").TextEncoder : TextEncoder;
      let d0 = new Xz("utf-8");
      const Jz = typeof d0.encodeInto == "function" ? function(s, e) {
        return d0.encodeInto(s, e);
      } : function(s, e) {
        const t = d0.encode(s);
        return e.set(t), {
          read: s.length,
          written: t.length
        };
      };
      function Zr(s, e, t) {
        if (t === void 0) {
          const a = d0.encode(s), l = e(a.length, 1) >>> 0;
          return h0().subarray(l, l + a.length).set(a), Ho = a.length, l;
        }
        let i = s.length, n = e(i, 1) >>> 0;
        const o = h0();
        let r = 0;
        for (; r < i; r++) {
          const a = s.charCodeAt(r);
          if (a > 127) break;
          o[n + r] = a;
        }
        if (r !== i) {
          r !== 0 && (s = s.slice(r)), n = t(n, i, i = r + s.length * 3, 1) >>> 0;
          const a = h0().subarray(n + r, n + i), l = Jz(s, a);
          r += l.written, n = t(n, i, r, 1) >>> 0;
        }
        return Ho = r, n;
      }
      let $d = null;
      function cn() {
        return ($d === null || $d.buffer.detached === true || $d.buffer.detached === void 0 && $d.buffer !== Ue.memory.buffer) && ($d = new DataView(Ue.memory.buffer)), $d;
      }
      const eU = typeof TextDecoder > "u" ? (0, module.require)("util").TextDecoder : TextDecoder;
      let $7 = new eU("utf-8", {
        ignoreBOM: true,
        fatal: true
      });
      $7.decode();
      function Qr(s, e) {
        return s = s >>> 0, $7.decode(h0().subarray(s, s + e));
      }
      function tU(s) {
        let e, t;
        try {
          const o = Ue.__wbindgen_add_to_stack_pointer(-16), r = Zr(s, Ue.__wbindgen_export_0, Ue.__wbindgen_export_1), a = Ho;
          Ue.execute(o, r, a);
          var i = cn().getInt32(o + 4 * 0, true), n = cn().getInt32(o + 4 * 1, true);
          return e = i, t = n, Qr(i, n);
        } finally {
          Ue.__wbindgen_add_to_stack_pointer(16), Ue.__wbindgen_export_2(e, t, 1);
        }
      }
      function iU(s) {
        let e, t;
        try {
          const o = Ue.__wbindgen_add_to_stack_pointer(-16), r = Zr(s, Ue.__wbindgen_export_0, Ue.__wbindgen_export_1), a = Ho;
          Ue.compile_to_core(o, r, a);
          var i = cn().getInt32(o + 4 * 0, true), n = cn().getInt32(o + 4 * 1, true);
          return e = i, t = n, Qr(i, n);
        } finally {
          Ue.__wbindgen_add_to_stack_pointer(16), Ue.__wbindgen_export_2(e, t, 1);
        }
      }
      function nU(s) {
        let e, t;
        try {
          const o = Ue.__wbindgen_add_to_stack_pointer(-16), r = Zr(s, Ue.__wbindgen_export_0, Ue.__wbindgen_export_1), a = Ho;
          Ue.compile_to_mono(o, r, a);
          var i = cn().getInt32(o + 4 * 0, true), n = cn().getInt32(o + 4 * 1, true);
          return e = i, t = n, Qr(i, n);
        } finally {
          Ue.__wbindgen_add_to_stack_pointer(16), Ue.__wbindgen_export_2(e, t, 1);
        }
      }
      function sU(s) {
        let e, t;
        try {
          const o = Ue.__wbindgen_add_to_stack_pointer(-16), r = Zr(s, Ue.__wbindgen_export_0, Ue.__wbindgen_export_1), a = Ho;
          Ue.compile_to_anf(o, r, a);
          var i = cn().getInt32(o + 4 * 0, true), n = cn().getInt32(o + 4 * 1, true);
          return e = i, t = n, Qr(i, n);
        } finally {
          Ue.__wbindgen_add_to_stack_pointer(16), Ue.__wbindgen_export_2(e, t, 1);
        }
      }
      function oU(s) {
        let e, t;
        try {
          const o = Ue.__wbindgen_add_to_stack_pointer(-16), r = Zr(s, Ue.__wbindgen_export_0, Ue.__wbindgen_export_1), a = Ho;
          Ue.compile_to_go(o, r, a);
          var i = cn().getInt32(o + 4 * 0, true), n = cn().getInt32(o + 4 * 1, true);
          return e = i, t = n, Qr(i, n);
        } finally {
          Ue.__wbindgen_add_to_stack_pointer(16), Ue.__wbindgen_export_2(e, t, 1);
        }
      }
      function rU(s) {
        let e, t;
        try {
          const o = Ue.__wbindgen_add_to_stack_pointer(-16), r = Zr(s, Ue.__wbindgen_export_0, Ue.__wbindgen_export_1), a = Ho;
          Ue.get_cst(o, r, a);
          var i = cn().getInt32(o + 4 * 0, true), n = cn().getInt32(o + 4 * 1, true);
          return e = i, t = n, Qr(i, n);
        } finally {
          Ue.__wbindgen_add_to_stack_pointer(16), Ue.__wbindgen_export_2(e, t, 1);
        }
      }
      function aU(s) {
        let e, t;
        try {
          const o = Ue.__wbindgen_add_to_stack_pointer(-16), r = Zr(s, Ue.__wbindgen_export_0, Ue.__wbindgen_export_1), a = Ho;
          Ue.get_ast(o, r, a);
          var i = cn().getInt32(o + 4 * 0, true), n = cn().getInt32(o + 4 * 1, true);
          return e = i, t = n, Qr(i, n);
        } finally {
          Ue.__wbindgen_add_to_stack_pointer(16), Ue.__wbindgen_export_2(e, t, 1);
        }
      }
      function lU(s) {
        let e, t;
        try {
          const o = Ue.__wbindgen_add_to_stack_pointer(-16), r = Zr(s, Ue.__wbindgen_export_0, Ue.__wbindgen_export_1), a = Ho;
          Ue.get_tast(o, r, a);
          var i = cn().getInt32(o + 4 * 0, true), n = cn().getInt32(o + 4 * 1, true);
          return e = i, t = n, Qr(i, n);
        } finally {
          Ue.__wbindgen_add_to_stack_pointer(16), Ue.__wbindgen_export_2(e, t, 1);
        }
      }
      function cU(s, e, t) {
        let i, n;
        try {
          const a = Ue.__wbindgen_add_to_stack_pointer(-16), l = Zr(s, Ue.__wbindgen_export_0, Ue.__wbindgen_export_1), u = Ho;
          Ue.hover(a, l, u, e, t);
          var o = cn().getInt32(a + 4 * 0, true), r = cn().getInt32(a + 4 * 1, true);
          return i = o, n = r, Qr(o, r);
        } finally {
          Ue.__wbindgen_add_to_stack_pointer(16), Ue.__wbindgen_export_2(i, n, 1);
        }
      }
      function uU(s, e, t) {
        let i, n;
        try {
          const a = Ue.__wbindgen_add_to_stack_pointer(-16), l = Zr(s, Ue.__wbindgen_export_0, Ue.__wbindgen_export_1), u = Ho;
          Ue.dot_completions(a, l, u, e, t);
          var o = cn().getInt32(a + 4 * 0, true), r = cn().getInt32(a + 4 * 1, true);
          return i = o, n = r, Qr(o, r);
        } finally {
          Ue.__wbindgen_add_to_stack_pointer(16), Ue.__wbindgen_export_2(i, n, 1);
        }
      }
      function hU(s, e, t) {
        let i, n;
        try {
          const a = Ue.__wbindgen_add_to_stack_pointer(-16), l = Zr(s, Ue.__wbindgen_export_0, Ue.__wbindgen_export_1), u = Ho;
          Ue.colon_colon_completions(a, l, u, e, t);
          var o = cn().getInt32(a + 4 * 0, true), r = cn().getInt32(a + 4 * 1, true);
          return i = o, n = r, Qr(o, r);
        } finally {
          Ue.__wbindgen_add_to_stack_pointer(16), Ue.__wbindgen_export_2(i, n, 1);
        }
      }
      Qz(Zz);
      function ko(s, e = 0) {
        return s[s.length - (1 + e)];
      }
      function dU(s) {
        if (s.length === 0) throw new Error("Invalid tail call");
        return [
          s.slice(0, s.length - 1),
          s[s.length - 1]
        ];
      }
      function Qi(s, e, t = (i, n) => i === n) {
        if (s === e) return true;
        if (!s || !e || s.length !== e.length) return false;
        for (let i = 0, n = s.length; i < n; i++) if (!t(s[i], e[i])) return false;
        return true;
      }
      function fU(s, e) {
        const t = s.length - 1;
        e < t && (s[e] = s[t]), s.pop();
      }
      function gU(s, e, t) {
        return mU(s.length, (i) => t(s[i], e));
      }
      function mU(s, e) {
        let t = 0, i = s - 1;
        for (; t <= i; ) {
          const n = (t + i) / 2 | 0, o = e(n);
          if (o < 0) t = n + 1;
          else if (o > 0) i = n - 1;
          else return n;
        }
        return -(t + 1);
      }
      function* TE(s, e) {
        let t, i;
        for (const n of s) i !== void 0 && e(i, n) ? t.push(n) : (t && (yield t), t = [
          n
        ]), i = n;
        t && (yield t);
      }
      function q7(s, e) {
        for (let t = 0; t <= s.length; t++) e(t === 0 ? void 0 : s[t - 1], t === s.length ? void 0 : s[t]);
      }
      function pU(s, e) {
        for (let t = 0; t < s.length; t++) e(t === 0 ? void 0 : s[t - 1], s[t], t + 1 === s.length ? void 0 : s[t + 1]);
      }
      function NE(s) {
        return s.filter((e) => !!e);
      }
      function w4(s) {
        let e = 0;
        for (let t = 0; t < s.length; t++) s[t] && (s[e] = s[t], e += 1);
        s.length = e;
      }
      function _U(s) {
        return !Array.isArray(s) || s.length === 0;
      }
      function OC(s) {
        return Array.isArray(s) && s.length > 0;
      }
      function Nh(s, e = (t) => t) {
        const t = /* @__PURE__ */ new Set();
        return s.filter((i) => {
          const n = e(i);
          return t.has(n) ? false : (t.add(n), true);
        });
      }
      function IE(s, e) {
        return s.length > 0 ? s[0] : e;
      }
      function Ls(s, e) {
        let t = typeof e == "number" ? s : 0;
        typeof e == "number" ? t = s : (t = 0, e = s);
        const i = [];
        if (t <= e) for (let n = t; n < e; n++) i.push(n);
        else for (let n = t; n > e; n--) i.push(n);
        return i;
      }
      function PC(s, e, t) {
        const i = s.slice(0, e), n = s.slice(e);
        return i.concat(t, n);
      }
      function cL(s, e) {
        const t = s.indexOf(e);
        t > -1 && (s.splice(t, 1), s.unshift(e));
      }
      function vb(s, e) {
        const t = s.indexOf(e);
        t > -1 && (s.splice(t, 1), s.push(e));
      }
      function Nx(s, e) {
        for (const t of e) s.push(t);
      }
      function bU(s, e, t) {
        const i = K7(s, e), n = s.length, o = t.length;
        s.length = n + o;
        for (let r = n - 1; r >= i; r--) s[r + o] = s[r];
        for (let r = 0; r < o; r++) s[r + i] = t[r];
      }
      function y4(s, e, t, i) {
        const n = K7(s, e);
        let o = s.splice(n, t);
        return o === void 0 && (o = []), bU(s, n, i), o;
      }
      function K7(s, e) {
        return e < 0 ? Math.max(e + s.length, 0) : Math.min(e, s.length);
      }
      var qp;
      (function(s) {
        function e(o) {
          return o < 0;
        }
        s.isLessThan = e;
        function t(o) {
          return o <= 0;
        }
        s.isLessThanOrEqual = t;
        function i(o) {
          return o > 0;
        }
        s.isGreaterThan = i;
        function n(o) {
          return o === 0;
        }
        s.isNeitherLessOrGreaterThan = n, s.greaterThan = 1, s.lessThan = -1, s.neitherLessOrGreaterThan = 0;
      })(qp || (qp = {}));
      function fr(s, e) {
        return (t, i) => e(s(t), s(i));
      }
      function vU(...s) {
        return (e, t) => {
          for (const i of s) {
            const n = i(e, t);
            if (!qp.isNeitherLessOrGreaterThan(n)) return n;
          }
          return qp.neitherLessOrGreaterThan;
        };
      }
      const Zc = (s, e) => s - e, CU = (s, e) => Zc(s ? 1 : 0, e ? 1 : 0);
      function wU(s) {
        return (e, t) => -s(e, t);
      }
      class zl {
        constructor(e) {
          this.items = e, this.firstIdx = 0, this.lastIdx = this.items.length - 1;
        }
        get length() {
          return this.lastIdx - this.firstIdx + 1;
        }
        takeWhile(e) {
          let t = this.firstIdx;
          for (; t < this.items.length && e(this.items[t]); ) t++;
          const i = t === this.firstIdx ? null : this.items.slice(this.firstIdx, t);
          return this.firstIdx = t, i;
        }
        takeFromEndWhile(e) {
          let t = this.lastIdx;
          for (; t >= 0 && e(this.items[t]); ) t--;
          const i = t === this.lastIdx ? null : this.items.slice(t + 1, this.lastIdx + 1);
          return this.lastIdx = t, i;
        }
        peek() {
          if (this.length !== 0) return this.items[this.firstIdx];
        }
        dequeue() {
          const e = this.items[this.firstIdx];
          return this.firstIdx++, e;
        }
        takeCount(e) {
          const t = this.items.slice(this.firstIdx, this.firstIdx + e);
          return this.firstIdx += e, t;
        }
      }
      const _Rl = class _Rl {
        constructor(e) {
          this.iterate = e;
        }
        toArray() {
          const e = [];
          return this.iterate((t) => (e.push(t), true)), e;
        }
        filter(e) {
          return new _Rl((t) => this.iterate((i) => e(i) ? t(i) : true));
        }
        map(e) {
          return new _Rl((t) => this.iterate((i) => t(e(i))));
        }
        findLast(e) {
          let t;
          return this.iterate((i) => (e(i) && (t = i), true)), t;
        }
        findLastMaxBy(e) {
          let t, i = true;
          return this.iterate((n) => ((i || qp.isGreaterThan(e(n, t))) && (i = false, t = n), true)), t;
        }
      };
      _Rl.empty = new _Rl((e) => {
      });
      let Rl = _Rl;
      function ho(s) {
        return typeof s == "string";
      }
      function Es(s) {
        return typeof s == "object" && s !== null && !Array.isArray(s) && !(s instanceof RegExp) && !(s instanceof Date);
      }
      function yU(s) {
        const e = Object.getPrototypeOf(Uint8Array);
        return typeof s == "object" && s instanceof e;
      }
      function wg(s) {
        return typeof s == "number" && !isNaN(s);
      }
      function S4(s) {
        return !!s && typeof s[Symbol.iterator] == "function";
      }
      function j7(s) {
        return s === true || s === false;
      }
      function Po(s) {
        return typeof s > "u";
      }
      function Jf(s) {
        return !ao(s);
      }
      function ao(s) {
        return Po(s) || s === null;
      }
      function Qc(s, e) {
        if (!s) throw new Error("Unexpected type");
      }
      function G7(s) {
        if (ao(s)) throw new Error("Assertion Failed: argument is undefined or null");
        return s;
      }
      function $0(s) {
        return typeof s == "function";
      }
      function SU(s, e) {
        const t = Math.min(s.length, e.length);
        for (let i = 0; i < t; i++) LU(s[i], e[i]);
      }
      function LU(s, e) {
        if (ho(e)) {
          if (typeof s !== e) throw new Error(`argument does not match constraint: typeof ${e}`);
        } else if ($0(e)) {
          try {
            if (s instanceof e) return;
          } catch {
          }
          if (!ao(s) && s.constructor === e || e.length === 1 && e.call(void 0, s) === true) return;
          throw new Error("argument does not match one of these constraints: arg instanceof constraint, arg.constructor === constraint, nor constraint(arg) === true");
        }
      }
      function Dc(s) {
        if (!s || typeof s != "object" || s instanceof RegExp) return s;
        const e = Array.isArray(s) ? [] : {};
        return Object.entries(s).forEach(([t, i]) => {
          e[t] = i && typeof i == "object" ? Dc(i) : i;
        }), e;
      }
      function xU(s) {
        if (!s || typeof s != "object") return s;
        const e = [
          s
        ];
        for (; e.length > 0; ) {
          const t = e.shift();
          Object.freeze(t);
          for (const i in t) if (Y7.call(t, i)) {
            const n = t[i];
            typeof n == "object" && !Object.isFrozen(n) && !yU(n) && e.push(n);
          }
        }
        return s;
      }
      const Y7 = Object.prototype.hasOwnProperty;
      function Z7(s, e) {
        return Ix(s, e, /* @__PURE__ */ new Set());
      }
      function Ix(s, e, t) {
        if (ao(s)) return s;
        const i = e(s);
        if (typeof i < "u") return i;
        if (Array.isArray(s)) {
          const n = [];
          for (const o of s) n.push(Ix(o, e, t));
          return n;
        }
        if (Es(s)) {
          if (t.has(s)) throw new Error("Cannot clone recursive data-structure");
          t.add(s);
          const n = {};
          for (const o in s) Y7.call(s, o) && (n[o] = Ix(s[o], e, t));
          return t.delete(s), n;
        }
        return s;
      }
      function $s(s, e) {
        if (s === e) return true;
        if (s == null || e === null || e === void 0 || typeof s != typeof e || typeof s != "object" || Array.isArray(s) !== Array.isArray(e)) return false;
        let t, i;
        if (Array.isArray(s)) {
          if (s.length !== e.length) return false;
          for (t = 0; t < s.length; t++) if (!$s(s[t], e[t])) return false;
        } else {
          const n = [];
          for (i in s) n.push(i);
          n.sort();
          const o = [];
          for (i in e) o.push(i);
          if (o.sort(), !$s(n, o)) return false;
          for (t = 0; t < n.length; t++) if (!$s(s[n[t]], e[n[t]])) return false;
        }
        return true;
      }
      function kU(s) {
        let e = [];
        for (; Object.prototype !== s; ) e = e.concat(Object.getOwnPropertyNames(s)), s = Object.getPrototypeOf(s);
        return e;
      }
      function Mx(s) {
        const e = [];
        for (const t of kU(s)) typeof s[t] == "function" && e.push(t);
        return e;
      }
      function DU(s, e) {
        const t = (n) => function() {
          const o = Array.prototype.slice.call(arguments, 0);
          return e(n, o);
        }, i = {};
        for (const n of s) i[n] = t(n);
        return i;
      }
      function Q7() {
        return globalThis._VSCODE_NLS_MESSAGES;
      }
      function ME() {
        return globalThis._VSCODE_NLS_LANGUAGE;
      }
      const EU = ME() === "pseudo" || typeof document < "u" && document.location && document.location.hash.indexOf("pseudo=true") >= 0;
      function L4(s, e) {
        let t;
        return e.length === 0 ? t = s : t = s.replace(/\{(\d+)\}/g, (i, n) => {
          const o = n[0], r = e[o];
          let a = i;
          return typeof r == "string" ? a = r : (typeof r == "number" || typeof r == "boolean" || r === void 0 || r === null) && (a = String(r)), a;
        }), EU && (t = "\uFF3B" + t.replace(/[aouei]/g, "$&$&") + "\uFF3D"), t;
      }
      function C(s, e, ...t) {
        return L4(typeof s == "number" ? TU(s, e) : e, t);
      }
      function TU(s, e) {
        var _a3;
        const t = (_a3 = Q7()) == null ? void 0 : _a3[s];
        if (typeof t != "string") {
          if (typeof e == "string") return e;
          throw new Error(`!!! NLS MISSING: ${s} !!!`);
        }
        return t;
      }
      const af = "en";
      let q0 = false, K0 = false, f0 = false, X7 = false, AE = false, RE = false, J7 = false, Cb, uL = af, x4 = af, NU, dl;
      const Ol = globalThis;
      let Eo;
      typeof Ol.vscode < "u" && typeof Ol.vscode.process < "u" ? Eo = Ol.vscode.process : typeof process < "u" && typeof ((_a2 = process == null ? void 0 : process.versions) == null ? void 0 : _a2.node) == "string" && (Eo = process);
      const IU = typeof ((_b2 = Eo == null ? void 0 : Eo.versions) == null ? void 0 : _b2.electron) == "string", MU = IU && (Eo == null ? void 0 : Eo.type) === "renderer";
      if (typeof Eo == "object") {
        q0 = Eo.platform === "win32", K0 = Eo.platform === "darwin", f0 = Eo.platform === "linux", f0 && Eo.env.SNAP && Eo.env.SNAP_REVISION, Eo.env.CI || Eo.env.BUILD_ARTIFACTSTAGINGDIRECTORY, Cb = af, uL = af;
        const s = Eo.env.VSCODE_NLS_CONFIG;
        if (s) try {
          const e = JSON.parse(s);
          Cb = e.userLocale, x4 = e.osLocale, uL = e.resolvedLanguage || af, NU = (_c = e.languagePack) == null ? void 0 : _c.translationsConfigFile;
        } catch {
        }
        X7 = true;
      } else typeof navigator == "object" && !MU ? (dl = navigator.userAgent, q0 = dl.indexOf("Windows") >= 0, K0 = dl.indexOf("Macintosh") >= 0, RE = (dl.indexOf("Macintosh") >= 0 || dl.indexOf("iPad") >= 0 || dl.indexOf("iPhone") >= 0) && !!navigator.maxTouchPoints && navigator.maxTouchPoints > 0, f0 = dl.indexOf("Linux") >= 0, J7 = (dl == null ? void 0 : dl.indexOf("Mobi")) >= 0, AE = true, uL = ME() || af, Cb = navigator.language.toLowerCase(), x4 = Cb) : console.error("Unable to resolve platform.");
      const Ks = q0, _t = K0, Is = f0, j0 = X7, yg = AE, AU = AE && typeof Ol.importScripts == "function", RU = AU ? Ol.origin : void 0, Ih = RE, e9 = J7, Ta = dl, OU = typeof Ol.postMessage == "function" && !Ol.importScripts, t9 = (() => {
        if (OU) {
          const s = [];
          Ol.addEventListener("message", (t) => {
            if (t.data && t.data.vscodeScheduleAsyncWork) for (let i = 0, n = s.length; i < n; i++) {
              const o = s[i];
              if (o.id === t.data.vscodeScheduleAsyncWork) {
                s.splice(i, 1), o.callback();
                return;
              }
            }
          });
          let e = 0;
          return (t) => {
            const i = ++e;
            s.push({
              id: i,
              callback: t
            }), Ol.postMessage({
              vscodeScheduleAsyncWork: i
            }, "*");
          };
        }
        return (s) => setTimeout(s);
      })(), ur = K0 || RE ? 2 : q0 ? 1 : 3;
      let k4 = true, D4 = false;
      function PU() {
        if (!D4) {
          D4 = true;
          const s = new Uint8Array(2);
          s[0] = 1, s[1] = 2, k4 = new Uint16Array(s.buffer)[0] === 513;
        }
        return k4;
      }
      const i9 = !!(Ta && Ta.indexOf("Chrome") >= 0), BU = !!(Ta && Ta.indexOf("Firefox") >= 0), FU = !!(!i9 && Ta && Ta.indexOf("Safari") >= 0), VU = !!(Ta && Ta.indexOf("Edg/") >= 0), WU = !!(Ta && Ta.indexOf("Android") >= 0), zn = {
        tabSize: 4,
        indentSize: 4,
        insertSpaces: true,
        detectIndentation: true,
        trimAutoWhitespace: true,
        largeFileOptimizations: true,
        bracketPairColorizationOptions: {
          enabled: true,
          independentColorPoolPerBracketType: false
        }
      };
      var kt;
      (function(s) {
        function e(k) {
          return k && typeof k == "object" && typeof k[Symbol.iterator] == "function";
        }
        s.is = e;
        const t = Object.freeze([]);
        function i() {
          return t;
        }
        s.empty = i;
        function* n(k) {
          yield k;
        }
        s.single = n;
        function o(k) {
          return e(k) ? k : n(k);
        }
        s.wrap = o;
        function r(k) {
          return k || t;
        }
        s.from = r;
        function* a(k) {
          for (let T = k.length - 1; T >= 0; T--) yield k[T];
        }
        s.reverse = a;
        function l(k) {
          return !k || k[Symbol.iterator]().next().done === true;
        }
        s.isEmpty = l;
        function u(k) {
          return k[Symbol.iterator]().next().value;
        }
        s.first = u;
        function d(k, T) {
          let M = 0;
          for (const I of k) if (T(I, M++)) return true;
          return false;
        }
        s.some = d;
        function f(k, T) {
          for (const M of k) if (T(M)) return M;
        }
        s.find = f;
        function* m(k, T) {
          for (const M of k) T(M) && (yield M);
        }
        s.filter = m;
        function* _(k, T) {
          let M = 0;
          for (const I of k) yield T(I, M++);
        }
        s.map = _;
        function* b(k, T) {
          let M = 0;
          for (const I of k) yield* T(I, M++);
        }
        s.flatMap = b;
        function* v(...k) {
          for (const T of k) yield* T;
        }
        s.concat = v;
        function y(k, T, M) {
          let I = M;
          for (const R of k) I = T(I, R);
          return I;
        }
        s.reduce = y;
        function* x(k, T, M = k.length) {
          for (T < 0 && (T += k.length), M < 0 ? M += k.length : M > k.length && (M = k.length); T < M; T++) yield k[T];
        }
        s.slice = x;
        function L(k, T = Number.POSITIVE_INFINITY) {
          const M = [];
          if (T === 0) return [
            M,
            k
          ];
          const I = k[Symbol.iterator]();
          for (let R = 0; R < T; R++) {
            const A = I.next();
            if (A.done) return [
              M,
              s.empty()
            ];
            M.push(A.value);
          }
          return [
            M,
            {
              [Symbol.iterator]() {
                return I;
              }
            }
          ];
        }
        s.consume = L;
        async function D(k) {
          const T = [];
          for await (const M of k) T.push(M);
          return Promise.resolve(T);
        }
        s.asyncToArray = D;
      })(kt || (kt = {}));
      let qi = (_d = class {
        constructor(e) {
          this.element = e, this.next = _d.Undefined, this.prev = _d.Undefined;
        }
      }, _d.Undefined = new _d(void 0), _d);
      class Us {
        constructor() {
          this._first = qi.Undefined, this._last = qi.Undefined, this._size = 0;
        }
        get size() {
          return this._size;
        }
        isEmpty() {
          return this._first === qi.Undefined;
        }
        clear() {
          let e = this._first;
          for (; e !== qi.Undefined; ) {
            const t = e.next;
            e.prev = qi.Undefined, e.next = qi.Undefined, e = t;
          }
          this._first = qi.Undefined, this._last = qi.Undefined, this._size = 0;
        }
        unshift(e) {
          return this._insert(e, false);
        }
        push(e) {
          return this._insert(e, true);
        }
        _insert(e, t) {
          const i = new qi(e);
          if (this._first === qi.Undefined) this._first = i, this._last = i;
          else if (t) {
            const o = this._last;
            this._last = i, i.prev = o, o.next = i;
          } else {
            const o = this._first;
            this._first = i, i.next = o, o.prev = i;
          }
          this._size += 1;
          let n = false;
          return () => {
            n || (n = true, this._remove(i));
          };
        }
        shift() {
          if (this._first !== qi.Undefined) {
            const e = this._first.element;
            return this._remove(this._first), e;
          }
        }
        pop() {
          if (this._last !== qi.Undefined) {
            const e = this._last.element;
            return this._remove(this._last), e;
          }
        }
        _remove(e) {
          if (e.prev !== qi.Undefined && e.next !== qi.Undefined) {
            const t = e.prev;
            t.next = e.next, e.next.prev = t;
          } else e.prev === qi.Undefined && e.next === qi.Undefined ? (this._first = qi.Undefined, this._last = qi.Undefined) : e.next === qi.Undefined ? (this._last = this._last.prev, this._last.next = qi.Undefined) : e.prev === qi.Undefined && (this._first = this._first.next, this._first.prev = qi.Undefined);
          this._size -= 1;
        }
        *[Symbol.iterator]() {
          let e = this._first;
          for (; e !== qi.Undefined; ) yield e.element, e = e.next;
        }
      }
      const n9 = "`~!@#$%^&*()-=+[{]}\\|;:'\",.<>/?";
      function HU(s = "") {
        let e = "(-?\\d*\\.\\d\\w*)|([^";
        for (const t of n9) s.indexOf(t) >= 0 || (e += "\\" + t);
        return e += "\\s]+)", new RegExp(e, "g");
      }
      const OE = HU();
      function PE(s) {
        let e = OE;
        if (s && s instanceof RegExp) if (s.global) e = s;
        else {
          let t = "g";
          s.ignoreCase && (t += "i"), s.multiline && (t += "m"), s.unicode && (t += "u"), e = new RegExp(s.source, t);
        }
        return e.lastIndex = 0, e;
      }
      const s9 = new Us();
      s9.unshift({
        maxLen: 1e3,
        windowSize: 15,
        timeBudget: 150
      });
      function Kp(s, e, t, i, n) {
        if (e = PE(e), n || (n = kt.first(s9)), t.length > n.maxLen) {
          let u = s - n.maxLen / 2;
          return u < 0 ? u = 0 : i += u, t = t.substring(u, s + n.maxLen / 2), Kp(s, e, t, i, n);
        }
        const o = Date.now(), r = s - 1 - i;
        let a = -1, l = null;
        for (let u = 1; !(Date.now() - o >= n.timeBudget); u++) {
          const d = r - n.windowSize * u;
          e.lastIndex = Math.max(0, d);
          const f = zU(e, t, r, a);
          if (!f && l || (l = f, d <= 0)) break;
          a = d;
        }
        if (l) {
          const u = {
            word: l[0],
            startColumn: i + 1 + l.index,
            endColumn: i + 1 + l.index + l[0].length
          };
          return e.lastIndex = 0, u;
        }
        return null;
      }
      function zU(s, e, t, i) {
        let n;
        for (; n = s.exec(e); ) {
          const o = n.index || 0;
          if (o <= t && s.lastIndex >= t) return n;
          if (i > 0 && o > i) return null;
        }
        return null;
      }
      const ma = 8;
      class o9 {
        constructor(e) {
          this._values = e;
        }
        hasChanged(e) {
          return this._values[e];
        }
      }
      class r9 {
        constructor() {
          this.stableMinimapLayoutInput = null, this.stableFitMaxMinimapScale = 0, this.stableFitRemainingWidth = 0;
        }
      }
      class oi {
        constructor(e, t, i, n) {
          this.id = e, this.name = t, this.defaultValue = i, this.schema = n;
        }
        applyUpdate(e, t) {
          return BC(e, t);
        }
        compute(e, t, i) {
          return i;
        }
      }
      class gp {
        constructor(e, t) {
          this.newValue = e, this.didChange = t;
        }
      }
      function BC(s, e) {
        if (typeof s != "object" || typeof e != "object" || !s || !e) return new gp(e, s !== e);
        if (Array.isArray(s) || Array.isArray(e)) {
          const i = Array.isArray(s) && Array.isArray(e) && Qi(s, e);
          return new gp(e, !i);
        }
        let t = false;
        for (const i in e) if (e.hasOwnProperty(i)) {
          const n = BC(s[i], e[i]);
          n.didChange && (s[i] = n.newValue, t = true);
        }
        return new gp(s, t);
      }
      class R_ {
        constructor(e) {
          this.schema = void 0, this.id = e, this.name = "_never_", this.defaultValue = void 0;
        }
        applyUpdate(e, t) {
          return BC(e, t);
        }
        validate(e) {
          return this.defaultValue;
        }
      }
      class Sg {
        constructor(e, t, i, n) {
          this.id = e, this.name = t, this.defaultValue = i, this.schema = n;
        }
        applyUpdate(e, t) {
          return BC(e, t);
        }
        validate(e) {
          return typeof e > "u" ? this.defaultValue : e;
        }
        compute(e, t, i) {
          return i;
        }
      }
      function Ee(s, e) {
        return typeof s > "u" ? e : s === "false" ? false : !!s;
      }
      class ht extends Sg {
        constructor(e, t, i, n = void 0) {
          typeof n < "u" && (n.type = "boolean", n.default = i), super(e, t, i, n);
        }
        validate(e) {
          return Ee(e, this.defaultValue);
        }
      }
      function $u(s, e, t, i) {
        if (typeof s > "u") return e;
        let n = parseInt(s, 10);
        return isNaN(n) ? e : (n = Math.max(t, n), n = Math.min(i, n), n | 0);
      }
      class Ut extends Sg {
        static clampedInt(e, t, i, n) {
          return $u(e, t, i, n);
        }
        constructor(e, t, i, n, o, r = void 0) {
          typeof r < "u" && (r.type = "integer", r.default = i, r.minimum = n, r.maximum = o), super(e, t, i, r), this.minimum = n, this.maximum = o;
        }
        validate(e) {
          return Ut.clampedInt(e, this.defaultValue, this.minimum, this.maximum);
        }
      }
      function UU(s, e, t, i) {
        if (typeof s > "u") return e;
        const n = co.float(s, e);
        return co.clamp(n, t, i);
      }
      class co extends Sg {
        static clamp(e, t, i) {
          return e < t ? t : e > i ? i : e;
        }
        static float(e, t) {
          if (typeof e == "number") return e;
          if (typeof e > "u") return t;
          const i = parseFloat(e);
          return isNaN(i) ? t : i;
        }
        constructor(e, t, i, n, o) {
          typeof o < "u" && (o.type = "number", o.default = i), super(e, t, i, o), this.validationFn = n;
        }
        validate(e) {
          return this.validationFn(co.float(e, this.defaultValue));
        }
      }
      class ts extends Sg {
        static string(e, t) {
          return typeof e != "string" ? t : e;
        }
        constructor(e, t, i, n = void 0) {
          typeof n < "u" && (n.type = "string", n.default = i), super(e, t, i, n);
        }
        validate(e) {
          return ts.string(e, this.defaultValue);
        }
      }
      function di(s, e, t, i) {
        return typeof s != "string" ? e : i && s in i ? i[s] : t.indexOf(s) === -1 ? e : s;
      }
      class hi extends Sg {
        constructor(e, t, i, n, o = void 0) {
          typeof o < "u" && (o.type = "string", o.enum = n, o.default = i), super(e, t, i, o), this._allowedValues = n;
        }
        validate(e) {
          return di(e, this.defaultValue, this._allowedValues);
        }
      }
      class wb extends oi {
        constructor(e, t, i, n, o, r, a = void 0) {
          typeof a < "u" && (a.type = "string", a.enum = o, a.default = n), super(e, t, i, a), this._allowedValues = o, this._convert = r;
        }
        validate(e) {
          return typeof e != "string" ? this.defaultValue : this._allowedValues.indexOf(e) === -1 ? this.defaultValue : this._convert(e);
        }
      }
      function $U(s) {
        switch (s) {
          case "none":
            return 0;
          case "keep":
            return 1;
          case "brackets":
            return 2;
          case "advanced":
            return 3;
          case "full":
            return 4;
        }
      }
      class qU extends oi {
        constructor() {
          super(2, "accessibilitySupport", 0, {
            type: "string",
            enum: [
              "auto",
              "on",
              "off"
            ],
            enumDescriptions: [
              C("accessibilitySupport.auto", "Use platform APIs to detect when a Screen Reader is attached."),
              C("accessibilitySupport.on", "Optimize for usage with a Screen Reader."),
              C("accessibilitySupport.off", "Assume a screen reader is not attached.")
            ],
            default: "auto",
            tags: [
              "accessibility"
            ],
            description: C("accessibilitySupport", "Controls if the UI should run in a mode where it is optimized for screen readers.")
          });
        }
        validate(e) {
          switch (e) {
            case "auto":
              return 0;
            case "off":
              return 1;
            case "on":
              return 2;
          }
          return this.defaultValue;
        }
        compute(e, t, i) {
          return i === 0 ? e.accessibilitySupport : i;
        }
      }
      class KU extends oi {
        constructor() {
          const e = {
            insertSpace: true,
            ignoreEmptyLines: true
          };
          super(23, "comments", e, {
            "editor.comments.insertSpace": {
              type: "boolean",
              default: e.insertSpace,
              description: C("comments.insertSpace", "Controls whether a space character is inserted when commenting.")
            },
            "editor.comments.ignoreEmptyLines": {
              type: "boolean",
              default: e.ignoreEmptyLines,
              description: C("comments.ignoreEmptyLines", "Controls if empty lines should be ignored with toggle, add or remove actions for line comments.")
            }
          });
        }
        validate(e) {
          if (!e || typeof e != "object") return this.defaultValue;
          const t = e;
          return {
            insertSpace: Ee(t.insertSpace, this.defaultValue.insertSpace),
            ignoreEmptyLines: Ee(t.ignoreEmptyLines, this.defaultValue.ignoreEmptyLines)
          };
        }
      }
      function jU(s) {
        switch (s) {
          case "blink":
            return 1;
          case "smooth":
            return 2;
          case "phase":
            return 3;
          case "expand":
            return 4;
          case "solid":
            return 5;
        }
      }
      var vn;
      (function(s) {
        s[s.Line = 1] = "Line", s[s.Block = 2] = "Block", s[s.Underline = 3] = "Underline", s[s.LineThin = 4] = "LineThin", s[s.BlockOutline = 5] = "BlockOutline", s[s.UnderlineThin = 6] = "UnderlineThin";
      })(vn || (vn = {}));
      function GU(s) {
        switch (s) {
          case "line":
            return vn.Line;
          case "block":
            return vn.Block;
          case "underline":
            return vn.Underline;
          case "line-thin":
            return vn.LineThin;
          case "block-outline":
            return vn.BlockOutline;
          case "underline-thin":
            return vn.UnderlineThin;
        }
      }
      class YU extends R_ {
        constructor() {
          super(143);
        }
        compute(e, t, i) {
          const n = [
            "monaco-editor"
          ];
          return t.get(39) && n.push(t.get(39)), e.extraEditorClassName && n.push(e.extraEditorClassName), t.get(74) === "default" ? n.push("mouse-default") : t.get(74) === "copy" && n.push("mouse-copy"), t.get(112) && n.push("showUnused"), t.get(141) && n.push("showDeprecated"), n.join(" ");
        }
      }
      class ZU extends ht {
        constructor() {
          super(37, "emptySelectionClipboard", true, {
            description: C("emptySelectionClipboard", "Controls whether copying without a selection copies the current line.")
          });
        }
        compute(e, t, i) {
          return i && e.emptySelectionClipboard;
        }
      }
      class QU extends oi {
        constructor() {
          const e = {
            cursorMoveOnType: true,
            seedSearchStringFromSelection: "always",
            autoFindInSelection: "never",
            globalFindClipboard: false,
            addExtraSpaceOnTop: true,
            loop: true
          };
          super(41, "find", e, {
            "editor.find.cursorMoveOnType": {
              type: "boolean",
              default: e.cursorMoveOnType,
              description: C("find.cursorMoveOnType", "Controls whether the cursor should jump to find matches while typing.")
            },
            "editor.find.seedSearchStringFromSelection": {
              type: "string",
              enum: [
                "never",
                "always",
                "selection"
              ],
              default: e.seedSearchStringFromSelection,
              enumDescriptions: [
                C("editor.find.seedSearchStringFromSelection.never", "Never seed search string from the editor selection."),
                C("editor.find.seedSearchStringFromSelection.always", "Always seed search string from the editor selection, including word at cursor position."),
                C("editor.find.seedSearchStringFromSelection.selection", "Only seed search string from the editor selection.")
              ],
              description: C("find.seedSearchStringFromSelection", "Controls whether the search string in the Find Widget is seeded from the editor selection.")
            },
            "editor.find.autoFindInSelection": {
              type: "string",
              enum: [
                "never",
                "always",
                "multiline"
              ],
              default: e.autoFindInSelection,
              enumDescriptions: [
                C("editor.find.autoFindInSelection.never", "Never turn on Find in Selection automatically (default)."),
                C("editor.find.autoFindInSelection.always", "Always turn on Find in Selection automatically."),
                C("editor.find.autoFindInSelection.multiline", "Turn on Find in Selection automatically when multiple lines of content are selected.")
              ],
              description: C("find.autoFindInSelection", "Controls the condition for turning on Find in Selection automatically.")
            },
            "editor.find.globalFindClipboard": {
              type: "boolean",
              default: e.globalFindClipboard,
              description: C("find.globalFindClipboard", "Controls whether the Find Widget should read or modify the shared find clipboard on macOS."),
              included: _t
            },
            "editor.find.addExtraSpaceOnTop": {
              type: "boolean",
              default: e.addExtraSpaceOnTop,
              description: C("find.addExtraSpaceOnTop", "Controls whether the Find Widget should add extra lines on top of the editor. When true, you can scroll beyond the first line when the Find Widget is visible.")
            },
            "editor.find.loop": {
              type: "boolean",
              default: e.loop,
              description: C("find.loop", "Controls whether the search automatically restarts from the beginning (or the end) when no further matches can be found.")
            }
          });
        }
        validate(e) {
          if (!e || typeof e != "object") return this.defaultValue;
          const t = e;
          return {
            cursorMoveOnType: Ee(t.cursorMoveOnType, this.defaultValue.cursorMoveOnType),
            seedSearchStringFromSelection: typeof e.seedSearchStringFromSelection == "boolean" ? e.seedSearchStringFromSelection ? "always" : "never" : di(t.seedSearchStringFromSelection, this.defaultValue.seedSearchStringFromSelection, [
              "never",
              "always",
              "selection"
            ]),
            autoFindInSelection: typeof e.autoFindInSelection == "boolean" ? e.autoFindInSelection ? "always" : "never" : di(t.autoFindInSelection, this.defaultValue.autoFindInSelection, [
              "never",
              "always",
              "multiline"
            ]),
            globalFindClipboard: Ee(t.globalFindClipboard, this.defaultValue.globalFindClipboard),
            addExtraSpaceOnTop: Ee(t.addExtraSpaceOnTop, this.defaultValue.addExtraSpaceOnTop),
            loop: Ee(t.loop, this.defaultValue.loop)
          };
        }
      }
      const _Fr = class _Fr extends oi {
        constructor() {
          super(51, "fontLigatures", _Fr.OFF, {
            anyOf: [
              {
                type: "boolean",
                description: C("fontLigatures", "Enables/Disables font ligatures ('calt' and 'liga' font features). Change this to a string for fine-grained control of the 'font-feature-settings' CSS property.")
              },
              {
                type: "string",
                description: C("fontFeatureSettings", "Explicit 'font-feature-settings' CSS property. A boolean can be passed instead if one only needs to turn on/off ligatures.")
              }
            ],
            description: C("fontLigaturesGeneral", "Configures font ligatures or font features. Can be either a boolean to enable/disable ligatures or a string for the value of the CSS 'font-feature-settings' property."),
            default: false
          });
        }
        validate(e) {
          return typeof e > "u" ? this.defaultValue : typeof e == "string" ? e === "false" || e.length === 0 ? _Fr.OFF : e === "true" ? _Fr.ON : e : e ? _Fr.ON : _Fr.OFF;
        }
      };
      _Fr.OFF = '"liga" off, "calt" off';
      _Fr.ON = '"liga" on, "calt" on';
      let Fr = _Fr;
      const _Sl = class _Sl extends oi {
        constructor() {
          super(54, "fontVariations", _Sl.OFF, {
            anyOf: [
              {
                type: "boolean",
                description: C("fontVariations", "Enables/Disables the translation from font-weight to font-variation-settings. Change this to a string for fine-grained control of the 'font-variation-settings' CSS property.")
              },
              {
                type: "string",
                description: C("fontVariationSettings", "Explicit 'font-variation-settings' CSS property. A boolean can be passed instead if one only needs to translate font-weight to font-variation-settings.")
              }
            ],
            description: C("fontVariationsGeneral", "Configures font variations. Can be either a boolean to enable/disable the translation from font-weight to font-variation-settings or a string for the value of the CSS 'font-variation-settings' property."),
            default: false
          });
        }
        validate(e) {
          return typeof e > "u" ? this.defaultValue : typeof e == "string" ? e === "false" ? _Sl.OFF : e === "true" ? _Sl.TRANSLATE : e : e ? _Sl.TRANSLATE : _Sl.OFF;
        }
        compute(e, t, i) {
          return e.fontInfo.fontVariationSettings;
        }
      };
      _Sl.OFF = "normal";
      _Sl.TRANSLATE = "translate";
      let Sl = _Sl;
      class XU extends R_ {
        constructor() {
          super(50);
        }
        compute(e, t, i) {
          return e.fontInfo;
        }
      }
      class JU extends Sg {
        constructor() {
          super(52, "fontSize", fo.fontSize, {
            type: "number",
            minimum: 6,
            maximum: 100,
            default: fo.fontSize,
            description: C("fontSize", "Controls the font size in pixels.")
          });
        }
        validate(e) {
          const t = co.float(e, this.defaultValue);
          return t === 0 ? fo.fontSize : co.clamp(t, 6, 100);
        }
        compute(e, t, i) {
          return e.fontInfo.fontSize;
        }
      }
      const _Qu = class _Qu extends oi {
        constructor() {
          super(53, "fontWeight", fo.fontWeight, {
            anyOf: [
              {
                type: "number",
                minimum: _Qu.MINIMUM_VALUE,
                maximum: _Qu.MAXIMUM_VALUE,
                errorMessage: C("fontWeightErrorMessage", 'Only "normal" and "bold" keywords or numbers between 1 and 1000 are allowed.')
              },
              {
                type: "string",
                pattern: "^(normal|bold|1000|[1-9][0-9]{0,2})$"
              },
              {
                enum: _Qu.SUGGESTION_VALUES
              }
            ],
            default: fo.fontWeight,
            description: C("fontWeight", 'Controls the font weight. Accepts "normal" and "bold" keywords or numbers between 1 and 1000.')
          });
        }
        validate(e) {
          return e === "normal" || e === "bold" ? e : String(Ut.clampedInt(e, fo.fontWeight, _Qu.MINIMUM_VALUE, _Qu.MAXIMUM_VALUE));
        }
      };
      _Qu.SUGGESTION_VALUES = [
        "normal",
        "bold",
        "100",
        "200",
        "300",
        "400",
        "500",
        "600",
        "700",
        "800",
        "900"
      ];
      _Qu.MINIMUM_VALUE = 1;
      _Qu.MAXIMUM_VALUE = 1e3;
      let Qu = _Qu;
      class e$ extends oi {
        constructor() {
          const e = {
            multiple: "peek",
            multipleDefinitions: "peek",
            multipleTypeDefinitions: "peek",
            multipleDeclarations: "peek",
            multipleImplementations: "peek",
            multipleReferences: "peek",
            multipleTests: "peek",
            alternativeDefinitionCommand: "editor.action.goToReferences",
            alternativeTypeDefinitionCommand: "editor.action.goToReferences",
            alternativeDeclarationCommand: "editor.action.goToReferences",
            alternativeImplementationCommand: "",
            alternativeReferenceCommand: "",
            alternativeTestsCommand: ""
          }, t = {
            type: "string",
            enum: [
              "peek",
              "gotoAndPeek",
              "goto"
            ],
            default: e.multiple,
            enumDescriptions: [
              C("editor.gotoLocation.multiple.peek", "Show Peek view of the results (default)"),
              C("editor.gotoLocation.multiple.gotoAndPeek", "Go to the primary result and show a Peek view"),
              C("editor.gotoLocation.multiple.goto", "Go to the primary result and enable Peek-less navigation to others")
            ]
          }, i = [
            "",
            "editor.action.referenceSearch.trigger",
            "editor.action.goToReferences",
            "editor.action.peekImplementation",
            "editor.action.goToImplementation",
            "editor.action.peekTypeDefinition",
            "editor.action.goToTypeDefinition",
            "editor.action.peekDeclaration",
            "editor.action.revealDeclaration",
            "editor.action.peekDefinition",
            "editor.action.revealDefinitionAside",
            "editor.action.revealDefinition"
          ];
          super(58, "gotoLocation", e, {
            "editor.gotoLocation.multiple": {
              deprecationMessage: C("editor.gotoLocation.multiple.deprecated", "This setting is deprecated, please use separate settings like 'editor.editor.gotoLocation.multipleDefinitions' or 'editor.editor.gotoLocation.multipleImplementations' instead.")
            },
            "editor.gotoLocation.multipleDefinitions": {
              description: C("editor.editor.gotoLocation.multipleDefinitions", "Controls the behavior the 'Go to Definition'-command when multiple target locations exist."),
              ...t
            },
            "editor.gotoLocation.multipleTypeDefinitions": {
              description: C("editor.editor.gotoLocation.multipleTypeDefinitions", "Controls the behavior the 'Go to Type Definition'-command when multiple target locations exist."),
              ...t
            },
            "editor.gotoLocation.multipleDeclarations": {
              description: C("editor.editor.gotoLocation.multipleDeclarations", "Controls the behavior the 'Go to Declaration'-command when multiple target locations exist."),
              ...t
            },
            "editor.gotoLocation.multipleImplementations": {
              description: C("editor.editor.gotoLocation.multipleImplemenattions", "Controls the behavior the 'Go to Implementations'-command when multiple target locations exist."),
              ...t
            },
            "editor.gotoLocation.multipleReferences": {
              description: C("editor.editor.gotoLocation.multipleReferences", "Controls the behavior the 'Go to References'-command when multiple target locations exist."),
              ...t
            },
            "editor.gotoLocation.alternativeDefinitionCommand": {
              type: "string",
              default: e.alternativeDefinitionCommand,
              enum: i,
              description: C("alternativeDefinitionCommand", "Alternative command id that is being executed when the result of 'Go to Definition' is the current location.")
            },
            "editor.gotoLocation.alternativeTypeDefinitionCommand": {
              type: "string",
              default: e.alternativeTypeDefinitionCommand,
              enum: i,
              description: C("alternativeTypeDefinitionCommand", "Alternative command id that is being executed when the result of 'Go to Type Definition' is the current location.")
            },
            "editor.gotoLocation.alternativeDeclarationCommand": {
              type: "string",
              default: e.alternativeDeclarationCommand,
              enum: i,
              description: C("alternativeDeclarationCommand", "Alternative command id that is being executed when the result of 'Go to Declaration' is the current location.")
            },
            "editor.gotoLocation.alternativeImplementationCommand": {
              type: "string",
              default: e.alternativeImplementationCommand,
              enum: i,
              description: C("alternativeImplementationCommand", "Alternative command id that is being executed when the result of 'Go to Implementation' is the current location.")
            },
            "editor.gotoLocation.alternativeReferenceCommand": {
              type: "string",
              default: e.alternativeReferenceCommand,
              enum: i,
              description: C("alternativeReferenceCommand", "Alternative command id that is being executed when the result of 'Go to Reference' is the current location.")
            }
          });
        }
        validate(e) {
          if (!e || typeof e != "object") return this.defaultValue;
          const t = e;
          return {
            multiple: di(t.multiple, this.defaultValue.multiple, [
              "peek",
              "gotoAndPeek",
              "goto"
            ]),
            multipleDefinitions: t.multipleDefinitions ?? di(t.multipleDefinitions, "peek", [
              "peek",
              "gotoAndPeek",
              "goto"
            ]),
            multipleTypeDefinitions: t.multipleTypeDefinitions ?? di(t.multipleTypeDefinitions, "peek", [
              "peek",
              "gotoAndPeek",
              "goto"
            ]),
            multipleDeclarations: t.multipleDeclarations ?? di(t.multipleDeclarations, "peek", [
              "peek",
              "gotoAndPeek",
              "goto"
            ]),
            multipleImplementations: t.multipleImplementations ?? di(t.multipleImplementations, "peek", [
              "peek",
              "gotoAndPeek",
              "goto"
            ]),
            multipleReferences: t.multipleReferences ?? di(t.multipleReferences, "peek", [
              "peek",
              "gotoAndPeek",
              "goto"
            ]),
            multipleTests: t.multipleTests ?? di(t.multipleTests, "peek", [
              "peek",
              "gotoAndPeek",
              "goto"
            ]),
            alternativeDefinitionCommand: ts.string(t.alternativeDefinitionCommand, this.defaultValue.alternativeDefinitionCommand),
            alternativeTypeDefinitionCommand: ts.string(t.alternativeTypeDefinitionCommand, this.defaultValue.alternativeTypeDefinitionCommand),
            alternativeDeclarationCommand: ts.string(t.alternativeDeclarationCommand, this.defaultValue.alternativeDeclarationCommand),
            alternativeImplementationCommand: ts.string(t.alternativeImplementationCommand, this.defaultValue.alternativeImplementationCommand),
            alternativeReferenceCommand: ts.string(t.alternativeReferenceCommand, this.defaultValue.alternativeReferenceCommand),
            alternativeTestsCommand: ts.string(t.alternativeTestsCommand, this.defaultValue.alternativeTestsCommand)
          };
        }
      }
      class t$ extends oi {
        constructor() {
          const e = {
            enabled: true,
            delay: 300,
            hidingDelay: 300,
            sticky: true,
            above: true
          };
          super(60, "hover", e, {
            "editor.hover.enabled": {
              type: "boolean",
              default: e.enabled,
              description: C("hover.enabled", "Controls whether the hover is shown.")
            },
            "editor.hover.delay": {
              type: "number",
              default: e.delay,
              minimum: 0,
              maximum: 1e4,
              description: C("hover.delay", "Controls the delay in milliseconds after which the hover is shown.")
            },
            "editor.hover.sticky": {
              type: "boolean",
              default: e.sticky,
              description: C("hover.sticky", "Controls whether the hover should remain visible when mouse is moved over it.")
            },
            "editor.hover.hidingDelay": {
              type: "integer",
              minimum: 0,
              default: e.hidingDelay,
              description: C("hover.hidingDelay", "Controls the delay in milliseconds after which the hover is hidden. Requires `editor.hover.sticky` to be enabled.")
            },
            "editor.hover.above": {
              type: "boolean",
              default: e.above,
              description: C("hover.above", "Prefer showing hovers above the line, if there's space.")
            }
          });
        }
        validate(e) {
          if (!e || typeof e != "object") return this.defaultValue;
          const t = e;
          return {
            enabled: Ee(t.enabled, this.defaultValue.enabled),
            delay: Ut.clampedInt(t.delay, this.defaultValue.delay, 0, 1e4),
            sticky: Ee(t.sticky, this.defaultValue.sticky),
            hidingDelay: Ut.clampedInt(t.hidingDelay, this.defaultValue.hidingDelay, 0, 6e5),
            above: Ee(t.above, this.defaultValue.above)
          };
        }
      }
      class Nf extends R_ {
        constructor() {
          super(146);
        }
        compute(e, t, i) {
          return Nf.computeLayout(t, {
            memory: e.memory,
            outerWidth: e.outerWidth,
            outerHeight: e.outerHeight,
            isDominatedByLongLines: e.isDominatedByLongLines,
            lineHeight: e.fontInfo.lineHeight,
            viewLineCount: e.viewLineCount,
            lineNumbersDigitCount: e.lineNumbersDigitCount,
            typicalHalfwidthCharacterWidth: e.fontInfo.typicalHalfwidthCharacterWidth,
            maxDigitWidth: e.fontInfo.maxDigitWidth,
            pixelRatio: e.pixelRatio,
            glyphMarginDecorationLaneCount: e.glyphMarginDecorationLaneCount
          });
        }
        static computeContainedMinimapLineCount(e) {
          const t = e.height / e.lineHeight, i = Math.floor(e.paddingTop / e.lineHeight);
          let n = Math.floor(e.paddingBottom / e.lineHeight);
          e.scrollBeyondLastLine && (n = Math.max(n, t - 1));
          const o = (i + e.viewLineCount + n) / (e.pixelRatio * e.height), r = Math.floor(e.viewLineCount / o);
          return {
            typicalViewportLineCount: t,
            extraLinesBeforeFirstLine: i,
            extraLinesBeyondLastLine: n,
            desiredRatio: o,
            minimapLineCount: r
          };
        }
        static _computeMinimapLayout(e, t) {
          const i = e.outerWidth, n = e.outerHeight, o = e.pixelRatio;
          if (!e.minimap.enabled) return {
            renderMinimap: 0,
            minimapLeft: 0,
            minimapWidth: 0,
            minimapHeightIsEditorHeight: false,
            minimapIsSampling: false,
            minimapScale: 1,
            minimapLineHeight: 1,
            minimapCanvasInnerWidth: 0,
            minimapCanvasInnerHeight: Math.floor(o * n),
            minimapCanvasOuterWidth: 0,
            minimapCanvasOuterHeight: n
          };
          const r = t.stableMinimapLayoutInput, a = r && e.outerHeight === r.outerHeight && e.lineHeight === r.lineHeight && e.typicalHalfwidthCharacterWidth === r.typicalHalfwidthCharacterWidth && e.pixelRatio === r.pixelRatio && e.scrollBeyondLastLine === r.scrollBeyondLastLine && e.paddingTop === r.paddingTop && e.paddingBottom === r.paddingBottom && e.minimap.enabled === r.minimap.enabled && e.minimap.side === r.minimap.side && e.minimap.size === r.minimap.size && e.minimap.showSlider === r.minimap.showSlider && e.minimap.renderCharacters === r.minimap.renderCharacters && e.minimap.maxColumn === r.minimap.maxColumn && e.minimap.scale === r.minimap.scale && e.verticalScrollbarWidth === r.verticalScrollbarWidth && e.isViewportWrapping === r.isViewportWrapping, l = e.lineHeight, u = e.typicalHalfwidthCharacterWidth, d = e.scrollBeyondLastLine, f = e.minimap.renderCharacters;
          let m = o >= 2 ? Math.round(e.minimap.scale * 2) : e.minimap.scale;
          const _ = e.minimap.maxColumn, b = e.minimap.size, v = e.minimap.side, y = e.verticalScrollbarWidth, x = e.viewLineCount, L = e.remainingWidth, D = e.isViewportWrapping, k = f ? 2 : 3;
          let T = Math.floor(o * n);
          const M = T / o;
          let I = false, R = false, A = k * m, Y = m / o, U = 1;
          if (b === "fill" || b === "fit") {
            const { typicalViewportLineCount: de, extraLinesBeforeFirstLine: fe, extraLinesBeyondLastLine: W, desiredRatio: ne, minimapLineCount: xe } = Nf.computeContainedMinimapLineCount({
              viewLineCount: x,
              scrollBeyondLastLine: d,
              paddingTop: e.paddingTop,
              paddingBottom: e.paddingBottom,
              height: n,
              lineHeight: l,
              pixelRatio: o
            });
            if (x / xe > 1) I = true, R = true, m = 1, A = 1, Y = m / o;
            else {
              let Ae = false, Ve = m + 1;
              if (b === "fit") {
                const We = Math.ceil((fe + x + W) * A);
                D && a && L <= t.stableFitRemainingWidth ? (Ae = true, Ve = t.stableFitMaxMinimapScale) : Ae = We > T;
              }
              if (b === "fill" || Ae) {
                I = true;
                const We = m;
                A = Math.min(l * o, Math.max(1, Math.floor(1 / ne))), D && a && L <= t.stableFitRemainingWidth && (Ve = t.stableFitMaxMinimapScale), m = Math.min(Ve, Math.max(1, Math.floor(A / k))), m > We && (U = Math.min(2, m / We)), Y = m / o / U, T = Math.ceil(Math.max(de, fe + x + W) * A), D ? (t.stableMinimapLayoutInput = e, t.stableFitRemainingWidth = L, t.stableFitMaxMinimapScale = m) : (t.stableMinimapLayoutInput = null, t.stableFitRemainingWidth = 0);
              }
            }
          }
          const j = Math.floor(_ * Y), ee = Math.min(j, Math.max(0, Math.floor((L - y - 2) * Y / (u + Y))) + ma);
          let K = Math.floor(o * ee);
          const te = K / o;
          K = Math.floor(K * U);
          const H = f ? 1 : 2, se = v === "left" ? 0 : i - ee - y;
          return {
            renderMinimap: H,
            minimapLeft: se,
            minimapWidth: ee,
            minimapHeightIsEditorHeight: I,
            minimapIsSampling: R,
            minimapScale: m,
            minimapLineHeight: A,
            minimapCanvasInnerWidth: K,
            minimapCanvasInnerHeight: T,
            minimapCanvasOuterWidth: te,
            minimapCanvasOuterHeight: M
          };
        }
        static computeLayout(e, t) {
          const i = t.outerWidth | 0, n = t.outerHeight | 0, o = t.lineHeight | 0, r = t.lineNumbersDigitCount | 0, a = t.typicalHalfwidthCharacterWidth, l = t.maxDigitWidth, u = t.pixelRatio, d = t.viewLineCount, f = e.get(138), m = f === "inherit" ? e.get(137) : f, _ = m === "inherit" ? e.get(133) : m, b = e.get(136), v = t.isDominatedByLongLines, y = e.get(57), x = e.get(68).renderType !== 0, L = e.get(69), D = e.get(106), k = e.get(84), T = e.get(73), M = e.get(104), I = M.verticalScrollbarSize, R = M.verticalHasArrows, A = M.arrowSize, Y = M.horizontalScrollbarSize, U = e.get(43), j = e.get(111) !== "never";
          let ee = e.get(66);
          U && j && (ee += 16);
          let K = 0;
          if (x) {
            const ct = Math.max(r, L);
            K = Math.round(ct * l);
          }
          let te = 0;
          y && (te = o * t.glyphMarginDecorationLaneCount);
          let H = 0, se = H + te, de = se + K, fe = de + ee;
          const W = i - te - K - ee;
          let ne = false, xe = false, ye = -1;
          m === "inherit" && v ? (ne = true, xe = true) : _ === "on" || _ === "bounded" ? xe = true : _ === "wordWrapColumn" && (ye = b);
          const Ae = Nf._computeMinimapLayout({
            outerWidth: i,
            outerHeight: n,
            lineHeight: o,
            typicalHalfwidthCharacterWidth: a,
            pixelRatio: u,
            scrollBeyondLastLine: D,
            paddingTop: k.top,
            paddingBottom: k.bottom,
            minimap: T,
            verticalScrollbarWidth: I,
            viewLineCount: d,
            remainingWidth: W,
            isViewportWrapping: xe
          }, t.memory || new r9());
          Ae.renderMinimap !== 0 && Ae.minimapLeft === 0 && (H += Ae.minimapWidth, se += Ae.minimapWidth, de += Ae.minimapWidth, fe += Ae.minimapWidth);
          const Ve = W - Ae.minimapWidth, We = Math.max(1, Math.floor((Ve - I - 2) / a)), xi = R ? A : 0;
          return xe && (ye = Math.max(1, We), _ === "bounded" && (ye = Math.min(ye, b))), {
            width: i,
            height: n,
            glyphMarginLeft: H,
            glyphMarginWidth: te,
            glyphMarginDecorationLaneCount: t.glyphMarginDecorationLaneCount,
            lineNumbersLeft: se,
            lineNumbersWidth: K,
            decorationsLeft: de,
            decorationsWidth: ee,
            contentLeft: fe,
            contentWidth: Ve,
            minimap: Ae,
            viewportColumn: We,
            isWordWrapMinified: ne,
            isViewportWrapping: xe,
            wrappingColumn: ye,
            verticalScrollbarWidth: I,
            horizontalScrollbarHeight: Y,
            overviewRuler: {
              top: xi,
              width: I,
              height: n - 2 * xi,
              right: 0
            }
          };
        }
      }
      class i$ extends oi {
        constructor() {
          super(140, "wrappingStrategy", "simple", {
            "editor.wrappingStrategy": {
              enumDescriptions: [
                C("wrappingStrategy.simple", "Assumes that all characters are of the same width. This is a fast algorithm that works correctly for monospace fonts and certain scripts (like Latin characters) where glyphs are of equal width."),
                C("wrappingStrategy.advanced", "Delegates wrapping points computation to the browser. This is a slow algorithm, that might cause freezes for large files, but it works correctly in all cases.")
              ],
              type: "string",
              enum: [
                "simple",
                "advanced"
              ],
              default: "simple",
              description: C("wrappingStrategy", "Controls the algorithm that computes wrapping points. Note that when in accessibility mode, advanced will be used for the best experience.")
            }
          });
        }
        validate(e) {
          return di(e, "simple", [
            "simple",
            "advanced"
          ]);
        }
        compute(e, t, i) {
          return t.get(2) === 2 ? "advanced" : i;
        }
      }
      var ml;
      (function(s) {
        s.Off = "off", s.OnCode = "onCode", s.On = "on";
      })(ml || (ml = {}));
      class n$ extends oi {
        constructor() {
          const e = {
            enabled: ml.OnCode
          };
          super(65, "lightbulb", e, {
            "editor.lightbulb.enabled": {
              type: "string",
              tags: [
                "experimental"
              ],
              enum: [
                ml.Off,
                ml.OnCode,
                ml.On
              ],
              default: e.enabled,
              enumDescriptions: [
                C("editor.lightbulb.enabled.off", "Disable the code action menu."),
                C("editor.lightbulb.enabled.onCode", "Show the code action menu when the cursor is on lines with code."),
                C("editor.lightbulb.enabled.on", "Show the code action menu when the cursor is on lines with code or on empty lines.")
              ],
              description: C("enabled", "Enables the Code Action lightbulb in the editor.")
            }
          });
        }
        validate(e) {
          return !e || typeof e != "object" ? this.defaultValue : {
            enabled: di(e.enabled, this.defaultValue.enabled, [
              ml.Off,
              ml.OnCode,
              ml.On
            ])
          };
        }
      }
      class s$ extends oi {
        constructor() {
          const e = {
            enabled: true,
            maxLineCount: 5,
            defaultModel: "outlineModel",
            scrollWithEditor: true
          };
          super(116, "stickyScroll", e, {
            "editor.stickyScroll.enabled": {
              type: "boolean",
              default: e.enabled,
              description: C("editor.stickyScroll.enabled", "Shows the nested current scopes during the scroll at the top of the editor."),
              tags: [
                "experimental"
              ]
            },
            "editor.stickyScroll.maxLineCount": {
              type: "number",
              default: e.maxLineCount,
              minimum: 1,
              maximum: 20,
              description: C("editor.stickyScroll.maxLineCount", "Defines the maximum number of sticky lines to show.")
            },
            "editor.stickyScroll.defaultModel": {
              type: "string",
              enum: [
                "outlineModel",
                "foldingProviderModel",
                "indentationModel"
              ],
              default: e.defaultModel,
              description: C("editor.stickyScroll.defaultModel", "Defines the model to use for determining which lines to stick. If the outline model does not exist, it will fall back on the folding provider model which falls back on the indentation model. This order is respected in all three cases.")
            },
            "editor.stickyScroll.scrollWithEditor": {
              type: "boolean",
              default: e.scrollWithEditor,
              description: C("editor.stickyScroll.scrollWithEditor", "Enable scrolling of Sticky Scroll with the editor's horizontal scrollbar.")
            }
          });
        }
        validate(e) {
          if (!e || typeof e != "object") return this.defaultValue;
          const t = e;
          return {
            enabled: Ee(t.enabled, this.defaultValue.enabled),
            maxLineCount: Ut.clampedInt(t.maxLineCount, this.defaultValue.maxLineCount, 1, 20),
            defaultModel: di(t.defaultModel, this.defaultValue.defaultModel, [
              "outlineModel",
              "foldingProviderModel",
              "indentationModel"
            ]),
            scrollWithEditor: Ee(t.scrollWithEditor, this.defaultValue.scrollWithEditor)
          };
        }
      }
      class o$ extends oi {
        constructor() {
          const e = {
            enabled: "on",
            fontSize: 0,
            fontFamily: "",
            padding: false
          };
          super(142, "inlayHints", e, {
            "editor.inlayHints.enabled": {
              type: "string",
              default: e.enabled,
              description: C("inlayHints.enable", "Enables the inlay hints in the editor."),
              enum: [
                "on",
                "onUnlessPressed",
                "offUnlessPressed",
                "off"
              ],
              markdownEnumDescriptions: [
                C("editor.inlayHints.on", "Inlay hints are enabled"),
                C("editor.inlayHints.onUnlessPressed", "Inlay hints are showing by default and hide when holding {0}", _t ? "Ctrl+Option" : "Ctrl+Alt"),
                C("editor.inlayHints.offUnlessPressed", "Inlay hints are hidden by default and show when holding {0}", _t ? "Ctrl+Option" : "Ctrl+Alt"),
                C("editor.inlayHints.off", "Inlay hints are disabled")
              ]
            },
            "editor.inlayHints.fontSize": {
              type: "number",
              default: e.fontSize,
              markdownDescription: C("inlayHints.fontSize", "Controls font size of inlay hints in the editor. As default the {0} is used when the configured value is less than {1} or greater than the editor font size.", "`#editor.fontSize#`", "`5`")
            },
            "editor.inlayHints.fontFamily": {
              type: "string",
              default: e.fontFamily,
              markdownDescription: C("inlayHints.fontFamily", "Controls font family of inlay hints in the editor. When set to empty, the {0} is used.", "`#editor.fontFamily#`")
            },
            "editor.inlayHints.padding": {
              type: "boolean",
              default: e.padding,
              description: C("inlayHints.padding", "Enables the padding around the inlay hints in the editor.")
            }
          });
        }
        validate(e) {
          if (!e || typeof e != "object") return this.defaultValue;
          const t = e;
          return typeof t.enabled == "boolean" && (t.enabled = t.enabled ? "on" : "off"), {
            enabled: di(t.enabled, this.defaultValue.enabled, [
              "on",
              "off",
              "offUnlessPressed",
              "onUnlessPressed"
            ]),
            fontSize: Ut.clampedInt(t.fontSize, this.defaultValue.fontSize, 0, 100),
            fontFamily: ts.string(t.fontFamily, this.defaultValue.fontFamily),
            padding: Ee(t.padding, this.defaultValue.padding)
          };
        }
      }
      class r$ extends oi {
        constructor() {
          super(66, "lineDecorationsWidth", 10);
        }
        validate(e) {
          return typeof e == "string" && /^\d+(\.\d+)?ch$/.test(e) ? -parseFloat(e.substring(0, e.length - 2)) : Ut.clampedInt(e, this.defaultValue, 0, 1e3);
        }
        compute(e, t, i) {
          return i < 0 ? Ut.clampedInt(-i * e.fontInfo.typicalHalfwidthCharacterWidth, this.defaultValue, 0, 1e3) : i;
        }
      }
      class a$ extends co {
        constructor() {
          super(67, "lineHeight", fo.lineHeight, (e) => co.clamp(e, 0, 150), {
            markdownDescription: C("lineHeight", `Controls the line height. 
 - Use 0 to automatically compute the line height from the font size.
 - Values between 0 and 8 will be used as a multiplier with the font size.
 - Values greater than or equal to 8 will be used as effective values.`)
          });
        }
        compute(e, t, i) {
          return e.fontInfo.lineHeight;
        }
      }
      class l$ extends oi {
        constructor() {
          const e = {
            enabled: true,
            size: "proportional",
            side: "right",
            showSlider: "mouseover",
            autohide: false,
            renderCharacters: true,
            maxColumn: 120,
            scale: 1,
            showRegionSectionHeaders: true,
            showMarkSectionHeaders: true,
            sectionHeaderFontSize: 9,
            sectionHeaderLetterSpacing: 1
          };
          super(73, "minimap", e, {
            "editor.minimap.enabled": {
              type: "boolean",
              default: e.enabled,
              description: C("minimap.enabled", "Controls whether the minimap is shown.")
            },
            "editor.minimap.autohide": {
              type: "boolean",
              default: e.autohide,
              description: C("minimap.autohide", "Controls whether the minimap is hidden automatically.")
            },
            "editor.minimap.size": {
              type: "string",
              enum: [
                "proportional",
                "fill",
                "fit"
              ],
              enumDescriptions: [
                C("minimap.size.proportional", "The minimap has the same size as the editor contents (and might scroll)."),
                C("minimap.size.fill", "The minimap will stretch or shrink as necessary to fill the height of the editor (no scrolling)."),
                C("minimap.size.fit", "The minimap will shrink as necessary to never be larger than the editor (no scrolling).")
              ],
              default: e.size,
              description: C("minimap.size", "Controls the size of the minimap.")
            },
            "editor.minimap.side": {
              type: "string",
              enum: [
                "left",
                "right"
              ],
              default: e.side,
              description: C("minimap.side", "Controls the side where to render the minimap.")
            },
            "editor.minimap.showSlider": {
              type: "string",
              enum: [
                "always",
                "mouseover"
              ],
              default: e.showSlider,
              description: C("minimap.showSlider", "Controls when the minimap slider is shown.")
            },
            "editor.minimap.scale": {
              type: "number",
              default: e.scale,
              minimum: 1,
              maximum: 3,
              enum: [
                1,
                2,
                3
              ],
              description: C("minimap.scale", "Scale of content drawn in the minimap: 1, 2 or 3.")
            },
            "editor.minimap.renderCharacters": {
              type: "boolean",
              default: e.renderCharacters,
              description: C("minimap.renderCharacters", "Render the actual characters on a line as opposed to color blocks.")
            },
            "editor.minimap.maxColumn": {
              type: "number",
              default: e.maxColumn,
              description: C("minimap.maxColumn", "Limit the width of the minimap to render at most a certain number of columns.")
            },
            "editor.minimap.showRegionSectionHeaders": {
              type: "boolean",
              default: e.showRegionSectionHeaders,
              description: C("minimap.showRegionSectionHeaders", "Controls whether named regions are shown as section headers in the minimap.")
            },
            "editor.minimap.showMarkSectionHeaders": {
              type: "boolean",
              default: e.showMarkSectionHeaders,
              description: C("minimap.showMarkSectionHeaders", "Controls whether MARK: comments are shown as section headers in the minimap.")
            },
            "editor.minimap.sectionHeaderFontSize": {
              type: "number",
              default: e.sectionHeaderFontSize,
              description: C("minimap.sectionHeaderFontSize", "Controls the font size of section headers in the minimap.")
            },
            "editor.minimap.sectionHeaderLetterSpacing": {
              type: "number",
              default: e.sectionHeaderLetterSpacing,
              description: C("minimap.sectionHeaderLetterSpacing", "Controls the amount of space (in pixels) between characters of section header. This helps the readability of the header in small font sizes.")
            }
          });
        }
        validate(e) {
          if (!e || typeof e != "object") return this.defaultValue;
          const t = e;
          return {
            enabled: Ee(t.enabled, this.defaultValue.enabled),
            autohide: Ee(t.autohide, this.defaultValue.autohide),
            size: di(t.size, this.defaultValue.size, [
              "proportional",
              "fill",
              "fit"
            ]),
            side: di(t.side, this.defaultValue.side, [
              "right",
              "left"
            ]),
            showSlider: di(t.showSlider, this.defaultValue.showSlider, [
              "always",
              "mouseover"
            ]),
            renderCharacters: Ee(t.renderCharacters, this.defaultValue.renderCharacters),
            scale: Ut.clampedInt(t.scale, 1, 1, 3),
            maxColumn: Ut.clampedInt(t.maxColumn, this.defaultValue.maxColumn, 1, 1e4),
            showRegionSectionHeaders: Ee(t.showRegionSectionHeaders, this.defaultValue.showRegionSectionHeaders),
            showMarkSectionHeaders: Ee(t.showMarkSectionHeaders, this.defaultValue.showMarkSectionHeaders),
            sectionHeaderFontSize: co.clamp(t.sectionHeaderFontSize ?? this.defaultValue.sectionHeaderFontSize, 4, 32),
            sectionHeaderLetterSpacing: co.clamp(t.sectionHeaderLetterSpacing ?? this.defaultValue.sectionHeaderLetterSpacing, 0, 5)
          };
        }
      }
      function c$(s) {
        return s === "ctrlCmd" ? _t ? "metaKey" : "ctrlKey" : "altKey";
      }
      class u$ extends oi {
        constructor() {
          super(84, "padding", {
            top: 0,
            bottom: 0
          }, {
            "editor.padding.top": {
              type: "number",
              default: 0,
              minimum: 0,
              maximum: 1e3,
              description: C("padding.top", "Controls the amount of space between the top edge of the editor and the first line.")
            },
            "editor.padding.bottom": {
              type: "number",
              default: 0,
              minimum: 0,
              maximum: 1e3,
              description: C("padding.bottom", "Controls the amount of space between the bottom edge of the editor and the last line.")
            }
          });
        }
        validate(e) {
          if (!e || typeof e != "object") return this.defaultValue;
          const t = e;
          return {
            top: Ut.clampedInt(t.top, 0, 0, 1e3),
            bottom: Ut.clampedInt(t.bottom, 0, 0, 1e3)
          };
        }
      }
      class h$ extends oi {
        constructor() {
          const e = {
            enabled: true,
            cycle: true
          };
          super(86, "parameterHints", e, {
            "editor.parameterHints.enabled": {
              type: "boolean",
              default: e.enabled,
              description: C("parameterHints.enabled", "Enables a pop-up that shows parameter documentation and type information as you type.")
            },
            "editor.parameterHints.cycle": {
              type: "boolean",
              default: e.cycle,
              description: C("parameterHints.cycle", "Controls whether the parameter hints menu cycles or closes when reaching the end of the list.")
            }
          });
        }
        validate(e) {
          if (!e || typeof e != "object") return this.defaultValue;
          const t = e;
          return {
            enabled: Ee(t.enabled, this.defaultValue.enabled),
            cycle: Ee(t.cycle, this.defaultValue.cycle)
          };
        }
      }
      class d$ extends R_ {
        constructor() {
          super(144);
        }
        compute(e, t, i) {
          return e.pixelRatio;
        }
      }
      class f$ extends oi {
        constructor() {
          super(88, "placeholder", void 0);
        }
        validate(e) {
          return typeof e > "u" ? this.defaultValue : typeof e == "string" ? e : this.defaultValue;
        }
      }
      class g$ extends oi {
        constructor() {
          const e = {
            other: "on",
            comments: "off",
            strings: "off"
          }, t = [
            {
              type: "boolean"
            },
            {
              type: "string",
              enum: [
                "on",
                "inline",
                "off"
              ],
              enumDescriptions: [
                C("on", "Quick suggestions show inside the suggest widget"),
                C("inline", "Quick suggestions show as ghost text"),
                C("off", "Quick suggestions are disabled")
              ]
            }
          ];
          super(90, "quickSuggestions", e, {
            type: "object",
            additionalProperties: false,
            properties: {
              strings: {
                anyOf: t,
                default: e.strings,
                description: C("quickSuggestions.strings", "Enable quick suggestions inside strings.")
              },
              comments: {
                anyOf: t,
                default: e.comments,
                description: C("quickSuggestions.comments", "Enable quick suggestions inside comments.")
              },
              other: {
                anyOf: t,
                default: e.other,
                description: C("quickSuggestions.other", "Enable quick suggestions outside of strings and comments.")
              }
            },
            default: e,
            markdownDescription: C("quickSuggestions", "Controls whether suggestions should automatically show up while typing. This can be controlled for typing in comments, strings, and other code. Quick suggestion can be configured to show as ghost text or with the suggest widget. Also be aware of the {0}-setting which controls if suggestions are triggered by special characters.", "`#editor.suggestOnTriggerCharacters#`")
          }), this.defaultValue = e;
        }
        validate(e) {
          if (typeof e == "boolean") {
            const u = e ? "on" : "off";
            return {
              comments: u,
              strings: u,
              other: u
            };
          }
          if (!e || typeof e != "object") return this.defaultValue;
          const { other: t, comments: i, strings: n } = e, o = [
            "on",
            "inline",
            "off"
          ];
          let r, a, l;
          return typeof t == "boolean" ? r = t ? "on" : "off" : r = di(t, this.defaultValue.other, o), typeof i == "boolean" ? a = i ? "on" : "off" : a = di(i, this.defaultValue.comments, o), typeof n == "boolean" ? l = n ? "on" : "off" : l = di(n, this.defaultValue.strings, o), {
            other: r,
            comments: a,
            strings: l
          };
        }
      }
      class m$ extends oi {
        constructor() {
          super(68, "lineNumbers", {
            renderType: 1,
            renderFn: null
          }, {
            type: "string",
            enum: [
              "off",
              "on",
              "relative",
              "interval"
            ],
            enumDescriptions: [
              C("lineNumbers.off", "Line numbers are not rendered."),
              C("lineNumbers.on", "Line numbers are rendered as absolute number."),
              C("lineNumbers.relative", "Line numbers are rendered as distance in lines to cursor position."),
              C("lineNumbers.interval", "Line numbers are rendered every 10 lines.")
            ],
            default: "on",
            description: C("lineNumbers", "Controls the display of line numbers.")
          });
        }
        validate(e) {
          let t = this.defaultValue.renderType, i = this.defaultValue.renderFn;
          return typeof e < "u" && (typeof e == "function" ? (t = 4, i = e) : e === "interval" ? t = 3 : e === "relative" ? t = 2 : e === "on" ? t = 1 : t = 0), {
            renderType: t,
            renderFn: i
          };
        }
      }
      function G0(s) {
        const e = s.get(99);
        return e === "editable" ? s.get(92) : e !== "on";
      }
      class p$ extends oi {
        constructor() {
          const e = [], t = {
            type: "number",
            description: C("rulers.size", "Number of monospace characters at which this editor ruler will render.")
          };
          super(103, "rulers", e, {
            type: "array",
            items: {
              anyOf: [
                t,
                {
                  type: [
                    "object"
                  ],
                  properties: {
                    column: t,
                    color: {
                      type: "string",
                      description: C("rulers.color", "Color of this editor ruler."),
                      format: "color-hex"
                    }
                  }
                }
              ]
            },
            default: e,
            description: C("rulers", "Render vertical rulers after a certain number of monospace characters. Use multiple values for multiple rulers. No rulers are drawn if array is empty.")
          });
        }
        validate(e) {
          if (Array.isArray(e)) {
            const t = [];
            for (const i of e) if (typeof i == "number") t.push({
              column: Ut.clampedInt(i, 0, 0, 1e4),
              color: null
            });
            else if (i && typeof i == "object") {
              const n = i;
              t.push({
                column: Ut.clampedInt(n.column, 0, 0, 1e4),
                color: n.color
              });
            }
            return t.sort((i, n) => i.column - n.column), t;
          }
          return this.defaultValue;
        }
      }
      class _$ extends oi {
        constructor() {
          super(93, "readOnlyMessage", void 0);
        }
        validate(e) {
          return !e || typeof e != "object" ? this.defaultValue : e;
        }
      }
      function E4(s, e) {
        if (typeof s != "string") return e;
        switch (s) {
          case "hidden":
            return 2;
          case "visible":
            return 3;
          default:
            return 1;
        }
      }
      let b$ = class extends oi {
        constructor() {
          const e = {
            vertical: 1,
            horizontal: 1,
            arrowSize: 11,
            useShadows: true,
            verticalHasArrows: false,
            horizontalHasArrows: false,
            horizontalScrollbarSize: 12,
            horizontalSliderSize: 12,
            verticalScrollbarSize: 14,
            verticalSliderSize: 14,
            handleMouseWheel: true,
            alwaysConsumeMouseWheel: true,
            scrollByPage: false,
            ignoreHorizontalScrollbarInContentHeight: false
          };
          super(104, "scrollbar", e, {
            "editor.scrollbar.vertical": {
              type: "string",
              enum: [
                "auto",
                "visible",
                "hidden"
              ],
              enumDescriptions: [
                C("scrollbar.vertical.auto", "The vertical scrollbar will be visible only when necessary."),
                C("scrollbar.vertical.visible", "The vertical scrollbar will always be visible."),
                C("scrollbar.vertical.fit", "The vertical scrollbar will always be hidden.")
              ],
              default: "auto",
              description: C("scrollbar.vertical", "Controls the visibility of the vertical scrollbar.")
            },
            "editor.scrollbar.horizontal": {
              type: "string",
              enum: [
                "auto",
                "visible",
                "hidden"
              ],
              enumDescriptions: [
                C("scrollbar.horizontal.auto", "The horizontal scrollbar will be visible only when necessary."),
                C("scrollbar.horizontal.visible", "The horizontal scrollbar will always be visible."),
                C("scrollbar.horizontal.fit", "The horizontal scrollbar will always be hidden.")
              ],
              default: "auto",
              description: C("scrollbar.horizontal", "Controls the visibility of the horizontal scrollbar.")
            },
            "editor.scrollbar.verticalScrollbarSize": {
              type: "number",
              default: e.verticalScrollbarSize,
              description: C("scrollbar.verticalScrollbarSize", "The width of the vertical scrollbar.")
            },
            "editor.scrollbar.horizontalScrollbarSize": {
              type: "number",
              default: e.horizontalScrollbarSize,
              description: C("scrollbar.horizontalScrollbarSize", "The height of the horizontal scrollbar.")
            },
            "editor.scrollbar.scrollByPage": {
              type: "boolean",
              default: e.scrollByPage,
              description: C("scrollbar.scrollByPage", "Controls whether clicks scroll by page or jump to click position.")
            },
            "editor.scrollbar.ignoreHorizontalScrollbarInContentHeight": {
              type: "boolean",
              default: e.ignoreHorizontalScrollbarInContentHeight,
              description: C("scrollbar.ignoreHorizontalScrollbarInContentHeight", "When set, the horizontal scrollbar will not increase the size of the editor's content.")
            }
          });
        }
        validate(e) {
          if (!e || typeof e != "object") return this.defaultValue;
          const t = e, i = Ut.clampedInt(t.horizontalScrollbarSize, this.defaultValue.horizontalScrollbarSize, 0, 1e3), n = Ut.clampedInt(t.verticalScrollbarSize, this.defaultValue.verticalScrollbarSize, 0, 1e3);
          return {
            arrowSize: Ut.clampedInt(t.arrowSize, this.defaultValue.arrowSize, 0, 1e3),
            vertical: E4(t.vertical, this.defaultValue.vertical),
            horizontal: E4(t.horizontal, this.defaultValue.horizontal),
            useShadows: Ee(t.useShadows, this.defaultValue.useShadows),
            verticalHasArrows: Ee(t.verticalHasArrows, this.defaultValue.verticalHasArrows),
            horizontalHasArrows: Ee(t.horizontalHasArrows, this.defaultValue.horizontalHasArrows),
            handleMouseWheel: Ee(t.handleMouseWheel, this.defaultValue.handleMouseWheel),
            alwaysConsumeMouseWheel: Ee(t.alwaysConsumeMouseWheel, this.defaultValue.alwaysConsumeMouseWheel),
            horizontalScrollbarSize: i,
            horizontalSliderSize: Ut.clampedInt(t.horizontalSliderSize, i, 0, 1e3),
            verticalScrollbarSize: n,
            verticalSliderSize: Ut.clampedInt(t.verticalSliderSize, n, 0, 1e3),
            scrollByPage: Ee(t.scrollByPage, this.defaultValue.scrollByPage),
            ignoreHorizontalScrollbarInContentHeight: Ee(t.ignoreHorizontalScrollbarInContentHeight, this.defaultValue.ignoreHorizontalScrollbarInContentHeight)
          };
        }
      };
      const Dr = "inUntrustedWorkspace", Pu = {
        allowedCharacters: "editor.unicodeHighlight.allowedCharacters",
        invisibleCharacters: "editor.unicodeHighlight.invisibleCharacters",
        nonBasicASCII: "editor.unicodeHighlight.nonBasicASCII",
        ambiguousCharacters: "editor.unicodeHighlight.ambiguousCharacters",
        includeComments: "editor.unicodeHighlight.includeComments",
        includeStrings: "editor.unicodeHighlight.includeStrings",
        allowedLocales: "editor.unicodeHighlight.allowedLocales"
      };
      class v$ extends oi {
        constructor() {
          const e = {
            nonBasicASCII: Dr,
            invisibleCharacters: true,
            ambiguousCharacters: true,
            includeComments: Dr,
            includeStrings: true,
            allowedCharacters: {},
            allowedLocales: {
              _os: true,
              _vscode: true
            }
          };
          super(126, "unicodeHighlight", e, {
            [Pu.nonBasicASCII]: {
              restricted: true,
              type: [
                "boolean",
                "string"
              ],
              enum: [
                true,
                false,
                Dr
              ],
              default: e.nonBasicASCII,
              description: C("unicodeHighlight.nonBasicASCII", "Controls whether all non-basic ASCII characters are highlighted. Only characters between U+0020 and U+007E, tab, line-feed and carriage-return are considered basic ASCII.")
            },
            [Pu.invisibleCharacters]: {
              restricted: true,
              type: "boolean",
              default: e.invisibleCharacters,
              description: C("unicodeHighlight.invisibleCharacters", "Controls whether characters that just reserve space or have no width at all are highlighted.")
            },
            [Pu.ambiguousCharacters]: {
              restricted: true,
              type: "boolean",
              default: e.ambiguousCharacters,
              description: C("unicodeHighlight.ambiguousCharacters", "Controls whether characters are highlighted that can be confused with basic ASCII characters, except those that are common in the current user locale.")
            },
            [Pu.includeComments]: {
              restricted: true,
              type: [
                "boolean",
                "string"
              ],
              enum: [
                true,
                false,
                Dr
              ],
              default: e.includeComments,
              description: C("unicodeHighlight.includeComments", "Controls whether characters in comments should also be subject to Unicode highlighting.")
            },
            [Pu.includeStrings]: {
              restricted: true,
              type: [
                "boolean",
                "string"
              ],
              enum: [
                true,
                false,
                Dr
              ],
              default: e.includeStrings,
              description: C("unicodeHighlight.includeStrings", "Controls whether characters in strings should also be subject to Unicode highlighting.")
            },
            [Pu.allowedCharacters]: {
              restricted: true,
              type: "object",
              default: e.allowedCharacters,
              description: C("unicodeHighlight.allowedCharacters", "Defines allowed characters that are not being highlighted."),
              additionalProperties: {
                type: "boolean"
              }
            },
            [Pu.allowedLocales]: {
              restricted: true,
              type: "object",
              additionalProperties: {
                type: "boolean"
              },
              default: e.allowedLocales,
              description: C("unicodeHighlight.allowedLocales", "Unicode characters that are common in allowed locales are not being highlighted.")
            }
          });
        }
        applyUpdate(e, t) {
          let i = false;
          t.allowedCharacters && e && ($s(e.allowedCharacters, t.allowedCharacters) || (e = {
            ...e,
            allowedCharacters: t.allowedCharacters
          }, i = true)), t.allowedLocales && e && ($s(e.allowedLocales, t.allowedLocales) || (e = {
            ...e,
            allowedLocales: t.allowedLocales
          }, i = true));
          const n = super.applyUpdate(e, t);
          return i ? new gp(n.newValue, true) : n;
        }
        validate(e) {
          if (!e || typeof e != "object") return this.defaultValue;
          const t = e;
          return {
            nonBasicASCII: If(t.nonBasicASCII, Dr, [
              true,
              false,
              Dr
            ]),
            invisibleCharacters: Ee(t.invisibleCharacters, this.defaultValue.invisibleCharacters),
            ambiguousCharacters: Ee(t.ambiguousCharacters, this.defaultValue.ambiguousCharacters),
            includeComments: If(t.includeComments, Dr, [
              true,
              false,
              Dr
            ]),
            includeStrings: If(t.includeStrings, Dr, [
              true,
              false,
              Dr
            ]),
            allowedCharacters: this.validateBooleanMap(e.allowedCharacters, this.defaultValue.allowedCharacters),
            allowedLocales: this.validateBooleanMap(e.allowedLocales, this.defaultValue.allowedLocales)
          };
        }
        validateBooleanMap(e, t) {
          if (typeof e != "object" || !e) return t;
          const i = {};
          for (const [n, o] of Object.entries(e)) o === true && (i[n] = true);
          return i;
        }
      }
      class C$ extends oi {
        constructor() {
          const e = {
            enabled: true,
            mode: "subwordSmart",
            showToolbar: "onHover",
            suppressSuggestions: false,
            keepOnBlur: false,
            fontFamily: "default"
          };
          super(62, "inlineSuggest", e, {
            "editor.inlineSuggest.enabled": {
              type: "boolean",
              default: e.enabled,
              description: C("inlineSuggest.enabled", "Controls whether to automatically show inline suggestions in the editor.")
            },
            "editor.inlineSuggest.showToolbar": {
              type: "string",
              default: e.showToolbar,
              enum: [
                "always",
                "onHover",
                "never"
              ],
              enumDescriptions: [
                C("inlineSuggest.showToolbar.always", "Show the inline suggestion toolbar whenever an inline suggestion is shown."),
                C("inlineSuggest.showToolbar.onHover", "Show the inline suggestion toolbar when hovering over an inline suggestion."),
                C("inlineSuggest.showToolbar.never", "Never show the inline suggestion toolbar.")
              ],
              description: C("inlineSuggest.showToolbar", "Controls when to show the inline suggestion toolbar.")
            },
            "editor.inlineSuggest.suppressSuggestions": {
              type: "boolean",
              default: e.suppressSuggestions,
              description: C("inlineSuggest.suppressSuggestions", "Controls how inline suggestions interact with the suggest widget. If enabled, the suggest widget is not shown automatically when inline suggestions are available.")
            },
            "editor.inlineSuggest.fontFamily": {
              type: "string",
              default: e.fontFamily,
              description: C("inlineSuggest.fontFamily", "Controls the font family of the inline suggestions.")
            }
          });
        }
        validate(e) {
          if (!e || typeof e != "object") return this.defaultValue;
          const t = e;
          return {
            enabled: Ee(t.enabled, this.defaultValue.enabled),
            mode: di(t.mode, this.defaultValue.mode, [
              "prefix",
              "subword",
              "subwordSmart"
            ]),
            showToolbar: di(t.showToolbar, this.defaultValue.showToolbar, [
              "always",
              "onHover",
              "never"
            ]),
            suppressSuggestions: Ee(t.suppressSuggestions, this.defaultValue.suppressSuggestions),
            keepOnBlur: Ee(t.keepOnBlur, this.defaultValue.keepOnBlur),
            fontFamily: ts.string(t.fontFamily, this.defaultValue.fontFamily)
          };
        }
      }
      class w$ extends oi {
        constructor() {
          const e = {
            enabled: false,
            showToolbar: "onHover",
            fontFamily: "default",
            keepOnBlur: false
          };
          super(63, "experimentalInlineEdit", e, {
            "editor.experimentalInlineEdit.enabled": {
              type: "boolean",
              default: e.enabled,
              description: C("inlineEdit.enabled", "Controls whether to show inline edits in the editor.")
            },
            "editor.experimentalInlineEdit.showToolbar": {
              type: "string",
              default: e.showToolbar,
              enum: [
                "always",
                "onHover",
                "never"
              ],
              enumDescriptions: [
                C("inlineEdit.showToolbar.always", "Show the inline edit toolbar whenever an inline suggestion is shown."),
                C("inlineEdit.showToolbar.onHover", "Show the inline edit toolbar when hovering over an inline suggestion."),
                C("inlineEdit.showToolbar.never", "Never show the inline edit toolbar.")
              ],
              description: C("inlineEdit.showToolbar", "Controls when to show the inline edit toolbar.")
            },
            "editor.experimentalInlineEdit.fontFamily": {
              type: "string",
              default: e.fontFamily,
              description: C("inlineEdit.fontFamily", "Controls the font family of the inline edit.")
            }
          });
        }
        validate(e) {
          if (!e || typeof e != "object") return this.defaultValue;
          const t = e;
          return {
            enabled: Ee(t.enabled, this.defaultValue.enabled),
            showToolbar: di(t.showToolbar, this.defaultValue.showToolbar, [
              "always",
              "onHover",
              "never"
            ]),
            fontFamily: ts.string(t.fontFamily, this.defaultValue.fontFamily),
            keepOnBlur: Ee(t.keepOnBlur, this.defaultValue.keepOnBlur)
          };
        }
      }
      class y$ extends oi {
        constructor() {
          const e = {
            enabled: zn.bracketPairColorizationOptions.enabled,
            independentColorPoolPerBracketType: zn.bracketPairColorizationOptions.independentColorPoolPerBracketType
          };
          super(15, "bracketPairColorization", e, {
            "editor.bracketPairColorization.enabled": {
              type: "boolean",
              default: e.enabled,
              markdownDescription: C("bracketPairColorization.enabled", "Controls whether bracket pair colorization is enabled or not. Use {0} to override the bracket highlight colors.", "`#workbench.colorCustomizations#`")
            },
            "editor.bracketPairColorization.independentColorPoolPerBracketType": {
              type: "boolean",
              default: e.independentColorPoolPerBracketType,
              description: C("bracketPairColorization.independentColorPoolPerBracketType", "Controls whether each bracket type has its own independent color pool.")
            }
          });
        }
        validate(e) {
          if (!e || typeof e != "object") return this.defaultValue;
          const t = e;
          return {
            enabled: Ee(t.enabled, this.defaultValue.enabled),
            independentColorPoolPerBracketType: Ee(t.independentColorPoolPerBracketType, this.defaultValue.independentColorPoolPerBracketType)
          };
        }
      }
      class S$ extends oi {
        constructor() {
          const e = {
            bracketPairs: false,
            bracketPairsHorizontal: "active",
            highlightActiveBracketPair: true,
            indentation: true,
            highlightActiveIndentation: true
          };
          super(16, "guides", e, {
            "editor.guides.bracketPairs": {
              type: [
                "boolean",
                "string"
              ],
              enum: [
                true,
                "active",
                false
              ],
              enumDescriptions: [
                C("editor.guides.bracketPairs.true", "Enables bracket pair guides."),
                C("editor.guides.bracketPairs.active", "Enables bracket pair guides only for the active bracket pair."),
                C("editor.guides.bracketPairs.false", "Disables bracket pair guides.")
              ],
              default: e.bracketPairs,
              description: C("editor.guides.bracketPairs", "Controls whether bracket pair guides are enabled or not.")
            },
            "editor.guides.bracketPairsHorizontal": {
              type: [
                "boolean",
                "string"
              ],
              enum: [
                true,
                "active",
                false
              ],
              enumDescriptions: [
                C("editor.guides.bracketPairsHorizontal.true", "Enables horizontal guides as addition to vertical bracket pair guides."),
                C("editor.guides.bracketPairsHorizontal.active", "Enables horizontal guides only for the active bracket pair."),
                C("editor.guides.bracketPairsHorizontal.false", "Disables horizontal bracket pair guides.")
              ],
              default: e.bracketPairsHorizontal,
              description: C("editor.guides.bracketPairsHorizontal", "Controls whether horizontal bracket pair guides are enabled or not.")
            },
            "editor.guides.highlightActiveBracketPair": {
              type: "boolean",
              default: e.highlightActiveBracketPair,
              description: C("editor.guides.highlightActiveBracketPair", "Controls whether the editor should highlight the active bracket pair.")
            },
            "editor.guides.indentation": {
              type: "boolean",
              default: e.indentation,
              description: C("editor.guides.indentation", "Controls whether the editor should render indent guides.")
            },
            "editor.guides.highlightActiveIndentation": {
              type: [
                "boolean",
                "string"
              ],
              enum: [
                true,
                "always",
                false
              ],
              enumDescriptions: [
                C("editor.guides.highlightActiveIndentation.true", "Highlights the active indent guide."),
                C("editor.guides.highlightActiveIndentation.always", "Highlights the active indent guide even if bracket guides are highlighted."),
                C("editor.guides.highlightActiveIndentation.false", "Do not highlight the active indent guide.")
              ],
              default: e.highlightActiveIndentation,
              description: C("editor.guides.highlightActiveIndentation", "Controls whether the editor should highlight the active indent guide.")
            }
          });
        }
        validate(e) {
          if (!e || typeof e != "object") return this.defaultValue;
          const t = e;
          return {
            bracketPairs: If(t.bracketPairs, this.defaultValue.bracketPairs, [
              true,
              false,
              "active"
            ]),
            bracketPairsHorizontal: If(t.bracketPairsHorizontal, this.defaultValue.bracketPairsHorizontal, [
              true,
              false,
              "active"
            ]),
            highlightActiveBracketPair: Ee(t.highlightActiveBracketPair, this.defaultValue.highlightActiveBracketPair),
            indentation: Ee(t.indentation, this.defaultValue.indentation),
            highlightActiveIndentation: If(t.highlightActiveIndentation, this.defaultValue.highlightActiveIndentation, [
              true,
              false,
              "always"
            ])
          };
        }
      }
      function If(s, e, t) {
        const i = t.indexOf(s);
        return i === -1 ? e : t[i];
      }
      class L$ extends oi {
        constructor() {
          const e = {
            insertMode: "insert",
            filterGraceful: true,
            snippetsPreventQuickSuggestions: false,
            localityBonus: false,
            shareSuggestSelections: false,
            selectionMode: "always",
            showIcons: true,
            showStatusBar: false,
            preview: false,
            previewMode: "subwordSmart",
            showInlineDetails: true,
            showMethods: true,
            showFunctions: true,
            showConstructors: true,
            showDeprecated: true,
            matchOnWordStartOnly: true,
            showFields: true,
            showVariables: true,
            showClasses: true,
            showStructs: true,
            showInterfaces: true,
            showModules: true,
            showProperties: true,
            showEvents: true,
            showOperators: true,
            showUnits: true,
            showValues: true,
            showConstants: true,
            showEnums: true,
            showEnumMembers: true,
            showKeywords: true,
            showWords: true,
            showColors: true,
            showFiles: true,
            showReferences: true,
            showFolders: true,
            showTypeParameters: true,
            showSnippets: true,
            showUsers: true,
            showIssues: true
          };
          super(119, "suggest", e, {
            "editor.suggest.insertMode": {
              type: "string",
              enum: [
                "insert",
                "replace"
              ],
              enumDescriptions: [
                C("suggest.insertMode.insert", "Insert suggestion without overwriting text right of the cursor."),
                C("suggest.insertMode.replace", "Insert suggestion and overwrite text right of the cursor.")
              ],
              default: e.insertMode,
              description: C("suggest.insertMode", "Controls whether words are overwritten when accepting completions. Note that this depends on extensions opting into this feature.")
            },
            "editor.suggest.filterGraceful": {
              type: "boolean",
              default: e.filterGraceful,
              description: C("suggest.filterGraceful", "Controls whether filtering and sorting suggestions accounts for small typos.")
            },
            "editor.suggest.localityBonus": {
              type: "boolean",
              default: e.localityBonus,
              description: C("suggest.localityBonus", "Controls whether sorting favors words that appear close to the cursor.")
            },
            "editor.suggest.shareSuggestSelections": {
              type: "boolean",
              default: e.shareSuggestSelections,
              markdownDescription: C("suggest.shareSuggestSelections", "Controls whether remembered suggestion selections are shared between multiple workspaces and windows (needs `#editor.suggestSelection#`).")
            },
            "editor.suggest.selectionMode": {
              type: "string",
              enum: [
                "always",
                "never",
                "whenTriggerCharacter",
                "whenQuickSuggestion"
              ],
              enumDescriptions: [
                C("suggest.insertMode.always", "Always select a suggestion when automatically triggering IntelliSense."),
                C("suggest.insertMode.never", "Never select a suggestion when automatically triggering IntelliSense."),
                C("suggest.insertMode.whenTriggerCharacter", "Select a suggestion only when triggering IntelliSense from a trigger character."),
                C("suggest.insertMode.whenQuickSuggestion", "Select a suggestion only when triggering IntelliSense as you type.")
              ],
              default: e.selectionMode,
              markdownDescription: C("suggest.selectionMode", "Controls whether a suggestion is selected when the widget shows. Note that this only applies to automatically triggered suggestions ({0} and {1}) and that a suggestion is always selected when explicitly invoked, e.g via `Ctrl+Space`.", "`#editor.quickSuggestions#`", "`#editor.suggestOnTriggerCharacters#`")
            },
            "editor.suggest.snippetsPreventQuickSuggestions": {
              type: "boolean",
              default: e.snippetsPreventQuickSuggestions,
              description: C("suggest.snippetsPreventQuickSuggestions", "Controls whether an active snippet prevents quick suggestions.")
            },
            "editor.suggest.showIcons": {
              type: "boolean",
              default: e.showIcons,
              description: C("suggest.showIcons", "Controls whether to show or hide icons in suggestions.")
            },
            "editor.suggest.showStatusBar": {
              type: "boolean",
              default: e.showStatusBar,
              description: C("suggest.showStatusBar", "Controls the visibility of the status bar at the bottom of the suggest widget.")
            },
            "editor.suggest.preview": {
              type: "boolean",
              default: e.preview,
              description: C("suggest.preview", "Controls whether to preview the suggestion outcome in the editor.")
            },
            "editor.suggest.showInlineDetails": {
              type: "boolean",
              default: e.showInlineDetails,
              description: C("suggest.showInlineDetails", "Controls whether suggest details show inline with the label or only in the details widget.")
            },
            "editor.suggest.maxVisibleSuggestions": {
              type: "number",
              deprecationMessage: C("suggest.maxVisibleSuggestions.dep", "This setting is deprecated. The suggest widget can now be resized.")
            },
            "editor.suggest.filteredTypes": {
              type: "object",
              deprecationMessage: C("deprecated", "This setting is deprecated, please use separate settings like 'editor.suggest.showKeywords' or 'editor.suggest.showSnippets' instead.")
            },
            "editor.suggest.showMethods": {
              type: "boolean",
              default: true,
              markdownDescription: C("editor.suggest.showMethods", "When enabled IntelliSense shows `method`-suggestions.")
            },
            "editor.suggest.showFunctions": {
              type: "boolean",
              default: true,
              markdownDescription: C("editor.suggest.showFunctions", "When enabled IntelliSense shows `function`-suggestions.")
            },
            "editor.suggest.showConstructors": {
              type: "boolean",
              default: true,
              markdownDescription: C("editor.suggest.showConstructors", "When enabled IntelliSense shows `constructor`-suggestions.")
            },
            "editor.suggest.showDeprecated": {
              type: "boolean",
              default: true,
              markdownDescription: C("editor.suggest.showDeprecated", "When enabled IntelliSense shows `deprecated`-suggestions.")
            },
            "editor.suggest.matchOnWordStartOnly": {
              type: "boolean",
              default: true,
              markdownDescription: C("editor.suggest.matchOnWordStartOnly", "When enabled IntelliSense filtering requires that the first character matches on a word start. For example, `c` on `Console` or `WebContext` but _not_ on `description`. When disabled IntelliSense will show more results but still sorts them by match quality.")
            },
            "editor.suggest.showFields": {
              type: "boolean",
              default: true,
              markdownDescription: C("editor.suggest.showFields", "When enabled IntelliSense shows `field`-suggestions.")
            },
            "editor.suggest.showVariables": {
              type: "boolean",
              default: true,
              markdownDescription: C("editor.suggest.showVariables", "When enabled IntelliSense shows `variable`-suggestions.")
            },
            "editor.suggest.showClasses": {
              type: "boolean",
              default: true,
              markdownDescription: C("editor.suggest.showClasss", "When enabled IntelliSense shows `class`-suggestions.")
            },
            "editor.suggest.showStructs": {
              type: "boolean",
              default: true,
              markdownDescription: C("editor.suggest.showStructs", "When enabled IntelliSense shows `struct`-suggestions.")
            },
            "editor.suggest.showInterfaces": {
              type: "boolean",
              default: true,
              markdownDescription: C("editor.suggest.showInterfaces", "When enabled IntelliSense shows `interface`-suggestions.")
            },
            "editor.suggest.showModules": {
              type: "boolean",
              default: true,
              markdownDescription: C("editor.suggest.showModules", "When enabled IntelliSense shows `module`-suggestions.")
            },
            "editor.suggest.showProperties": {
              type: "boolean",
              default: true,
              markdownDescription: C("editor.suggest.showPropertys", "When enabled IntelliSense shows `property`-suggestions.")
            },
            "editor.suggest.showEvents": {
              type: "boolean",
              default: true,
              markdownDescription: C("editor.suggest.showEvents", "When enabled IntelliSense shows `event`-suggestions.")
            },
            "editor.suggest.showOperators": {
              type: "boolean",
              default: true,
              markdownDescription: C("editor.suggest.showOperators", "When enabled IntelliSense shows `operator`-suggestions.")
            },
            "editor.suggest.showUnits": {
              type: "boolean",
              default: true,
              markdownDescription: C("editor.suggest.showUnits", "When enabled IntelliSense shows `unit`-suggestions.")
            },
            "editor.suggest.showValues": {
              type: "boolean",
              default: true,
              markdownDescription: C("editor.suggest.showValues", "When enabled IntelliSense shows `value`-suggestions.")
            },
            "editor.suggest.showConstants": {
              type: "boolean",
              default: true,
              markdownDescription: C("editor.suggest.showConstants", "When enabled IntelliSense shows `constant`-suggestions.")
            },
            "editor.suggest.showEnums": {
              type: "boolean",
              default: true,
              markdownDescription: C("editor.suggest.showEnums", "When enabled IntelliSense shows `enum`-suggestions.")
            },
            "editor.suggest.showEnumMembers": {
              type: "boolean",
              default: true,
              markdownDescription: C("editor.suggest.showEnumMembers", "When enabled IntelliSense shows `enumMember`-suggestions.")
            },
            "editor.suggest.showKeywords": {
              type: "boolean",
              default: true,
              markdownDescription: C("editor.suggest.showKeywords", "When enabled IntelliSense shows `keyword`-suggestions.")
            },
            "editor.suggest.showWords": {
              type: "boolean",
              default: true,
              markdownDescription: C("editor.suggest.showTexts", "When enabled IntelliSense shows `text`-suggestions.")
            },
            "editor.suggest.showColors": {
              type: "boolean",
              default: true,
              markdownDescription: C("editor.suggest.showColors", "When enabled IntelliSense shows `color`-suggestions.")
            },
            "editor.suggest.showFiles": {
              type: "boolean",
              default: true,
              markdownDescription: C("editor.suggest.showFiles", "When enabled IntelliSense shows `file`-suggestions.")
            },
            "editor.suggest.showReferences": {
              type: "boolean",
              default: true,
              markdownDescription: C("editor.suggest.showReferences", "When enabled IntelliSense shows `reference`-suggestions.")
            },
            "editor.suggest.showCustomcolors": {
              type: "boolean",
              default: true,
              markdownDescription: C("editor.suggest.showCustomcolors", "When enabled IntelliSense shows `customcolor`-suggestions.")
            },
            "editor.suggest.showFolders": {
              type: "boolean",
              default: true,
              markdownDescription: C("editor.suggest.showFolders", "When enabled IntelliSense shows `folder`-suggestions.")
            },
            "editor.suggest.showTypeParameters": {
              type: "boolean",
              default: true,
              markdownDescription: C("editor.suggest.showTypeParameters", "When enabled IntelliSense shows `typeParameter`-suggestions.")
            },
            "editor.suggest.showSnippets": {
              type: "boolean",
              default: true,
              markdownDescription: C("editor.suggest.showSnippets", "When enabled IntelliSense shows `snippet`-suggestions.")
            },
            "editor.suggest.showUsers": {
              type: "boolean",
              default: true,
              markdownDescription: C("editor.suggest.showUsers", "When enabled IntelliSense shows `user`-suggestions.")
            },
            "editor.suggest.showIssues": {
              type: "boolean",
              default: true,
              markdownDescription: C("editor.suggest.showIssues", "When enabled IntelliSense shows `issues`-suggestions.")
            }
          });
        }
        validate(e) {
          if (!e || typeof e != "object") return this.defaultValue;
          const t = e;
          return {
            insertMode: di(t.insertMode, this.defaultValue.insertMode, [
              "insert",
              "replace"
            ]),
            filterGraceful: Ee(t.filterGraceful, this.defaultValue.filterGraceful),
            snippetsPreventQuickSuggestions: Ee(t.snippetsPreventQuickSuggestions, this.defaultValue.filterGraceful),
            localityBonus: Ee(t.localityBonus, this.defaultValue.localityBonus),
            shareSuggestSelections: Ee(t.shareSuggestSelections, this.defaultValue.shareSuggestSelections),
            selectionMode: di(t.selectionMode, this.defaultValue.selectionMode, [
              "always",
              "never",
              "whenQuickSuggestion",
              "whenTriggerCharacter"
            ]),
            showIcons: Ee(t.showIcons, this.defaultValue.showIcons),
            showStatusBar: Ee(t.showStatusBar, this.defaultValue.showStatusBar),
            preview: Ee(t.preview, this.defaultValue.preview),
            previewMode: di(t.previewMode, this.defaultValue.previewMode, [
              "prefix",
              "subword",
              "subwordSmart"
            ]),
            showInlineDetails: Ee(t.showInlineDetails, this.defaultValue.showInlineDetails),
            showMethods: Ee(t.showMethods, this.defaultValue.showMethods),
            showFunctions: Ee(t.showFunctions, this.defaultValue.showFunctions),
            showConstructors: Ee(t.showConstructors, this.defaultValue.showConstructors),
            showDeprecated: Ee(t.showDeprecated, this.defaultValue.showDeprecated),
            matchOnWordStartOnly: Ee(t.matchOnWordStartOnly, this.defaultValue.matchOnWordStartOnly),
            showFields: Ee(t.showFields, this.defaultValue.showFields),
            showVariables: Ee(t.showVariables, this.defaultValue.showVariables),
            showClasses: Ee(t.showClasses, this.defaultValue.showClasses),
            showStructs: Ee(t.showStructs, this.defaultValue.showStructs),
            showInterfaces: Ee(t.showInterfaces, this.defaultValue.showInterfaces),
            showModules: Ee(t.showModules, this.defaultValue.showModules),
            showProperties: Ee(t.showProperties, this.defaultValue.showProperties),
            showEvents: Ee(t.showEvents, this.defaultValue.showEvents),
            showOperators: Ee(t.showOperators, this.defaultValue.showOperators),
            showUnits: Ee(t.showUnits, this.defaultValue.showUnits),
            showValues: Ee(t.showValues, this.defaultValue.showValues),
            showConstants: Ee(t.showConstants, this.defaultValue.showConstants),
            showEnums: Ee(t.showEnums, this.defaultValue.showEnums),
            showEnumMembers: Ee(t.showEnumMembers, this.defaultValue.showEnumMembers),
            showKeywords: Ee(t.showKeywords, this.defaultValue.showKeywords),
            showWords: Ee(t.showWords, this.defaultValue.showWords),
            showColors: Ee(t.showColors, this.defaultValue.showColors),
            showFiles: Ee(t.showFiles, this.defaultValue.showFiles),
            showReferences: Ee(t.showReferences, this.defaultValue.showReferences),
            showFolders: Ee(t.showFolders, this.defaultValue.showFolders),
            showTypeParameters: Ee(t.showTypeParameters, this.defaultValue.showTypeParameters),
            showSnippets: Ee(t.showSnippets, this.defaultValue.showSnippets),
            showUsers: Ee(t.showUsers, this.defaultValue.showUsers),
            showIssues: Ee(t.showIssues, this.defaultValue.showIssues)
          };
        }
      }
      class x$ extends oi {
        constructor() {
          super(114, "smartSelect", {
            selectLeadingAndTrailingWhitespace: true,
            selectSubwords: true
          }, {
            "editor.smartSelect.selectLeadingAndTrailingWhitespace": {
              description: C("selectLeadingAndTrailingWhitespace", "Whether leading and trailing whitespace should always be selected."),
              default: true,
              type: "boolean"
            },
            "editor.smartSelect.selectSubwords": {
              description: C("selectSubwords", "Whether subwords (like 'foo' in 'fooBar' or 'foo_bar') should be selected."),
              default: true,
              type: "boolean"
            }
          });
        }
        validate(e) {
          return !e || typeof e != "object" ? this.defaultValue : {
            selectLeadingAndTrailingWhitespace: Ee(e.selectLeadingAndTrailingWhitespace, this.defaultValue.selectLeadingAndTrailingWhitespace),
            selectSubwords: Ee(e.selectSubwords, this.defaultValue.selectSubwords)
          };
        }
      }
      class k$ extends oi {
        constructor() {
          const e = [];
          super(131, "wordSegmenterLocales", e, {
            anyOf: [
              {
                description: C("wordSegmenterLocales", "Locales to be used for word segmentation when doing word related navigations or operations. Specify the BCP 47 language tag of the word you wish to recognize (e.g., ja, zh-CN, zh-Hant-TW, etc.)."),
                type: "string"
              },
              {
                description: C("wordSegmenterLocales", "Locales to be used for word segmentation when doing word related navigations or operations. Specify the BCP 47 language tag of the word you wish to recognize (e.g., ja, zh-CN, zh-Hant-TW, etc.)."),
                type: "array",
                items: {
                  type: "string"
                }
              }
            ]
          });
        }
        validate(e) {
          if (typeof e == "string" && (e = [
            e
          ]), Array.isArray(e)) {
            const t = [];
            for (const i of e) if (typeof i == "string") try {
              Intl.Segmenter.supportedLocalesOf(i).length > 0 && t.push(i);
            } catch {
            }
            return t;
          }
          return this.defaultValue;
        }
      }
      class D$ extends oi {
        constructor() {
          super(139, "wrappingIndent", 1, {
            "editor.wrappingIndent": {
              type: "string",
              enum: [
                "none",
                "same",
                "indent",
                "deepIndent"
              ],
              enumDescriptions: [
                C("wrappingIndent.none", "No indentation. Wrapped lines begin at column 1."),
                C("wrappingIndent.same", "Wrapped lines get the same indentation as the parent."),
                C("wrappingIndent.indent", "Wrapped lines get +1 indentation toward the parent."),
                C("wrappingIndent.deepIndent", "Wrapped lines get +2 indentation toward the parent.")
              ],
              description: C("wrappingIndent", "Controls the indentation of wrapped lines."),
              default: "same"
            }
          });
        }
        validate(e) {
          switch (e) {
            case "none":
              return 0;
            case "same":
              return 1;
            case "indent":
              return 2;
            case "deepIndent":
              return 3;
          }
          return 1;
        }
        compute(e, t, i) {
          return t.get(2) === 2 ? 0 : i;
        }
      }
      class E$ extends R_ {
        constructor() {
          super(147);
        }
        compute(e, t, i) {
          const n = t.get(146);
          return {
            isDominatedByLongLines: e.isDominatedByLongLines,
            isWordWrapMinified: n.isWordWrapMinified,
            isViewportWrapping: n.isViewportWrapping,
            wrappingColumn: n.wrappingColumn
          };
        }
      }
      class T$ extends oi {
        constructor() {
          const e = {
            enabled: true,
            showDropSelector: "afterDrop"
          };
          super(36, "dropIntoEditor", e, {
            "editor.dropIntoEditor.enabled": {
              type: "boolean",
              default: e.enabled,
              markdownDescription: C("dropIntoEditor.enabled", "Controls whether you can drag and drop a file into a text editor by holding down the `Shift` key (instead of opening the file in an editor).")
            },
            "editor.dropIntoEditor.showDropSelector": {
              type: "string",
              markdownDescription: C("dropIntoEditor.showDropSelector", "Controls if a widget is shown when dropping files into the editor. This widget lets you control how the file is dropped."),
              enum: [
                "afterDrop",
                "never"
              ],
              enumDescriptions: [
                C("dropIntoEditor.showDropSelector.afterDrop", "Show the drop selector widget after a file is dropped into the editor."),
                C("dropIntoEditor.showDropSelector.never", "Never show the drop selector widget. Instead the default drop provider is always used.")
              ],
              default: "afterDrop"
            }
          });
        }
        validate(e) {
          if (!e || typeof e != "object") return this.defaultValue;
          const t = e;
          return {
            enabled: Ee(t.enabled, this.defaultValue.enabled),
            showDropSelector: di(t.showDropSelector, this.defaultValue.showDropSelector, [
              "afterDrop",
              "never"
            ])
          };
        }
      }
      class N$ extends oi {
        constructor() {
          const e = {
            enabled: true,
            showPasteSelector: "afterPaste"
          };
          super(85, "pasteAs", e, {
            "editor.pasteAs.enabled": {
              type: "boolean",
              default: e.enabled,
              markdownDescription: C("pasteAs.enabled", "Controls whether you can paste content in different ways.")
            },
            "editor.pasteAs.showPasteSelector": {
              type: "string",
              markdownDescription: C("pasteAs.showPasteSelector", "Controls if a widget is shown when pasting content in to the editor. This widget lets you control how the file is pasted."),
              enum: [
                "afterPaste",
                "never"
              ],
              enumDescriptions: [
                C("pasteAs.showPasteSelector.afterPaste", "Show the paste selector widget after content is pasted into the editor."),
                C("pasteAs.showPasteSelector.never", "Never show the paste selector widget. Instead the default pasting behavior is always used.")
              ],
              default: "afterPaste"
            }
          });
        }
        validate(e) {
          if (!e || typeof e != "object") return this.defaultValue;
          const t = e;
          return {
            enabled: Ee(t.enabled, this.defaultValue.enabled),
            showPasteSelector: di(t.showPasteSelector, this.defaultValue.showPasteSelector, [
              "afterPaste",
              "never"
            ])
          };
        }
      }
      const I$ = "Consolas, 'Courier New', monospace", M$ = "Menlo, Monaco, 'Courier New', monospace", A$ = "'Droid Sans Mono', 'monospace', monospace", fo = {
        fontFamily: _t ? M$ : Is ? A$ : I$,
        fontWeight: "normal",
        fontSize: _t ? 12 : 14,
        lineHeight: 0,
        letterSpacing: 0
      }, lf = [];
      function me(s) {
        return lf[s.id] = s, s;
      }
      const Uh = {
        acceptSuggestionOnCommitCharacter: me(new ht(0, "acceptSuggestionOnCommitCharacter", true, {
          markdownDescription: C("acceptSuggestionOnCommitCharacter", "Controls whether suggestions should be accepted on commit characters. For example, in JavaScript, the semi-colon (`;`) can be a commit character that accepts a suggestion and types that character.")
        })),
        acceptSuggestionOnEnter: me(new hi(1, "acceptSuggestionOnEnter", "on", [
          "on",
          "smart",
          "off"
        ], {
          markdownEnumDescriptions: [
            "",
            C("acceptSuggestionOnEnterSmart", "Only accept a suggestion with `Enter` when it makes a textual change."),
            ""
          ],
          markdownDescription: C("acceptSuggestionOnEnter", "Controls whether suggestions should be accepted on `Enter`, in addition to `Tab`. Helps to avoid ambiguity between inserting new lines or accepting suggestions.")
        })),
        accessibilitySupport: me(new qU()),
        accessibilityPageSize: me(new Ut(3, "accessibilityPageSize", 10, 1, 1073741824, {
          description: C("accessibilityPageSize", "Controls the number of lines in the editor that can be read out by a screen reader at once. When we detect a screen reader we automatically set the default to be 500. Warning: this has a performance implication for numbers larger than the default."),
          tags: [
            "accessibility"
          ]
        })),
        ariaLabel: me(new ts(4, "ariaLabel", C("editorViewAccessibleLabel", "Editor content"))),
        ariaRequired: me(new ht(5, "ariaRequired", false, void 0)),
        screenReaderAnnounceInlineSuggestion: me(new ht(8, "screenReaderAnnounceInlineSuggestion", true, {
          description: C("screenReaderAnnounceInlineSuggestion", "Control whether inline suggestions are announced by a screen reader."),
          tags: [
            "accessibility"
          ]
        })),
        autoClosingBrackets: me(new hi(6, "autoClosingBrackets", "languageDefined", [
          "always",
          "languageDefined",
          "beforeWhitespace",
          "never"
        ], {
          enumDescriptions: [
            "",
            C("editor.autoClosingBrackets.languageDefined", "Use language configurations to determine when to autoclose brackets."),
            C("editor.autoClosingBrackets.beforeWhitespace", "Autoclose brackets only when the cursor is to the left of whitespace."),
            ""
          ],
          description: C("autoClosingBrackets", "Controls whether the editor should automatically close brackets after the user adds an opening bracket.")
        })),
        autoClosingComments: me(new hi(7, "autoClosingComments", "languageDefined", [
          "always",
          "languageDefined",
          "beforeWhitespace",
          "never"
        ], {
          enumDescriptions: [
            "",
            C("editor.autoClosingComments.languageDefined", "Use language configurations to determine when to autoclose comments."),
            C("editor.autoClosingComments.beforeWhitespace", "Autoclose comments only when the cursor is to the left of whitespace."),
            ""
          ],
          description: C("autoClosingComments", "Controls whether the editor should automatically close comments after the user adds an opening comment.")
        })),
        autoClosingDelete: me(new hi(9, "autoClosingDelete", "auto", [
          "always",
          "auto",
          "never"
        ], {
          enumDescriptions: [
            "",
            C("editor.autoClosingDelete.auto", "Remove adjacent closing quotes or brackets only if they were automatically inserted."),
            ""
          ],
          description: C("autoClosingDelete", "Controls whether the editor should remove adjacent closing quotes or brackets when deleting.")
        })),
        autoClosingOvertype: me(new hi(10, "autoClosingOvertype", "auto", [
          "always",
          "auto",
          "never"
        ], {
          enumDescriptions: [
            "",
            C("editor.autoClosingOvertype.auto", "Type over closing quotes or brackets only if they were automatically inserted."),
            ""
          ],
          description: C("autoClosingOvertype", "Controls whether the editor should type over closing quotes or brackets.")
        })),
        autoClosingQuotes: me(new hi(11, "autoClosingQuotes", "languageDefined", [
          "always",
          "languageDefined",
          "beforeWhitespace",
          "never"
        ], {
          enumDescriptions: [
            "",
            C("editor.autoClosingQuotes.languageDefined", "Use language configurations to determine when to autoclose quotes."),
            C("editor.autoClosingQuotes.beforeWhitespace", "Autoclose quotes only when the cursor is to the left of whitespace."),
            ""
          ],
          description: C("autoClosingQuotes", "Controls whether the editor should automatically close quotes after the user adds an opening quote.")
        })),
        autoIndent: me(new wb(12, "autoIndent", 4, "full", [
          "none",
          "keep",
          "brackets",
          "advanced",
          "full"
        ], $U, {
          enumDescriptions: [
            C("editor.autoIndent.none", "The editor will not insert indentation automatically."),
            C("editor.autoIndent.keep", "The editor will keep the current line's indentation."),
            C("editor.autoIndent.brackets", "The editor will keep the current line's indentation and honor language defined brackets."),
            C("editor.autoIndent.advanced", "The editor will keep the current line's indentation, honor language defined brackets and invoke special onEnterRules defined by languages."),
            C("editor.autoIndent.full", "The editor will keep the current line's indentation, honor language defined brackets, invoke special onEnterRules defined by languages, and honor indentationRules defined by languages.")
          ],
          description: C("autoIndent", "Controls whether the editor should automatically adjust the indentation when users type, paste, move or indent lines.")
        })),
        automaticLayout: me(new ht(13, "automaticLayout", false)),
        autoSurround: me(new hi(14, "autoSurround", "languageDefined", [
          "languageDefined",
          "quotes",
          "brackets",
          "never"
        ], {
          enumDescriptions: [
            C("editor.autoSurround.languageDefined", "Use language configurations to determine when to automatically surround selections."),
            C("editor.autoSurround.quotes", "Surround with quotes but not brackets."),
            C("editor.autoSurround.brackets", "Surround with brackets but not quotes."),
            ""
          ],
          description: C("autoSurround", "Controls whether the editor should automatically surround selections when typing quotes or brackets.")
        })),
        bracketPairColorization: me(new y$()),
        bracketPairGuides: me(new S$()),
        stickyTabStops: me(new ht(117, "stickyTabStops", false, {
          description: C("stickyTabStops", "Emulate selection behavior of tab characters when using spaces for indentation. Selection will stick to tab stops.")
        })),
        codeLens: me(new ht(17, "codeLens", true, {
          description: C("codeLens", "Controls whether the editor shows CodeLens.")
        })),
        codeLensFontFamily: me(new ts(18, "codeLensFontFamily", "", {
          description: C("codeLensFontFamily", "Controls the font family for CodeLens.")
        })),
        codeLensFontSize: me(new Ut(19, "codeLensFontSize", 0, 0, 100, {
          type: "number",
          default: 0,
          minimum: 0,
          maximum: 100,
          markdownDescription: C("codeLensFontSize", "Controls the font size in pixels for CodeLens. When set to 0, 90% of `#editor.fontSize#` is used.")
        })),
        colorDecorators: me(new ht(20, "colorDecorators", true, {
          description: C("colorDecorators", "Controls whether the editor should render the inline color decorators and color picker.")
        })),
        colorDecoratorActivatedOn: me(new hi(149, "colorDecoratorsActivatedOn", "clickAndHover", [
          "clickAndHover",
          "hover",
          "click"
        ], {
          enumDescriptions: [
            C("editor.colorDecoratorActivatedOn.clickAndHover", "Make the color picker appear both on click and hover of the color decorator"),
            C("editor.colorDecoratorActivatedOn.hover", "Make the color picker appear on hover of the color decorator"),
            C("editor.colorDecoratorActivatedOn.click", "Make the color picker appear on click of the color decorator")
          ],
          description: C("colorDecoratorActivatedOn", "Controls the condition to make a color picker appear from a color decorator")
        })),
        colorDecoratorsLimit: me(new Ut(21, "colorDecoratorsLimit", 500, 1, 1e6, {
          markdownDescription: C("colorDecoratorsLimit", "Controls the max number of color decorators that can be rendered in an editor at once.")
        })),
        columnSelection: me(new ht(22, "columnSelection", false, {
          description: C("columnSelection", "Enable that the selection with the mouse and keys is doing column selection.")
        })),
        comments: me(new KU()),
        contextmenu: me(new ht(24, "contextmenu", true)),
        copyWithSyntaxHighlighting: me(new ht(25, "copyWithSyntaxHighlighting", true, {
          description: C("copyWithSyntaxHighlighting", "Controls whether syntax highlighting should be copied into the clipboard.")
        })),
        cursorBlinking: me(new wb(26, "cursorBlinking", 1, "blink", [
          "blink",
          "smooth",
          "phase",
          "expand",
          "solid"
        ], jU, {
          description: C("cursorBlinking", "Control the cursor animation style.")
        })),
        cursorSmoothCaretAnimation: me(new hi(27, "cursorSmoothCaretAnimation", "off", [
          "off",
          "explicit",
          "on"
        ], {
          enumDescriptions: [
            C("cursorSmoothCaretAnimation.off", "Smooth caret animation is disabled."),
            C("cursorSmoothCaretAnimation.explicit", "Smooth caret animation is enabled only when the user moves the cursor with an explicit gesture."),
            C("cursorSmoothCaretAnimation.on", "Smooth caret animation is always enabled.")
          ],
          description: C("cursorSmoothCaretAnimation", "Controls whether the smooth caret animation should be enabled.")
        })),
        cursorStyle: me(new wb(28, "cursorStyle", vn.Line, "line", [
          "line",
          "block",
          "underline",
          "line-thin",
          "block-outline",
          "underline-thin"
        ], GU, {
          description: C("cursorStyle", "Controls the cursor style.")
        })),
        cursorSurroundingLines: me(new Ut(29, "cursorSurroundingLines", 0, 0, 1073741824, {
          description: C("cursorSurroundingLines", "Controls the minimal number of visible leading lines (minimum 0) and trailing lines (minimum 1) surrounding the cursor. Known as 'scrollOff' or 'scrollOffset' in some other editors.")
        })),
        cursorSurroundingLinesStyle: me(new hi(30, "cursorSurroundingLinesStyle", "default", [
          "default",
          "all"
        ], {
          enumDescriptions: [
            C("cursorSurroundingLinesStyle.default", "`cursorSurroundingLines` is enforced only when triggered via the keyboard or API."),
            C("cursorSurroundingLinesStyle.all", "`cursorSurroundingLines` is enforced always.")
          ],
          markdownDescription: C("cursorSurroundingLinesStyle", "Controls when `#editor.cursorSurroundingLines#` should be enforced.")
        })),
        cursorWidth: me(new Ut(31, "cursorWidth", 0, 0, 1073741824, {
          markdownDescription: C("cursorWidth", "Controls the width of the cursor when `#editor.cursorStyle#` is set to `line`.")
        })),
        disableLayerHinting: me(new ht(32, "disableLayerHinting", false)),
        disableMonospaceOptimizations: me(new ht(33, "disableMonospaceOptimizations", false)),
        domReadOnly: me(new ht(34, "domReadOnly", false)),
        dragAndDrop: me(new ht(35, "dragAndDrop", true, {
          description: C("dragAndDrop", "Controls whether the editor should allow moving selections via drag and drop.")
        })),
        emptySelectionClipboard: me(new ZU()),
        dropIntoEditor: me(new T$()),
        stickyScroll: me(new s$()),
        experimentalWhitespaceRendering: me(new hi(38, "experimentalWhitespaceRendering", "svg", [
          "svg",
          "font",
          "off"
        ], {
          enumDescriptions: [
            C("experimentalWhitespaceRendering.svg", "Use a new rendering method with svgs."),
            C("experimentalWhitespaceRendering.font", "Use a new rendering method with font characters."),
            C("experimentalWhitespaceRendering.off", "Use the stable rendering method.")
          ],
          description: C("experimentalWhitespaceRendering", "Controls whether whitespace is rendered with a new, experimental method.")
        })),
        extraEditorClassName: me(new ts(39, "extraEditorClassName", "")),
        fastScrollSensitivity: me(new co(40, "fastScrollSensitivity", 5, (s) => s <= 0 ? 5 : s, {
          markdownDescription: C("fastScrollSensitivity", "Scrolling speed multiplier when pressing `Alt`.")
        })),
        find: me(new QU()),
        fixedOverflowWidgets: me(new ht(42, "fixedOverflowWidgets", false)),
        folding: me(new ht(43, "folding", true, {
          description: C("folding", "Controls whether the editor has code folding enabled.")
        })),
        foldingStrategy: me(new hi(44, "foldingStrategy", "auto", [
          "auto",
          "indentation"
        ], {
          enumDescriptions: [
            C("foldingStrategy.auto", "Use a language-specific folding strategy if available, else the indentation-based one."),
            C("foldingStrategy.indentation", "Use the indentation-based folding strategy.")
          ],
          description: C("foldingStrategy", "Controls the strategy for computing folding ranges.")
        })),
        foldingHighlight: me(new ht(45, "foldingHighlight", true, {
          description: C("foldingHighlight", "Controls whether the editor should highlight folded ranges.")
        })),
        foldingImportsByDefault: me(new ht(46, "foldingImportsByDefault", false, {
          description: C("foldingImportsByDefault", "Controls whether the editor automatically collapses import ranges.")
        })),
        foldingMaximumRegions: me(new Ut(47, "foldingMaximumRegions", 5e3, 10, 65e3, {
          description: C("foldingMaximumRegions", "The maximum number of foldable regions. Increasing this value may result in the editor becoming less responsive when the current source has a large number of foldable regions.")
        })),
        unfoldOnClickAfterEndOfLine: me(new ht(48, "unfoldOnClickAfterEndOfLine", false, {
          description: C("unfoldOnClickAfterEndOfLine", "Controls whether clicking on the empty content after a folded line will unfold the line.")
        })),
        fontFamily: me(new ts(49, "fontFamily", fo.fontFamily, {
          description: C("fontFamily", "Controls the font family.")
        })),
        fontInfo: me(new XU()),
        fontLigatures2: me(new Fr()),
        fontSize: me(new JU()),
        fontWeight: me(new Qu()),
        fontVariations: me(new Sl()),
        formatOnPaste: me(new ht(55, "formatOnPaste", false, {
          description: C("formatOnPaste", "Controls whether the editor should automatically format the pasted content. A formatter must be available and the formatter should be able to format a range in a document.")
        })),
        formatOnType: me(new ht(56, "formatOnType", false, {
          description: C("formatOnType", "Controls whether the editor should automatically format the line after typing.")
        })),
        glyphMargin: me(new ht(57, "glyphMargin", true, {
          description: C("glyphMargin", "Controls whether the editor should render the vertical glyph margin. Glyph margin is mostly used for debugging.")
        })),
        gotoLocation: me(new e$()),
        hideCursorInOverviewRuler: me(new ht(59, "hideCursorInOverviewRuler", false, {
          description: C("hideCursorInOverviewRuler", "Controls whether the cursor should be hidden in the overview ruler.")
        })),
        hover: me(new t$()),
        inDiffEditor: me(new ht(61, "inDiffEditor", false)),
        letterSpacing: me(new co(64, "letterSpacing", fo.letterSpacing, (s) => co.clamp(s, -5, 20), {
          description: C("letterSpacing", "Controls the letter spacing in pixels.")
        })),
        lightbulb: me(new n$()),
        lineDecorationsWidth: me(new r$()),
        lineHeight: me(new a$()),
        lineNumbers: me(new m$()),
        lineNumbersMinChars: me(new Ut(69, "lineNumbersMinChars", 5, 1, 300)),
        linkedEditing: me(new ht(70, "linkedEditing", false, {
          description: C("linkedEditing", "Controls whether the editor has linked editing enabled. Depending on the language, related symbols such as HTML tags, are updated while editing.")
        })),
        links: me(new ht(71, "links", true, {
          description: C("links", "Controls whether the editor should detect links and make them clickable.")
        })),
        matchBrackets: me(new hi(72, "matchBrackets", "always", [
          "always",
          "near",
          "never"
        ], {
          description: C("matchBrackets", "Highlight matching brackets.")
        })),
        minimap: me(new l$()),
        mouseStyle: me(new hi(74, "mouseStyle", "text", [
          "text",
          "default",
          "copy"
        ])),
        mouseWheelScrollSensitivity: me(new co(75, "mouseWheelScrollSensitivity", 1, (s) => s === 0 ? 1 : s, {
          markdownDescription: C("mouseWheelScrollSensitivity", "A multiplier to be used on the `deltaX` and `deltaY` of mouse wheel scroll events.")
        })),
        mouseWheelZoom: me(new ht(76, "mouseWheelZoom", false, {
          markdownDescription: _t ? C("mouseWheelZoom.mac", "Zoom the font of the editor when using mouse wheel and holding `Cmd`.") : C("mouseWheelZoom", "Zoom the font of the editor when using mouse wheel and holding `Ctrl`.")
        })),
        multiCursorMergeOverlapping: me(new ht(77, "multiCursorMergeOverlapping", true, {
          description: C("multiCursorMergeOverlapping", "Merge multiple cursors when they are overlapping.")
        })),
        multiCursorModifier: me(new wb(78, "multiCursorModifier", "altKey", "alt", [
          "ctrlCmd",
          "alt"
        ], c$, {
          markdownEnumDescriptions: [
            C("multiCursorModifier.ctrlCmd", "Maps to `Control` on Windows and Linux and to `Command` on macOS."),
            C("multiCursorModifier.alt", "Maps to `Alt` on Windows and Linux and to `Option` on macOS.")
          ],
          markdownDescription: C({
            key: "multiCursorModifier",
            comment: [
              "- `ctrlCmd` refers to a value the setting can take and should not be localized.",
              "- `Control` and `Command` refer to the modifier keys Ctrl or Cmd on the keyboard and can be localized."
            ]
          }, "The modifier to be used to add multiple cursors with the mouse. The Go to Definition and Open Link mouse gestures will adapt such that they do not conflict with the [multicursor modifier](https://code.visualstudio.com/docs/editor/codebasics#_multicursor-modifier).")
        })),
        multiCursorPaste: me(new hi(79, "multiCursorPaste", "spread", [
          "spread",
          "full"
        ], {
          markdownEnumDescriptions: [
            C("multiCursorPaste.spread", "Each cursor pastes a single line of the text."),
            C("multiCursorPaste.full", "Each cursor pastes the full text.")
          ],
          markdownDescription: C("multiCursorPaste", "Controls pasting when the line count of the pasted text matches the cursor count.")
        })),
        multiCursorLimit: me(new Ut(80, "multiCursorLimit", 1e4, 1, 1e5, {
          markdownDescription: C("multiCursorLimit", "Controls the max number of cursors that can be in an active editor at once.")
        })),
        occurrencesHighlight: me(new hi(81, "occurrencesHighlight", "singleFile", [
          "off",
          "singleFile",
          "multiFile"
        ], {
          markdownEnumDescriptions: [
            C("occurrencesHighlight.off", "Does not highlight occurrences."),
            C("occurrencesHighlight.singleFile", "Highlights occurrences only in the current file."),
            C("occurrencesHighlight.multiFile", "Experimental: Highlights occurrences across all valid open files.")
          ],
          markdownDescription: C("occurrencesHighlight", "Controls whether occurrences should be highlighted across open files.")
        })),
        overviewRulerBorder: me(new ht(82, "overviewRulerBorder", true, {
          description: C("overviewRulerBorder", "Controls whether a border should be drawn around the overview ruler.")
        })),
        overviewRulerLanes: me(new Ut(83, "overviewRulerLanes", 3, 0, 3)),
        padding: me(new u$()),
        pasteAs: me(new N$()),
        parameterHints: me(new h$()),
        peekWidgetDefaultFocus: me(new hi(87, "peekWidgetDefaultFocus", "tree", [
          "tree",
          "editor"
        ], {
          enumDescriptions: [
            C("peekWidgetDefaultFocus.tree", "Focus the tree when opening peek"),
            C("peekWidgetDefaultFocus.editor", "Focus the editor when opening peek")
          ],
          description: C("peekWidgetDefaultFocus", "Controls whether to focus the inline editor or the tree in the peek widget.")
        })),
        placeholder: me(new f$()),
        definitionLinkOpensInPeek: me(new ht(89, "definitionLinkOpensInPeek", false, {
          description: C("definitionLinkOpensInPeek", "Controls whether the Go to Definition mouse gesture always opens the peek widget.")
        })),
        quickSuggestions: me(new g$()),
        quickSuggestionsDelay: me(new Ut(91, "quickSuggestionsDelay", 10, 0, 1073741824, {
          description: C("quickSuggestionsDelay", "Controls the delay in milliseconds after which quick suggestions will show up.")
        })),
        readOnly: me(new ht(92, "readOnly", false)),
        readOnlyMessage: me(new _$()),
        renameOnType: me(new ht(94, "renameOnType", false, {
          description: C("renameOnType", "Controls whether the editor auto renames on type."),
          markdownDeprecationMessage: C("renameOnTypeDeprecate", "Deprecated, use `editor.linkedEditing` instead.")
        })),
        renderControlCharacters: me(new ht(95, "renderControlCharacters", true, {
          description: C("renderControlCharacters", "Controls whether the editor should render control characters."),
          restricted: true
        })),
        renderFinalNewline: me(new hi(96, "renderFinalNewline", Is ? "dimmed" : "on", [
          "off",
          "on",
          "dimmed"
        ], {
          description: C("renderFinalNewline", "Render last line number when the file ends with a newline.")
        })),
        renderLineHighlight: me(new hi(97, "renderLineHighlight", "line", [
          "none",
          "gutter",
          "line",
          "all"
        ], {
          enumDescriptions: [
            "",
            "",
            "",
            C("renderLineHighlight.all", "Highlights both the gutter and the current line.")
          ],
          description: C("renderLineHighlight", "Controls how the editor should render the current line highlight.")
        })),
        renderLineHighlightOnlyWhenFocus: me(new ht(98, "renderLineHighlightOnlyWhenFocus", false, {
          description: C("renderLineHighlightOnlyWhenFocus", "Controls if the editor should render the current line highlight only when the editor is focused.")
        })),
        renderValidationDecorations: me(new hi(99, "renderValidationDecorations", "editable", [
          "editable",
          "on",
          "off"
        ])),
        renderWhitespace: me(new hi(100, "renderWhitespace", "selection", [
          "none",
          "boundary",
          "selection",
          "trailing",
          "all"
        ], {
          enumDescriptions: [
            "",
            C("renderWhitespace.boundary", "Render whitespace characters except for single spaces between words."),
            C("renderWhitespace.selection", "Render whitespace characters only on selected text."),
            C("renderWhitespace.trailing", "Render only trailing whitespace characters."),
            ""
          ],
          description: C("renderWhitespace", "Controls how the editor should render whitespace characters.")
        })),
        revealHorizontalRightPadding: me(new Ut(101, "revealHorizontalRightPadding", 15, 0, 1e3)),
        roundedSelection: me(new ht(102, "roundedSelection", true, {
          description: C("roundedSelection", "Controls whether selections should have rounded corners.")
        })),
        rulers: me(new p$()),
        scrollbar: me(new b$()),
        scrollBeyondLastColumn: me(new Ut(105, "scrollBeyondLastColumn", 4, 0, 1073741824, {
          description: C("scrollBeyondLastColumn", "Controls the number of extra characters beyond which the editor will scroll horizontally.")
        })),
        scrollBeyondLastLine: me(new ht(106, "scrollBeyondLastLine", true, {
          description: C("scrollBeyondLastLine", "Controls whether the editor will scroll beyond the last line.")
        })),
        scrollPredominantAxis: me(new ht(107, "scrollPredominantAxis", true, {
          description: C("scrollPredominantAxis", "Scroll only along the predominant axis when scrolling both vertically and horizontally at the same time. Prevents horizontal drift when scrolling vertically on a trackpad.")
        })),
        selectionClipboard: me(new ht(108, "selectionClipboard", true, {
          description: C("selectionClipboard", "Controls whether the Linux primary clipboard should be supported."),
          included: Is
        })),
        selectionHighlight: me(new ht(109, "selectionHighlight", true, {
          description: C("selectionHighlight", "Controls whether the editor should highlight matches similar to the selection.")
        })),
        selectOnLineNumbers: me(new ht(110, "selectOnLineNumbers", true)),
        showFoldingControls: me(new hi(111, "showFoldingControls", "mouseover", [
          "always",
          "never",
          "mouseover"
        ], {
          enumDescriptions: [
            C("showFoldingControls.always", "Always show the folding controls."),
            C("showFoldingControls.never", "Never show the folding controls and reduce the gutter size."),
            C("showFoldingControls.mouseover", "Only show the folding controls when the mouse is over the gutter.")
          ],
          description: C("showFoldingControls", "Controls when the folding controls on the gutter are shown.")
        })),
        showUnused: me(new ht(112, "showUnused", true, {
          description: C("showUnused", "Controls fading out of unused code.")
        })),
        showDeprecated: me(new ht(141, "showDeprecated", true, {
          description: C("showDeprecated", "Controls strikethrough deprecated variables.")
        })),
        inlayHints: me(new o$()),
        snippetSuggestions: me(new hi(113, "snippetSuggestions", "inline", [
          "top",
          "bottom",
          "inline",
          "none"
        ], {
          enumDescriptions: [
            C("snippetSuggestions.top", "Show snippet suggestions on top of other suggestions."),
            C("snippetSuggestions.bottom", "Show snippet suggestions below other suggestions."),
            C("snippetSuggestions.inline", "Show snippets suggestions with other suggestions."),
            C("snippetSuggestions.none", "Do not show snippet suggestions.")
          ],
          description: C("snippetSuggestions", "Controls whether snippets are shown with other suggestions and how they are sorted.")
        })),
        smartSelect: me(new x$()),
        smoothScrolling: me(new ht(115, "smoothScrolling", false, {
          description: C("smoothScrolling", "Controls whether the editor will scroll using an animation.")
        })),
        stopRenderingLineAfter: me(new Ut(118, "stopRenderingLineAfter", 1e4, -1, 1073741824)),
        suggest: me(new L$()),
        inlineSuggest: me(new C$()),
        inlineEdit: me(new w$()),
        inlineCompletionsAccessibilityVerbose: me(new ht(150, "inlineCompletionsAccessibilityVerbose", false, {
          description: C("inlineCompletionsAccessibilityVerbose", "Controls whether the accessibility hint should be provided to screen reader users when an inline completion is shown.")
        })),
        suggestFontSize: me(new Ut(120, "suggestFontSize", 0, 0, 1e3, {
          markdownDescription: C("suggestFontSize", "Font size for the suggest widget. When set to {0}, the value of {1} is used.", "`0`", "`#editor.fontSize#`")
        })),
        suggestLineHeight: me(new Ut(121, "suggestLineHeight", 0, 0, 1e3, {
          markdownDescription: C("suggestLineHeight", "Line height for the suggest widget. When set to {0}, the value of {1} is used. The minimum value is 8.", "`0`", "`#editor.lineHeight#`")
        })),
        suggestOnTriggerCharacters: me(new ht(122, "suggestOnTriggerCharacters", true, {
          description: C("suggestOnTriggerCharacters", "Controls whether suggestions should automatically show up when typing trigger characters.")
        })),
        suggestSelection: me(new hi(123, "suggestSelection", "first", [
          "first",
          "recentlyUsed",
          "recentlyUsedByPrefix"
        ], {
          markdownEnumDescriptions: [
            C("suggestSelection.first", "Always select the first suggestion."),
            C("suggestSelection.recentlyUsed", "Select recent suggestions unless further typing selects one, e.g. `console.| -> console.log` because `log` has been completed recently."),
            C("suggestSelection.recentlyUsedByPrefix", "Select suggestions based on previous prefixes that have completed those suggestions, e.g. `co -> console` and `con -> const`.")
          ],
          description: C("suggestSelection", "Controls how suggestions are pre-selected when showing the suggest list.")
        })),
        tabCompletion: me(new hi(124, "tabCompletion", "off", [
          "on",
          "off",
          "onlySnippets"
        ], {
          enumDescriptions: [
            C("tabCompletion.on", "Tab complete will insert the best matching suggestion when pressing tab."),
            C("tabCompletion.off", "Disable tab completions."),
            C("tabCompletion.onlySnippets", "Tab complete snippets when their prefix match. Works best when 'quickSuggestions' aren't enabled.")
          ],
          description: C("tabCompletion", "Enables tab completions.")
        })),
        tabIndex: me(new Ut(125, "tabIndex", 0, -1, 1073741824)),
        unicodeHighlight: me(new v$()),
        unusualLineTerminators: me(new hi(127, "unusualLineTerminators", "prompt", [
          "auto",
          "off",
          "prompt"
        ], {
          enumDescriptions: [
            C("unusualLineTerminators.auto", "Unusual line terminators are automatically removed."),
            C("unusualLineTerminators.off", "Unusual line terminators are ignored."),
            C("unusualLineTerminators.prompt", "Unusual line terminators prompt to be removed.")
          ],
          description: C("unusualLineTerminators", "Remove unusual line terminators that might cause problems.")
        })),
        useShadowDOM: me(new ht(128, "useShadowDOM", true)),
        useTabStops: me(new ht(129, "useTabStops", true, {
          description: C("useTabStops", "Spaces and tabs are inserted and deleted in alignment with tab stops.")
        })),
        wordBreak: me(new hi(130, "wordBreak", "normal", [
          "normal",
          "keepAll"
        ], {
          markdownEnumDescriptions: [
            C("wordBreak.normal", "Use the default line break rule."),
            C("wordBreak.keepAll", "Word breaks should not be used for Chinese/Japanese/Korean (CJK) text. Non-CJK text behavior is the same as for normal.")
          ],
          description: C("wordBreak", "Controls the word break rules used for Chinese/Japanese/Korean (CJK) text.")
        })),
        wordSegmenterLocales: me(new k$()),
        wordSeparators: me(new ts(132, "wordSeparators", n9, {
          description: C("wordSeparators", "Characters that will be used as word separators when doing word related navigations or operations.")
        })),
        wordWrap: me(new hi(133, "wordWrap", "off", [
          "off",
          "on",
          "wordWrapColumn",
          "bounded"
        ], {
          markdownEnumDescriptions: [
            C("wordWrap.off", "Lines will never wrap."),
            C("wordWrap.on", "Lines will wrap at the viewport width."),
            C({
              key: "wordWrap.wordWrapColumn",
              comment: [
                "- `editor.wordWrapColumn` refers to a different setting and should not be localized."
              ]
            }, "Lines will wrap at `#editor.wordWrapColumn#`."),
            C({
              key: "wordWrap.bounded",
              comment: [
                "- viewport means the edge of the visible window size.",
                "- `editor.wordWrapColumn` refers to a different setting and should not be localized."
              ]
            }, "Lines will wrap at the minimum of viewport and `#editor.wordWrapColumn#`.")
          ],
          description: C({
            key: "wordWrap",
            comment: [
              "- 'off', 'on', 'wordWrapColumn' and 'bounded' refer to values the setting can take and should not be localized.",
              "- `editor.wordWrapColumn` refers to a different setting and should not be localized."
            ]
          }, "Controls how lines should wrap.")
        })),
        wordWrapBreakAfterCharacters: me(new ts(134, "wordWrapBreakAfterCharacters", " 	})]?|/&.,;\xA2\xB0\u2032\u2033\u2030\u2103\u3001\u3002\uFF61\uFF64\uFFE0\uFF0C\uFF0E\uFF1A\uFF1B\uFF1F\uFF01\uFF05\u30FB\uFF65\u309D\u309E\u30FD\u30FE\u30FC\u30A1\u30A3\u30A5\u30A7\u30A9\u30C3\u30E3\u30E5\u30E7\u30EE\u30F5\u30F6\u3041\u3043\u3045\u3047\u3049\u3063\u3083\u3085\u3087\u308E\u3095\u3096\u31F0\u31F1\u31F2\u31F3\u31F4\u31F5\u31F6\u31F7\u31F8\u31F9\u31FA\u31FB\u31FC\u31FD\u31FE\u31FF\u3005\u303B\uFF67\uFF68\uFF69\uFF6A\uFF6B\uFF6C\uFF6D\uFF6E\uFF6F\uFF70\u201D\u3009\u300B\u300D\u300F\u3011\u3015\uFF09\uFF3D\uFF5D\uFF63")),
        wordWrapBreakBeforeCharacters: me(new ts(135, "wordWrapBreakBeforeCharacters", "([{\u2018\u201C\u3008\u300A\u300C\u300E\u3010\u3014\uFF08\uFF3B\uFF5B\uFF62\xA3\xA5\uFF04\uFFE1\uFFE5+\uFF0B")),
        wordWrapColumn: me(new Ut(136, "wordWrapColumn", 80, 1, 1073741824, {
          markdownDescription: C({
            key: "wordWrapColumn",
            comment: [
              "- `editor.wordWrap` refers to a different setting and should not be localized.",
              "- 'wordWrapColumn' and 'bounded' refer to values the different setting can take and should not be localized."
            ]
          }, "Controls the wrapping column of the editor when `#editor.wordWrap#` is `wordWrapColumn` or `bounded`.")
        })),
        wordWrapOverride1: me(new hi(137, "wordWrapOverride1", "inherit", [
          "off",
          "on",
          "inherit"
        ])),
        wordWrapOverride2: me(new hi(138, "wordWrapOverride2", "inherit", [
          "off",
          "on",
          "inherit"
        ])),
        editorClassName: me(new YU()),
        defaultColorDecorators: me(new ht(148, "defaultColorDecorators", false, {
          markdownDescription: C("defaultColorDecorators", "Controls whether inline color decorations should be shown using the default document color provider")
        })),
        pixelRatio: me(new d$()),
        tabFocusMode: me(new ht(145, "tabFocusMode", false, {
          markdownDescription: C("tabFocusMode", "Controls whether the editor receives tabs or defers them to the workbench for navigation.")
        })),
        layoutInfo: me(new Nf()),
        wrappingInfo: me(new E$()),
        wrappingIndent: me(new D$()),
        wrappingStrategy: me(new i$())
      };
      class R$ {
        constructor() {
          this.listeners = [], this.unexpectedErrorHandler = function(e) {
            setTimeout(() => {
              throw e.stack ? eg.isErrorNoTelemetry(e) ? new eg(e.message + `

` + e.stack) : new Error(e.message + `

` + e.stack) : e;
            }, 0);
          };
        }
        emit(e) {
          this.listeners.forEach((t) => {
            t(e);
          });
        }
        onUnexpectedError(e) {
          this.unexpectedErrorHandler(e), this.emit(e);
        }
        onUnexpectedExternalError(e) {
          this.unexpectedErrorHandler(e);
        }
      }
      const a9 = new R$();
      function qt(s) {
        O_(s) || a9.onUnexpectedError(s);
      }
      function BE(s) {
        O_(s) || a9.onUnexpectedExternalError(s);
      }
      function T4(s) {
        if (s instanceof Error) {
          const { name: e, message: t } = s, i = s.stacktrace || s.stack;
          return {
            $isError: true,
            name: e,
            message: t,
            stack: i,
            noTelemetry: eg.isErrorNoTelemetry(s)
          };
        }
        return s;
      }
      const Y0 = "Canceled";
      function O_(s) {
        return s instanceof P_ ? true : s instanceof Error && s.name === Y0 && s.message === Y0;
      }
      class P_ extends Error {
        constructor() {
          super(Y0), this.name = this.message;
        }
      }
      function O$() {
        const s = new Error(Y0);
        return s.name = s.message, s;
      }
      function FC(s) {
        return s ? new Error(`Illegal argument: ${s}`) : new Error("Illegal argument");
      }
      function FE(s) {
        return s ? new Error(`Illegal state: ${s}`) : new Error("Illegal state");
      }
      class P$ extends Error {
        constructor(e) {
          super("NotSupported"), e && (this.message = e);
        }
      }
      class eg extends Error {
        constructor(e) {
          super(e), this.name = "CodeExpectedError";
        }
        static fromError(e) {
          if (e instanceof eg) return e;
          const t = new eg();
          return t.message = e.message, t.stack = e.stack, t;
        }
        static isErrorNoTelemetry(e) {
          return e.name === "CodeExpectedError";
        }
      }
      class It extends Error {
        constructor(e) {
          super(e || "An unexpected bug occurred."), Object.setPrototypeOf(this, It.prototype);
        }
      }
      function tg(s, e) {
        const t = this;
        let i = false, n;
        return function() {
          return i || (i = true, n = s.apply(t, arguments)), n;
        };
      }
      function l9(s) {
        return typeof s == "object" && s !== null && typeof s.dispose == "function" && s.dispose.length === 0;
      }
      function On(s) {
        if (kt.is(s)) {
          const e = [];
          for (const t of s) if (t) try {
            t.dispose();
          } catch (i) {
            e.push(i);
          }
          if (e.length === 1) throw e[0];
          if (e.length > 1) throw new AggregateError(e, "Encountered errors while disposing of store");
          return Array.isArray(s) ? [] : s;
        } else if (s) return s.dispose(), s;
      }
      function ka(...s) {
        return Ze(() => On(s));
      }
      function Ze(s) {
        return {
          dispose: tg(() => {
            s();
          })
        };
      }
      const _Me = class _Me {
        constructor() {
          this._toDispose = /* @__PURE__ */ new Set(), this._isDisposed = false;
        }
        dispose() {
          this._isDisposed || (this._isDisposed = true, this.clear());
        }
        get isDisposed() {
          return this._isDisposed;
        }
        clear() {
          if (this._toDispose.size !== 0) try {
            On(this._toDispose);
          } finally {
            this._toDispose.clear();
          }
        }
        add(e) {
          if (!e) return e;
          if (e === this) throw new Error("Cannot register a disposable on itself!");
          return this._isDisposed ? _Me.DISABLE_DISPOSED_WARNING || console.warn(new Error("Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!").stack) : this._toDispose.add(e), e;
        }
        deleteAndLeak(e) {
          e && this._toDispose.has(e) && this._toDispose.delete(e);
        }
      };
      _Me.DISABLE_DISPOSED_WARNING = false;
      let Me = _Me;
      const _he2 = class _he2 {
        constructor() {
          this._store = new Me(), this._store;
        }
        dispose() {
          this._store.dispose();
        }
        _register(e) {
          if (e === this) throw new Error("Cannot register a disposable on itself!");
          return this._store.add(e);
        }
      };
      _he2.None = Object.freeze({
        dispose() {
        }
      });
      let he = _he2;
      class Ul {
        constructor() {
          this._isDisposed = false;
        }
        get value() {
          return this._isDisposed ? void 0 : this._value;
        }
        set value(e) {
          var _a3;
          this._isDisposed || e === this._value || ((_a3 = this._value) == null ? void 0 : _a3.dispose(), this._value = e);
        }
        clear() {
          this.value = void 0;
        }
        dispose() {
          var _a3;
          this._isDisposed = true, (_a3 = this._value) == null ? void 0 : _a3.dispose(), this._value = void 0;
        }
      }
      class B$ {
        constructor(e) {
          this.object = e;
        }
        dispose() {
        }
      }
      class VE {
        constructor() {
          this._store = /* @__PURE__ */ new Map(), this._isDisposed = false;
        }
        dispose() {
          this._isDisposed = true, this.clearAndDisposeAll();
        }
        clearAndDisposeAll() {
          if (this._store.size) try {
            On(this._store.values());
          } finally {
            this._store.clear();
          }
        }
        get(e) {
          return this._store.get(e);
        }
        set(e, t, i = false) {
          var _a3;
          this._isDisposed && console.warn(new Error("Trying to add a disposable to a DisposableMap that has already been disposed of. The added object will be leaked!").stack), i || ((_a3 = this._store.get(e)) == null ? void 0 : _a3.dispose()), this._store.set(e, t);
        }
        deleteAndDispose(e) {
          var _a3;
          (_a3 = this._store.get(e)) == null ? void 0 : _a3.dispose(), this._store.delete(e);
        }
        [Symbol.iterator]() {
          return this._store[Symbol.iterator]();
        }
      }
      const F$ = globalThis.performance && typeof globalThis.performance.now == "function";
      class $h {
        static create(e) {
          return new $h(e);
        }
        constructor(e) {
          this._now = F$ && e === false ? Date.now : globalThis.performance.now.bind(globalThis.performance), this._startTime = this._now(), this._stopTime = -1;
        }
        stop() {
          this._stopTime = this._now();
        }
        reset() {
          this._startTime = this._now(), this._stopTime = -1;
        }
        elapsed() {
          return this._stopTime !== -1 ? this._stopTime - this._startTime : this._now() - this._startTime;
        }
      }
      var be;
      (function(s) {
        s.None = () => he.None;
        function e(ee, K) {
          return m(ee, () => {
          }, 0, void 0, true, void 0, K);
        }
        s.defer = e;
        function t(ee) {
          return (K, te = null, H) => {
            let se = false, de;
            return de = ee((fe) => {
              if (!se) return de ? de.dispose() : se = true, K.call(te, fe);
            }, null, H), se && de.dispose(), de;
          };
        }
        s.once = t;
        function i(ee, K) {
          return s.once(s.filter(ee, K));
        }
        s.onceIf = i;
        function n(ee, K, te) {
          return d((H, se = null, de) => ee((fe) => H.call(se, K(fe)), null, de), te);
        }
        s.map = n;
        function o(ee, K, te) {
          return d((H, se = null, de) => ee((fe) => {
            K(fe), H.call(se, fe);
          }, null, de), te);
        }
        s.forEach = o;
        function r(ee, K, te) {
          return d((H, se = null, de) => ee((fe) => K(fe) && H.call(se, fe), null, de), te);
        }
        s.filter = r;
        function a(ee) {
          return ee;
        }
        s.signal = a;
        function l(...ee) {
          return (K, te = null, H) => {
            const se = ka(...ee.map((de) => de((fe) => K.call(te, fe))));
            return f(se, H);
          };
        }
        s.any = l;
        function u(ee, K, te, H) {
          let se = te;
          return n(ee, (de) => (se = K(se, de), se), H);
        }
        s.reduce = u;
        function d(ee, K) {
          let te;
          const H = {
            onWillAddFirstListener() {
              te = ee(se.fire, se);
            },
            onDidRemoveLastListener() {
              te == null ? void 0 : te.dispose();
            }
          }, se = new G(H);
          return K == null ? void 0 : K.add(se), se.event;
        }
        function f(ee, K) {
          return K instanceof Array ? K.push(ee) : K && K.add(ee), ee;
        }
        function m(ee, K, te = 100, H = false, se = false, de, fe) {
          let W, ne, xe, ye = 0, Ae;
          const Ve = {
            leakWarningThreshold: de,
            onWillAddFirstListener() {
              W = ee((xi) => {
                ye++, ne = K(ne, xi), H && !xe && (We.fire(ne), ne = void 0), Ae = () => {
                  const ct = ne;
                  ne = void 0, xe = void 0, (!H || ye > 1) && We.fire(ct), ye = 0;
                }, typeof te == "number" ? (clearTimeout(xe), xe = setTimeout(Ae, te)) : xe === void 0 && (xe = 0, queueMicrotask(Ae));
              });
            },
            onWillRemoveListener() {
              se && ye > 0 && (Ae == null ? void 0 : Ae());
            },
            onDidRemoveLastListener() {
              Ae = void 0, W.dispose();
            }
          }, We = new G(Ve);
          return fe == null ? void 0 : fe.add(We), We.event;
        }
        s.debounce = m;
        function _(ee, K = 0, te) {
          return s.debounce(ee, (H, se) => H ? (H.push(se), H) : [
            se
          ], K, void 0, true, void 0, te);
        }
        s.accumulate = _;
        function b(ee, K = (H, se) => H === se, te) {
          let H = true, se;
          return r(ee, (de) => {
            const fe = H || !K(de, se);
            return H = false, se = de, fe;
          }, te);
        }
        s.latch = b;
        function v(ee, K, te) {
          return [
            s.filter(ee, K, te),
            s.filter(ee, (H) => !K(H), te)
          ];
        }
        s.split = v;
        function y(ee, K = false, te = [], H) {
          let se = te.slice(), de = ee((ne) => {
            se ? se.push(ne) : W.fire(ne);
          });
          H && H.add(de);
          const fe = () => {
            se == null ? void 0 : se.forEach((ne) => W.fire(ne)), se = null;
          }, W = new G({
            onWillAddFirstListener() {
              de || (de = ee((ne) => W.fire(ne)), H && H.add(de));
            },
            onDidAddFirstListener() {
              se && (K ? setTimeout(fe) : fe());
            },
            onDidRemoveLastListener() {
              de && de.dispose(), de = null;
            }
          });
          return H && H.add(W), W.event;
        }
        s.buffer = y;
        function x(ee, K) {
          return (H, se, de) => {
            const fe = K(new D());
            return ee(function(W) {
              const ne = fe.evaluate(W);
              ne !== L && H.call(se, ne);
            }, void 0, de);
          };
        }
        s.chain = x;
        const L = Symbol("HaltChainable");
        class D {
          constructor() {
            this.steps = [];
          }
          map(K) {
            return this.steps.push(K), this;
          }
          forEach(K) {
            return this.steps.push((te) => (K(te), te)), this;
          }
          filter(K) {
            return this.steps.push((te) => K(te) ? te : L), this;
          }
          reduce(K, te) {
            let H = te;
            return this.steps.push((se) => (H = K(H, se), H)), this;
          }
          latch(K = (te, H) => te === H) {
            let te = true, H;
            return this.steps.push((se) => {
              const de = te || !K(se, H);
              return te = false, H = se, de ? se : L;
            }), this;
          }
          evaluate(K) {
            for (const te of this.steps) if (K = te(K), K === L) break;
            return K;
          }
        }
        function k(ee, K, te = (H) => H) {
          const H = (...W) => fe.fire(te(...W)), se = () => ee.on(K, H), de = () => ee.removeListener(K, H), fe = new G({
            onWillAddFirstListener: se,
            onDidRemoveLastListener: de
          });
          return fe.event;
        }
        s.fromNodeEventEmitter = k;
        function T(ee, K, te = (H) => H) {
          const H = (...W) => fe.fire(te(...W)), se = () => ee.addEventListener(K, H), de = () => ee.removeEventListener(K, H), fe = new G({
            onWillAddFirstListener: se,
            onDidRemoveLastListener: de
          });
          return fe.event;
        }
        s.fromDOMEventEmitter = T;
        function M(ee) {
          return new Promise((K) => t(ee)(K));
        }
        s.toPromise = M;
        function I(ee) {
          const K = new G();
          return ee.then((te) => {
            K.fire(te);
          }, () => {
            K.fire(void 0);
          }).finally(() => {
            K.dispose();
          }), K.event;
        }
        s.fromPromise = I;
        function R(ee, K) {
          return ee((te) => K.fire(te));
        }
        s.forward = R;
        function A(ee, K, te) {
          return K(te), ee((H) => K(H));
        }
        s.runAndSubscribe = A;
        class Y {
          constructor(K, te) {
            this._observable = K, this._counter = 0, this._hasChanged = false;
            const H = {
              onWillAddFirstListener: () => {
                K.addObserver(this), this._observable.reportChanges();
              },
              onDidRemoveLastListener: () => {
                K.removeObserver(this);
              }
            };
            this.emitter = new G(H), te && te.add(this.emitter);
          }
          beginUpdate(K) {
            this._counter++;
          }
          handlePossibleChange(K) {
          }
          handleChange(K, te) {
            this._hasChanged = true;
          }
          endUpdate(K) {
            this._counter--, this._counter === 0 && (this._observable.reportChanges(), this._hasChanged && (this._hasChanged = false, this.emitter.fire(this._observable.get())));
          }
        }
        function U(ee, K) {
          return new Y(ee, K).emitter.event;
        }
        s.fromObservable = U;
        function j(ee) {
          return (K, te, H) => {
            let se = 0, de = false;
            const fe = {
              beginUpdate() {
                se++;
              },
              endUpdate() {
                se--, se === 0 && (ee.reportChanges(), de && (de = false, K.call(te)));
              },
              handlePossibleChange() {
              },
              handleChange() {
                de = true;
              }
            };
            ee.addObserver(fe), ee.reportChanges();
            const W = {
              dispose() {
                ee.removeObserver(fe);
              }
            };
            return H instanceof Me ? H.add(W) : Array.isArray(H) && H.push(W), W;
          };
        }
        s.fromObservableLight = j;
      })(be || (be = {}));
      const _Z0 = class _Z0 {
        constructor(e) {
          this.listenerCount = 0, this.invocationCount = 0, this.elapsedOverall = 0, this.durations = [], this.name = `${e}_${_Z0._idPool++}`, _Z0.all.add(this);
        }
        start(e) {
          this._stopWatch = new $h(), this.listenerCount = e;
        }
        stop() {
          if (this._stopWatch) {
            const e = this._stopWatch.elapsed();
            this.durations.push(e), this.elapsedOverall += e, this.invocationCount += 1, this._stopWatch = void 0;
          }
        }
      };
      _Z0.all = /* @__PURE__ */ new Set();
      _Z0._idPool = 0;
      let Z0 = _Z0;
      let V$ = -1;
      const _WE = class _WE {
        constructor(e, t, i = (_WE._idPool++).toString(16).padStart(3, "0")) {
          this._errorHandler = e, this.threshold = t, this.name = i, this._warnCountdown = 0;
        }
        dispose() {
          var _a3;
          (_a3 = this._stacks) == null ? void 0 : _a3.clear();
        }
        check(e, t) {
          const i = this.threshold;
          if (i <= 0 || t < i) return;
          this._stacks || (this._stacks = /* @__PURE__ */ new Map());
          const n = this._stacks.get(e.value) || 0;
          if (this._stacks.set(e.value, n + 1), this._warnCountdown -= 1, this._warnCountdown <= 0) {
            this._warnCountdown = i * 0.5;
            const [o, r] = this.getMostFrequentStack(), a = `[${this.name}] potential listener LEAK detected, having ${t} listeners already. MOST frequent listener (${r}):`;
            console.warn(a), console.warn(o);
            const l = new W$(a, o);
            this._errorHandler(l);
          }
          return () => {
            const o = this._stacks.get(e.value) || 0;
            this._stacks.set(e.value, o - 1);
          };
        }
        getMostFrequentStack() {
          if (!this._stacks) return;
          let e, t = 0;
          for (const [i, n] of this._stacks) (!e || t < n) && (e = [
            i,
            n
          ], t = n);
          return e;
        }
      };
      _WE._idPool = 1;
      let WE = _WE;
      class HE {
        static create() {
          const e = new Error();
          return new HE(e.stack ?? "");
        }
        constructor(e) {
          this.value = e;
        }
        print() {
          console.warn(this.value.split(`
`).slice(2).join(`
`));
        }
      }
      class W$ extends Error {
        constructor(e, t) {
          super(e), this.name = "ListenerLeakError", this.stack = t;
        }
      }
      class H$ extends Error {
        constructor(e, t) {
          super(e), this.name = "ListenerRefusalError", this.stack = t;
        }
      }
      class hL {
        constructor(e) {
          this.value = e;
        }
      }
      const z$ = 2;
      class G {
        constructor(e) {
          var _a3, _b3, _c2, _d2;
          this._size = 0, this._options = e, this._leakageMon = ((_a3 = this._options) == null ? void 0 : _a3.leakWarningThreshold) ? new WE((e == null ? void 0 : e.onListenerError) ?? qt, ((_b3 = this._options) == null ? void 0 : _b3.leakWarningThreshold) ?? V$) : void 0, this._perfMon = ((_c2 = this._options) == null ? void 0 : _c2._profName) ? new Z0(this._options._profName) : void 0, this._deliveryQueue = (_d2 = this._options) == null ? void 0 : _d2.deliveryQueue;
        }
        dispose() {
          var _a3, _b3, _c2, _d2;
          this._disposed || (this._disposed = true, ((_a3 = this._deliveryQueue) == null ? void 0 : _a3.current) === this && this._deliveryQueue.reset(), this._listeners && (this._listeners = void 0, this._size = 0), (_c2 = (_b3 = this._options) == null ? void 0 : _b3.onDidRemoveLastListener) == null ? void 0 : _c2.call(_b3), (_d2 = this._leakageMon) == null ? void 0 : _d2.dispose());
        }
        get event() {
          return this._event ?? (this._event = (e, t, i) => {
            var _a3, _b3, _c2, _d2, _e2;
            if (this._leakageMon && this._size > this._leakageMon.threshold ** 2) {
              const a = `[${this._leakageMon.name}] REFUSES to accept new listeners because it exceeded its threshold by far (${this._size} vs ${this._leakageMon.threshold})`;
              console.warn(a);
              const l = this._leakageMon.getMostFrequentStack() ?? [
                "UNKNOWN stack",
                -1
              ], u = new H$(`${a}. HINT: Stack shows most frequent listener (${l[1]}-times)`, l[0]);
              return (((_a3 = this._options) == null ? void 0 : _a3.onListenerError) || qt)(u), he.None;
            }
            if (this._disposed) return he.None;
            t && (e = e.bind(t));
            const n = new hL(e);
            let o;
            this._leakageMon && this._size >= Math.ceil(this._leakageMon.threshold * 0.2) && (n.stack = HE.create(), o = this._leakageMon.check(n.stack, this._size + 1)), this._listeners ? this._listeners instanceof hL ? (this._deliveryQueue ?? (this._deliveryQueue = new c9()), this._listeners = [
              this._listeners,
              n
            ]) : this._listeners.push(n) : ((_c2 = (_b3 = this._options) == null ? void 0 : _b3.onWillAddFirstListener) == null ? void 0 : _c2.call(_b3, this), this._listeners = n, (_e2 = (_d2 = this._options) == null ? void 0 : _d2.onDidAddFirstListener) == null ? void 0 : _e2.call(_d2, this)), this._size++;
            const r = Ze(() => {
              o == null ? void 0 : o(), this._removeListener(n);
            });
            return i instanceof Me ? i.add(r) : Array.isArray(i) && i.push(r), r;
          }), this._event;
        }
        _removeListener(e) {
          var _a3, _b3, _c2, _d2;
          if ((_b3 = (_a3 = this._options) == null ? void 0 : _a3.onWillRemoveListener) == null ? void 0 : _b3.call(_a3, this), !this._listeners) return;
          if (this._size === 1) {
            this._listeners = void 0, (_d2 = (_c2 = this._options) == null ? void 0 : _c2.onDidRemoveLastListener) == null ? void 0 : _d2.call(_c2, this), this._size = 0;
            return;
          }
          const t = this._listeners, i = t.indexOf(e);
          if (i === -1) throw console.log("disposed?", this._disposed), console.log("size?", this._size), console.log("arr?", JSON.stringify(this._listeners)), new Error("Attempted to dispose unknown listener");
          this._size--, t[i] = void 0;
          const n = this._deliveryQueue.current === this;
          if (this._size * z$ <= t.length) {
            let o = 0;
            for (let r = 0; r < t.length; r++) t[r] ? t[o++] = t[r] : n && (this._deliveryQueue.end--, o < this._deliveryQueue.i && this._deliveryQueue.i--);
            t.length = o;
          }
        }
        _deliver(e, t) {
          var _a3;
          if (!e) return;
          const i = ((_a3 = this._options) == null ? void 0 : _a3.onListenerError) || qt;
          if (!i) {
            e.value(t);
            return;
          }
          try {
            e.value(t);
          } catch (n) {
            i(n);
          }
        }
        _deliverQueue(e) {
          const t = e.current._listeners;
          for (; e.i < e.end; ) this._deliver(t[e.i++], e.value);
          e.reset();
        }
        fire(e) {
          var _a3, _b3, _c2, _d2;
          if (((_a3 = this._deliveryQueue) == null ? void 0 : _a3.current) && (this._deliverQueue(this._deliveryQueue), (_b3 = this._perfMon) == null ? void 0 : _b3.stop()), (_c2 = this._perfMon) == null ? void 0 : _c2.start(this._size), this._listeners) if (this._listeners instanceof hL) this._deliver(this._listeners, e);
          else {
            const t = this._deliveryQueue;
            t.enqueue(this, e, this._listeners.length), this._deliverQueue(t);
          }
          (_d2 = this._perfMon) == null ? void 0 : _d2.stop();
        }
        hasListeners() {
          return this._size > 0;
        }
      }
      const U$ = () => new c9();
      class c9 {
        constructor() {
          this.i = -1, this.end = 0;
        }
        enqueue(e, t, i) {
          this.i = 0, this.end = i, this.current = e, this.value = t;
        }
        reset() {
          this.i = this.end, this.current = void 0, this.value = void 0;
        }
      }
      class jp extends G {
        constructor(e) {
          super(e), this._isPaused = 0, this._eventQueue = new Us(), this._mergeFn = e == null ? void 0 : e.merge;
        }
        pause() {
          this._isPaused++;
        }
        resume() {
          if (this._isPaused !== 0 && --this._isPaused === 0) if (this._mergeFn) {
            if (this._eventQueue.size > 0) {
              const e = Array.from(this._eventQueue);
              this._eventQueue.clear(), super.fire(this._mergeFn(e));
            }
          } else for (; !this._isPaused && this._eventQueue.size !== 0; ) super.fire(this._eventQueue.shift());
        }
        fire(e) {
          this._size && (this._isPaused !== 0 ? this._eventQueue.push(e) : super.fire(e));
        }
      }
      class u9 extends jp {
        constructor(e) {
          super(e), this._delay = e.delay ?? 100;
        }
        fire(e) {
          this._handle || (this.pause(), this._handle = setTimeout(() => {
            this._handle = void 0, this.resume();
          }, this._delay)), super.fire(e);
        }
      }
      class $$ extends G {
        constructor(e) {
          super(e), this._queuedEvents = [], this._mergeFn = e == null ? void 0 : e.merge;
        }
        fire(e) {
          this.hasListeners() && (this._queuedEvents.push(e), this._queuedEvents.length === 1 && queueMicrotask(() => {
            this._mergeFn ? super.fire(this._mergeFn(this._queuedEvents)) : this._queuedEvents.forEach((t) => super.fire(t)), this._queuedEvents = [];
          }));
        }
      }
      class q$ {
        constructor() {
          this.hasListeners = false, this.events = [], this.emitter = new G({
            onWillAddFirstListener: () => this.onFirstListenerAdd(),
            onDidRemoveLastListener: () => this.onLastListenerRemove()
          });
        }
        get event() {
          return this.emitter.event;
        }
        add(e) {
          const t = {
            event: e,
            listener: null
          };
          return this.events.push(t), this.hasListeners && this.hook(t), Ze(tg(() => {
            this.hasListeners && this.unhook(t);
            const n = this.events.indexOf(t);
            this.events.splice(n, 1);
          }));
        }
        onFirstListenerAdd() {
          this.hasListeners = true, this.events.forEach((e) => this.hook(e));
        }
        onLastListenerRemove() {
          this.hasListeners = false, this.events.forEach((e) => this.unhook(e));
        }
        hook(e) {
          e.listener = e.event((t) => this.emitter.fire(t));
        }
        unhook(e) {
          var _a3;
          (_a3 = e.listener) == null ? void 0 : _a3.dispose(), e.listener = null;
        }
        dispose() {
          var _a3;
          this.emitter.dispose();
          for (const e of this.events) (_a3 = e.listener) == null ? void 0 : _a3.dispose();
          this.events = [];
        }
      }
      class B_ {
        constructor() {
          this.data = [];
        }
        wrapEvent(e, t, i) {
          return (n, o, r) => e((a) => {
            const l = this.data[this.data.length - 1];
            if (!t) {
              l ? l.buffers.push(() => n.call(o, a)) : n.call(o, a);
              return;
            }
            const u = l;
            if (!u) {
              n.call(o, t(i, a));
              return;
            }
            u.items ?? (u.items = []), u.items.push(a), u.buffers.length === 0 && l.buffers.push(() => {
              u.reducedResult ?? (u.reducedResult = i ? u.items.reduce(t, i) : u.items.reduce(t)), n.call(o, u.reducedResult);
            });
          }, void 0, r);
        }
        bufferEvents(e) {
          const t = {
            buffers: new Array()
          };
          this.data.push(t);
          const i = e();
          return this.data.pop(), t.buffers.forEach((n) => n()), i;
        }
      }
      class N4 {
        constructor() {
          this.listening = false, this.inputEvent = be.None, this.inputEventListener = he.None, this.emitter = new G({
            onDidAddFirstListener: () => {
              this.listening = true, this.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);
            },
            onDidRemoveLastListener: () => {
              this.listening = false, this.inputEventListener.dispose();
            }
          }), this.event = this.emitter.event;
        }
        set input(e) {
          this.inputEvent = e, this.listening && (this.inputEventListener.dispose(), this.inputEventListener = e(this.emitter.fire, this.emitter));
        }
        dispose() {
          this.inputEventListener.dispose(), this.emitter.dispose();
        }
      }
      const h9 = Object.freeze(function(s, e) {
        const t = setTimeout(s.bind(e), 0);
        return {
          dispose() {
            clearTimeout(t);
          }
        };
      });
      var mr;
      (function(s) {
        function e(t) {
          return t === s.None || t === s.Cancelled || t instanceof m0 ? true : !t || typeof t != "object" ? false : typeof t.isCancellationRequested == "boolean" && typeof t.onCancellationRequested == "function";
        }
        s.isCancellationToken = e, s.None = Object.freeze({
          isCancellationRequested: false,
          onCancellationRequested: be.None
        }), s.Cancelled = Object.freeze({
          isCancellationRequested: true,
          onCancellationRequested: h9
        });
      })(mr || (mr = {}));
      class m0 {
        constructor() {
          this._isCancelled = false, this._emitter = null;
        }
        cancel() {
          this._isCancelled || (this._isCancelled = true, this._emitter && (this._emitter.fire(void 0), this.dispose()));
        }
        get isCancellationRequested() {
          return this._isCancelled;
        }
        get onCancellationRequested() {
          return this._isCancelled ? h9 : (this._emitter || (this._emitter = new G()), this._emitter.event);
        }
        dispose() {
          this._emitter && (this._emitter.dispose(), this._emitter = null);
        }
      }
      class Lg {
        constructor(e) {
          this._token = void 0, this._parentListener = void 0, this._parentListener = e && e.onCancellationRequested(this.cancel, this);
        }
        get token() {
          return this._token || (this._token = new m0()), this._token;
        }
        cancel() {
          this._token ? this._token instanceof m0 && this._token.cancel() : this._token = mr.Cancelled;
        }
        dispose(e = false) {
          var _a3;
          e && this.cancel(), (_a3 = this._parentListener) == null ? void 0 : _a3.dispose(), this._token ? this._token instanceof m0 && this._token.dispose() : this._token = mr.None;
        }
      }
      class zE {
        constructor() {
          this._keyCodeToStr = [], this._strToKeyCode = /* @__PURE__ */ Object.create(null);
        }
        define(e, t) {
          this._keyCodeToStr[e] = t, this._strToKeyCode[t.toLowerCase()] = e;
        }
        keyCodeToStr(e) {
          return this._keyCodeToStr[e];
        }
        strToKeyCode(e) {
          return this._strToKeyCode[e.toLowerCase()] || 0;
        }
      }
      const p0 = new zE(), Ax = new zE(), Rx = new zE(), d9 = new Array(230), K$ = /* @__PURE__ */ Object.create(null), j$ = /* @__PURE__ */ Object.create(null), UE = [];
      for (let s = 0; s <= 193; s++) UE[s] = -1;
      (function() {
        const s = "", e = [
          [
            1,
            0,
            "None",
            0,
            "unknown",
            0,
            "VK_UNKNOWN",
            s,
            s
          ],
          [
            1,
            1,
            "Hyper",
            0,
            s,
            0,
            s,
            s,
            s
          ],
          [
            1,
            2,
            "Super",
            0,
            s,
            0,
            s,
            s,
            s
          ],
          [
            1,
            3,
            "Fn",
            0,
            s,
            0,
            s,
            s,
            s
          ],
          [
            1,
            4,
            "FnLock",
            0,
            s,
            0,
            s,
            s,
            s
          ],
          [
            1,
            5,
            "Suspend",
            0,
            s,
            0,
            s,
            s,
            s
          ],
          [
            1,
            6,
            "Resume",
            0,
            s,
            0,
            s,
            s,
            s
          ],
          [
            1,
            7,
            "Turbo",
            0,
            s,
            0,
            s,
            s,
            s
          ],
          [
            1,
            8,
            "Sleep",
            0,
            s,
            0,
            "VK_SLEEP",
            s,
            s
          ],
          [
            1,
            9,
            "WakeUp",
            0,
            s,
            0,
            s,
            s,
            s
          ],
          [
            0,
            10,
            "KeyA",
            31,
            "A",
            65,
            "VK_A",
            s,
            s
          ],
          [
            0,
            11,
            "KeyB",
            32,
            "B",
            66,
            "VK_B",
            s,
            s
          ],
          [
            0,
            12,
            "KeyC",
            33,
            "C",
            67,
            "VK_C",
            s,
            s
          ],
          [
            0,
            13,
            "KeyD",
            34,
            "D",
            68,
            "VK_D",
            s,
            s
          ],
          [
            0,
            14,
            "KeyE",
            35,
            "E",
            69,
            "VK_E",
            s,
            s
          ],
          [
            0,
            15,
            "KeyF",
            36,
            "F",
            70,
            "VK_F",
            s,
            s
          ],
          [
            0,
            16,
            "KeyG",
            37,
            "G",
            71,
            "VK_G",
            s,
            s
          ],
          [
            0,
            17,
            "KeyH",
            38,
            "H",
            72,
            "VK_H",
            s,
            s
          ],
          [
            0,
            18,
            "KeyI",
            39,
            "I",
            73,
            "VK_I",
            s,
            s
          ],
          [
            0,
            19,
            "KeyJ",
            40,
            "J",
            74,
            "VK_J",
            s,
            s
          ],
          [
            0,
            20,
            "KeyK",
            41,
            "K",
            75,
            "VK_K",
            s,
            s
          ],
          [
            0,
            21,
            "KeyL",
            42,
            "L",
            76,
            "VK_L",
            s,
            s
          ],
          [
            0,
            22,
            "KeyM",
            43,
            "M",
            77,
            "VK_M",
            s,
            s
          ],
          [
            0,
            23,
            "KeyN",
            44,
            "N",
            78,
            "VK_N",
            s,
            s
          ],
          [
            0,
            24,
            "KeyO",
            45,
            "O",
            79,
            "VK_O",
            s,
            s
          ],
          [
            0,
            25,
            "KeyP",
            46,
            "P",
            80,
            "VK_P",
            s,
            s
          ],
          [
            0,
            26,
            "KeyQ",
            47,
            "Q",
            81,
            "VK_Q",
            s,
            s
          ],
          [
            0,
            27,
            "KeyR",
            48,
            "R",
            82,
            "VK_R",
            s,
            s
          ],
          [
            0,
            28,
            "KeyS",
            49,
            "S",
            83,
            "VK_S",
            s,
            s
          ],
          [
            0,
            29,
            "KeyT",
            50,
            "T",
            84,
            "VK_T",
            s,
            s
          ],
          [
            0,
            30,
            "KeyU",
            51,
            "U",
            85,
            "VK_U",
            s,
            s
          ],
          [
            0,
            31,
            "KeyV",
            52,
            "V",
            86,
            "VK_V",
            s,
            s
          ],
          [
            0,
            32,
            "KeyW",
            53,
            "W",
            87,
            "VK_W",
            s,
            s
          ],
          [
            0,
            33,
            "KeyX",
            54,
            "X",
            88,
            "VK_X",
            s,
            s
          ],
          [
            0,
            34,
            "KeyY",
            55,
            "Y",
            89,
            "VK_Y",
            s,
            s
          ],
          [
            0,
            35,
            "KeyZ",
            56,
            "Z",
            90,
            "VK_Z",
            s,
            s
          ],
          [
            0,
            36,
            "Digit1",
            22,
            "1",
            49,
            "VK_1",
            s,
            s
          ],
          [
            0,
            37,
            "Digit2",
            23,
            "2",
            50,
            "VK_2",
            s,
            s
          ],
          [
            0,
            38,
            "Digit3",
            24,
            "3",
            51,
            "VK_3",
            s,
            s
          ],
          [
            0,
            39,
            "Digit4",
            25,
            "4",
            52,
            "VK_4",
            s,
            s
          ],
          [
            0,
            40,
            "Digit5",
            26,
            "5",
            53,
            "VK_5",
            s,
            s
          ],
          [
            0,
            41,
            "Digit6",
            27,
            "6",
            54,
            "VK_6",
            s,
            s
          ],
          [
            0,
            42,
            "Digit7",
            28,
            "7",
            55,
            "VK_7",
            s,
            s
          ],
          [
            0,
            43,
            "Digit8",
            29,
            "8",
            56,
            "VK_8",
            s,
            s
          ],
          [
            0,
            44,
            "Digit9",
            30,
            "9",
            57,
            "VK_9",
            s,
            s
          ],
          [
            0,
            45,
            "Digit0",
            21,
            "0",
            48,
            "VK_0",
            s,
            s
          ],
          [
            1,
            46,
            "Enter",
            3,
            "Enter",
            13,
            "VK_RETURN",
            s,
            s
          ],
          [
            1,
            47,
            "Escape",
            9,
            "Escape",
            27,
            "VK_ESCAPE",
            s,
            s
          ],
          [
            1,
            48,
            "Backspace",
            1,
            "Backspace",
            8,
            "VK_BACK",
            s,
            s
          ],
          [
            1,
            49,
            "Tab",
            2,
            "Tab",
            9,
            "VK_TAB",
            s,
            s
          ],
          [
            1,
            50,
            "Space",
            10,
            "Space",
            32,
            "VK_SPACE",
            s,
            s
          ],
          [
            0,
            51,
            "Minus",
            88,
            "-",
            189,
            "VK_OEM_MINUS",
            "-",
            "OEM_MINUS"
          ],
          [
            0,
            52,
            "Equal",
            86,
            "=",
            187,
            "VK_OEM_PLUS",
            "=",
            "OEM_PLUS"
          ],
          [
            0,
            53,
            "BracketLeft",
            92,
            "[",
            219,
            "VK_OEM_4",
            "[",
            "OEM_4"
          ],
          [
            0,
            54,
            "BracketRight",
            94,
            "]",
            221,
            "VK_OEM_6",
            "]",
            "OEM_6"
          ],
          [
            0,
            55,
            "Backslash",
            93,
            "\\",
            220,
            "VK_OEM_5",
            "\\",
            "OEM_5"
          ],
          [
            0,
            56,
            "IntlHash",
            0,
            s,
            0,
            s,
            s,
            s
          ],
          [
            0,
            57,
            "Semicolon",
            85,
            ";",
            186,
            "VK_OEM_1",
            ";",
            "OEM_1"
          ],
          [
            0,
            58,
            "Quote",
            95,
            "'",
            222,
            "VK_OEM_7",
            "'",
            "OEM_7"
          ],
          [
            0,
            59,
            "Backquote",
            91,
            "`",
            192,
            "VK_OEM_3",
            "`",
            "OEM_3"
          ],
          [
            0,
            60,
            "Comma",
            87,
            ",",
            188,
            "VK_OEM_COMMA",
            ",",
            "OEM_COMMA"
          ],
          [
            0,
            61,
            "Period",
            89,
            ".",
            190,
            "VK_OEM_PERIOD",
            ".",
            "OEM_PERIOD"
          ],
          [
            0,
            62,
            "Slash",
            90,
            "/",
            191,
            "VK_OEM_2",
            "/",
            "OEM_2"
          ],
          [
            1,
            63,
            "CapsLock",
            8,
            "CapsLock",
            20,
            "VK_CAPITAL",
            s,
            s
          ],
          [
            1,
            64,
            "F1",
            59,
            "F1",
            112,
            "VK_F1",
            s,
            s
          ],
          [
            1,
            65,
            "F2",
            60,
            "F2",
            113,
            "VK_F2",
            s,
            s
          ],
          [
            1,
            66,
            "F3",
            61,
            "F3",
            114,
            "VK_F3",
            s,
            s
          ],
          [
            1,
            67,
            "F4",
            62,
            "F4",
            115,
            "VK_F4",
            s,
            s
          ],
          [
            1,
            68,
            "F5",
            63,
            "F5",
            116,
            "VK_F5",
            s,
            s
          ],
          [
            1,
            69,
            "F6",
            64,
            "F6",
            117,
            "VK_F6",
            s,
            s
          ],
          [
            1,
            70,
            "F7",
            65,
            "F7",
            118,
            "VK_F7",
            s,
            s
          ],
          [
            1,
            71,
            "F8",
            66,
            "F8",
            119,
            "VK_F8",
            s,
            s
          ],
          [
            1,
            72,
            "F9",
            67,
            "F9",
            120,
            "VK_F9",
            s,
            s
          ],
          [
            1,
            73,
            "F10",
            68,
            "F10",
            121,
            "VK_F10",
            s,
            s
          ],
          [
            1,
            74,
            "F11",
            69,
            "F11",
            122,
            "VK_F11",
            s,
            s
          ],
          [
            1,
            75,
            "F12",
            70,
            "F12",
            123,
            "VK_F12",
            s,
            s
          ],
          [
            1,
            76,
            "PrintScreen",
            0,
            s,
            0,
            s,
            s,
            s
          ],
          [
            1,
            77,
            "ScrollLock",
            84,
            "ScrollLock",
            145,
            "VK_SCROLL",
            s,
            s
          ],
          [
            1,
            78,
            "Pause",
            7,
            "PauseBreak",
            19,
            "VK_PAUSE",
            s,
            s
          ],
          [
            1,
            79,
            "Insert",
            19,
            "Insert",
            45,
            "VK_INSERT",
            s,
            s
          ],
          [
            1,
            80,
            "Home",
            14,
            "Home",
            36,
            "VK_HOME",
            s,
            s
          ],
          [
            1,
            81,
            "PageUp",
            11,
            "PageUp",
            33,
            "VK_PRIOR",
            s,
            s
          ],
          [
            1,
            82,
            "Delete",
            20,
            "Delete",
            46,
            "VK_DELETE",
            s,
            s
          ],
          [
            1,
            83,
            "End",
            13,
            "End",
            35,
            "VK_END",
            s,
            s
          ],
          [
            1,
            84,
            "PageDown",
            12,
            "PageDown",
            34,
            "VK_NEXT",
            s,
            s
          ],
          [
            1,
            85,
            "ArrowRight",
            17,
            "RightArrow",
            39,
            "VK_RIGHT",
            "Right",
            s
          ],
          [
            1,
            86,
            "ArrowLeft",
            15,
            "LeftArrow",
            37,
            "VK_LEFT",
            "Left",
            s
          ],
          [
            1,
            87,
            "ArrowDown",
            18,
            "DownArrow",
            40,
            "VK_DOWN",
            "Down",
            s
          ],
          [
            1,
            88,
            "ArrowUp",
            16,
            "UpArrow",
            38,
            "VK_UP",
            "Up",
            s
          ],
          [
            1,
            89,
            "NumLock",
            83,
            "NumLock",
            144,
            "VK_NUMLOCK",
            s,
            s
          ],
          [
            1,
            90,
            "NumpadDivide",
            113,
            "NumPad_Divide",
            111,
            "VK_DIVIDE",
            s,
            s
          ],
          [
            1,
            91,
            "NumpadMultiply",
            108,
            "NumPad_Multiply",
            106,
            "VK_MULTIPLY",
            s,
            s
          ],
          [
            1,
            92,
            "NumpadSubtract",
            111,
            "NumPad_Subtract",
            109,
            "VK_SUBTRACT",
            s,
            s
          ],
          [
            1,
            93,
            "NumpadAdd",
            109,
            "NumPad_Add",
            107,
            "VK_ADD",
            s,
            s
          ],
          [
            1,
            94,
            "NumpadEnter",
            3,
            s,
            0,
            s,
            s,
            s
          ],
          [
            1,
            95,
            "Numpad1",
            99,
            "NumPad1",
            97,
            "VK_NUMPAD1",
            s,
            s
          ],
          [
            1,
            96,
            "Numpad2",
            100,
            "NumPad2",
            98,
            "VK_NUMPAD2",
            s,
            s
          ],
          [
            1,
            97,
            "Numpad3",
            101,
            "NumPad3",
            99,
            "VK_NUMPAD3",
            s,
            s
          ],
          [
            1,
            98,
            "Numpad4",
            102,
            "NumPad4",
            100,
            "VK_NUMPAD4",
            s,
            s
          ],
          [
            1,
            99,
            "Numpad5",
            103,
            "NumPad5",
            101,
            "VK_NUMPAD5",
            s,
            s
          ],
          [
            1,
            100,
            "Numpad6",
            104,
            "NumPad6",
            102,
            "VK_NUMPAD6",
            s,
            s
          ],
          [
            1,
            101,
            "Numpad7",
            105,
            "NumPad7",
            103,
            "VK_NUMPAD7",
            s,
            s
          ],
          [
            1,
            102,
            "Numpad8",
            106,
            "NumPad8",
            104,
            "VK_NUMPAD8",
            s,
            s
          ],
          [
            1,
            103,
            "Numpad9",
            107,
            "NumPad9",
            105,
            "VK_NUMPAD9",
            s,
            s
          ],
          [
            1,
            104,
            "Numpad0",
            98,
            "NumPad0",
            96,
            "VK_NUMPAD0",
            s,
            s
          ],
          [
            1,
            105,
            "NumpadDecimal",
            112,
            "NumPad_Decimal",
            110,
            "VK_DECIMAL",
            s,
            s
          ],
          [
            0,
            106,
            "IntlBackslash",
            97,
            "OEM_102",
            226,
            "VK_OEM_102",
            s,
            s
          ],
          [
            1,
            107,
            "ContextMenu",
            58,
            "ContextMenu",
            93,
            s,
            s,
            s
          ],
          [
            1,
            108,
            "Power",
            0,
            s,
            0,
            s,
            s,
            s
          ],
          [
            1,
            109,
            "NumpadEqual",
            0,
            s,
            0,
            s,
            s,
            s
          ],
          [
            1,
            110,
            "F13",
            71,
            "F13",
            124,
            "VK_F13",
            s,
            s
          ],
          [
            1,
            111,
            "F14",
            72,
            "F14",
            125,
            "VK_F14",
            s,
            s
          ],
          [
            1,
            112,
            "F15",
            73,
            "F15",
            126,
            "VK_F15",
            s,
            s
          ],
          [
            1,
            113,
            "F16",
            74,
            "F16",
            127,
            "VK_F16",
            s,
            s
          ],
          [
            1,
            114,
            "F17",
            75,
            "F17",
            128,
            "VK_F17",
            s,
            s
          ],
          [
            1,
            115,
            "F18",
            76,
            "F18",
            129,
            "VK_F18",
            s,
            s
          ],
          [
            1,
            116,
            "F19",
            77,
            "F19",
            130,
            "VK_F19",
            s,
            s
          ],
          [
            1,
            117,
            "F20",
            78,
            "F20",
            131,
            "VK_F20",
            s,
            s
          ],
          [
            1,
            118,
            "F21",
            79,
            "F21",
            132,
            "VK_F21",
            s,
            s
          ],
          [
            1,
            119,
            "F22",
            80,
            "F22",
            133,
            "VK_F22",
            s,
            s
          ],
          [
            1,
            120,
            "F23",
            81,
            "F23",
            134,
            "VK_F23",
            s,
            s
          ],
          [
            1,
            121,
            "F24",
            82,
            "F24",
            135,
            "VK_F24",
            s,
            s
          ],
          [
            1,
            122,
            "Open",
            0,
            s,
            0,
            s,
            s,
            s
          ],
          [
            1,
            123,
            "Help",
            0,
            s,
            0,
            s,
            s,
            s
          ],
          [
            1,
            124,
            "Select",
            0,
            s,
            0,
            s,
            s,
            s
          ],
          [
            1,
            125,
            "Again",
            0,
            s,
            0,
            s,
            s,
            s
          ],
          [
            1,
            126,
            "Undo",
            0,
            s,
            0,
            s,
            s,
            s
          ],
          [
            1,
            127,
            "Cut",
            0,
            s,
            0,
            s,
            s,
            s
          ],
          [
            1,
            128,
            "Copy",
            0,
            s,
            0,
            s,
            s,
            s
          ],
          [
            1,
            129,
            "Paste",
            0,
            s,
            0,
            s,
            s,
            s
          ],
          [
            1,
            130,
            "Find",
            0,
            s,
            0,
            s,
            s,
            s
          ],
          [
            1,
            131,
            "AudioVolumeMute",
            117,
            "AudioVolumeMute",
            173,
            "VK_VOLUME_MUTE",
            s,
            s
          ],
          [
            1,
            132,
            "AudioVolumeUp",
            118,
            "AudioVolumeUp",
            175,
            "VK_VOLUME_UP",
            s,
            s
          ],
          [
            1,
            133,
            "AudioVolumeDown",
            119,
            "AudioVolumeDown",
            174,
            "VK_VOLUME_DOWN",
            s,
            s
          ],
          [
            1,
            134,
            "NumpadComma",
            110,
            "NumPad_Separator",
            108,
            "VK_SEPARATOR",
            s,
            s
          ],
          [
            0,
            135,
            "IntlRo",
            115,
            "ABNT_C1",
            193,
            "VK_ABNT_C1",
            s,
            s
          ],
          [
            1,
            136,
            "KanaMode",
            0,
            s,
            0,
            s,
            s,
            s
          ],
          [
            0,
            137,
            "IntlYen",
            0,
            s,
            0,
            s,
            s,
            s
          ],
          [
            1,
            138,
            "Convert",
            0,
            s,
            0,
            s,
            s,
            s
          ],
          [
            1,
            139,
            "NonConvert",
            0,
            s,
            0,
            s,
            s,
            s
          ],
          [
            1,
            140,
            "Lang1",
            0,
            s,
            0,
            s,
            s,
            s
          ],
          [
            1,
            141,
            "Lang2",
            0,
            s,
            0,
            s,
            s,
            s
          ],
          [
            1,
            142,
            "Lang3",
            0,
            s,
            0,
            s,
            s,
            s
          ],
          [
            1,
            143,
            "Lang4",
            0,
            s,
            0,
            s,
            s,
            s
          ],
          [
            1,
            144,
            "Lang5",
            0,
            s,
            0,
            s,
            s,
            s
          ],
          [
            1,
            145,
            "Abort",
            0,
            s,
            0,
            s,
            s,
            s
          ],
          [
            1,
            146,
            "Props",
            0,
            s,
            0,
            s,
            s,
            s
          ],
          [
            1,
            147,
            "NumpadParenLeft",
            0,
            s,
            0,
            s,
            s,
            s
          ],
          [
            1,
            148,
            "NumpadParenRight",
            0,
            s,
            0,
            s,
            s,
            s
          ],
          [
            1,
            149,
            "NumpadBackspace",
            0,
            s,
            0,
            s,
            s,
            s
          ],
          [
            1,
            150,
            "NumpadMemoryStore",
            0,
            s,
            0,
            s,
            s,
            s
          ],
          [
            1,
            151,
            "NumpadMemoryRecall",
            0,
            s,
            0,
            s,
            s,
            s
          ],
          [
            1,
            152,
            "NumpadMemoryClear",
            0,
            s,
            0,
            s,
            s,
            s
          ],
          [
            1,
            153,
            "NumpadMemoryAdd",
            0,
            s,
            0,
            s,
            s,
            s
          ],
          [
            1,
            154,
            "NumpadMemorySubtract",
            0,
            s,
            0,
            s,
            s,
            s
          ],
          [
            1,
            155,
            "NumpadClear",
            131,
            "Clear",
            12,
            "VK_CLEAR",
            s,
            s
          ],
          [
            1,
            156,
            "NumpadClearEntry",
            0,
            s,
            0,
            s,
            s,
            s
          ],
          [
            1,
            0,
            s,
            5,
            "Ctrl",
            17,
            "VK_CONTROL",
            s,
            s
          ],
          [
            1,
            0,
            s,
            4,
            "Shift",
            16,
            "VK_SHIFT",
            s,
            s
          ],
          [
            1,
            0,
            s,
            6,
            "Alt",
            18,
            "VK_MENU",
            s,
            s
          ],
          [
            1,
            0,
            s,
            57,
            "Meta",
            91,
            "VK_COMMAND",
            s,
            s
          ],
          [
            1,
            157,
            "ControlLeft",
            5,
            s,
            0,
            "VK_LCONTROL",
            s,
            s
          ],
          [
            1,
            158,
            "ShiftLeft",
            4,
            s,
            0,
            "VK_LSHIFT",
            s,
            s
          ],
          [
            1,
            159,
            "AltLeft",
            6,
            s,
            0,
            "VK_LMENU",
            s,
            s
          ],
          [
            1,
            160,
            "MetaLeft",
            57,
            s,
            0,
            "VK_LWIN",
            s,
            s
          ],
          [
            1,
            161,
            "ControlRight",
            5,
            s,
            0,
            "VK_RCONTROL",
            s,
            s
          ],
          [
            1,
            162,
            "ShiftRight",
            4,
            s,
            0,
            "VK_RSHIFT",
            s,
            s
          ],
          [
            1,
            163,
            "AltRight",
            6,
            s,
            0,
            "VK_RMENU",
            s,
            s
          ],
          [
            1,
            164,
            "MetaRight",
            57,
            s,
            0,
            "VK_RWIN",
            s,
            s
          ],
          [
            1,
            165,
            "BrightnessUp",
            0,
            s,
            0,
            s,
            s,
            s
          ],
          [
            1,
            166,
            "BrightnessDown",
            0,
            s,
            0,
            s,
            s,
            s
          ],
          [
            1,
            167,
            "MediaPlay",
            0,
            s,
            0,
            s,
            s,
            s
          ],
          [
            1,
            168,
            "MediaRecord",
            0,
            s,
            0,
            s,
            s,
            s
          ],
          [
            1,
            169,
            "MediaFastForward",
            0,
            s,
            0,
            s,
            s,
            s
          ],
          [
            1,
            170,
            "MediaRewind",
            0,
            s,
            0,
            s,
            s,
            s
          ],
          [
            1,
            171,
            "MediaTrackNext",
            124,
            "MediaTrackNext",
            176,
            "VK_MEDIA_NEXT_TRACK",
            s,
            s
          ],
          [
            1,
            172,
            "MediaTrackPrevious",
            125,
            "MediaTrackPrevious",
            177,
            "VK_MEDIA_PREV_TRACK",
            s,
            s
          ],
          [
            1,
            173,
            "MediaStop",
            126,
            "MediaStop",
            178,
            "VK_MEDIA_STOP",
            s,
            s
          ],
          [
            1,
            174,
            "Eject",
            0,
            s,
            0,
            s,
            s,
            s
          ],
          [
            1,
            175,
            "MediaPlayPause",
            127,
            "MediaPlayPause",
            179,
            "VK_MEDIA_PLAY_PAUSE",
            s,
            s
          ],
          [
            1,
            176,
            "MediaSelect",
            128,
            "LaunchMediaPlayer",
            181,
            "VK_MEDIA_LAUNCH_MEDIA_SELECT",
            s,
            s
          ],
          [
            1,
            177,
            "LaunchMail",
            129,
            "LaunchMail",
            180,
            "VK_MEDIA_LAUNCH_MAIL",
            s,
            s
          ],
          [
            1,
            178,
            "LaunchApp2",
            130,
            "LaunchApp2",
            183,
            "VK_MEDIA_LAUNCH_APP2",
            s,
            s
          ],
          [
            1,
            179,
            "LaunchApp1",
            0,
            s,
            0,
            "VK_MEDIA_LAUNCH_APP1",
            s,
            s
          ],
          [
            1,
            180,
            "SelectTask",
            0,
            s,
            0,
            s,
            s,
            s
          ],
          [
            1,
            181,
            "LaunchScreenSaver",
            0,
            s,
            0,
            s,
            s,
            s
          ],
          [
            1,
            182,
            "BrowserSearch",
            120,
            "BrowserSearch",
            170,
            "VK_BROWSER_SEARCH",
            s,
            s
          ],
          [
            1,
            183,
            "BrowserHome",
            121,
            "BrowserHome",
            172,
            "VK_BROWSER_HOME",
            s,
            s
          ],
          [
            1,
            184,
            "BrowserBack",
            122,
            "BrowserBack",
            166,
            "VK_BROWSER_BACK",
            s,
            s
          ],
          [
            1,
            185,
            "BrowserForward",
            123,
            "BrowserForward",
            167,
            "VK_BROWSER_FORWARD",
            s,
            s
          ],
          [
            1,
            186,
            "BrowserStop",
            0,
            s,
            0,
            "VK_BROWSER_STOP",
            s,
            s
          ],
          [
            1,
            187,
            "BrowserRefresh",
            0,
            s,
            0,
            "VK_BROWSER_REFRESH",
            s,
            s
          ],
          [
            1,
            188,
            "BrowserFavorites",
            0,
            s,
            0,
            "VK_BROWSER_FAVORITES",
            s,
            s
          ],
          [
            1,
            189,
            "ZoomToggle",
            0,
            s,
            0,
            s,
            s,
            s
          ],
          [
            1,
            190,
            "MailReply",
            0,
            s,
            0,
            s,
            s,
            s
          ],
          [
            1,
            191,
            "MailForward",
            0,
            s,
            0,
            s,
            s,
            s
          ],
          [
            1,
            192,
            "MailSend",
            0,
            s,
            0,
            s,
            s,
            s
          ],
          [
            1,
            0,
            s,
            114,
            "KeyInComposition",
            229,
            s,
            s,
            s
          ],
          [
            1,
            0,
            s,
            116,
            "ABNT_C2",
            194,
            "VK_ABNT_C2",
            s,
            s
          ],
          [
            1,
            0,
            s,
            96,
            "OEM_8",
            223,
            "VK_OEM_8",
            s,
            s
          ],
          [
            1,
            0,
            s,
            0,
            s,
            0,
            "VK_KANA",
            s,
            s
          ],
          [
            1,
            0,
            s,
            0,
            s,
            0,
            "VK_HANGUL",
            s,
            s
          ],
          [
            1,
            0,
            s,
            0,
            s,
            0,
            "VK_JUNJA",
            s,
            s
          ],
          [
            1,
            0,
            s,
            0,
            s,
            0,
            "VK_FINAL",
            s,
            s
          ],
          [
            1,
            0,
            s,
            0,
            s,
            0,
            "VK_HANJA",
            s,
            s
          ],
          [
            1,
            0,
            s,
            0,
            s,
            0,
            "VK_KANJI",
            s,
            s
          ],
          [
            1,
            0,
            s,
            0,
            s,
            0,
            "VK_CONVERT",
            s,
            s
          ],
          [
            1,
            0,
            s,
            0,
            s,
            0,
            "VK_NONCONVERT",
            s,
            s
          ],
          [
            1,
            0,
            s,
            0,
            s,
            0,
            "VK_ACCEPT",
            s,
            s
          ],
          [
            1,
            0,
            s,
            0,
            s,
            0,
            "VK_MODECHANGE",
            s,
            s
          ],
          [
            1,
            0,
            s,
            0,
            s,
            0,
            "VK_SELECT",
            s,
            s
          ],
          [
            1,
            0,
            s,
            0,
            s,
            0,
            "VK_PRINT",
            s,
            s
          ],
          [
            1,
            0,
            s,
            0,
            s,
            0,
            "VK_EXECUTE",
            s,
            s
          ],
          [
            1,
            0,
            s,
            0,
            s,
            0,
            "VK_SNAPSHOT",
            s,
            s
          ],
          [
            1,
            0,
            s,
            0,
            s,
            0,
            "VK_HELP",
            s,
            s
          ],
          [
            1,
            0,
            s,
            0,
            s,
            0,
            "VK_APPS",
            s,
            s
          ],
          [
            1,
            0,
            s,
            0,
            s,
            0,
            "VK_PROCESSKEY",
            s,
            s
          ],
          [
            1,
            0,
            s,
            0,
            s,
            0,
            "VK_PACKET",
            s,
            s
          ],
          [
            1,
            0,
            s,
            0,
            s,
            0,
            "VK_DBE_SBCSCHAR",
            s,
            s
          ],
          [
            1,
            0,
            s,
            0,
            s,
            0,
            "VK_DBE_DBCSCHAR",
            s,
            s
          ],
          [
            1,
            0,
            s,
            0,
            s,
            0,
            "VK_ATTN",
            s,
            s
          ],
          [
            1,
            0,
            s,
            0,
            s,
            0,
            "VK_CRSEL",
            s,
            s
          ],
          [
            1,
            0,
            s,
            0,
            s,
            0,
            "VK_EXSEL",
            s,
            s
          ],
          [
            1,
            0,
            s,
            0,
            s,
            0,
            "VK_EREOF",
            s,
            s
          ],
          [
            1,
            0,
            s,
            0,
            s,
            0,
            "VK_PLAY",
            s,
            s
          ],
          [
            1,
            0,
            s,
            0,
            s,
            0,
            "VK_ZOOM",
            s,
            s
          ],
          [
            1,
            0,
            s,
            0,
            s,
            0,
            "VK_NONAME",
            s,
            s
          ],
          [
            1,
            0,
            s,
            0,
            s,
            0,
            "VK_PA1",
            s,
            s
          ],
          [
            1,
            0,
            s,
            0,
            s,
            0,
            "VK_OEM_CLEAR",
            s,
            s
          ]
        ], t = [], i = [];
        for (const n of e) {
          const [o, r, a, l, u, d, f, m, _] = n;
          if (i[r] || (i[r] = true, K$[a] = r, j$[a.toLowerCase()] = r, o && (UE[r] = l)), !t[l]) {
            if (t[l] = true, !u) throw new Error(`String representation missing for key code ${l} around scan code ${a}`);
            p0.define(l, u), Ax.define(l, m || u), Rx.define(l, _ || m || u);
          }
          d && (d9[d] = l);
        }
      })();
      var Ll;
      (function(s) {
        function e(a) {
          return p0.keyCodeToStr(a);
        }
        s.toString = e;
        function t(a) {
          return p0.strToKeyCode(a);
        }
        s.fromString = t;
        function i(a) {
          return Ax.keyCodeToStr(a);
        }
        s.toUserSettingsUS = i;
        function n(a) {
          return Rx.keyCodeToStr(a);
        }
        s.toUserSettingsGeneral = n;
        function o(a) {
          return Ax.strToKeyCode(a) || Rx.strToKeyCode(a);
        }
        s.fromUserSettings = o;
        function r(a) {
          if (a >= 98 && a <= 113) return null;
          switch (a) {
            case 16:
              return "Up";
            case 18:
              return "Down";
            case 15:
              return "Left";
            case 17:
              return "Right";
          }
          return p0.keyCodeToStr(a);
        }
        s.toElectronAccelerator = r;
      })(Ll || (Ll = {}));
      function G$(s, e) {
        const t = (e & 65535) << 16 >>> 0;
        return (s | t) >>> 0;
      }
      var I4 = {};
      let Mf;
      const dL = globalThis.vscode;
      if (typeof dL < "u" && typeof dL.process < "u") {
        const s = dL.process;
        Mf = {
          get platform() {
            return s.platform;
          },
          get arch() {
            return s.arch;
          },
          get env() {
            return s.env;
          },
          cwd() {
            return s.cwd();
          }
        };
      } else typeof process < "u" && typeof ((_e = process == null ? void 0 : process.versions) == null ? void 0 : _e.node) == "string" ? Mf = {
        get platform() {
          return process.platform;
        },
        get arch() {
          return process.arch;
        },
        get env() {
          return I4;
        },
        cwd() {
          return I4.VSCODE_CWD || process.cwd();
        }
      } : Mf = {
        get platform() {
          return Ks ? "win32" : _t ? "darwin" : "linux";
        },
        get arch() {
        },
        get env() {
          return {};
        },
        cwd() {
          return "/";
        }
      };
      const Q0 = Mf.cwd, Ox = Mf.env, Y$ = Mf.platform, Z$ = 65, Q$ = 97, X$ = 90, J$ = 122, Xc = 46, Xn = 47, no = 92, wc = 58, eq = 63;
      class f9 extends Error {
        constructor(e, t, i) {
          let n;
          typeof t == "string" && t.indexOf("not ") === 0 ? (n = "must not be", t = t.replace(/^not /, "")) : n = "must be";
          const o = e.indexOf(".") !== -1 ? "property" : "argument";
          let r = `The "${e}" ${o} ${n} of type ${t}`;
          r += `. Received type ${typeof i}`, super(r), this.code = "ERR_INVALID_ARG_TYPE";
        }
      }
      function tq(s, e) {
        if (s === null || typeof s != "object") throw new f9(e, "Object", s);
      }
      function sn(s, e) {
        if (typeof s != "string") throw new f9(e, "string", s);
      }
      const Kl = Y$ === "win32";
      function Nt(s) {
        return s === Xn || s === no;
      }
      function Px(s) {
        return s === Xn;
      }
      function yc(s) {
        return s >= Z$ && s <= X$ || s >= Q$ && s <= J$;
      }
      function X0(s, e, t, i) {
        let n = "", o = 0, r = -1, a = 0, l = 0;
        for (let u = 0; u <= s.length; ++u) {
          if (u < s.length) l = s.charCodeAt(u);
          else {
            if (i(l)) break;
            l = Xn;
          }
          if (i(l)) {
            if (!(r === u - 1 || a === 1)) if (a === 2) {
              if (n.length < 2 || o !== 2 || n.charCodeAt(n.length - 1) !== Xc || n.charCodeAt(n.length - 2) !== Xc) {
                if (n.length > 2) {
                  const d = n.lastIndexOf(t);
                  d === -1 ? (n = "", o = 0) : (n = n.slice(0, d), o = n.length - 1 - n.lastIndexOf(t)), r = u, a = 0;
                  continue;
                } else if (n.length !== 0) {
                  n = "", o = 0, r = u, a = 0;
                  continue;
                }
              }
              e && (n += n.length > 0 ? `${t}..` : "..", o = 2);
            } else n.length > 0 ? n += `${t}${s.slice(r + 1, u)}` : n = s.slice(r + 1, u), o = u - r - 1;
            r = u, a = 0;
          } else l === Xc && a !== -1 ? ++a : a = -1;
        }
        return n;
      }
      function iq(s) {
        return s ? `${s[0] === "." ? "" : "."}${s}` : "";
      }
      function g9(s, e) {
        tq(e, "pathObject");
        const t = e.dir || e.root, i = e.base || `${e.name || ""}${iq(e.ext)}`;
        return t ? t === e.root ? `${t}${i}` : `${t}${s}${i}` : i;
      }
      const Ts = {
        resolve(...s) {
          let e = "", t = "", i = false;
          for (let n = s.length - 1; n >= -1; n--) {
            let o;
            if (n >= 0) {
              if (o = s[n], sn(o, `paths[${n}]`), o.length === 0) continue;
            } else e.length === 0 ? o = Q0() : (o = Ox[`=${e}`] || Q0(), (o === void 0 || o.slice(0, 2).toLowerCase() !== e.toLowerCase() && o.charCodeAt(2) === no) && (o = `${e}\\`));
            const r = o.length;
            let a = 0, l = "", u = false;
            const d = o.charCodeAt(0);
            if (r === 1) Nt(d) && (a = 1, u = true);
            else if (Nt(d)) if (u = true, Nt(o.charCodeAt(1))) {
              let f = 2, m = f;
              for (; f < r && !Nt(o.charCodeAt(f)); ) f++;
              if (f < r && f !== m) {
                const _ = o.slice(m, f);
                for (m = f; f < r && Nt(o.charCodeAt(f)); ) f++;
                if (f < r && f !== m) {
                  for (m = f; f < r && !Nt(o.charCodeAt(f)); ) f++;
                  (f === r || f !== m) && (l = `\\\\${_}\\${o.slice(m, f)}`, a = f);
                }
              }
            } else a = 1;
            else yc(d) && o.charCodeAt(1) === wc && (l = o.slice(0, 2), a = 2, r > 2 && Nt(o.charCodeAt(2)) && (u = true, a = 3));
            if (l.length > 0) if (e.length > 0) {
              if (l.toLowerCase() !== e.toLowerCase()) continue;
            } else e = l;
            if (i) {
              if (e.length > 0) break;
            } else if (t = `${o.slice(a)}\\${t}`, i = u, u && e.length > 0) break;
          }
          return t = X0(t, !i, "\\", Nt), i ? `${e}\\${t}` : `${e}${t}` || ".";
        },
        normalize(s) {
          sn(s, "path");
          const e = s.length;
          if (e === 0) return ".";
          let t = 0, i, n = false;
          const o = s.charCodeAt(0);
          if (e === 1) return Px(o) ? "\\" : s;
          if (Nt(o)) if (n = true, Nt(s.charCodeAt(1))) {
            let a = 2, l = a;
            for (; a < e && !Nt(s.charCodeAt(a)); ) a++;
            if (a < e && a !== l) {
              const u = s.slice(l, a);
              for (l = a; a < e && Nt(s.charCodeAt(a)); ) a++;
              if (a < e && a !== l) {
                for (l = a; a < e && !Nt(s.charCodeAt(a)); ) a++;
                if (a === e) return `\\\\${u}\\${s.slice(l)}\\`;
                a !== l && (i = `\\\\${u}\\${s.slice(l, a)}`, t = a);
              }
            }
          } else t = 1;
          else yc(o) && s.charCodeAt(1) === wc && (i = s.slice(0, 2), t = 2, e > 2 && Nt(s.charCodeAt(2)) && (n = true, t = 3));
          let r = t < e ? X0(s.slice(t), !n, "\\", Nt) : "";
          return r.length === 0 && !n && (r = "."), r.length > 0 && Nt(s.charCodeAt(e - 1)) && (r += "\\"), i === void 0 ? n ? `\\${r}` : r : n ? `${i}\\${r}` : `${i}${r}`;
        },
        isAbsolute(s) {
          sn(s, "path");
          const e = s.length;
          if (e === 0) return false;
          const t = s.charCodeAt(0);
          return Nt(t) || e > 2 && yc(t) && s.charCodeAt(1) === wc && Nt(s.charCodeAt(2));
        },
        join(...s) {
          if (s.length === 0) return ".";
          let e, t;
          for (let o = 0; o < s.length; ++o) {
            const r = s[o];
            sn(r, "path"), r.length > 0 && (e === void 0 ? e = t = r : e += `\\${r}`);
          }
          if (e === void 0) return ".";
          let i = true, n = 0;
          if (typeof t == "string" && Nt(t.charCodeAt(0))) {
            ++n;
            const o = t.length;
            o > 1 && Nt(t.charCodeAt(1)) && (++n, o > 2 && (Nt(t.charCodeAt(2)) ? ++n : i = false));
          }
          if (i) {
            for (; n < e.length && Nt(e.charCodeAt(n)); ) n++;
            n >= 2 && (e = `\\${e.slice(n)}`);
          }
          return Ts.normalize(e);
        },
        relative(s, e) {
          if (sn(s, "from"), sn(e, "to"), s === e) return "";
          const t = Ts.resolve(s), i = Ts.resolve(e);
          if (t === i || (s = t.toLowerCase(), e = i.toLowerCase(), s === e)) return "";
          let n = 0;
          for (; n < s.length && s.charCodeAt(n) === no; ) n++;
          let o = s.length;
          for (; o - 1 > n && s.charCodeAt(o - 1) === no; ) o--;
          const r = o - n;
          let a = 0;
          for (; a < e.length && e.charCodeAt(a) === no; ) a++;
          let l = e.length;
          for (; l - 1 > a && e.charCodeAt(l - 1) === no; ) l--;
          const u = l - a, d = r < u ? r : u;
          let f = -1, m = 0;
          for (; m < d; m++) {
            const b = s.charCodeAt(n + m);
            if (b !== e.charCodeAt(a + m)) break;
            b === no && (f = m);
          }
          if (m !== d) {
            if (f === -1) return i;
          } else {
            if (u > d) {
              if (e.charCodeAt(a + m) === no) return i.slice(a + m + 1);
              if (m === 2) return i.slice(a + m);
            }
            r > d && (s.charCodeAt(n + m) === no ? f = m : m === 2 && (f = 3)), f === -1 && (f = 0);
          }
          let _ = "";
          for (m = n + f + 1; m <= o; ++m) (m === o || s.charCodeAt(m) === no) && (_ += _.length === 0 ? ".." : "\\..");
          return a += f, _.length > 0 ? `${_}${i.slice(a, l)}` : (i.charCodeAt(a) === no && ++a, i.slice(a, l));
        },
        toNamespacedPath(s) {
          if (typeof s != "string" || s.length === 0) return s;
          const e = Ts.resolve(s);
          if (e.length <= 2) return s;
          if (e.charCodeAt(0) === no) {
            if (e.charCodeAt(1) === no) {
              const t = e.charCodeAt(2);
              if (t !== eq && t !== Xc) return `\\\\?\\UNC\\${e.slice(2)}`;
            }
          } else if (yc(e.charCodeAt(0)) && e.charCodeAt(1) === wc && e.charCodeAt(2) === no) return `\\\\?\\${e}`;
          return s;
        },
        dirname(s) {
          sn(s, "path");
          const e = s.length;
          if (e === 0) return ".";
          let t = -1, i = 0;
          const n = s.charCodeAt(0);
          if (e === 1) return Nt(n) ? s : ".";
          if (Nt(n)) {
            if (t = i = 1, Nt(s.charCodeAt(1))) {
              let a = 2, l = a;
              for (; a < e && !Nt(s.charCodeAt(a)); ) a++;
              if (a < e && a !== l) {
                for (l = a; a < e && Nt(s.charCodeAt(a)); ) a++;
                if (a < e && a !== l) {
                  for (l = a; a < e && !Nt(s.charCodeAt(a)); ) a++;
                  if (a === e) return s;
                  a !== l && (t = i = a + 1);
                }
              }
            }
          } else yc(n) && s.charCodeAt(1) === wc && (t = e > 2 && Nt(s.charCodeAt(2)) ? 3 : 2, i = t);
          let o = -1, r = true;
          for (let a = e - 1; a >= i; --a) if (Nt(s.charCodeAt(a))) {
            if (!r) {
              o = a;
              break;
            }
          } else r = false;
          if (o === -1) {
            if (t === -1) return ".";
            o = t;
          }
          return s.slice(0, o);
        },
        basename(s, e) {
          e !== void 0 && sn(e, "suffix"), sn(s, "path");
          let t = 0, i = -1, n = true, o;
          if (s.length >= 2 && yc(s.charCodeAt(0)) && s.charCodeAt(1) === wc && (t = 2), e !== void 0 && e.length > 0 && e.length <= s.length) {
            if (e === s) return "";
            let r = e.length - 1, a = -1;
            for (o = s.length - 1; o >= t; --o) {
              const l = s.charCodeAt(o);
              if (Nt(l)) {
                if (!n) {
                  t = o + 1;
                  break;
                }
              } else a === -1 && (n = false, a = o + 1), r >= 0 && (l === e.charCodeAt(r) ? --r === -1 && (i = o) : (r = -1, i = a));
            }
            return t === i ? i = a : i === -1 && (i = s.length), s.slice(t, i);
          }
          for (o = s.length - 1; o >= t; --o) if (Nt(s.charCodeAt(o))) {
            if (!n) {
              t = o + 1;
              break;
            }
          } else i === -1 && (n = false, i = o + 1);
          return i === -1 ? "" : s.slice(t, i);
        },
        extname(s) {
          sn(s, "path");
          let e = 0, t = -1, i = 0, n = -1, o = true, r = 0;
          s.length >= 2 && s.charCodeAt(1) === wc && yc(s.charCodeAt(0)) && (e = i = 2);
          for (let a = s.length - 1; a >= e; --a) {
            const l = s.charCodeAt(a);
            if (Nt(l)) {
              if (!o) {
                i = a + 1;
                break;
              }
              continue;
            }
            n === -1 && (o = false, n = a + 1), l === Xc ? t === -1 ? t = a : r !== 1 && (r = 1) : t !== -1 && (r = -1);
          }
          return t === -1 || n === -1 || r === 0 || r === 1 && t === n - 1 && t === i + 1 ? "" : s.slice(t, n);
        },
        format: g9.bind(null, "\\"),
        parse(s) {
          sn(s, "path");
          const e = {
            root: "",
            dir: "",
            base: "",
            ext: "",
            name: ""
          };
          if (s.length === 0) return e;
          const t = s.length;
          let i = 0, n = s.charCodeAt(0);
          if (t === 1) return Nt(n) ? (e.root = e.dir = s, e) : (e.base = e.name = s, e);
          if (Nt(n)) {
            if (i = 1, Nt(s.charCodeAt(1))) {
              let f = 2, m = f;
              for (; f < t && !Nt(s.charCodeAt(f)); ) f++;
              if (f < t && f !== m) {
                for (m = f; f < t && Nt(s.charCodeAt(f)); ) f++;
                if (f < t && f !== m) {
                  for (m = f; f < t && !Nt(s.charCodeAt(f)); ) f++;
                  f === t ? i = f : f !== m && (i = f + 1);
                }
              }
            }
          } else if (yc(n) && s.charCodeAt(1) === wc) {
            if (t <= 2) return e.root = e.dir = s, e;
            if (i = 2, Nt(s.charCodeAt(2))) {
              if (t === 3) return e.root = e.dir = s, e;
              i = 3;
            }
          }
          i > 0 && (e.root = s.slice(0, i));
          let o = -1, r = i, a = -1, l = true, u = s.length - 1, d = 0;
          for (; u >= i; --u) {
            if (n = s.charCodeAt(u), Nt(n)) {
              if (!l) {
                r = u + 1;
                break;
              }
              continue;
            }
            a === -1 && (l = false, a = u + 1), n === Xc ? o === -1 ? o = u : d !== 1 && (d = 1) : o !== -1 && (d = -1);
          }
          return a !== -1 && (o === -1 || d === 0 || d === 1 && o === a - 1 && o === r + 1 ? e.base = e.name = s.slice(r, a) : (e.name = s.slice(r, o), e.base = s.slice(r, a), e.ext = s.slice(o, a))), r > 0 && r !== i ? e.dir = s.slice(0, r - 1) : e.dir = e.root, e;
        },
        sep: "\\",
        delimiter: ";",
        win32: null,
        posix: null
      }, nq = (() => {
        if (Kl) {
          const s = /\\/g;
          return () => {
            const e = Q0().replace(s, "/");
            return e.slice(e.indexOf("/"));
          };
        }
        return () => Q0();
      })(), Ii = {
        resolve(...s) {
          let e = "", t = false;
          for (let i = s.length - 1; i >= -1 && !t; i--) {
            const n = i >= 0 ? s[i] : nq();
            sn(n, `paths[${i}]`), n.length !== 0 && (e = `${n}/${e}`, t = n.charCodeAt(0) === Xn);
          }
          return e = X0(e, !t, "/", Px), t ? `/${e}` : e.length > 0 ? e : ".";
        },
        normalize(s) {
          if (sn(s, "path"), s.length === 0) return ".";
          const e = s.charCodeAt(0) === Xn, t = s.charCodeAt(s.length - 1) === Xn;
          return s = X0(s, !e, "/", Px), s.length === 0 ? e ? "/" : t ? "./" : "." : (t && (s += "/"), e ? `/${s}` : s);
        },
        isAbsolute(s) {
          return sn(s, "path"), s.length > 0 && s.charCodeAt(0) === Xn;
        },
        join(...s) {
          if (s.length === 0) return ".";
          let e;
          for (let t = 0; t < s.length; ++t) {
            const i = s[t];
            sn(i, "path"), i.length > 0 && (e === void 0 ? e = i : e += `/${i}`);
          }
          return e === void 0 ? "." : Ii.normalize(e);
        },
        relative(s, e) {
          if (sn(s, "from"), sn(e, "to"), s === e || (s = Ii.resolve(s), e = Ii.resolve(e), s === e)) return "";
          const t = 1, i = s.length, n = i - t, o = 1, r = e.length - o, a = n < r ? n : r;
          let l = -1, u = 0;
          for (; u < a; u++) {
            const f = s.charCodeAt(t + u);
            if (f !== e.charCodeAt(o + u)) break;
            f === Xn && (l = u);
          }
          if (u === a) if (r > a) {
            if (e.charCodeAt(o + u) === Xn) return e.slice(o + u + 1);
            if (u === 0) return e.slice(o + u);
          } else n > a && (s.charCodeAt(t + u) === Xn ? l = u : u === 0 && (l = 0));
          let d = "";
          for (u = t + l + 1; u <= i; ++u) (u === i || s.charCodeAt(u) === Xn) && (d += d.length === 0 ? ".." : "/..");
          return `${d}${e.slice(o + l)}`;
        },
        toNamespacedPath(s) {
          return s;
        },
        dirname(s) {
          if (sn(s, "path"), s.length === 0) return ".";
          const e = s.charCodeAt(0) === Xn;
          let t = -1, i = true;
          for (let n = s.length - 1; n >= 1; --n) if (s.charCodeAt(n) === Xn) {
            if (!i) {
              t = n;
              break;
            }
          } else i = false;
          return t === -1 ? e ? "/" : "." : e && t === 1 ? "//" : s.slice(0, t);
        },
        basename(s, e) {
          e !== void 0 && sn(e, "ext"), sn(s, "path");
          let t = 0, i = -1, n = true, o;
          if (e !== void 0 && e.length > 0 && e.length <= s.length) {
            if (e === s) return "";
            let r = e.length - 1, a = -1;
            for (o = s.length - 1; o >= 0; --o) {
              const l = s.charCodeAt(o);
              if (l === Xn) {
                if (!n) {
                  t = o + 1;
                  break;
                }
              } else a === -1 && (n = false, a = o + 1), r >= 0 && (l === e.charCodeAt(r) ? --r === -1 && (i = o) : (r = -1, i = a));
            }
            return t === i ? i = a : i === -1 && (i = s.length), s.slice(t, i);
          }
          for (o = s.length - 1; o >= 0; --o) if (s.charCodeAt(o) === Xn) {
            if (!n) {
              t = o + 1;
              break;
            }
          } else i === -1 && (n = false, i = o + 1);
          return i === -1 ? "" : s.slice(t, i);
        },
        extname(s) {
          sn(s, "path");
          let e = -1, t = 0, i = -1, n = true, o = 0;
          for (let r = s.length - 1; r >= 0; --r) {
            const a = s.charCodeAt(r);
            if (a === Xn) {
              if (!n) {
                t = r + 1;
                break;
              }
              continue;
            }
            i === -1 && (n = false, i = r + 1), a === Xc ? e === -1 ? e = r : o !== 1 && (o = 1) : e !== -1 && (o = -1);
          }
          return e === -1 || i === -1 || o === 0 || o === 1 && e === i - 1 && e === t + 1 ? "" : s.slice(e, i);
        },
        format: g9.bind(null, "/"),
        parse(s) {
          sn(s, "path");
          const e = {
            root: "",
            dir: "",
            base: "",
            ext: "",
            name: ""
          };
          if (s.length === 0) return e;
          const t = s.charCodeAt(0) === Xn;
          let i;
          t ? (e.root = "/", i = 1) : i = 0;
          let n = -1, o = 0, r = -1, a = true, l = s.length - 1, u = 0;
          for (; l >= i; --l) {
            const d = s.charCodeAt(l);
            if (d === Xn) {
              if (!a) {
                o = l + 1;
                break;
              }
              continue;
            }
            r === -1 && (a = false, r = l + 1), d === Xc ? n === -1 ? n = l : u !== 1 && (u = 1) : n !== -1 && (u = -1);
          }
          if (r !== -1) {
            const d = o === 0 && t ? 1 : o;
            n === -1 || u === 0 || u === 1 && n === r - 1 && n === o + 1 ? e.base = e.name = s.slice(d, r) : (e.name = s.slice(d, n), e.base = s.slice(d, r), e.ext = s.slice(n, r));
          }
          return o > 0 ? e.dir = s.slice(0, o - 1) : t && (e.dir = "/"), e;
        },
        sep: "/",
        delimiter: ":",
        win32: null,
        posix: null
      };
      Ii.win32 = Ts.win32 = Ts;
      Ii.posix = Ts.posix = Ii;
      const m9 = Kl ? Ts.normalize : Ii.normalize, sq = Kl ? Ts.join : Ii.join, oq = Kl ? Ts.resolve : Ii.resolve, rq = Kl ? Ts.relative : Ii.relative, aq = Kl ? Ts.dirname : Ii.dirname, p9 = Kl ? Ts.basename : Ii.basename, lq = Kl ? Ts.extname : Ii.extname, Jc = Kl ? Ts.sep : Ii.sep, cq = /^\w[\w\d+.-]*$/, uq = /^\//, hq = /^\/\//;
      function dq(s, e) {
        if (!s.scheme && e) throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${s.authority}", path: "${s.path}", query: "${s.query}", fragment: "${s.fragment}"}`);
        if (s.scheme && !cq.test(s.scheme)) throw new Error("[UriError]: Scheme contains illegal characters.");
        if (s.path) {
          if (s.authority) {
            if (!uq.test(s.path)) throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
          } else if (hq.test(s.path)) throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
        }
      }
      function fq(s, e) {
        return !s && !e ? "file" : s;
      }
      function gq(s, e) {
        switch (s) {
          case "https":
          case "http":
          case "file":
            e ? e[0] !== Or && (e = Or + e) : e = Or;
            break;
        }
        return e;
      }
      const Di = "", Or = "/", mq = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
      class st {
        static isUri(e) {
          return e instanceof st ? true : e ? typeof e.authority == "string" && typeof e.fragment == "string" && typeof e.path == "string" && typeof e.query == "string" && typeof e.scheme == "string" && typeof e.fsPath == "string" && typeof e.with == "function" && typeof e.toString == "function" : false;
        }
        constructor(e, t, i, n, o, r = false) {
          typeof e == "object" ? (this.scheme = e.scheme || Di, this.authority = e.authority || Di, this.path = e.path || Di, this.query = e.query || Di, this.fragment = e.fragment || Di) : (this.scheme = fq(e, r), this.authority = t || Di, this.path = gq(this.scheme, i || Di), this.query = n || Di, this.fragment = o || Di, dq(this, r));
        }
        get fsPath() {
          return J0(this, false);
        }
        with(e) {
          if (!e) return this;
          let { scheme: t, authority: i, path: n, query: o, fragment: r } = e;
          return t === void 0 ? t = this.scheme : t === null && (t = Di), i === void 0 ? i = this.authority : i === null && (i = Di), n === void 0 ? n = this.path : n === null && (n = Di), o === void 0 ? o = this.query : o === null && (o = Di), r === void 0 ? r = this.fragment : r === null && (r = Di), t === this.scheme && i === this.authority && n === this.path && o === this.query && r === this.fragment ? this : new qd(t, i, n, o, r);
        }
        static parse(e, t = false) {
          const i = mq.exec(e);
          return i ? new qd(i[2] || Di, yb(i[4] || Di), yb(i[5] || Di), yb(i[7] || Di), yb(i[9] || Di), t) : new qd(Di, Di, Di, Di, Di);
        }
        static file(e) {
          let t = Di;
          if (Ks && (e = e.replace(/\\/g, Or)), e[0] === Or && e[1] === Or) {
            const i = e.indexOf(Or, 2);
            i === -1 ? (t = e.substring(2), e = Or) : (t = e.substring(2, i), e = e.substring(i) || Or);
          }
          return new qd("file", t, e, Di, Di);
        }
        static from(e, t) {
          return new qd(e.scheme, e.authority, e.path, e.query, e.fragment, t);
        }
        static joinPath(e, ...t) {
          if (!e.path) throw new Error("[UriError]: cannot call joinPath on URI without path");
          let i;
          return Ks && e.scheme === "file" ? i = st.file(Ts.join(J0(e, true), ...t)).path : i = Ii.join(e.path, ...t), e.with({
            path: i
          });
        }
        toString(e = false) {
          return Bx(this, e);
        }
        toJSON() {
          return this;
        }
        static revive(e) {
          if (e) {
            if (e instanceof st) return e;
            {
              const t = new qd(e);
              return t._formatted = e.external ?? null, t._fsPath = e._sep === _9 ? e.fsPath ?? null : null, t;
            }
          } else return e;
        }
      }
      const _9 = Ks ? 1 : void 0;
      class qd extends st {
        constructor() {
          super(...arguments), this._formatted = null, this._fsPath = null;
        }
        get fsPath() {
          return this._fsPath || (this._fsPath = J0(this, false)), this._fsPath;
        }
        toString(e = false) {
          return e ? Bx(this, true) : (this._formatted || (this._formatted = Bx(this, false)), this._formatted);
        }
        toJSON() {
          const e = {
            $mid: 1
          };
          return this._fsPath && (e.fsPath = this._fsPath, e._sep = _9), this._formatted && (e.external = this._formatted), this.path && (e.path = this.path), this.scheme && (e.scheme = this.scheme), this.authority && (e.authority = this.authority), this.query && (e.query = this.query), this.fragment && (e.fragment = this.fragment), e;
        }
      }
      const b9 = {
        58: "%3A",
        47: "%2F",
        63: "%3F",
        35: "%23",
        91: "%5B",
        93: "%5D",
        64: "%40",
        33: "%21",
        36: "%24",
        38: "%26",
        39: "%27",
        40: "%28",
        41: "%29",
        42: "%2A",
        43: "%2B",
        44: "%2C",
        59: "%3B",
        61: "%3D",
        32: "%20"
      };
      function M4(s, e, t) {
        let i, n = -1;
        for (let o = 0; o < s.length; o++) {
          const r = s.charCodeAt(o);
          if (r >= 97 && r <= 122 || r >= 65 && r <= 90 || r >= 48 && r <= 57 || r === 45 || r === 46 || r === 95 || r === 126 || e && r === 47 || t && r === 91 || t && r === 93 || t && r === 58) n !== -1 && (i += encodeURIComponent(s.substring(n, o)), n = -1), i !== void 0 && (i += s.charAt(o));
          else {
            i === void 0 && (i = s.substr(0, o));
            const a = b9[r];
            a !== void 0 ? (n !== -1 && (i += encodeURIComponent(s.substring(n, o)), n = -1), i += a) : n === -1 && (n = o);
          }
        }
        return n !== -1 && (i += encodeURIComponent(s.substring(n))), i !== void 0 ? i : s;
      }
      function pq(s) {
        let e;
        for (let t = 0; t < s.length; t++) {
          const i = s.charCodeAt(t);
          i === 35 || i === 63 ? (e === void 0 && (e = s.substr(0, t)), e += b9[i]) : e !== void 0 && (e += s[t]);
        }
        return e !== void 0 ? e : s;
      }
      function J0(s, e) {
        let t;
        return s.authority && s.path.length > 1 && s.scheme === "file" ? t = `//${s.authority}${s.path}` : s.path.charCodeAt(0) === 47 && (s.path.charCodeAt(1) >= 65 && s.path.charCodeAt(1) <= 90 || s.path.charCodeAt(1) >= 97 && s.path.charCodeAt(1) <= 122) && s.path.charCodeAt(2) === 58 ? e ? t = s.path.substr(1) : t = s.path[1].toLowerCase() + s.path.substr(2) : t = s.path, Ks && (t = t.replace(/\//g, "\\")), t;
      }
      function Bx(s, e) {
        const t = e ? pq : M4;
        let i = "", { scheme: n, authority: o, path: r, query: a, fragment: l } = s;
        if (n && (i += n, i += ":"), (o || n === "file") && (i += Or, i += Or), o) {
          let u = o.indexOf("@");
          if (u !== -1) {
            const d = o.substr(0, u);
            o = o.substr(u + 1), u = d.lastIndexOf(":"), u === -1 ? i += t(d, false, false) : (i += t(d.substr(0, u), false, false), i += ":", i += t(d.substr(u + 1), false, true)), i += "@";
          }
          o = o.toLowerCase(), u = o.lastIndexOf(":"), u === -1 ? i += t(o, false, true) : (i += t(o.substr(0, u), false, true), i += o.substr(u));
        }
        if (r) {
          if (r.length >= 3 && r.charCodeAt(0) === 47 && r.charCodeAt(2) === 58) {
            const u = r.charCodeAt(1);
            u >= 65 && u <= 90 && (r = `/${String.fromCharCode(u + 32)}:${r.substr(3)}`);
          } else if (r.length >= 2 && r.charCodeAt(1) === 58) {
            const u = r.charCodeAt(0);
            u >= 65 && u <= 90 && (r = `${String.fromCharCode(u + 32)}:${r.substr(2)}`);
          }
          i += t(r, true, false);
        }
        return a && (i += "?", i += t(a, false, false)), l && (i += "#", i += e ? l : M4(l, false, false)), i;
      }
      function v9(s) {
        try {
          return decodeURIComponent(s);
        } catch {
          return s.length > 3 ? s.substr(0, 3) + v9(s.substr(3)) : s;
        }
      }
      const A4 = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
      function yb(s) {
        return s.match(A4) ? s.replace(A4, (e) => v9(e)) : s;
      }
      class X {
        constructor(e, t) {
          this.lineNumber = e, this.column = t;
        }
        with(e = this.lineNumber, t = this.column) {
          return e === this.lineNumber && t === this.column ? this : new X(e, t);
        }
        delta(e = 0, t = 0) {
          return this.with(this.lineNumber + e, this.column + t);
        }
        equals(e) {
          return X.equals(this, e);
        }
        static equals(e, t) {
          return !e && !t ? true : !!e && !!t && e.lineNumber === t.lineNumber && e.column === t.column;
        }
        isBefore(e) {
          return X.isBefore(this, e);
        }
        static isBefore(e, t) {
          return e.lineNumber < t.lineNumber ? true : t.lineNumber < e.lineNumber ? false : e.column < t.column;
        }
        isBeforeOrEqual(e) {
          return X.isBeforeOrEqual(this, e);
        }
        static isBeforeOrEqual(e, t) {
          return e.lineNumber < t.lineNumber ? true : t.lineNumber < e.lineNumber ? false : e.column <= t.column;
        }
        static compare(e, t) {
          const i = e.lineNumber | 0, n = t.lineNumber | 0;
          if (i === n) {
            const o = e.column | 0, r = t.column | 0;
            return o - r;
          }
          return i - n;
        }
        clone() {
          return new X(this.lineNumber, this.column);
        }
        toString() {
          return "(" + this.lineNumber + "," + this.column + ")";
        }
        static lift(e) {
          return new X(e.lineNumber, e.column);
        }
        static isIPosition(e) {
          return e && typeof e.lineNumber == "number" && typeof e.column == "number";
        }
        toJSON() {
          return {
            lineNumber: this.lineNumber,
            column: this.column
          };
        }
      }
      let z = class pn {
        constructor(e, t, i, n) {
          e > i || e === i && t > n ? (this.startLineNumber = i, this.startColumn = n, this.endLineNumber = e, this.endColumn = t) : (this.startLineNumber = e, this.startColumn = t, this.endLineNumber = i, this.endColumn = n);
        }
        isEmpty() {
          return pn.isEmpty(this);
        }
        static isEmpty(e) {
          return e.startLineNumber === e.endLineNumber && e.startColumn === e.endColumn;
        }
        containsPosition(e) {
          return pn.containsPosition(this, e);
        }
        static containsPosition(e, t) {
          return !(t.lineNumber < e.startLineNumber || t.lineNumber > e.endLineNumber || t.lineNumber === e.startLineNumber && t.column < e.startColumn || t.lineNumber === e.endLineNumber && t.column > e.endColumn);
        }
        static strictContainsPosition(e, t) {
          return !(t.lineNumber < e.startLineNumber || t.lineNumber > e.endLineNumber || t.lineNumber === e.startLineNumber && t.column <= e.startColumn || t.lineNumber === e.endLineNumber && t.column >= e.endColumn);
        }
        containsRange(e) {
          return pn.containsRange(this, e);
        }
        static containsRange(e, t) {
          return !(t.startLineNumber < e.startLineNumber || t.endLineNumber < e.startLineNumber || t.startLineNumber > e.endLineNumber || t.endLineNumber > e.endLineNumber || t.startLineNumber === e.startLineNumber && t.startColumn < e.startColumn || t.endLineNumber === e.endLineNumber && t.endColumn > e.endColumn);
        }
        strictContainsRange(e) {
          return pn.strictContainsRange(this, e);
        }
        static strictContainsRange(e, t) {
          return !(t.startLineNumber < e.startLineNumber || t.endLineNumber < e.startLineNumber || t.startLineNumber > e.endLineNumber || t.endLineNumber > e.endLineNumber || t.startLineNumber === e.startLineNumber && t.startColumn <= e.startColumn || t.endLineNumber === e.endLineNumber && t.endColumn >= e.endColumn);
        }
        plusRange(e) {
          return pn.plusRange(this, e);
        }
        static plusRange(e, t) {
          let i, n, o, r;
          return t.startLineNumber < e.startLineNumber ? (i = t.startLineNumber, n = t.startColumn) : t.startLineNumber === e.startLineNumber ? (i = t.startLineNumber, n = Math.min(t.startColumn, e.startColumn)) : (i = e.startLineNumber, n = e.startColumn), t.endLineNumber > e.endLineNumber ? (o = t.endLineNumber, r = t.endColumn) : t.endLineNumber === e.endLineNumber ? (o = t.endLineNumber, r = Math.max(t.endColumn, e.endColumn)) : (o = e.endLineNumber, r = e.endColumn), new pn(i, n, o, r);
        }
        intersectRanges(e) {
          return pn.intersectRanges(this, e);
        }
        static intersectRanges(e, t) {
          let i = e.startLineNumber, n = e.startColumn, o = e.endLineNumber, r = e.endColumn;
          const a = t.startLineNumber, l = t.startColumn, u = t.endLineNumber, d = t.endColumn;
          return i < a ? (i = a, n = l) : i === a && (n = Math.max(n, l)), o > u ? (o = u, r = d) : o === u && (r = Math.min(r, d)), i > o || i === o && n > r ? null : new pn(i, n, o, r);
        }
        equalsRange(e) {
          return pn.equalsRange(this, e);
        }
        static equalsRange(e, t) {
          return !e && !t ? true : !!e && !!t && e.startLineNumber === t.startLineNumber && e.startColumn === t.startColumn && e.endLineNumber === t.endLineNumber && e.endColumn === t.endColumn;
        }
        getEndPosition() {
          return pn.getEndPosition(this);
        }
        static getEndPosition(e) {
          return new X(e.endLineNumber, e.endColumn);
        }
        getStartPosition() {
          return pn.getStartPosition(this);
        }
        static getStartPosition(e) {
          return new X(e.startLineNumber, e.startColumn);
        }
        toString() {
          return "[" + this.startLineNumber + "," + this.startColumn + " -> " + this.endLineNumber + "," + this.endColumn + "]";
        }
        setEndPosition(e, t) {
          return new pn(this.startLineNumber, this.startColumn, e, t);
        }
        setStartPosition(e, t) {
          return new pn(e, t, this.endLineNumber, this.endColumn);
        }
        collapseToStart() {
          return pn.collapseToStart(this);
        }
        static collapseToStart(e) {
          return new pn(e.startLineNumber, e.startColumn, e.startLineNumber, e.startColumn);
        }
        collapseToEnd() {
          return pn.collapseToEnd(this);
        }
        static collapseToEnd(e) {
          return new pn(e.endLineNumber, e.endColumn, e.endLineNumber, e.endColumn);
        }
        delta(e) {
          return new pn(this.startLineNumber + e, this.startColumn, this.endLineNumber + e, this.endColumn);
        }
        static fromPositions(e, t = e) {
          return new pn(e.lineNumber, e.column, t.lineNumber, t.column);
        }
        static lift(e) {
          return e ? new pn(e.startLineNumber, e.startColumn, e.endLineNumber, e.endColumn) : null;
        }
        static isIRange(e) {
          return e && typeof e.startLineNumber == "number" && typeof e.startColumn == "number" && typeof e.endLineNumber == "number" && typeof e.endColumn == "number";
        }
        static areIntersectingOrTouching(e, t) {
          return !(e.endLineNumber < t.startLineNumber || e.endLineNumber === t.startLineNumber && e.endColumn < t.startColumn || t.endLineNumber < e.startLineNumber || t.endLineNumber === e.startLineNumber && t.endColumn < e.startColumn);
        }
        static areIntersecting(e, t) {
          return !(e.endLineNumber < t.startLineNumber || e.endLineNumber === t.startLineNumber && e.endColumn <= t.startColumn || t.endLineNumber < e.startLineNumber || t.endLineNumber === e.startLineNumber && t.endColumn <= e.startColumn);
        }
        static compareRangesUsingStarts(e, t) {
          if (e && t) {
            const o = e.startLineNumber | 0, r = t.startLineNumber | 0;
            if (o === r) {
              const a = e.startColumn | 0, l = t.startColumn | 0;
              if (a === l) {
                const u = e.endLineNumber | 0, d = t.endLineNumber | 0;
                if (u === d) {
                  const f = e.endColumn | 0, m = t.endColumn | 0;
                  return f - m;
                }
                return u - d;
              }
              return a - l;
            }
            return o - r;
          }
          return (e ? 1 : 0) - (t ? 1 : 0);
        }
        static compareRangesUsingEnds(e, t) {
          return e.endLineNumber === t.endLineNumber ? e.endColumn === t.endColumn ? e.startLineNumber === t.startLineNumber ? e.startColumn - t.startColumn : e.startLineNumber - t.startLineNumber : e.endColumn - t.endColumn : e.endLineNumber - t.endLineNumber;
        }
        static spansMultipleLines(e) {
          return e.endLineNumber > e.startLineNumber;
        }
        toJSON() {
          return this;
        }
      };
      class mt extends z {
        constructor(e, t, i, n) {
          super(e, t, i, n), this.selectionStartLineNumber = e, this.selectionStartColumn = t, this.positionLineNumber = i, this.positionColumn = n;
        }
        toString() {
          return "[" + this.selectionStartLineNumber + "," + this.selectionStartColumn + " -> " + this.positionLineNumber + "," + this.positionColumn + "]";
        }
        equalsSelection(e) {
          return mt.selectionsEqual(this, e);
        }
        static selectionsEqual(e, t) {
          return e.selectionStartLineNumber === t.selectionStartLineNumber && e.selectionStartColumn === t.selectionStartColumn && e.positionLineNumber === t.positionLineNumber && e.positionColumn === t.positionColumn;
        }
        getDirection() {
          return this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn ? 0 : 1;
        }
        setEndPosition(e, t) {
          return this.getDirection() === 0 ? new mt(this.startLineNumber, this.startColumn, e, t) : new mt(e, t, this.startLineNumber, this.startColumn);
        }
        getPosition() {
          return new X(this.positionLineNumber, this.positionColumn);
        }
        getSelectionStart() {
          return new X(this.selectionStartLineNumber, this.selectionStartColumn);
        }
        setStartPosition(e, t) {
          return this.getDirection() === 0 ? new mt(e, t, this.endLineNumber, this.endColumn) : new mt(this.endLineNumber, this.endColumn, e, t);
        }
        static fromPositions(e, t = e) {
          return new mt(e.lineNumber, e.column, t.lineNumber, t.column);
        }
        static fromRange(e, t) {
          return t === 0 ? new mt(e.startLineNumber, e.startColumn, e.endLineNumber, e.endColumn) : new mt(e.endLineNumber, e.endColumn, e.startLineNumber, e.startColumn);
        }
        static liftSelection(e) {
          return new mt(e.selectionStartLineNumber, e.selectionStartColumn, e.positionLineNumber, e.positionColumn);
        }
        static selectionsArrEqual(e, t) {
          if (e && !t || !e && t) return false;
          if (!e && !t) return true;
          if (e.length !== t.length) return false;
          for (let i = 0, n = e.length; i < n; i++) if (!this.selectionsEqual(e[i], t[i])) return false;
          return true;
        }
        static isISelection(e) {
          return e && typeof e.selectionStartLineNumber == "number" && typeof e.selectionStartColumn == "number" && typeof e.positionLineNumber == "number" && typeof e.positionColumn == "number";
        }
        static createWithDirection(e, t, i, n, o) {
          return o === 0 ? new mt(e, t, i, n) : new mt(i, n, e, t);
        }
      }
      const Fx = /* @__PURE__ */ Object.create(null);
      function E(s, e) {
        if (ho(e)) {
          const t = Fx[e];
          if (t === void 0) throw new Error(`${s} references an unknown codicon: ${e}`);
          e = t;
        }
        return Fx[s] = e, {
          id: s
        };
      }
      function C9() {
        return Fx;
      }
      const _q = {
        add: E("add", 6e4),
        plus: E("plus", 6e4),
        gistNew: E("gist-new", 6e4),
        repoCreate: E("repo-create", 6e4),
        lightbulb: E("lightbulb", 60001),
        lightBulb: E("light-bulb", 60001),
        repo: E("repo", 60002),
        repoDelete: E("repo-delete", 60002),
        gistFork: E("gist-fork", 60003),
        repoForked: E("repo-forked", 60003),
        gitPullRequest: E("git-pull-request", 60004),
        gitPullRequestAbandoned: E("git-pull-request-abandoned", 60004),
        recordKeys: E("record-keys", 60005),
        keyboard: E("keyboard", 60005),
        tag: E("tag", 60006),
        gitPullRequestLabel: E("git-pull-request-label", 60006),
        tagAdd: E("tag-add", 60006),
        tagRemove: E("tag-remove", 60006),
        person: E("person", 60007),
        personFollow: E("person-follow", 60007),
        personOutline: E("person-outline", 60007),
        personFilled: E("person-filled", 60007),
        gitBranch: E("git-branch", 60008),
        gitBranchCreate: E("git-branch-create", 60008),
        gitBranchDelete: E("git-branch-delete", 60008),
        sourceControl: E("source-control", 60008),
        mirror: E("mirror", 60009),
        mirrorPublic: E("mirror-public", 60009),
        star: E("star", 60010),
        starAdd: E("star-add", 60010),
        starDelete: E("star-delete", 60010),
        starEmpty: E("star-empty", 60010),
        comment: E("comment", 60011),
        commentAdd: E("comment-add", 60011),
        alert: E("alert", 60012),
        warning: E("warning", 60012),
        search: E("search", 60013),
        searchSave: E("search-save", 60013),
        logOut: E("log-out", 60014),
        signOut: E("sign-out", 60014),
        logIn: E("log-in", 60015),
        signIn: E("sign-in", 60015),
        eye: E("eye", 60016),
        eyeUnwatch: E("eye-unwatch", 60016),
        eyeWatch: E("eye-watch", 60016),
        circleFilled: E("circle-filled", 60017),
        primitiveDot: E("primitive-dot", 60017),
        closeDirty: E("close-dirty", 60017),
        debugBreakpoint: E("debug-breakpoint", 60017),
        debugBreakpointDisabled: E("debug-breakpoint-disabled", 60017),
        debugHint: E("debug-hint", 60017),
        terminalDecorationSuccess: E("terminal-decoration-success", 60017),
        primitiveSquare: E("primitive-square", 60018),
        edit: E("edit", 60019),
        pencil: E("pencil", 60019),
        info: E("info", 60020),
        issueOpened: E("issue-opened", 60020),
        gistPrivate: E("gist-private", 60021),
        gitForkPrivate: E("git-fork-private", 60021),
        lock: E("lock", 60021),
        mirrorPrivate: E("mirror-private", 60021),
        close: E("close", 60022),
        removeClose: E("remove-close", 60022),
        x: E("x", 60022),
        repoSync: E("repo-sync", 60023),
        sync: E("sync", 60023),
        clone: E("clone", 60024),
        desktopDownload: E("desktop-download", 60024),
        beaker: E("beaker", 60025),
        microscope: E("microscope", 60025),
        vm: E("vm", 60026),
        deviceDesktop: E("device-desktop", 60026),
        file: E("file", 60027),
        fileText: E("file-text", 60027),
        more: E("more", 60028),
        ellipsis: E("ellipsis", 60028),
        kebabHorizontal: E("kebab-horizontal", 60028),
        mailReply: E("mail-reply", 60029),
        reply: E("reply", 60029),
        organization: E("organization", 60030),
        organizationFilled: E("organization-filled", 60030),
        organizationOutline: E("organization-outline", 60030),
        newFile: E("new-file", 60031),
        fileAdd: E("file-add", 60031),
        newFolder: E("new-folder", 60032),
        fileDirectoryCreate: E("file-directory-create", 60032),
        trash: E("trash", 60033),
        trashcan: E("trashcan", 60033),
        history: E("history", 60034),
        clock: E("clock", 60034),
        folder: E("folder", 60035),
        fileDirectory: E("file-directory", 60035),
        symbolFolder: E("symbol-folder", 60035),
        logoGithub: E("logo-github", 60036),
        markGithub: E("mark-github", 60036),
        github: E("github", 60036),
        terminal: E("terminal", 60037),
        console: E("console", 60037),
        repl: E("repl", 60037),
        zap: E("zap", 60038),
        symbolEvent: E("symbol-event", 60038),
        error: E("error", 60039),
        stop: E("stop", 60039),
        variable: E("variable", 60040),
        symbolVariable: E("symbol-variable", 60040),
        array: E("array", 60042),
        symbolArray: E("symbol-array", 60042),
        symbolModule: E("symbol-module", 60043),
        symbolPackage: E("symbol-package", 60043),
        symbolNamespace: E("symbol-namespace", 60043),
        symbolObject: E("symbol-object", 60043),
        symbolMethod: E("symbol-method", 60044),
        symbolFunction: E("symbol-function", 60044),
        symbolConstructor: E("symbol-constructor", 60044),
        symbolBoolean: E("symbol-boolean", 60047),
        symbolNull: E("symbol-null", 60047),
        symbolNumeric: E("symbol-numeric", 60048),
        symbolNumber: E("symbol-number", 60048),
        symbolStructure: E("symbol-structure", 60049),
        symbolStruct: E("symbol-struct", 60049),
        symbolParameter: E("symbol-parameter", 60050),
        symbolTypeParameter: E("symbol-type-parameter", 60050),
        symbolKey: E("symbol-key", 60051),
        symbolText: E("symbol-text", 60051),
        symbolReference: E("symbol-reference", 60052),
        goToFile: E("go-to-file", 60052),
        symbolEnum: E("symbol-enum", 60053),
        symbolValue: E("symbol-value", 60053),
        symbolRuler: E("symbol-ruler", 60054),
        symbolUnit: E("symbol-unit", 60054),
        activateBreakpoints: E("activate-breakpoints", 60055),
        archive: E("archive", 60056),
        arrowBoth: E("arrow-both", 60057),
        arrowDown: E("arrow-down", 60058),
        arrowLeft: E("arrow-left", 60059),
        arrowRight: E("arrow-right", 60060),
        arrowSmallDown: E("arrow-small-down", 60061),
        arrowSmallLeft: E("arrow-small-left", 60062),
        arrowSmallRight: E("arrow-small-right", 60063),
        arrowSmallUp: E("arrow-small-up", 60064),
        arrowUp: E("arrow-up", 60065),
        bell: E("bell", 60066),
        bold: E("bold", 60067),
        book: E("book", 60068),
        bookmark: E("bookmark", 60069),
        debugBreakpointConditionalUnverified: E("debug-breakpoint-conditional-unverified", 60070),
        debugBreakpointConditional: E("debug-breakpoint-conditional", 60071),
        debugBreakpointConditionalDisabled: E("debug-breakpoint-conditional-disabled", 60071),
        debugBreakpointDataUnverified: E("debug-breakpoint-data-unverified", 60072),
        debugBreakpointData: E("debug-breakpoint-data", 60073),
        debugBreakpointDataDisabled: E("debug-breakpoint-data-disabled", 60073),
        debugBreakpointLogUnverified: E("debug-breakpoint-log-unverified", 60074),
        debugBreakpointLog: E("debug-breakpoint-log", 60075),
        debugBreakpointLogDisabled: E("debug-breakpoint-log-disabled", 60075),
        briefcase: E("briefcase", 60076),
        broadcast: E("broadcast", 60077),
        browser: E("browser", 60078),
        bug: E("bug", 60079),
        calendar: E("calendar", 60080),
        caseSensitive: E("case-sensitive", 60081),
        check: E("check", 60082),
        checklist: E("checklist", 60083),
        chevronDown: E("chevron-down", 60084),
        chevronLeft: E("chevron-left", 60085),
        chevronRight: E("chevron-right", 60086),
        chevronUp: E("chevron-up", 60087),
        chromeClose: E("chrome-close", 60088),
        chromeMaximize: E("chrome-maximize", 60089),
        chromeMinimize: E("chrome-minimize", 60090),
        chromeRestore: E("chrome-restore", 60091),
        circleOutline: E("circle-outline", 60092),
        circle: E("circle", 60092),
        debugBreakpointUnverified: E("debug-breakpoint-unverified", 60092),
        terminalDecorationIncomplete: E("terminal-decoration-incomplete", 60092),
        circleSlash: E("circle-slash", 60093),
        circuitBoard: E("circuit-board", 60094),
        clearAll: E("clear-all", 60095),
        clippy: E("clippy", 60096),
        closeAll: E("close-all", 60097),
        cloudDownload: E("cloud-download", 60098),
        cloudUpload: E("cloud-upload", 60099),
        code: E("code", 60100),
        collapseAll: E("collapse-all", 60101),
        colorMode: E("color-mode", 60102),
        commentDiscussion: E("comment-discussion", 60103),
        creditCard: E("credit-card", 60105),
        dash: E("dash", 60108),
        dashboard: E("dashboard", 60109),
        database: E("database", 60110),
        debugContinue: E("debug-continue", 60111),
        debugDisconnect: E("debug-disconnect", 60112),
        debugPause: E("debug-pause", 60113),
        debugRestart: E("debug-restart", 60114),
        debugStart: E("debug-start", 60115),
        debugStepInto: E("debug-step-into", 60116),
        debugStepOut: E("debug-step-out", 60117),
        debugStepOver: E("debug-step-over", 60118),
        debugStop: E("debug-stop", 60119),
        debug: E("debug", 60120),
        deviceCameraVideo: E("device-camera-video", 60121),
        deviceCamera: E("device-camera", 60122),
        deviceMobile: E("device-mobile", 60123),
        diffAdded: E("diff-added", 60124),
        diffIgnored: E("diff-ignored", 60125),
        diffModified: E("diff-modified", 60126),
        diffRemoved: E("diff-removed", 60127),
        diffRenamed: E("diff-renamed", 60128),
        diff: E("diff", 60129),
        diffSidebyside: E("diff-sidebyside", 60129),
        discard: E("discard", 60130),
        editorLayout: E("editor-layout", 60131),
        emptyWindow: E("empty-window", 60132),
        exclude: E("exclude", 60133),
        extensions: E("extensions", 60134),
        eyeClosed: E("eye-closed", 60135),
        fileBinary: E("file-binary", 60136),
        fileCode: E("file-code", 60137),
        fileMedia: E("file-media", 60138),
        filePdf: E("file-pdf", 60139),
        fileSubmodule: E("file-submodule", 60140),
        fileSymlinkDirectory: E("file-symlink-directory", 60141),
        fileSymlinkFile: E("file-symlink-file", 60142),
        fileZip: E("file-zip", 60143),
        files: E("files", 60144),
        filter: E("filter", 60145),
        flame: E("flame", 60146),
        foldDown: E("fold-down", 60147),
        foldUp: E("fold-up", 60148),
        fold: E("fold", 60149),
        folderActive: E("folder-active", 60150),
        folderOpened: E("folder-opened", 60151),
        gear: E("gear", 60152),
        gift: E("gift", 60153),
        gistSecret: E("gist-secret", 60154),
        gist: E("gist", 60155),
        gitCommit: E("git-commit", 60156),
        gitCompare: E("git-compare", 60157),
        compareChanges: E("compare-changes", 60157),
        gitMerge: E("git-merge", 60158),
        githubAction: E("github-action", 60159),
        githubAlt: E("github-alt", 60160),
        globe: E("globe", 60161),
        grabber: E("grabber", 60162),
        graph: E("graph", 60163),
        gripper: E("gripper", 60164),
        heart: E("heart", 60165),
        home: E("home", 60166),
        horizontalRule: E("horizontal-rule", 60167),
        hubot: E("hubot", 60168),
        inbox: E("inbox", 60169),
        issueReopened: E("issue-reopened", 60171),
        issues: E("issues", 60172),
        italic: E("italic", 60173),
        jersey: E("jersey", 60174),
        json: E("json", 60175),
        kebabVertical: E("kebab-vertical", 60176),
        key: E("key", 60177),
        law: E("law", 60178),
        lightbulbAutofix: E("lightbulb-autofix", 60179),
        linkExternal: E("link-external", 60180),
        link: E("link", 60181),
        listOrdered: E("list-ordered", 60182),
        listUnordered: E("list-unordered", 60183),
        liveShare: E("live-share", 60184),
        loading: E("loading", 60185),
        location: E("location", 60186),
        mailRead: E("mail-read", 60187),
        mail: E("mail", 60188),
        markdown: E("markdown", 60189),
        megaphone: E("megaphone", 60190),
        mention: E("mention", 60191),
        milestone: E("milestone", 60192),
        gitPullRequestMilestone: E("git-pull-request-milestone", 60192),
        mortarBoard: E("mortar-board", 60193),
        move: E("move", 60194),
        multipleWindows: E("multiple-windows", 60195),
        mute: E("mute", 60196),
        noNewline: E("no-newline", 60197),
        note: E("note", 60198),
        octoface: E("octoface", 60199),
        openPreview: E("open-preview", 60200),
        package: E("package", 60201),
        paintcan: E("paintcan", 60202),
        pin: E("pin", 60203),
        play: E("play", 60204),
        run: E("run", 60204),
        plug: E("plug", 60205),
        preserveCase: E("preserve-case", 60206),
        preview: E("preview", 60207),
        project: E("project", 60208),
        pulse: E("pulse", 60209),
        question: E("question", 60210),
        quote: E("quote", 60211),
        radioTower: E("radio-tower", 60212),
        reactions: E("reactions", 60213),
        references: E("references", 60214),
        refresh: E("refresh", 60215),
        regex: E("regex", 60216),
        remoteExplorer: E("remote-explorer", 60217),
        remote: E("remote", 60218),
        remove: E("remove", 60219),
        replaceAll: E("replace-all", 60220),
        replace: E("replace", 60221),
        repoClone: E("repo-clone", 60222),
        repoForcePush: E("repo-force-push", 60223),
        repoPull: E("repo-pull", 60224),
        repoPush: E("repo-push", 60225),
        report: E("report", 60226),
        requestChanges: E("request-changes", 60227),
        rocket: E("rocket", 60228),
        rootFolderOpened: E("root-folder-opened", 60229),
        rootFolder: E("root-folder", 60230),
        rss: E("rss", 60231),
        ruby: E("ruby", 60232),
        saveAll: E("save-all", 60233),
        saveAs: E("save-as", 60234),
        save: E("save", 60235),
        screenFull: E("screen-full", 60236),
        screenNormal: E("screen-normal", 60237),
        searchStop: E("search-stop", 60238),
        server: E("server", 60240),
        settingsGear: E("settings-gear", 60241),
        settings: E("settings", 60242),
        shield: E("shield", 60243),
        smiley: E("smiley", 60244),
        sortPrecedence: E("sort-precedence", 60245),
        splitHorizontal: E("split-horizontal", 60246),
        splitVertical: E("split-vertical", 60247),
        squirrel: E("squirrel", 60248),
        starFull: E("star-full", 60249),
        starHalf: E("star-half", 60250),
        symbolClass: E("symbol-class", 60251),
        symbolColor: E("symbol-color", 60252),
        symbolConstant: E("symbol-constant", 60253),
        symbolEnumMember: E("symbol-enum-member", 60254),
        symbolField: E("symbol-field", 60255),
        symbolFile: E("symbol-file", 60256),
        symbolInterface: E("symbol-interface", 60257),
        symbolKeyword: E("symbol-keyword", 60258),
        symbolMisc: E("symbol-misc", 60259),
        symbolOperator: E("symbol-operator", 60260),
        symbolProperty: E("symbol-property", 60261),
        wrench: E("wrench", 60261),
        wrenchSubaction: E("wrench-subaction", 60261),
        symbolSnippet: E("symbol-snippet", 60262),
        tasklist: E("tasklist", 60263),
        telescope: E("telescope", 60264),
        textSize: E("text-size", 60265),
        threeBars: E("three-bars", 60266),
        thumbsdown: E("thumbsdown", 60267),
        thumbsup: E("thumbsup", 60268),
        tools: E("tools", 60269),
        triangleDown: E("triangle-down", 60270),
        triangleLeft: E("triangle-left", 60271),
        triangleRight: E("triangle-right", 60272),
        triangleUp: E("triangle-up", 60273),
        twitter: E("twitter", 60274),
        unfold: E("unfold", 60275),
        unlock: E("unlock", 60276),
        unmute: E("unmute", 60277),
        unverified: E("unverified", 60278),
        verified: E("verified", 60279),
        versions: E("versions", 60280),
        vmActive: E("vm-active", 60281),
        vmOutline: E("vm-outline", 60282),
        vmRunning: E("vm-running", 60283),
        watch: E("watch", 60284),
        whitespace: E("whitespace", 60285),
        wholeWord: E("whole-word", 60286),
        window: E("window", 60287),
        wordWrap: E("word-wrap", 60288),
        zoomIn: E("zoom-in", 60289),
        zoomOut: E("zoom-out", 60290),
        listFilter: E("list-filter", 60291),
        listFlat: E("list-flat", 60292),
        listSelection: E("list-selection", 60293),
        selection: E("selection", 60293),
        listTree: E("list-tree", 60294),
        debugBreakpointFunctionUnverified: E("debug-breakpoint-function-unverified", 60295),
        debugBreakpointFunction: E("debug-breakpoint-function", 60296),
        debugBreakpointFunctionDisabled: E("debug-breakpoint-function-disabled", 60296),
        debugStackframeActive: E("debug-stackframe-active", 60297),
        circleSmallFilled: E("circle-small-filled", 60298),
        debugStackframeDot: E("debug-stackframe-dot", 60298),
        terminalDecorationMark: E("terminal-decoration-mark", 60298),
        debugStackframe: E("debug-stackframe", 60299),
        debugStackframeFocused: E("debug-stackframe-focused", 60299),
        debugBreakpointUnsupported: E("debug-breakpoint-unsupported", 60300),
        symbolString: E("symbol-string", 60301),
        debugReverseContinue: E("debug-reverse-continue", 60302),
        debugStepBack: E("debug-step-back", 60303),
        debugRestartFrame: E("debug-restart-frame", 60304),
        debugAlt: E("debug-alt", 60305),
        callIncoming: E("call-incoming", 60306),
        callOutgoing: E("call-outgoing", 60307),
        menu: E("menu", 60308),
        expandAll: E("expand-all", 60309),
        feedback: E("feedback", 60310),
        gitPullRequestReviewer: E("git-pull-request-reviewer", 60310),
        groupByRefType: E("group-by-ref-type", 60311),
        ungroupByRefType: E("ungroup-by-ref-type", 60312),
        account: E("account", 60313),
        gitPullRequestAssignee: E("git-pull-request-assignee", 60313),
        bellDot: E("bell-dot", 60314),
        debugConsole: E("debug-console", 60315),
        library: E("library", 60316),
        output: E("output", 60317),
        runAll: E("run-all", 60318),
        syncIgnored: E("sync-ignored", 60319),
        pinned: E("pinned", 60320),
        githubInverted: E("github-inverted", 60321),
        serverProcess: E("server-process", 60322),
        serverEnvironment: E("server-environment", 60323),
        pass: E("pass", 60324),
        issueClosed: E("issue-closed", 60324),
        stopCircle: E("stop-circle", 60325),
        playCircle: E("play-circle", 60326),
        record: E("record", 60327),
        debugAltSmall: E("debug-alt-small", 60328),
        vmConnect: E("vm-connect", 60329),
        cloud: E("cloud", 60330),
        merge: E("merge", 60331),
        export: E("export", 60332),
        graphLeft: E("graph-left", 60333),
        magnet: E("magnet", 60334),
        notebook: E("notebook", 60335),
        redo: E("redo", 60336),
        checkAll: E("check-all", 60337),
        pinnedDirty: E("pinned-dirty", 60338),
        passFilled: E("pass-filled", 60339),
        circleLargeFilled: E("circle-large-filled", 60340),
        circleLarge: E("circle-large", 60341),
        circleLargeOutline: E("circle-large-outline", 60341),
        combine: E("combine", 60342),
        gather: E("gather", 60342),
        table: E("table", 60343),
        variableGroup: E("variable-group", 60344),
        typeHierarchy: E("type-hierarchy", 60345),
        typeHierarchySub: E("type-hierarchy-sub", 60346),
        typeHierarchySuper: E("type-hierarchy-super", 60347),
        gitPullRequestCreate: E("git-pull-request-create", 60348),
        runAbove: E("run-above", 60349),
        runBelow: E("run-below", 60350),
        notebookTemplate: E("notebook-template", 60351),
        debugRerun: E("debug-rerun", 60352),
        workspaceTrusted: E("workspace-trusted", 60353),
        workspaceUntrusted: E("workspace-untrusted", 60354),
        workspaceUnknown: E("workspace-unknown", 60355),
        terminalCmd: E("terminal-cmd", 60356),
        terminalDebian: E("terminal-debian", 60357),
        terminalLinux: E("terminal-linux", 60358),
        terminalPowershell: E("terminal-powershell", 60359),
        terminalTmux: E("terminal-tmux", 60360),
        terminalUbuntu: E("terminal-ubuntu", 60361),
        terminalBash: E("terminal-bash", 60362),
        arrowSwap: E("arrow-swap", 60363),
        copy: E("copy", 60364),
        personAdd: E("person-add", 60365),
        filterFilled: E("filter-filled", 60366),
        wand: E("wand", 60367),
        debugLineByLine: E("debug-line-by-line", 60368),
        inspect: E("inspect", 60369),
        layers: E("layers", 60370),
        layersDot: E("layers-dot", 60371),
        layersActive: E("layers-active", 60372),
        compass: E("compass", 60373),
        compassDot: E("compass-dot", 60374),
        compassActive: E("compass-active", 60375),
        azure: E("azure", 60376),
        issueDraft: E("issue-draft", 60377),
        gitPullRequestClosed: E("git-pull-request-closed", 60378),
        gitPullRequestDraft: E("git-pull-request-draft", 60379),
        debugAll: E("debug-all", 60380),
        debugCoverage: E("debug-coverage", 60381),
        runErrors: E("run-errors", 60382),
        folderLibrary: E("folder-library", 60383),
        debugContinueSmall: E("debug-continue-small", 60384),
        beakerStop: E("beaker-stop", 60385),
        graphLine: E("graph-line", 60386),
        graphScatter: E("graph-scatter", 60387),
        pieChart: E("pie-chart", 60388),
        bracket: E("bracket", 60175),
        bracketDot: E("bracket-dot", 60389),
        bracketError: E("bracket-error", 60390),
        lockSmall: E("lock-small", 60391),
        azureDevops: E("azure-devops", 60392),
        verifiedFilled: E("verified-filled", 60393),
        newline: E("newline", 60394),
        layout: E("layout", 60395),
        layoutActivitybarLeft: E("layout-activitybar-left", 60396),
        layoutActivitybarRight: E("layout-activitybar-right", 60397),
        layoutPanelLeft: E("layout-panel-left", 60398),
        layoutPanelCenter: E("layout-panel-center", 60399),
        layoutPanelJustify: E("layout-panel-justify", 60400),
        layoutPanelRight: E("layout-panel-right", 60401),
        layoutPanel: E("layout-panel", 60402),
        layoutSidebarLeft: E("layout-sidebar-left", 60403),
        layoutSidebarRight: E("layout-sidebar-right", 60404),
        layoutStatusbar: E("layout-statusbar", 60405),
        layoutMenubar: E("layout-menubar", 60406),
        layoutCentered: E("layout-centered", 60407),
        target: E("target", 60408),
        indent: E("indent", 60409),
        recordSmall: E("record-small", 60410),
        errorSmall: E("error-small", 60411),
        terminalDecorationError: E("terminal-decoration-error", 60411),
        arrowCircleDown: E("arrow-circle-down", 60412),
        arrowCircleLeft: E("arrow-circle-left", 60413),
        arrowCircleRight: E("arrow-circle-right", 60414),
        arrowCircleUp: E("arrow-circle-up", 60415),
        layoutSidebarRightOff: E("layout-sidebar-right-off", 60416),
        layoutPanelOff: E("layout-panel-off", 60417),
        layoutSidebarLeftOff: E("layout-sidebar-left-off", 60418),
        blank: E("blank", 60419),
        heartFilled: E("heart-filled", 60420),
        map: E("map", 60421),
        mapHorizontal: E("map-horizontal", 60421),
        foldHorizontal: E("fold-horizontal", 60421),
        mapFilled: E("map-filled", 60422),
        mapHorizontalFilled: E("map-horizontal-filled", 60422),
        foldHorizontalFilled: E("fold-horizontal-filled", 60422),
        circleSmall: E("circle-small", 60423),
        bellSlash: E("bell-slash", 60424),
        bellSlashDot: E("bell-slash-dot", 60425),
        commentUnresolved: E("comment-unresolved", 60426),
        gitPullRequestGoToChanges: E("git-pull-request-go-to-changes", 60427),
        gitPullRequestNewChanges: E("git-pull-request-new-changes", 60428),
        searchFuzzy: E("search-fuzzy", 60429),
        commentDraft: E("comment-draft", 60430),
        send: E("send", 60431),
        sparkle: E("sparkle", 60432),
        insert: E("insert", 60433),
        mic: E("mic", 60434),
        thumbsdownFilled: E("thumbsdown-filled", 60435),
        thumbsupFilled: E("thumbsup-filled", 60436),
        coffee: E("coffee", 60437),
        snake: E("snake", 60438),
        game: E("game", 60439),
        vr: E("vr", 60440),
        chip: E("chip", 60441),
        piano: E("piano", 60442),
        music: E("music", 60443),
        micFilled: E("mic-filled", 60444),
        repoFetch: E("repo-fetch", 60445),
        copilot: E("copilot", 60446),
        lightbulbSparkle: E("lightbulb-sparkle", 60447),
        robot: E("robot", 60448),
        sparkleFilled: E("sparkle-filled", 60449),
        diffSingle: E("diff-single", 60450),
        diffMultiple: E("diff-multiple", 60451),
        surroundWith: E("surround-with", 60452),
        share: E("share", 60453),
        gitStash: E("git-stash", 60454),
        gitStashApply: E("git-stash-apply", 60455),
        gitStashPop: E("git-stash-pop", 60456),
        vscode: E("vscode", 60457),
        vscodeInsiders: E("vscode-insiders", 60458),
        codeOss: E("code-oss", 60459),
        runCoverage: E("run-coverage", 60460),
        runAllCoverage: E("run-all-coverage", 60461),
        coverage: E("coverage", 60462),
        githubProject: E("github-project", 60463),
        mapVertical: E("map-vertical", 60464),
        foldVertical: E("fold-vertical", 60464),
        mapVerticalFilled: E("map-vertical-filled", 60465),
        foldVerticalFilled: E("fold-vertical-filled", 60465),
        goToSearch: E("go-to-search", 60466),
        percentage: E("percentage", 60467),
        sortPercentage: E("sort-percentage", 60467),
        attach: E("attach", 60468)
      }, bq = {
        dialogError: E("dialog-error", "error"),
        dialogWarning: E("dialog-warning", "warning"),
        dialogInfo: E("dialog-info", "info"),
        dialogClose: E("dialog-close", "close"),
        treeItemExpanded: E("tree-item-expanded", "chevron-down"),
        treeFilterOnTypeOn: E("tree-filter-on-type-on", "list-filter"),
        treeFilterOnTypeOff: E("tree-filter-on-type-off", "list-selection"),
        treeFilterClear: E("tree-filter-clear", "close"),
        treeItemLoading: E("tree-item-loading", "loading"),
        menuSelection: E("menu-selection", "check"),
        menuSubmenu: E("menu-submenu", "chevron-right"),
        menuBarMore: E("menubar-more", "more"),
        scrollbarButtonLeft: E("scrollbar-button-left", "triangle-left"),
        scrollbarButtonRight: E("scrollbar-button-right", "triangle-right"),
        scrollbarButtonUp: E("scrollbar-button-up", "triangle-up"),
        scrollbarButtonDown: E("scrollbar-button-down", "triangle-down"),
        toolBarMore: E("toolbar-more", "more"),
        quickInputBack: E("quick-input-back", "arrow-left"),
        dropDownButton: E("drop-down-button", 60084),
        symbolCustomColor: E("symbol-customcolor", 60252),
        exportIcon: E("export", 60332),
        workspaceUnspecified: E("workspace-unspecified", 60355),
        newLine: E("newline", 60394),
        thumbsDownFilled: E("thumbsdown-filled", 60435),
        thumbsUpFilled: E("thumbsup-filled", 60436),
        gitFetch: E("git-fetch", 60445),
        lightbulbSparkleAutofix: E("lightbulb-sparkle-autofix", 60447),
        debugBreakpointPending: E("debug-breakpoint-pending", 60377)
      }, Te = {
        ..._q,
        ...bq
      };
      let w9 = class {
        constructor() {
          this._tokenizationSupports = /* @__PURE__ */ new Map(), this._factories = /* @__PURE__ */ new Map(), this._onDidChange = new G(), this.onDidChange = this._onDidChange.event, this._colorMap = null;
        }
        handleChange(e) {
          this._onDidChange.fire({
            changedLanguages: e,
            changedColorMap: false
          });
        }
        register(e, t) {
          return this._tokenizationSupports.set(e, t), this.handleChange([
            e
          ]), Ze(() => {
            this._tokenizationSupports.get(e) === t && (this._tokenizationSupports.delete(e), this.handleChange([
              e
            ]));
          });
        }
        get(e) {
          return this._tokenizationSupports.get(e) || null;
        }
        registerFactory(e, t) {
          var _a3;
          (_a3 = this._factories.get(e)) == null ? void 0 : _a3.dispose();
          const i = new vq(this, e, t);
          return this._factories.set(e, i), Ze(() => {
            const n = this._factories.get(e);
            !n || n !== i || (this._factories.delete(e), n.dispose());
          });
        }
        async getOrCreate(e) {
          const t = this.get(e);
          if (t) return t;
          const i = this._factories.get(e);
          return !i || i.isResolved ? null : (await i.resolve(), this.get(e));
        }
        isResolved(e) {
          if (this.get(e)) return true;
          const i = this._factories.get(e);
          return !!(!i || i.isResolved);
        }
        setColorMap(e) {
          this._colorMap = e, this._onDidChange.fire({
            changedLanguages: Array.from(this._tokenizationSupports.keys()),
            changedColorMap: true
          });
        }
        getColorMap() {
          return this._colorMap;
        }
        getDefaultBackground() {
          return this._colorMap && this._colorMap.length > 2 ? this._colorMap[2] : null;
        }
      };
      class vq extends he {
        get isResolved() {
          return this._isResolved;
        }
        constructor(e, t, i) {
          super(), this._registry = e, this._languageId = t, this._factory = i, this._isDisposed = false, this._resolvePromise = null, this._isResolved = false;
        }
        dispose() {
          this._isDisposed = true, super.dispose();
        }
        async resolve() {
          return this._resolvePromise || (this._resolvePromise = this._create()), this._resolvePromise;
        }
        async _create() {
          const e = await this._factory.tokenizationSupport;
          this._isResolved = true, e && !this._isDisposed && this._register(this._registry.register(this._languageId, e));
        }
      }
      let Gp = class {
        constructor(e, t, i) {
          this.offset = e, this.type = t, this.language = i, this._tokenBrand = void 0;
        }
        toString() {
          return "(" + this.offset + ", " + this.type + ")";
        }
      };
      class $E {
        constructor(e, t) {
          this.tokens = e, this.endState = t, this._tokenizationResultBrand = void 0;
        }
      }
      class VC {
        constructor(e, t) {
          this.tokens = e, this.endState = t, this._encodedTokenizationResultBrand = void 0;
        }
      }
      var R4;
      (function(s) {
        s[s.Increase = 0] = "Increase", s[s.Decrease = 1] = "Decrease";
      })(R4 || (R4 = {}));
      var O4;
      (function(s) {
        const e = /* @__PURE__ */ new Map();
        e.set(0, Te.symbolMethod), e.set(1, Te.symbolFunction), e.set(2, Te.symbolConstructor), e.set(3, Te.symbolField), e.set(4, Te.symbolVariable), e.set(5, Te.symbolClass), e.set(6, Te.symbolStruct), e.set(7, Te.symbolInterface), e.set(8, Te.symbolModule), e.set(9, Te.symbolProperty), e.set(10, Te.symbolEvent), e.set(11, Te.symbolOperator), e.set(12, Te.symbolUnit), e.set(13, Te.symbolValue), e.set(15, Te.symbolEnum), e.set(14, Te.symbolConstant), e.set(15, Te.symbolEnum), e.set(16, Te.symbolEnumMember), e.set(17, Te.symbolKeyword), e.set(27, Te.symbolSnippet), e.set(18, Te.symbolText), e.set(19, Te.symbolColor), e.set(20, Te.symbolFile), e.set(21, Te.symbolReference), e.set(22, Te.symbolCustomColor), e.set(23, Te.symbolFolder), e.set(24, Te.symbolTypeParameter), e.set(25, Te.account), e.set(26, Te.issues);
        function t(o) {
          let r = e.get(o);
          return r || (console.info("No codicon found for CompletionItemKind " + o), r = Te.symbolProperty), r;
        }
        s.toIcon = t;
        const i = /* @__PURE__ */ new Map();
        i.set("method", 0), i.set("function", 1), i.set("constructor", 2), i.set("field", 3), i.set("variable", 4), i.set("class", 5), i.set("struct", 6), i.set("interface", 7), i.set("module", 8), i.set("property", 9), i.set("event", 10), i.set("operator", 11), i.set("unit", 12), i.set("value", 13), i.set("constant", 14), i.set("enum", 15), i.set("enum-member", 16), i.set("enumMember", 16), i.set("keyword", 17), i.set("snippet", 27), i.set("text", 18), i.set("color", 19), i.set("file", 20), i.set("reference", 21), i.set("customcolor", 22), i.set("folder", 23), i.set("type-parameter", 24), i.set("typeParameter", 24), i.set("account", 25), i.set("issue", 26);
        function n(o, r) {
          let a = i.get(o);
          return typeof a > "u" && !r && (a = 9), a;
        }
        s.fromString = n;
      })(O4 || (O4 = {}));
      var P4;
      (function(s) {
        s[s.Automatic = 0] = "Automatic", s[s.Explicit = 1] = "Explicit";
      })(P4 || (P4 = {}));
      class Cq {
        constructor(e, t, i, n) {
          this.range = e, this.text = t, this.completionKind = i, this.isSnippetText = n;
        }
        equals(e) {
          return z.lift(this.range).equalsRange(e.range) && this.text === e.text && this.completionKind === e.completionKind && this.isSnippetText === e.isSnippetText;
        }
      }
      var B4;
      (function(s) {
        s[s.Automatic = 0] = "Automatic", s[s.PasteAs = 1] = "PasteAs";
      })(B4 || (B4 = {}));
      var F4;
      (function(s) {
        s[s.Invoke = 1] = "Invoke", s[s.TriggerCharacter = 2] = "TriggerCharacter", s[s.ContentChange = 3] = "ContentChange";
      })(F4 || (F4 = {}));
      var V4;
      (function(s) {
        s[s.Text = 0] = "Text", s[s.Read = 1] = "Read", s[s.Write = 2] = "Write";
      })(V4 || (V4 = {}));
      C("Array", "array"), C("Boolean", "boolean"), C("Class", "class"), C("Constant", "constant"), C("Constructor", "constructor"), C("Enum", "enumeration"), C("EnumMember", "enumeration member"), C("Event", "event"), C("Field", "field"), C("File", "file"), C("Function", "function"), C("Interface", "interface"), C("Key", "key"), C("Method", "method"), C("Module", "module"), C("Namespace", "namespace"), C("Null", "null"), C("Number", "number"), C("Object", "object"), C("Operator", "operator"), C("Package", "package"), C("Property", "property"), C("String", "string"), C("Struct", "struct"), C("TypeParameter", "type parameter"), C("Variable", "variable");
      var Vx;
      (function(s) {
        const e = /* @__PURE__ */ new Map();
        e.set(0, Te.symbolFile), e.set(1, Te.symbolModule), e.set(2, Te.symbolNamespace), e.set(3, Te.symbolPackage), e.set(4, Te.symbolClass), e.set(5, Te.symbolMethod), e.set(6, Te.symbolProperty), e.set(7, Te.symbolField), e.set(8, Te.symbolConstructor), e.set(9, Te.symbolEnum), e.set(10, Te.symbolInterface), e.set(11, Te.symbolFunction), e.set(12, Te.symbolVariable), e.set(13, Te.symbolConstant), e.set(14, Te.symbolString), e.set(15, Te.symbolNumber), e.set(16, Te.symbolBoolean), e.set(17, Te.symbolArray), e.set(18, Te.symbolObject), e.set(19, Te.symbolKey), e.set(20, Te.symbolNull), e.set(21, Te.symbolEnumMember), e.set(22, Te.symbolStruct), e.set(23, Te.symbolEvent), e.set(24, Te.symbolOperator), e.set(25, Te.symbolTypeParameter);
        function t(i) {
          let n = e.get(i);
          return n || (console.info("No codicon found for SymbolKind " + i), n = Te.symbolProperty), n;
        }
        s.toIcon = t;
      })(Vx || (Vx = {}));
      const _pl = class _pl {
        static fromValue(e) {
          switch (e) {
            case "comment":
              return _pl.Comment;
            case "imports":
              return _pl.Imports;
            case "region":
              return _pl.Region;
          }
          return new _pl(e);
        }
        constructor(e) {
          this.value = e;
        }
      };
      _pl.Comment = new _pl("comment");
      _pl.Imports = new _pl("imports");
      _pl.Region = new _pl("region");
      let pl = _pl;
      var W4;
      (function(s) {
        s[s.AIGenerated = 1] = "AIGenerated";
      })(W4 || (W4 = {}));
      var H4;
      (function(s) {
        s[s.Invoke = 0] = "Invoke", s[s.Automatic = 1] = "Automatic";
      })(H4 || (H4 = {}));
      var z4;
      (function(s) {
        function e(t) {
          return !t || typeof t != "object" ? false : typeof t.id == "string" && typeof t.title == "string";
        }
        s.is = e;
      })(z4 || (z4 = {}));
      var U4;
      (function(s) {
        s[s.Type = 1] = "Type", s[s.Parameter = 2] = "Parameter";
      })(U4 || (U4 = {}));
      class wq {
        constructor(e) {
          this.createSupport = e, this._tokenizationSupport = null;
        }
        dispose() {
          this._tokenizationSupport && this._tokenizationSupport.then((e) => {
            e && e.dispose();
          });
        }
        get tokenizationSupport() {
          return this._tokenizationSupport || (this._tokenizationSupport = this.createSupport()), this._tokenizationSupport;
        }
      }
      const Bi = new w9(), Wx = new w9();
      var $4;
      (function(s) {
        s[s.Invoke = 0] = "Invoke", s[s.Automatic = 1] = "Automatic";
      })($4 || ($4 = {}));
      var Hx;
      (function(s) {
        s[s.Unknown = 0] = "Unknown", s[s.Disabled = 1] = "Disabled", s[s.Enabled = 2] = "Enabled";
      })(Hx || (Hx = {}));
      var zx;
      (function(s) {
        s[s.Invoke = 1] = "Invoke", s[s.Auto = 2] = "Auto";
      })(zx || (zx = {}));
      var Ux;
      (function(s) {
        s[s.None = 0] = "None", s[s.KeepWhitespace = 1] = "KeepWhitespace", s[s.InsertAsSnippet = 4] = "InsertAsSnippet";
      })(Ux || (Ux = {}));
      var $x;
      (function(s) {
        s[s.Method = 0] = "Method", s[s.Function = 1] = "Function", s[s.Constructor = 2] = "Constructor", s[s.Field = 3] = "Field", s[s.Variable = 4] = "Variable", s[s.Class = 5] = "Class", s[s.Struct = 6] = "Struct", s[s.Interface = 7] = "Interface", s[s.Module = 8] = "Module", s[s.Property = 9] = "Property", s[s.Event = 10] = "Event", s[s.Operator = 11] = "Operator", s[s.Unit = 12] = "Unit", s[s.Value = 13] = "Value", s[s.Constant = 14] = "Constant", s[s.Enum = 15] = "Enum", s[s.EnumMember = 16] = "EnumMember", s[s.Keyword = 17] = "Keyword", s[s.Text = 18] = "Text", s[s.Color = 19] = "Color", s[s.File = 20] = "File", s[s.Reference = 21] = "Reference", s[s.Customcolor = 22] = "Customcolor", s[s.Folder = 23] = "Folder", s[s.TypeParameter = 24] = "TypeParameter", s[s.User = 25] = "User", s[s.Issue = 26] = "Issue", s[s.Snippet = 27] = "Snippet";
      })($x || ($x = {}));
      var qx;
      (function(s) {
        s[s.Deprecated = 1] = "Deprecated";
      })(qx || (qx = {}));
      var Kx;
      (function(s) {
        s[s.Invoke = 0] = "Invoke", s[s.TriggerCharacter = 1] = "TriggerCharacter", s[s.TriggerForIncompleteCompletions = 2] = "TriggerForIncompleteCompletions";
      })(Kx || (Kx = {}));
      var jx;
      (function(s) {
        s[s.EXACT = 0] = "EXACT", s[s.ABOVE = 1] = "ABOVE", s[s.BELOW = 2] = "BELOW";
      })(jx || (jx = {}));
      var Gx;
      (function(s) {
        s[s.NotSet = 0] = "NotSet", s[s.ContentFlush = 1] = "ContentFlush", s[s.RecoverFromMarkers = 2] = "RecoverFromMarkers", s[s.Explicit = 3] = "Explicit", s[s.Paste = 4] = "Paste", s[s.Undo = 5] = "Undo", s[s.Redo = 6] = "Redo";
      })(Gx || (Gx = {}));
      var Yx;
      (function(s) {
        s[s.LF = 1] = "LF", s[s.CRLF = 2] = "CRLF";
      })(Yx || (Yx = {}));
      var Zx;
      (function(s) {
        s[s.Text = 0] = "Text", s[s.Read = 1] = "Read", s[s.Write = 2] = "Write";
      })(Zx || (Zx = {}));
      var Qx;
      (function(s) {
        s[s.None = 0] = "None", s[s.Keep = 1] = "Keep", s[s.Brackets = 2] = "Brackets", s[s.Advanced = 3] = "Advanced", s[s.Full = 4] = "Full";
      })(Qx || (Qx = {}));
      var Xx;
      (function(s) {
        s[s.acceptSuggestionOnCommitCharacter = 0] = "acceptSuggestionOnCommitCharacter", s[s.acceptSuggestionOnEnter = 1] = "acceptSuggestionOnEnter", s[s.accessibilitySupport = 2] = "accessibilitySupport", s[s.accessibilityPageSize = 3] = "accessibilityPageSize", s[s.ariaLabel = 4] = "ariaLabel", s[s.ariaRequired = 5] = "ariaRequired", s[s.autoClosingBrackets = 6] = "autoClosingBrackets", s[s.autoClosingComments = 7] = "autoClosingComments", s[s.screenReaderAnnounceInlineSuggestion = 8] = "screenReaderAnnounceInlineSuggestion", s[s.autoClosingDelete = 9] = "autoClosingDelete", s[s.autoClosingOvertype = 10] = "autoClosingOvertype", s[s.autoClosingQuotes = 11] = "autoClosingQuotes", s[s.autoIndent = 12] = "autoIndent", s[s.automaticLayout = 13] = "automaticLayout", s[s.autoSurround = 14] = "autoSurround", s[s.bracketPairColorization = 15] = "bracketPairColorization", s[s.guides = 16] = "guides", s[s.codeLens = 17] = "codeLens", s[s.codeLensFontFamily = 18] = "codeLensFontFamily", s[s.codeLensFontSize = 19] = "codeLensFontSize", s[s.colorDecorators = 20] = "colorDecorators", s[s.colorDecoratorsLimit = 21] = "colorDecoratorsLimit", s[s.columnSelection = 22] = "columnSelection", s[s.comments = 23] = "comments", s[s.contextmenu = 24] = "contextmenu", s[s.copyWithSyntaxHighlighting = 25] = "copyWithSyntaxHighlighting", s[s.cursorBlinking = 26] = "cursorBlinking", s[s.cursorSmoothCaretAnimation = 27] = "cursorSmoothCaretAnimation", s[s.cursorStyle = 28] = "cursorStyle", s[s.cursorSurroundingLines = 29] = "cursorSurroundingLines", s[s.cursorSurroundingLinesStyle = 30] = "cursorSurroundingLinesStyle", s[s.cursorWidth = 31] = "cursorWidth", s[s.disableLayerHinting = 32] = "disableLayerHinting", s[s.disableMonospaceOptimizations = 33] = "disableMonospaceOptimizations", s[s.domReadOnly = 34] = "domReadOnly", s[s.dragAndDrop = 35] = "dragAndDrop", s[s.dropIntoEditor = 36] = "dropIntoEditor", s[s.emptySelectionClipboard = 37] = "emptySelectionClipboard", s[s.experimentalWhitespaceRendering = 38] = "experimentalWhitespaceRendering", s[s.extraEditorClassName = 39] = "extraEditorClassName", s[s.fastScrollSensitivity = 40] = "fastScrollSensitivity", s[s.find = 41] = "find", s[s.fixedOverflowWidgets = 42] = "fixedOverflowWidgets", s[s.folding = 43] = "folding", s[s.foldingStrategy = 44] = "foldingStrategy", s[s.foldingHighlight = 45] = "foldingHighlight", s[s.foldingImportsByDefault = 46] = "foldingImportsByDefault", s[s.foldingMaximumRegions = 47] = "foldingMaximumRegions", s[s.unfoldOnClickAfterEndOfLine = 48] = "unfoldOnClickAfterEndOfLine", s[s.fontFamily = 49] = "fontFamily", s[s.fontInfo = 50] = "fontInfo", s[s.fontLigatures = 51] = "fontLigatures", s[s.fontSize = 52] = "fontSize", s[s.fontWeight = 53] = "fontWeight", s[s.fontVariations = 54] = "fontVariations", s[s.formatOnPaste = 55] = "formatOnPaste", s[s.formatOnType = 56] = "formatOnType", s[s.glyphMargin = 57] = "glyphMargin", s[s.gotoLocation = 58] = "gotoLocation", s[s.hideCursorInOverviewRuler = 59] = "hideCursorInOverviewRuler", s[s.hover = 60] = "hover", s[s.inDiffEditor = 61] = "inDiffEditor", s[s.inlineSuggest = 62] = "inlineSuggest", s[s.inlineEdit = 63] = "inlineEdit", s[s.letterSpacing = 64] = "letterSpacing", s[s.lightbulb = 65] = "lightbulb", s[s.lineDecorationsWidth = 66] = "lineDecorationsWidth", s[s.lineHeight = 67] = "lineHeight", s[s.lineNumbers = 68] = "lineNumbers", s[s.lineNumbersMinChars = 69] = "lineNumbersMinChars", s[s.linkedEditing = 70] = "linkedEditing", s[s.links = 71] = "links", s[s.matchBrackets = 72] = "matchBrackets", s[s.minimap = 73] = "minimap", s[s.mouseStyle = 74] = "mouseStyle", s[s.mouseWheelScrollSensitivity = 75] = "mouseWheelScrollSensitivity", s[s.mouseWheelZoom = 76] = "mouseWheelZoom", s[s.multiCursorMergeOverlapping = 77] = "multiCursorMergeOverlapping", s[s.multiCursorModifier = 78] = "multiCursorModifier", s[s.multiCursorPaste = 79] = "multiCursorPaste", s[s.multiCursorLimit = 80] = "multiCursorLimit", s[s.occurrencesHighlight = 81] = "occurrencesHighlight", s[s.overviewRulerBorder = 82] = "overviewRulerBorder", s[s.overviewRulerLanes = 83] = "overviewRulerLanes", s[s.padding = 84] = "padding", s[s.pasteAs = 85] = "pasteAs", s[s.parameterHints = 86] = "parameterHints", s[s.peekWidgetDefaultFocus = 87] = "peekWidgetDefaultFocus", s[s.placeholder = 88] = "placeholder", s[s.definitionLinkOpensInPeek = 89] = "definitionLinkOpensInPeek", s[s.quickSuggestions = 90] = "quickSuggestions", s[s.quickSuggestionsDelay = 91] = "quickSuggestionsDelay", s[s.readOnly = 92] = "readOnly", s[s.readOnlyMessage = 93] = "readOnlyMessage", s[s.renameOnType = 94] = "renameOnType", s[s.renderControlCharacters = 95] = "renderControlCharacters", s[s.renderFinalNewline = 96] = "renderFinalNewline", s[s.renderLineHighlight = 97] = "renderLineHighlight", s[s.renderLineHighlightOnlyWhenFocus = 98] = "renderLineHighlightOnlyWhenFocus", s[s.renderValidationDecorations = 99] = "renderValidationDecorations", s[s.renderWhitespace = 100] = "renderWhitespace", s[s.revealHorizontalRightPadding = 101] = "revealHorizontalRightPadding", s[s.roundedSelection = 102] = "roundedSelection", s[s.rulers = 103] = "rulers", s[s.scrollbar = 104] = "scrollbar", s[s.scrollBeyondLastColumn = 105] = "scrollBeyondLastColumn", s[s.scrollBeyondLastLine = 106] = "scrollBeyondLastLine", s[s.scrollPredominantAxis = 107] = "scrollPredominantAxis", s[s.selectionClipboard = 108] = "selectionClipboard", s[s.selectionHighlight = 109] = "selectionHighlight", s[s.selectOnLineNumbers = 110] = "selectOnLineNumbers", s[s.showFoldingControls = 111] = "showFoldingControls", s[s.showUnused = 112] = "showUnused", s[s.snippetSuggestions = 113] = "snippetSuggestions", s[s.smartSelect = 114] = "smartSelect", s[s.smoothScrolling = 115] = "smoothScrolling", s[s.stickyScroll = 116] = "stickyScroll", s[s.stickyTabStops = 117] = "stickyTabStops", s[s.stopRenderingLineAfter = 118] = "stopRenderingLineAfter", s[s.suggest = 119] = "suggest", s[s.suggestFontSize = 120] = "suggestFontSize", s[s.suggestLineHeight = 121] = "suggestLineHeight", s[s.suggestOnTriggerCharacters = 122] = "suggestOnTriggerCharacters", s[s.suggestSelection = 123] = "suggestSelection", s[s.tabCompletion = 124] = "tabCompletion", s[s.tabIndex = 125] = "tabIndex", s[s.unicodeHighlighting = 126] = "unicodeHighlighting", s[s.unusualLineTerminators = 127] = "unusualLineTerminators", s[s.useShadowDOM = 128] = "useShadowDOM", s[s.useTabStops = 129] = "useTabStops", s[s.wordBreak = 130] = "wordBreak", s[s.wordSegmenterLocales = 131] = "wordSegmenterLocales", s[s.wordSeparators = 132] = "wordSeparators", s[s.wordWrap = 133] = "wordWrap", s[s.wordWrapBreakAfterCharacters = 134] = "wordWrapBreakAfterCharacters", s[s.wordWrapBreakBeforeCharacters = 135] = "wordWrapBreakBeforeCharacters", s[s.wordWrapColumn = 136] = "wordWrapColumn", s[s.wordWrapOverride1 = 137] = "wordWrapOverride1", s[s.wordWrapOverride2 = 138] = "wordWrapOverride2", s[s.wrappingIndent = 139] = "wrappingIndent", s[s.wrappingStrategy = 140] = "wrappingStrategy", s[s.showDeprecated = 141] = "showDeprecated", s[s.inlayHints = 142] = "inlayHints", s[s.editorClassName = 143] = "editorClassName", s[s.pixelRatio = 144] = "pixelRatio", s[s.tabFocusMode = 145] = "tabFocusMode", s[s.layoutInfo = 146] = "layoutInfo", s[s.wrappingInfo = 147] = "wrappingInfo", s[s.defaultColorDecorators = 148] = "defaultColorDecorators", s[s.colorDecoratorsActivatedOn = 149] = "colorDecoratorsActivatedOn", s[s.inlineCompletionsAccessibilityVerbose = 150] = "inlineCompletionsAccessibilityVerbose";
      })(Xx || (Xx = {}));
      var Jx;
      (function(s) {
        s[s.TextDefined = 0] = "TextDefined", s[s.LF = 1] = "LF", s[s.CRLF = 2] = "CRLF";
      })(Jx || (Jx = {}));
      var ek;
      (function(s) {
        s[s.LF = 0] = "LF", s[s.CRLF = 1] = "CRLF";
      })(ek || (ek = {}));
      var tk;
      (function(s) {
        s[s.Left = 1] = "Left", s[s.Center = 2] = "Center", s[s.Right = 3] = "Right";
      })(tk || (tk = {}));
      var ik;
      (function(s) {
        s[s.Increase = 0] = "Increase", s[s.Decrease = 1] = "Decrease";
      })(ik || (ik = {}));
      var nk;
      (function(s) {
        s[s.None = 0] = "None", s[s.Indent = 1] = "Indent", s[s.IndentOutdent = 2] = "IndentOutdent", s[s.Outdent = 3] = "Outdent";
      })(nk || (nk = {}));
      var sk;
      (function(s) {
        s[s.Both = 0] = "Both", s[s.Right = 1] = "Right", s[s.Left = 2] = "Left", s[s.None = 3] = "None";
      })(sk || (sk = {}));
      var ok;
      (function(s) {
        s[s.Type = 1] = "Type", s[s.Parameter = 2] = "Parameter";
      })(ok || (ok = {}));
      var rk;
      (function(s) {
        s[s.Automatic = 0] = "Automatic", s[s.Explicit = 1] = "Explicit";
      })(rk || (rk = {}));
      var ak;
      (function(s) {
        s[s.Invoke = 0] = "Invoke", s[s.Automatic = 1] = "Automatic";
      })(ak || (ak = {}));
      var lk;
      (function(s) {
        s[s.DependsOnKbLayout = -1] = "DependsOnKbLayout", s[s.Unknown = 0] = "Unknown", s[s.Backspace = 1] = "Backspace", s[s.Tab = 2] = "Tab", s[s.Enter = 3] = "Enter", s[s.Shift = 4] = "Shift", s[s.Ctrl = 5] = "Ctrl", s[s.Alt = 6] = "Alt", s[s.PauseBreak = 7] = "PauseBreak", s[s.CapsLock = 8] = "CapsLock", s[s.Escape = 9] = "Escape", s[s.Space = 10] = "Space", s[s.PageUp = 11] = "PageUp", s[s.PageDown = 12] = "PageDown", s[s.End = 13] = "End", s[s.Home = 14] = "Home", s[s.LeftArrow = 15] = "LeftArrow", s[s.UpArrow = 16] = "UpArrow", s[s.RightArrow = 17] = "RightArrow", s[s.DownArrow = 18] = "DownArrow", s[s.Insert = 19] = "Insert", s[s.Delete = 20] = "Delete", s[s.Digit0 = 21] = "Digit0", s[s.Digit1 = 22] = "Digit1", s[s.Digit2 = 23] = "Digit2", s[s.Digit3 = 24] = "Digit3", s[s.Digit4 = 25] = "Digit4", s[s.Digit5 = 26] = "Digit5", s[s.Digit6 = 27] = "Digit6", s[s.Digit7 = 28] = "Digit7", s[s.Digit8 = 29] = "Digit8", s[s.Digit9 = 30] = "Digit9", s[s.KeyA = 31] = "KeyA", s[s.KeyB = 32] = "KeyB", s[s.KeyC = 33] = "KeyC", s[s.KeyD = 34] = "KeyD", s[s.KeyE = 35] = "KeyE", s[s.KeyF = 36] = "KeyF", s[s.KeyG = 37] = "KeyG", s[s.KeyH = 38] = "KeyH", s[s.KeyI = 39] = "KeyI", s[s.KeyJ = 40] = "KeyJ", s[s.KeyK = 41] = "KeyK", s[s.KeyL = 42] = "KeyL", s[s.KeyM = 43] = "KeyM", s[s.KeyN = 44] = "KeyN", s[s.KeyO = 45] = "KeyO", s[s.KeyP = 46] = "KeyP", s[s.KeyQ = 47] = "KeyQ", s[s.KeyR = 48] = "KeyR", s[s.KeyS = 49] = "KeyS", s[s.KeyT = 50] = "KeyT", s[s.KeyU = 51] = "KeyU", s[s.KeyV = 52] = "KeyV", s[s.KeyW = 53] = "KeyW", s[s.KeyX = 54] = "KeyX", s[s.KeyY = 55] = "KeyY", s[s.KeyZ = 56] = "KeyZ", s[s.Meta = 57] = "Meta", s[s.ContextMenu = 58] = "ContextMenu", s[s.F1 = 59] = "F1", s[s.F2 = 60] = "F2", s[s.F3 = 61] = "F3", s[s.F4 = 62] = "F4", s[s.F5 = 63] = "F5", s[s.F6 = 64] = "F6", s[s.F7 = 65] = "F7", s[s.F8 = 66] = "F8", s[s.F9 = 67] = "F9", s[s.F10 = 68] = "F10", s[s.F11 = 69] = "F11", s[s.F12 = 70] = "F12", s[s.F13 = 71] = "F13", s[s.F14 = 72] = "F14", s[s.F15 = 73] = "F15", s[s.F16 = 74] = "F16", s[s.F17 = 75] = "F17", s[s.F18 = 76] = "F18", s[s.F19 = 77] = "F19", s[s.F20 = 78] = "F20", s[s.F21 = 79] = "F21", s[s.F22 = 80] = "F22", s[s.F23 = 81] = "F23", s[s.F24 = 82] = "F24", s[s.NumLock = 83] = "NumLock", s[s.ScrollLock = 84] = "ScrollLock", s[s.Semicolon = 85] = "Semicolon", s[s.Equal = 86] = "Equal", s[s.Comma = 87] = "Comma", s[s.Minus = 88] = "Minus", s[s.Period = 89] = "Period", s[s.Slash = 90] = "Slash", s[s.Backquote = 91] = "Backquote", s[s.BracketLeft = 92] = "BracketLeft", s[s.Backslash = 93] = "Backslash", s[s.BracketRight = 94] = "BracketRight", s[s.Quote = 95] = "Quote", s[s.OEM_8 = 96] = "OEM_8", s[s.IntlBackslash = 97] = "IntlBackslash", s[s.Numpad0 = 98] = "Numpad0", s[s.Numpad1 = 99] = "Numpad1", s[s.Numpad2 = 100] = "Numpad2", s[s.Numpad3 = 101] = "Numpad3", s[s.Numpad4 = 102] = "Numpad4", s[s.Numpad5 = 103] = "Numpad5", s[s.Numpad6 = 104] = "Numpad6", s[s.Numpad7 = 105] = "Numpad7", s[s.Numpad8 = 106] = "Numpad8", s[s.Numpad9 = 107] = "Numpad9", s[s.NumpadMultiply = 108] = "NumpadMultiply", s[s.NumpadAdd = 109] = "NumpadAdd", s[s.NUMPAD_SEPARATOR = 110] = "NUMPAD_SEPARATOR", s[s.NumpadSubtract = 111] = "NumpadSubtract", s[s.NumpadDecimal = 112] = "NumpadDecimal", s[s.NumpadDivide = 113] = "NumpadDivide", s[s.KEY_IN_COMPOSITION = 114] = "KEY_IN_COMPOSITION", s[s.ABNT_C1 = 115] = "ABNT_C1", s[s.ABNT_C2 = 116] = "ABNT_C2", s[s.AudioVolumeMute = 117] = "AudioVolumeMute", s[s.AudioVolumeUp = 118] = "AudioVolumeUp", s[s.AudioVolumeDown = 119] = "AudioVolumeDown", s[s.BrowserSearch = 120] = "BrowserSearch", s[s.BrowserHome = 121] = "BrowserHome", s[s.BrowserBack = 122] = "BrowserBack", s[s.BrowserForward = 123] = "BrowserForward", s[s.MediaTrackNext = 124] = "MediaTrackNext", s[s.MediaTrackPrevious = 125] = "MediaTrackPrevious", s[s.MediaStop = 126] = "MediaStop", s[s.MediaPlayPause = 127] = "MediaPlayPause", s[s.LaunchMediaPlayer = 128] = "LaunchMediaPlayer", s[s.LaunchMail = 129] = "LaunchMail", s[s.LaunchApp2 = 130] = "LaunchApp2", s[s.Clear = 131] = "Clear", s[s.MAX_VALUE = 132] = "MAX_VALUE";
      })(lk || (lk = {}));
      var ck;
      (function(s) {
        s[s.Hint = 1] = "Hint", s[s.Info = 2] = "Info", s[s.Warning = 4] = "Warning", s[s.Error = 8] = "Error";
      })(ck || (ck = {}));
      var uk;
      (function(s) {
        s[s.Unnecessary = 1] = "Unnecessary", s[s.Deprecated = 2] = "Deprecated";
      })(uk || (uk = {}));
      var hk;
      (function(s) {
        s[s.Inline = 1] = "Inline", s[s.Gutter = 2] = "Gutter";
      })(hk || (hk = {}));
      var dk;
      (function(s) {
        s[s.Normal = 1] = "Normal", s[s.Underlined = 2] = "Underlined";
      })(dk || (dk = {}));
      var fk;
      (function(s) {
        s[s.UNKNOWN = 0] = "UNKNOWN", s[s.TEXTAREA = 1] = "TEXTAREA", s[s.GUTTER_GLYPH_MARGIN = 2] = "GUTTER_GLYPH_MARGIN", s[s.GUTTER_LINE_NUMBERS = 3] = "GUTTER_LINE_NUMBERS", s[s.GUTTER_LINE_DECORATIONS = 4] = "GUTTER_LINE_DECORATIONS", s[s.GUTTER_VIEW_ZONE = 5] = "GUTTER_VIEW_ZONE", s[s.CONTENT_TEXT = 6] = "CONTENT_TEXT", s[s.CONTENT_EMPTY = 7] = "CONTENT_EMPTY", s[s.CONTENT_VIEW_ZONE = 8] = "CONTENT_VIEW_ZONE", s[s.CONTENT_WIDGET = 9] = "CONTENT_WIDGET", s[s.OVERVIEW_RULER = 10] = "OVERVIEW_RULER", s[s.SCROLLBAR = 11] = "SCROLLBAR", s[s.OVERLAY_WIDGET = 12] = "OVERLAY_WIDGET", s[s.OUTSIDE_EDITOR = 13] = "OUTSIDE_EDITOR";
      })(fk || (fk = {}));
      var gk;
      (function(s) {
        s[s.AIGenerated = 1] = "AIGenerated";
      })(gk || (gk = {}));
      var mk;
      (function(s) {
        s[s.Invoke = 0] = "Invoke", s[s.Automatic = 1] = "Automatic";
      })(mk || (mk = {}));
      var pk;
      (function(s) {
        s[s.TOP_RIGHT_CORNER = 0] = "TOP_RIGHT_CORNER", s[s.BOTTOM_RIGHT_CORNER = 1] = "BOTTOM_RIGHT_CORNER", s[s.TOP_CENTER = 2] = "TOP_CENTER";
      })(pk || (pk = {}));
      var _k;
      (function(s) {
        s[s.Left = 1] = "Left", s[s.Center = 2] = "Center", s[s.Right = 4] = "Right", s[s.Full = 7] = "Full";
      })(_k || (_k = {}));
      var bk;
      (function(s) {
        s[s.Word = 0] = "Word", s[s.Line = 1] = "Line", s[s.Suggest = 2] = "Suggest";
      })(bk || (bk = {}));
      var vk;
      (function(s) {
        s[s.Left = 0] = "Left", s[s.Right = 1] = "Right", s[s.None = 2] = "None", s[s.LeftOfInjectedText = 3] = "LeftOfInjectedText", s[s.RightOfInjectedText = 4] = "RightOfInjectedText";
      })(vk || (vk = {}));
      var Ck;
      (function(s) {
        s[s.Off = 0] = "Off", s[s.On = 1] = "On", s[s.Relative = 2] = "Relative", s[s.Interval = 3] = "Interval", s[s.Custom = 4] = "Custom";
      })(Ck || (Ck = {}));
      var wk;
      (function(s) {
        s[s.None = 0] = "None", s[s.Text = 1] = "Text", s[s.Blocks = 2] = "Blocks";
      })(wk || (wk = {}));
      var yk;
      (function(s) {
        s[s.Smooth = 0] = "Smooth", s[s.Immediate = 1] = "Immediate";
      })(yk || (yk = {}));
      var Sk;
      (function(s) {
        s[s.Auto = 1] = "Auto", s[s.Hidden = 2] = "Hidden", s[s.Visible = 3] = "Visible";
      })(Sk || (Sk = {}));
      var Lk;
      (function(s) {
        s[s.LTR = 0] = "LTR", s[s.RTL = 1] = "RTL";
      })(Lk || (Lk = {}));
      var xk;
      (function(s) {
        s.Off = "off", s.OnCode = "onCode", s.On = "on";
      })(xk || (xk = {}));
      var kk;
      (function(s) {
        s[s.Invoke = 1] = "Invoke", s[s.TriggerCharacter = 2] = "TriggerCharacter", s[s.ContentChange = 3] = "ContentChange";
      })(kk || (kk = {}));
      var Dk;
      (function(s) {
        s[s.File = 0] = "File", s[s.Module = 1] = "Module", s[s.Namespace = 2] = "Namespace", s[s.Package = 3] = "Package", s[s.Class = 4] = "Class", s[s.Method = 5] = "Method", s[s.Property = 6] = "Property", s[s.Field = 7] = "Field", s[s.Constructor = 8] = "Constructor", s[s.Enum = 9] = "Enum", s[s.Interface = 10] = "Interface", s[s.Function = 11] = "Function", s[s.Variable = 12] = "Variable", s[s.Constant = 13] = "Constant", s[s.String = 14] = "String", s[s.Number = 15] = "Number", s[s.Boolean = 16] = "Boolean", s[s.Array = 17] = "Array", s[s.Object = 18] = "Object", s[s.Key = 19] = "Key", s[s.Null = 20] = "Null", s[s.EnumMember = 21] = "EnumMember", s[s.Struct = 22] = "Struct", s[s.Event = 23] = "Event", s[s.Operator = 24] = "Operator", s[s.TypeParameter = 25] = "TypeParameter";
      })(Dk || (Dk = {}));
      var Ek;
      (function(s) {
        s[s.Deprecated = 1] = "Deprecated";
      })(Ek || (Ek = {}));
      var Tk;
      (function(s) {
        s[s.Hidden = 0] = "Hidden", s[s.Blink = 1] = "Blink", s[s.Smooth = 2] = "Smooth", s[s.Phase = 3] = "Phase", s[s.Expand = 4] = "Expand", s[s.Solid = 5] = "Solid";
      })(Tk || (Tk = {}));
      var Nk;
      (function(s) {
        s[s.Line = 1] = "Line", s[s.Block = 2] = "Block", s[s.Underline = 3] = "Underline", s[s.LineThin = 4] = "LineThin", s[s.BlockOutline = 5] = "BlockOutline", s[s.UnderlineThin = 6] = "UnderlineThin";
      })(Nk || (Nk = {}));
      var Ik;
      (function(s) {
        s[s.AlwaysGrowsWhenTypingAtEdges = 0] = "AlwaysGrowsWhenTypingAtEdges", s[s.NeverGrowsWhenTypingAtEdges = 1] = "NeverGrowsWhenTypingAtEdges", s[s.GrowsOnlyWhenTypingBefore = 2] = "GrowsOnlyWhenTypingBefore", s[s.GrowsOnlyWhenTypingAfter = 3] = "GrowsOnlyWhenTypingAfter";
      })(Ik || (Ik = {}));
      var Mk;
      (function(s) {
        s[s.None = 0] = "None", s[s.Same = 1] = "Same", s[s.Indent = 2] = "Indent", s[s.DeepIndent = 3] = "DeepIndent";
      })(Mk || (Mk = {}));
      const _yq = class _yq {
        static chord(e, t) {
          return G$(e, t);
        }
      };
      _yq.CtrlCmd = 2048;
      _yq.Shift = 1024;
      _yq.Alt = 512;
      _yq.WinCtrl = 256;
      let yq = _yq;
      function y9() {
        return {
          editor: void 0,
          languages: void 0,
          CancellationTokenSource: Lg,
          Emitter: G,
          KeyCode: lk,
          KeyMod: yq,
          Position: X,
          Range: z,
          Selection: mt,
          SelectionDirection: Lk,
          MarkerSeverity: ck,
          MarkerTag: uk,
          Uri: st,
          Token: Gp
        };
      }
      function Sq(s, e) {
        const t = s;
        typeof t.vscodeWindowId != "number" && Object.defineProperty(t, "vscodeWindowId", {
          get: () => e
        });
      }
      const Kt = window;
      function S9(s) {
        return s;
      }
      class Lq {
        constructor(e, t) {
          this.lastCache = void 0, this.lastArgKey = void 0, typeof e == "function" ? (this._fn = e, this._computeKey = S9) : (this._fn = t, this._computeKey = e.getCacheKey);
        }
        get(e) {
          const t = this._computeKey(e);
          return this.lastArgKey !== t && (this.lastArgKey = t, this.lastCache = this._fn(e)), this.lastCache;
        }
      }
      class q4 {
        get cachedValues() {
          return this._map;
        }
        constructor(e, t) {
          this._map = /* @__PURE__ */ new Map(), this._map2 = /* @__PURE__ */ new Map(), typeof e == "function" ? (this._fn = e, this._computeKey = S9) : (this._fn = t, this._computeKey = e.getCacheKey);
        }
        get(e) {
          const t = this._computeKey(e);
          if (this._map2.has(t)) return this._map2.get(t);
          const i = this._fn(e);
          return this._map.set(e, i), this._map2.set(t, i), i;
        }
      }
      class iu {
        constructor(e) {
          this.executor = e, this._didRun = false;
        }
        get value() {
          if (!this._didRun) try {
            this._value = this.executor();
          } catch (e) {
            this._error = e;
          } finally {
            this._didRun = true;
          }
          if (this._error) throw this._error;
          return this._value;
        }
        get rawValue() {
          return this._value;
        }
      }
      function xq(s) {
        return !s || typeof s != "string" ? true : s.trim().length === 0;
      }
      const kq = /{(\d+)}/g;
      function Ak(s, ...e) {
        return e.length === 0 ? s : s.replace(kq, function(t, i) {
          const n = parseInt(i, 10);
          return isNaN(n) || n < 0 || n >= e.length ? t : e[n];
        });
      }
      function Dq(s) {
        return s.replace(/[<>"'&]/g, (e) => {
          switch (e) {
            case "<":
              return "&lt;";
            case ">":
              return "&gt;";
            case '"':
              return "&quot;";
            case "'":
              return "&apos;";
            case "&":
              return "&amp;";
          }
          return e;
        });
      }
      function mp(s) {
        return s.replace(/[<>&]/g, function(e) {
          switch (e) {
            case "<":
              return "&lt;";
            case ">":
              return "&gt;";
            case "&":
              return "&amp;";
            default:
              return e;
          }
        });
      }
      function $l(s) {
        return s.replace(/[\\\{\}\*\+\?\|\^\$\.\[\]\(\)]/g, "\\$&");
      }
      function WC(s, e) {
        if (!s || !e) return s;
        const t = e.length;
        if (t === 0 || s.length === 0) return s;
        let i = 0;
        for (; s.indexOf(e, i) === i; ) i = i + t;
        return s.substring(i);
      }
      function Eq(s, e) {
        if (!s) return s;
        const t = e.length, i = s.length;
        if (t === 0 || i === 0) return s;
        let n = i, o = -1;
        for (; o = s.lastIndexOf(e, n - 1), !(o === -1 || o + t !== n); ) {
          if (o === 0) return "";
          n = o;
        }
        return s.substring(0, n);
      }
      function Tq(s) {
        return s.replace(/[\-\\\{\}\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, "\\$&").replace(/[\*]/g, ".*");
      }
      function L9(s, e, t = {}) {
        if (!s) throw new Error("Cannot create regex from empty string");
        e || (s = $l(s)), t.wholeWord && (/\B/.test(s.charAt(0)) || (s = "\\b" + s), /\B/.test(s.charAt(s.length - 1)) || (s = s + "\\b"));
        let i = "";
        return t.global && (i += "g"), t.matchCase || (i += "i"), t.multiline && (i += "m"), t.unicode && (i += "u"), new RegExp(s, i);
      }
      function Nq(s) {
        return s.source === "^" || s.source === "^$" || s.source === "$" || s.source === "^\\s*$" ? false : !!(s.exec("") && s.lastIndex === 0);
      }
      function xg(s) {
        return s.split(/\r\n|\r|\n/);
      }
      function qs(s) {
        for (let e = 0, t = s.length; e < t; e++) {
          const i = s.charCodeAt(e);
          if (i !== 32 && i !== 9) return e;
        }
        return -1;
      }
      function us(s, e = 0, t = s.length) {
        for (let i = e; i < t; i++) {
          const n = s.charCodeAt(i);
          if (n !== 32 && n !== 9) return s.substring(e, i);
        }
        return s.substring(e, t);
      }
      function qh(s, e = s.length - 1) {
        for (let t = e; t >= 0; t--) {
          const i = s.charCodeAt(t);
          if (i !== 32 && i !== 9) return t;
        }
        return -1;
      }
      function Rk(s, e) {
        return s < e ? -1 : s > e ? 1 : 0;
      }
      function qE(s, e, t = 0, i = s.length, n = 0, o = e.length) {
        for (; t < i && n < o; t++, n++) {
          const l = s.charCodeAt(t), u = e.charCodeAt(n);
          if (l < u) return -1;
          if (l > u) return 1;
        }
        const r = i - t, a = o - n;
        return r < a ? -1 : r > a ? 1 : 0;
      }
      function K4(s, e) {
        return F_(s, e, 0, s.length, 0, e.length);
      }
      function F_(s, e, t = 0, i = s.length, n = 0, o = e.length) {
        for (; t < i && n < o; t++, n++) {
          let l = s.charCodeAt(t), u = e.charCodeAt(n);
          if (l === u) continue;
          if (l >= 128 || u >= 128) return qE(s.toLowerCase(), e.toLowerCase(), t, i, n, o);
          cf(l) && (l -= 32), cf(u) && (u -= 32);
          const d = l - u;
          if (d !== 0) return d;
        }
        const r = i - t, a = o - n;
        return r < a ? -1 : r > a ? 1 : 0;
      }
      function Sb(s) {
        return s >= 48 && s <= 57;
      }
      function cf(s) {
        return s >= 97 && s <= 122;
      }
      function Ec(s) {
        return s >= 65 && s <= 90;
      }
      function uf(s, e) {
        return s.length === e.length && F_(s, e) === 0;
      }
      function KE(s, e) {
        const t = e.length;
        return e.length > s.length ? false : F_(s, e, 0, t) === 0;
      }
      function Ok(s, e) {
        const t = Math.min(s.length, e.length);
        let i;
        for (i = 0; i < t; i++) if (s.charCodeAt(i) !== e.charCodeAt(i)) return i;
        return t;
      }
      function Pk(s, e) {
        const t = Math.min(s.length, e.length);
        let i;
        const n = s.length - 1, o = e.length - 1;
        for (i = 0; i < t; i++) if (s.charCodeAt(n - i) !== e.charCodeAt(o - i)) return i;
        return t;
      }
      function on(s) {
        return 55296 <= s && s <= 56319;
      }
      function ig(s) {
        return 56320 <= s && s <= 57343;
      }
      function jE(s, e) {
        return (s - 55296 << 10) + (e - 56320) + 65536;
      }
      function ev(s, e, t) {
        const i = s.charCodeAt(t);
        if (on(i) && t + 1 < e) {
          const n = s.charCodeAt(t + 1);
          if (ig(n)) return jE(i, n);
        }
        return i;
      }
      function Iq(s, e) {
        const t = s.charCodeAt(e - 1);
        if (ig(t) && e > 1) {
          const i = s.charCodeAt(e - 2);
          if (on(i)) return jE(i, t);
        }
        return t;
      }
      class GE {
        get offset() {
          return this._offset;
        }
        constructor(e, t = 0) {
          this._str = e, this._len = e.length, this._offset = t;
        }
        setOffset(e) {
          this._offset = e;
        }
        prevCodePoint() {
          const e = Iq(this._str, this._offset);
          return this._offset -= e >= 65536 ? 2 : 1, e;
        }
        nextCodePoint() {
          const e = ev(this._str, this._len, this._offset);
          return this._offset += e >= 65536 ? 2 : 1, e;
        }
        eol() {
          return this._offset >= this._len;
        }
      }
      class tv {
        get offset() {
          return this._iterator.offset;
        }
        constructor(e, t = 0) {
          this._iterator = new GE(e, t);
        }
        nextGraphemeLength() {
          const e = dh.getInstance(), t = this._iterator, i = t.offset;
          let n = e.getGraphemeBreakType(t.nextCodePoint());
          for (; !t.eol(); ) {
            const o = t.offset, r = e.getGraphemeBreakType(t.nextCodePoint());
            if (j4(n, r)) {
              t.setOffset(o);
              break;
            }
            n = r;
          }
          return t.offset - i;
        }
        prevGraphemeLength() {
          const e = dh.getInstance(), t = this._iterator, i = t.offset;
          let n = e.getGraphemeBreakType(t.prevCodePoint());
          for (; t.offset > 0; ) {
            const o = t.offset, r = e.getGraphemeBreakType(t.prevCodePoint());
            if (j4(r, n)) {
              t.setOffset(o);
              break;
            }
            n = r;
          }
          return i - t.offset;
        }
        eol() {
          return this._iterator.eol();
        }
      }
      function YE(s, e) {
        return new tv(s, e).nextGraphemeLength();
      }
      function x9(s, e) {
        return new tv(s, e).prevGraphemeLength();
      }
      function Mq(s, e) {
        e > 0 && ig(s.charCodeAt(e)) && e--;
        const t = e + YE(s, e);
        return [
          t - x9(s, t),
          t
        ];
      }
      let fL;
      function Aq() {
        return /(?:[\u05BE\u05C0\u05C3\u05C6\u05D0-\u05F4\u0608\u060B\u060D\u061B-\u064A\u066D-\u066F\u0671-\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u0710\u0712-\u072F\u074D-\u07A5\u07B1-\u07EA\u07F4\u07F5\u07FA\u07FE-\u0815\u081A\u0824\u0828\u0830-\u0858\u085E-\u088E\u08A0-\u08C9\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFD3D\uFD50-\uFDC7\uFDF0-\uFDFC\uFE70-\uFEFC]|\uD802[\uDC00-\uDD1B\uDD20-\uDE00\uDE10-\uDE35\uDE40-\uDEE4\uDEEB-\uDF35\uDF40-\uDFFF]|\uD803[\uDC00-\uDD23\uDE80-\uDEA9\uDEAD-\uDF45\uDF51-\uDF81\uDF86-\uDFF6]|\uD83A[\uDC00-\uDCCF\uDD00-\uDD43\uDD4B-\uDFFF]|\uD83B[\uDC00-\uDEBB])/;
      }
      function Yp(s) {
        return fL || (fL = Aq()), fL.test(s);
      }
      const Rq = /^[\t\n\r\x20-\x7E]*$/;
      function ZE(s) {
        return Rq.test(s);
      }
      const k9 = /[\u2028\u2029]/;
      function D9(s) {
        return k9.test(s);
      }
      function nu(s) {
        return s >= 11904 && s <= 55215 || s >= 63744 && s <= 64255 || s >= 65281 && s <= 65374;
      }
      function QE(s) {
        return s >= 127462 && s <= 127487 || s === 8986 || s === 8987 || s === 9200 || s === 9203 || s >= 9728 && s <= 10175 || s === 11088 || s === 11093 || s >= 127744 && s <= 128591 || s >= 128640 && s <= 128764 || s >= 128992 && s <= 129008 || s >= 129280 && s <= 129535 || s >= 129648 && s <= 129782;
      }
      const Oq = "\uFEFF";
      function XE(s) {
        return !!(s && s.length > 0 && s.charCodeAt(0) === 65279);
      }
      function E9(s) {
        return s = s % (2 * 26), s < 26 ? String.fromCharCode(97 + s) : String.fromCharCode(65 + s - 26);
      }
      function j4(s, e) {
        return s === 0 ? e !== 5 && e !== 7 : s === 2 && e === 3 ? false : s === 4 || s === 2 || s === 3 || e === 4 || e === 2 || e === 3 ? true : !(s === 8 && (e === 8 || e === 9 || e === 11 || e === 12) || (s === 11 || s === 9) && (e === 9 || e === 10) || (s === 12 || s === 10) && e === 10 || e === 5 || e === 13 || e === 7 || s === 1 || s === 13 && e === 14 || s === 6 && e === 6);
      }
      const _dh = class _dh {
        static getInstance() {
          return _dh._INSTANCE || (_dh._INSTANCE = new _dh()), _dh._INSTANCE;
        }
        constructor() {
          this._data = Pq();
        }
        getGraphemeBreakType(e) {
          if (e < 32) return e === 10 ? 3 : e === 13 ? 2 : 4;
          if (e < 127) return 0;
          const t = this._data, i = t.length / 3;
          let n = 1;
          for (; n <= i; ) if (e < t[3 * n]) n = 2 * n;
          else if (e > t[3 * n + 1]) n = 2 * n + 1;
          else return t[3 * n + 2];
          return 0;
        }
      };
      _dh._INSTANCE = null;
      let dh = _dh;
      function Pq() {
        return JSON.parse("[0,0,0,51229,51255,12,44061,44087,12,127462,127487,6,7083,7085,5,47645,47671,12,54813,54839,12,128678,128678,14,3270,3270,5,9919,9923,14,45853,45879,12,49437,49463,12,53021,53047,12,71216,71218,7,128398,128399,14,129360,129374,14,2519,2519,5,4448,4519,9,9742,9742,14,12336,12336,14,44957,44983,12,46749,46775,12,48541,48567,12,50333,50359,12,52125,52151,12,53917,53943,12,69888,69890,5,73018,73018,5,127990,127990,14,128558,128559,14,128759,128760,14,129653,129655,14,2027,2035,5,2891,2892,7,3761,3761,5,6683,6683,5,8293,8293,4,9825,9826,14,9999,9999,14,43452,43453,5,44509,44535,12,45405,45431,12,46301,46327,12,47197,47223,12,48093,48119,12,48989,49015,12,49885,49911,12,50781,50807,12,51677,51703,12,52573,52599,12,53469,53495,12,54365,54391,12,65279,65279,4,70471,70472,7,72145,72147,7,119173,119179,5,127799,127818,14,128240,128244,14,128512,128512,14,128652,128652,14,128721,128722,14,129292,129292,14,129445,129450,14,129734,129743,14,1476,1477,5,2366,2368,7,2750,2752,7,3076,3076,5,3415,3415,5,4141,4144,5,6109,6109,5,6964,6964,5,7394,7400,5,9197,9198,14,9770,9770,14,9877,9877,14,9968,9969,14,10084,10084,14,43052,43052,5,43713,43713,5,44285,44311,12,44733,44759,12,45181,45207,12,45629,45655,12,46077,46103,12,46525,46551,12,46973,46999,12,47421,47447,12,47869,47895,12,48317,48343,12,48765,48791,12,49213,49239,12,49661,49687,12,50109,50135,12,50557,50583,12,51005,51031,12,51453,51479,12,51901,51927,12,52349,52375,12,52797,52823,12,53245,53271,12,53693,53719,12,54141,54167,12,54589,54615,12,55037,55063,12,69506,69509,5,70191,70193,5,70841,70841,7,71463,71467,5,72330,72342,5,94031,94031,5,123628,123631,5,127763,127765,14,127941,127941,14,128043,128062,14,128302,128317,14,128465,128467,14,128539,128539,14,128640,128640,14,128662,128662,14,128703,128703,14,128745,128745,14,129004,129007,14,129329,129330,14,129402,129402,14,129483,129483,14,129686,129704,14,130048,131069,14,173,173,4,1757,1757,1,2200,2207,5,2434,2435,7,2631,2632,5,2817,2817,5,3008,3008,5,3201,3201,5,3387,3388,5,3542,3542,5,3902,3903,7,4190,4192,5,6002,6003,5,6439,6440,5,6765,6770,7,7019,7027,5,7154,7155,7,8205,8205,13,8505,8505,14,9654,9654,14,9757,9757,14,9792,9792,14,9852,9853,14,9890,9894,14,9937,9937,14,9981,9981,14,10035,10036,14,11035,11036,14,42654,42655,5,43346,43347,7,43587,43587,5,44006,44007,7,44173,44199,12,44397,44423,12,44621,44647,12,44845,44871,12,45069,45095,12,45293,45319,12,45517,45543,12,45741,45767,12,45965,45991,12,46189,46215,12,46413,46439,12,46637,46663,12,46861,46887,12,47085,47111,12,47309,47335,12,47533,47559,12,47757,47783,12,47981,48007,12,48205,48231,12,48429,48455,12,48653,48679,12,48877,48903,12,49101,49127,12,49325,49351,12,49549,49575,12,49773,49799,12,49997,50023,12,50221,50247,12,50445,50471,12,50669,50695,12,50893,50919,12,51117,51143,12,51341,51367,12,51565,51591,12,51789,51815,12,52013,52039,12,52237,52263,12,52461,52487,12,52685,52711,12,52909,52935,12,53133,53159,12,53357,53383,12,53581,53607,12,53805,53831,12,54029,54055,12,54253,54279,12,54477,54503,12,54701,54727,12,54925,54951,12,55149,55175,12,68101,68102,5,69762,69762,7,70067,70069,7,70371,70378,5,70720,70721,7,71087,71087,5,71341,71341,5,71995,71996,5,72249,72249,7,72850,72871,5,73109,73109,5,118576,118598,5,121505,121519,5,127245,127247,14,127568,127569,14,127777,127777,14,127872,127891,14,127956,127967,14,128015,128016,14,128110,128172,14,128259,128259,14,128367,128368,14,128424,128424,14,128488,128488,14,128530,128532,14,128550,128551,14,128566,128566,14,128647,128647,14,128656,128656,14,128667,128673,14,128691,128693,14,128715,128715,14,128728,128732,14,128752,128752,14,128765,128767,14,129096,129103,14,129311,129311,14,129344,129349,14,129394,129394,14,129413,129425,14,129466,129471,14,129511,129535,14,129664,129666,14,129719,129722,14,129760,129767,14,917536,917631,5,13,13,2,1160,1161,5,1564,1564,4,1807,1807,1,2085,2087,5,2307,2307,7,2382,2383,7,2497,2500,5,2563,2563,7,2677,2677,5,2763,2764,7,2879,2879,5,2914,2915,5,3021,3021,5,3142,3144,5,3263,3263,5,3285,3286,5,3398,3400,7,3530,3530,5,3633,3633,5,3864,3865,5,3974,3975,5,4155,4156,7,4229,4230,5,5909,5909,7,6078,6085,7,6277,6278,5,6451,6456,7,6744,6750,5,6846,6846,5,6972,6972,5,7074,7077,5,7146,7148,7,7222,7223,5,7416,7417,5,8234,8238,4,8417,8417,5,9000,9000,14,9203,9203,14,9730,9731,14,9748,9749,14,9762,9763,14,9776,9783,14,9800,9811,14,9831,9831,14,9872,9873,14,9882,9882,14,9900,9903,14,9929,9933,14,9941,9960,14,9974,9974,14,9989,9989,14,10006,10006,14,10062,10062,14,10160,10160,14,11647,11647,5,12953,12953,14,43019,43019,5,43232,43249,5,43443,43443,5,43567,43568,7,43696,43696,5,43765,43765,7,44013,44013,5,44117,44143,12,44229,44255,12,44341,44367,12,44453,44479,12,44565,44591,12,44677,44703,12,44789,44815,12,44901,44927,12,45013,45039,12,45125,45151,12,45237,45263,12,45349,45375,12,45461,45487,12,45573,45599,12,45685,45711,12,45797,45823,12,45909,45935,12,46021,46047,12,46133,46159,12,46245,46271,12,46357,46383,12,46469,46495,12,46581,46607,12,46693,46719,12,46805,46831,12,46917,46943,12,47029,47055,12,47141,47167,12,47253,47279,12,47365,47391,12,47477,47503,12,47589,47615,12,47701,47727,12,47813,47839,12,47925,47951,12,48037,48063,12,48149,48175,12,48261,48287,12,48373,48399,12,48485,48511,12,48597,48623,12,48709,48735,12,48821,48847,12,48933,48959,12,49045,49071,12,49157,49183,12,49269,49295,12,49381,49407,12,49493,49519,12,49605,49631,12,49717,49743,12,49829,49855,12,49941,49967,12,50053,50079,12,50165,50191,12,50277,50303,12,50389,50415,12,50501,50527,12,50613,50639,12,50725,50751,12,50837,50863,12,50949,50975,12,51061,51087,12,51173,51199,12,51285,51311,12,51397,51423,12,51509,51535,12,51621,51647,12,51733,51759,12,51845,51871,12,51957,51983,12,52069,52095,12,52181,52207,12,52293,52319,12,52405,52431,12,52517,52543,12,52629,52655,12,52741,52767,12,52853,52879,12,52965,52991,12,53077,53103,12,53189,53215,12,53301,53327,12,53413,53439,12,53525,53551,12,53637,53663,12,53749,53775,12,53861,53887,12,53973,53999,12,54085,54111,12,54197,54223,12,54309,54335,12,54421,54447,12,54533,54559,12,54645,54671,12,54757,54783,12,54869,54895,12,54981,55007,12,55093,55119,12,55243,55291,10,66045,66045,5,68325,68326,5,69688,69702,5,69817,69818,5,69957,69958,7,70089,70092,5,70198,70199,5,70462,70462,5,70502,70508,5,70750,70750,5,70846,70846,7,71100,71101,5,71230,71230,7,71351,71351,5,71737,71738,5,72000,72000,7,72160,72160,5,72273,72278,5,72752,72758,5,72882,72883,5,73031,73031,5,73461,73462,7,94192,94193,7,119149,119149,7,121403,121452,5,122915,122916,5,126980,126980,14,127358,127359,14,127535,127535,14,127759,127759,14,127771,127771,14,127792,127793,14,127825,127867,14,127897,127899,14,127945,127945,14,127985,127986,14,128000,128007,14,128021,128021,14,128066,128100,14,128184,128235,14,128249,128252,14,128266,128276,14,128335,128335,14,128379,128390,14,128407,128419,14,128444,128444,14,128481,128481,14,128499,128499,14,128526,128526,14,128536,128536,14,128543,128543,14,128556,128556,14,128564,128564,14,128577,128580,14,128643,128645,14,128649,128649,14,128654,128654,14,128660,128660,14,128664,128664,14,128675,128675,14,128686,128689,14,128695,128696,14,128705,128709,14,128717,128719,14,128725,128725,14,128736,128741,14,128747,128748,14,128755,128755,14,128762,128762,14,128981,128991,14,129009,129023,14,129160,129167,14,129296,129304,14,129320,129327,14,129340,129342,14,129356,129356,14,129388,129392,14,129399,129400,14,129404,129407,14,129432,129442,14,129454,129455,14,129473,129474,14,129485,129487,14,129648,129651,14,129659,129660,14,129671,129679,14,129709,129711,14,129728,129730,14,129751,129753,14,129776,129782,14,917505,917505,4,917760,917999,5,10,10,3,127,159,4,768,879,5,1471,1471,5,1536,1541,1,1648,1648,5,1767,1768,5,1840,1866,5,2070,2073,5,2137,2139,5,2274,2274,1,2363,2363,7,2377,2380,7,2402,2403,5,2494,2494,5,2507,2508,7,2558,2558,5,2622,2624,7,2641,2641,5,2691,2691,7,2759,2760,5,2786,2787,5,2876,2876,5,2881,2884,5,2901,2902,5,3006,3006,5,3014,3016,7,3072,3072,5,3134,3136,5,3157,3158,5,3260,3260,5,3266,3266,5,3274,3275,7,3328,3329,5,3391,3392,7,3405,3405,5,3457,3457,5,3536,3537,7,3551,3551,5,3636,3642,5,3764,3772,5,3895,3895,5,3967,3967,7,3993,4028,5,4146,4151,5,4182,4183,7,4226,4226,5,4253,4253,5,4957,4959,5,5940,5940,7,6070,6070,7,6087,6088,7,6158,6158,4,6432,6434,5,6448,6449,7,6679,6680,5,6742,6742,5,6754,6754,5,6783,6783,5,6912,6915,5,6966,6970,5,6978,6978,5,7042,7042,7,7080,7081,5,7143,7143,7,7150,7150,7,7212,7219,5,7380,7392,5,7412,7412,5,8203,8203,4,8232,8232,4,8265,8265,14,8400,8412,5,8421,8432,5,8617,8618,14,9167,9167,14,9200,9200,14,9410,9410,14,9723,9726,14,9733,9733,14,9745,9745,14,9752,9752,14,9760,9760,14,9766,9766,14,9774,9774,14,9786,9786,14,9794,9794,14,9823,9823,14,9828,9828,14,9833,9850,14,9855,9855,14,9875,9875,14,9880,9880,14,9885,9887,14,9896,9897,14,9906,9916,14,9926,9927,14,9935,9935,14,9939,9939,14,9962,9962,14,9972,9972,14,9978,9978,14,9986,9986,14,9997,9997,14,10002,10002,14,10017,10017,14,10055,10055,14,10071,10071,14,10133,10135,14,10548,10549,14,11093,11093,14,12330,12333,5,12441,12442,5,42608,42610,5,43010,43010,5,43045,43046,5,43188,43203,7,43302,43309,5,43392,43394,5,43446,43449,5,43493,43493,5,43571,43572,7,43597,43597,7,43703,43704,5,43756,43757,5,44003,44004,7,44009,44010,7,44033,44059,12,44089,44115,12,44145,44171,12,44201,44227,12,44257,44283,12,44313,44339,12,44369,44395,12,44425,44451,12,44481,44507,12,44537,44563,12,44593,44619,12,44649,44675,12,44705,44731,12,44761,44787,12,44817,44843,12,44873,44899,12,44929,44955,12,44985,45011,12,45041,45067,12,45097,45123,12,45153,45179,12,45209,45235,12,45265,45291,12,45321,45347,12,45377,45403,12,45433,45459,12,45489,45515,12,45545,45571,12,45601,45627,12,45657,45683,12,45713,45739,12,45769,45795,12,45825,45851,12,45881,45907,12,45937,45963,12,45993,46019,12,46049,46075,12,46105,46131,12,46161,46187,12,46217,46243,12,46273,46299,12,46329,46355,12,46385,46411,12,46441,46467,12,46497,46523,12,46553,46579,12,46609,46635,12,46665,46691,12,46721,46747,12,46777,46803,12,46833,46859,12,46889,46915,12,46945,46971,12,47001,47027,12,47057,47083,12,47113,47139,12,47169,47195,12,47225,47251,12,47281,47307,12,47337,47363,12,47393,47419,12,47449,47475,12,47505,47531,12,47561,47587,12,47617,47643,12,47673,47699,12,47729,47755,12,47785,47811,12,47841,47867,12,47897,47923,12,47953,47979,12,48009,48035,12,48065,48091,12,48121,48147,12,48177,48203,12,48233,48259,12,48289,48315,12,48345,48371,12,48401,48427,12,48457,48483,12,48513,48539,12,48569,48595,12,48625,48651,12,48681,48707,12,48737,48763,12,48793,48819,12,48849,48875,12,48905,48931,12,48961,48987,12,49017,49043,12,49073,49099,12,49129,49155,12,49185,49211,12,49241,49267,12,49297,49323,12,49353,49379,12,49409,49435,12,49465,49491,12,49521,49547,12,49577,49603,12,49633,49659,12,49689,49715,12,49745,49771,12,49801,49827,12,49857,49883,12,49913,49939,12,49969,49995,12,50025,50051,12,50081,50107,12,50137,50163,12,50193,50219,12,50249,50275,12,50305,50331,12,50361,50387,12,50417,50443,12,50473,50499,12,50529,50555,12,50585,50611,12,50641,50667,12,50697,50723,12,50753,50779,12,50809,50835,12,50865,50891,12,50921,50947,12,50977,51003,12,51033,51059,12,51089,51115,12,51145,51171,12,51201,51227,12,51257,51283,12,51313,51339,12,51369,51395,12,51425,51451,12,51481,51507,12,51537,51563,12,51593,51619,12,51649,51675,12,51705,51731,12,51761,51787,12,51817,51843,12,51873,51899,12,51929,51955,12,51985,52011,12,52041,52067,12,52097,52123,12,52153,52179,12,52209,52235,12,52265,52291,12,52321,52347,12,52377,52403,12,52433,52459,12,52489,52515,12,52545,52571,12,52601,52627,12,52657,52683,12,52713,52739,12,52769,52795,12,52825,52851,12,52881,52907,12,52937,52963,12,52993,53019,12,53049,53075,12,53105,53131,12,53161,53187,12,53217,53243,12,53273,53299,12,53329,53355,12,53385,53411,12,53441,53467,12,53497,53523,12,53553,53579,12,53609,53635,12,53665,53691,12,53721,53747,12,53777,53803,12,53833,53859,12,53889,53915,12,53945,53971,12,54001,54027,12,54057,54083,12,54113,54139,12,54169,54195,12,54225,54251,12,54281,54307,12,54337,54363,12,54393,54419,12,54449,54475,12,54505,54531,12,54561,54587,12,54617,54643,12,54673,54699,12,54729,54755,12,54785,54811,12,54841,54867,12,54897,54923,12,54953,54979,12,55009,55035,12,55065,55091,12,55121,55147,12,55177,55203,12,65024,65039,5,65520,65528,4,66422,66426,5,68152,68154,5,69291,69292,5,69633,69633,5,69747,69748,5,69811,69814,5,69826,69826,5,69932,69932,7,70016,70017,5,70079,70080,7,70095,70095,5,70196,70196,5,70367,70367,5,70402,70403,7,70464,70464,5,70487,70487,5,70709,70711,7,70725,70725,7,70833,70834,7,70843,70844,7,70849,70849,7,71090,71093,5,71103,71104,5,71227,71228,7,71339,71339,5,71344,71349,5,71458,71461,5,71727,71735,5,71985,71989,7,71998,71998,5,72002,72002,7,72154,72155,5,72193,72202,5,72251,72254,5,72281,72283,5,72344,72345,5,72766,72766,7,72874,72880,5,72885,72886,5,73023,73029,5,73104,73105,5,73111,73111,5,92912,92916,5,94095,94098,5,113824,113827,4,119142,119142,7,119155,119162,4,119362,119364,5,121476,121476,5,122888,122904,5,123184,123190,5,125252,125258,5,127183,127183,14,127340,127343,14,127377,127386,14,127491,127503,14,127548,127551,14,127744,127756,14,127761,127761,14,127769,127769,14,127773,127774,14,127780,127788,14,127796,127797,14,127820,127823,14,127869,127869,14,127894,127895,14,127902,127903,14,127943,127943,14,127947,127950,14,127972,127972,14,127988,127988,14,127992,127994,14,128009,128011,14,128019,128019,14,128023,128041,14,128064,128064,14,128102,128107,14,128174,128181,14,128238,128238,14,128246,128247,14,128254,128254,14,128264,128264,14,128278,128299,14,128329,128330,14,128348,128359,14,128371,128377,14,128392,128393,14,128401,128404,14,128421,128421,14,128433,128434,14,128450,128452,14,128476,128478,14,128483,128483,14,128495,128495,14,128506,128506,14,128519,128520,14,128528,128528,14,128534,128534,14,128538,128538,14,128540,128542,14,128544,128549,14,128552,128555,14,128557,128557,14,128560,128563,14,128565,128565,14,128567,128576,14,128581,128591,14,128641,128642,14,128646,128646,14,128648,128648,14,128650,128651,14,128653,128653,14,128655,128655,14,128657,128659,14,128661,128661,14,128663,128663,14,128665,128666,14,128674,128674,14,128676,128677,14,128679,128685,14,128690,128690,14,128694,128694,14,128697,128702,14,128704,128704,14,128710,128714,14,128716,128716,14,128720,128720,14,128723,128724,14,128726,128727,14,128733,128735,14,128742,128744,14,128746,128746,14,128749,128751,14,128753,128754,14,128756,128758,14,128761,128761,14,128763,128764,14,128884,128895,14,128992,129003,14,129008,129008,14,129036,129039,14,129114,129119,14,129198,129279,14,129293,129295,14,129305,129310,14,129312,129319,14,129328,129328,14,129331,129338,14,129343,129343,14,129351,129355,14,129357,129359,14,129375,129387,14,129393,129393,14,129395,129398,14,129401,129401,14,129403,129403,14,129408,129412,14,129426,129431,14,129443,129444,14,129451,129453,14,129456,129465,14,129472,129472,14,129475,129482,14,129484,129484,14,129488,129510,14,129536,129647,14,129652,129652,14,129656,129658,14,129661,129663,14,129667,129670,14,129680,129685,14,129705,129708,14,129712,129718,14,129723,129727,14,129731,129733,14,129744,129750,14,129754,129759,14,129768,129775,14,129783,129791,14,917504,917504,4,917506,917535,4,917632,917759,4,918000,921599,4,0,9,4,11,12,4,14,31,4,169,169,14,174,174,14,1155,1159,5,1425,1469,5,1473,1474,5,1479,1479,5,1552,1562,5,1611,1631,5,1750,1756,5,1759,1764,5,1770,1773,5,1809,1809,5,1958,1968,5,2045,2045,5,2075,2083,5,2089,2093,5,2192,2193,1,2250,2273,5,2275,2306,5,2362,2362,5,2364,2364,5,2369,2376,5,2381,2381,5,2385,2391,5,2433,2433,5,2492,2492,5,2495,2496,7,2503,2504,7,2509,2509,5,2530,2531,5,2561,2562,5,2620,2620,5,2625,2626,5,2635,2637,5,2672,2673,5,2689,2690,5,2748,2748,5,2753,2757,5,2761,2761,7,2765,2765,5,2810,2815,5,2818,2819,7,2878,2878,5,2880,2880,7,2887,2888,7,2893,2893,5,2903,2903,5,2946,2946,5,3007,3007,7,3009,3010,7,3018,3020,7,3031,3031,5,3073,3075,7,3132,3132,5,3137,3140,7,3146,3149,5,3170,3171,5,3202,3203,7,3262,3262,7,3264,3265,7,3267,3268,7,3271,3272,7,3276,3277,5,3298,3299,5,3330,3331,7,3390,3390,5,3393,3396,5,3402,3404,7,3406,3406,1,3426,3427,5,3458,3459,7,3535,3535,5,3538,3540,5,3544,3550,7,3570,3571,7,3635,3635,7,3655,3662,5,3763,3763,7,3784,3789,5,3893,3893,5,3897,3897,5,3953,3966,5,3968,3972,5,3981,3991,5,4038,4038,5,4145,4145,7,4153,4154,5,4157,4158,5,4184,4185,5,4209,4212,5,4228,4228,7,4237,4237,5,4352,4447,8,4520,4607,10,5906,5908,5,5938,5939,5,5970,5971,5,6068,6069,5,6071,6077,5,6086,6086,5,6089,6099,5,6155,6157,5,6159,6159,5,6313,6313,5,6435,6438,7,6441,6443,7,6450,6450,5,6457,6459,5,6681,6682,7,6741,6741,7,6743,6743,7,6752,6752,5,6757,6764,5,6771,6780,5,6832,6845,5,6847,6862,5,6916,6916,7,6965,6965,5,6971,6971,7,6973,6977,7,6979,6980,7,7040,7041,5,7073,7073,7,7078,7079,7,7082,7082,7,7142,7142,5,7144,7145,5,7149,7149,5,7151,7153,5,7204,7211,7,7220,7221,7,7376,7378,5,7393,7393,7,7405,7405,5,7415,7415,7,7616,7679,5,8204,8204,5,8206,8207,4,8233,8233,4,8252,8252,14,8288,8292,4,8294,8303,4,8413,8416,5,8418,8420,5,8482,8482,14,8596,8601,14,8986,8987,14,9096,9096,14,9193,9196,14,9199,9199,14,9201,9202,14,9208,9210,14,9642,9643,14,9664,9664,14,9728,9729,14,9732,9732,14,9735,9741,14,9743,9744,14,9746,9746,14,9750,9751,14,9753,9756,14,9758,9759,14,9761,9761,14,9764,9765,14,9767,9769,14,9771,9773,14,9775,9775,14,9784,9785,14,9787,9791,14,9793,9793,14,9795,9799,14,9812,9822,14,9824,9824,14,9827,9827,14,9829,9830,14,9832,9832,14,9851,9851,14,9854,9854,14,9856,9861,14,9874,9874,14,9876,9876,14,9878,9879,14,9881,9881,14,9883,9884,14,9888,9889,14,9895,9895,14,9898,9899,14,9904,9905,14,9917,9918,14,9924,9925,14,9928,9928,14,9934,9934,14,9936,9936,14,9938,9938,14,9940,9940,14,9961,9961,14,9963,9967,14,9970,9971,14,9973,9973,14,9975,9977,14,9979,9980,14,9982,9985,14,9987,9988,14,9992,9996,14,9998,9998,14,10000,10001,14,10004,10004,14,10013,10013,14,10024,10024,14,10052,10052,14,10060,10060,14,10067,10069,14,10083,10083,14,10085,10087,14,10145,10145,14,10175,10175,14,11013,11015,14,11088,11088,14,11503,11505,5,11744,11775,5,12334,12335,5,12349,12349,14,12951,12951,14,42607,42607,5,42612,42621,5,42736,42737,5,43014,43014,5,43043,43044,7,43047,43047,7,43136,43137,7,43204,43205,5,43263,43263,5,43335,43345,5,43360,43388,8,43395,43395,7,43444,43445,7,43450,43451,7,43454,43456,7,43561,43566,5,43569,43570,5,43573,43574,5,43596,43596,5,43644,43644,5,43698,43700,5,43710,43711,5,43755,43755,7,43758,43759,7,43766,43766,5,44005,44005,5,44008,44008,5,44012,44012,7,44032,44032,11,44060,44060,11,44088,44088,11,44116,44116,11,44144,44144,11,44172,44172,11,44200,44200,11,44228,44228,11,44256,44256,11,44284,44284,11,44312,44312,11,44340,44340,11,44368,44368,11,44396,44396,11,44424,44424,11,44452,44452,11,44480,44480,11,44508,44508,11,44536,44536,11,44564,44564,11,44592,44592,11,44620,44620,11,44648,44648,11,44676,44676,11,44704,44704,11,44732,44732,11,44760,44760,11,44788,44788,11,44816,44816,11,44844,44844,11,44872,44872,11,44900,44900,11,44928,44928,11,44956,44956,11,44984,44984,11,45012,45012,11,45040,45040,11,45068,45068,11,45096,45096,11,45124,45124,11,45152,45152,11,45180,45180,11,45208,45208,11,45236,45236,11,45264,45264,11,45292,45292,11,45320,45320,11,45348,45348,11,45376,45376,11,45404,45404,11,45432,45432,11,45460,45460,11,45488,45488,11,45516,45516,11,45544,45544,11,45572,45572,11,45600,45600,11,45628,45628,11,45656,45656,11,45684,45684,11,45712,45712,11,45740,45740,11,45768,45768,11,45796,45796,11,45824,45824,11,45852,45852,11,45880,45880,11,45908,45908,11,45936,45936,11,45964,45964,11,45992,45992,11,46020,46020,11,46048,46048,11,46076,46076,11,46104,46104,11,46132,46132,11,46160,46160,11,46188,46188,11,46216,46216,11,46244,46244,11,46272,46272,11,46300,46300,11,46328,46328,11,46356,46356,11,46384,46384,11,46412,46412,11,46440,46440,11,46468,46468,11,46496,46496,11,46524,46524,11,46552,46552,11,46580,46580,11,46608,46608,11,46636,46636,11,46664,46664,11,46692,46692,11,46720,46720,11,46748,46748,11,46776,46776,11,46804,46804,11,46832,46832,11,46860,46860,11,46888,46888,11,46916,46916,11,46944,46944,11,46972,46972,11,47000,47000,11,47028,47028,11,47056,47056,11,47084,47084,11,47112,47112,11,47140,47140,11,47168,47168,11,47196,47196,11,47224,47224,11,47252,47252,11,47280,47280,11,47308,47308,11,47336,47336,11,47364,47364,11,47392,47392,11,47420,47420,11,47448,47448,11,47476,47476,11,47504,47504,11,47532,47532,11,47560,47560,11,47588,47588,11,47616,47616,11,47644,47644,11,47672,47672,11,47700,47700,11,47728,47728,11,47756,47756,11,47784,47784,11,47812,47812,11,47840,47840,11,47868,47868,11,47896,47896,11,47924,47924,11,47952,47952,11,47980,47980,11,48008,48008,11,48036,48036,11,48064,48064,11,48092,48092,11,48120,48120,11,48148,48148,11,48176,48176,11,48204,48204,11,48232,48232,11,48260,48260,11,48288,48288,11,48316,48316,11,48344,48344,11,48372,48372,11,48400,48400,11,48428,48428,11,48456,48456,11,48484,48484,11,48512,48512,11,48540,48540,11,48568,48568,11,48596,48596,11,48624,48624,11,48652,48652,11,48680,48680,11,48708,48708,11,48736,48736,11,48764,48764,11,48792,48792,11,48820,48820,11,48848,48848,11,48876,48876,11,48904,48904,11,48932,48932,11,48960,48960,11,48988,48988,11,49016,49016,11,49044,49044,11,49072,49072,11,49100,49100,11,49128,49128,11,49156,49156,11,49184,49184,11,49212,49212,11,49240,49240,11,49268,49268,11,49296,49296,11,49324,49324,11,49352,49352,11,49380,49380,11,49408,49408,11,49436,49436,11,49464,49464,11,49492,49492,11,49520,49520,11,49548,49548,11,49576,49576,11,49604,49604,11,49632,49632,11,49660,49660,11,49688,49688,11,49716,49716,11,49744,49744,11,49772,49772,11,49800,49800,11,49828,49828,11,49856,49856,11,49884,49884,11,49912,49912,11,49940,49940,11,49968,49968,11,49996,49996,11,50024,50024,11,50052,50052,11,50080,50080,11,50108,50108,11,50136,50136,11,50164,50164,11,50192,50192,11,50220,50220,11,50248,50248,11,50276,50276,11,50304,50304,11,50332,50332,11,50360,50360,11,50388,50388,11,50416,50416,11,50444,50444,11,50472,50472,11,50500,50500,11,50528,50528,11,50556,50556,11,50584,50584,11,50612,50612,11,50640,50640,11,50668,50668,11,50696,50696,11,50724,50724,11,50752,50752,11,50780,50780,11,50808,50808,11,50836,50836,11,50864,50864,11,50892,50892,11,50920,50920,11,50948,50948,11,50976,50976,11,51004,51004,11,51032,51032,11,51060,51060,11,51088,51088,11,51116,51116,11,51144,51144,11,51172,51172,11,51200,51200,11,51228,51228,11,51256,51256,11,51284,51284,11,51312,51312,11,51340,51340,11,51368,51368,11,51396,51396,11,51424,51424,11,51452,51452,11,51480,51480,11,51508,51508,11,51536,51536,11,51564,51564,11,51592,51592,11,51620,51620,11,51648,51648,11,51676,51676,11,51704,51704,11,51732,51732,11,51760,51760,11,51788,51788,11,51816,51816,11,51844,51844,11,51872,51872,11,51900,51900,11,51928,51928,11,51956,51956,11,51984,51984,11,52012,52012,11,52040,52040,11,52068,52068,11,52096,52096,11,52124,52124,11,52152,52152,11,52180,52180,11,52208,52208,11,52236,52236,11,52264,52264,11,52292,52292,11,52320,52320,11,52348,52348,11,52376,52376,11,52404,52404,11,52432,52432,11,52460,52460,11,52488,52488,11,52516,52516,11,52544,52544,11,52572,52572,11,52600,52600,11,52628,52628,11,52656,52656,11,52684,52684,11,52712,52712,11,52740,52740,11,52768,52768,11,52796,52796,11,52824,52824,11,52852,52852,11,52880,52880,11,52908,52908,11,52936,52936,11,52964,52964,11,52992,52992,11,53020,53020,11,53048,53048,11,53076,53076,11,53104,53104,11,53132,53132,11,53160,53160,11,53188,53188,11,53216,53216,11,53244,53244,11,53272,53272,11,53300,53300,11,53328,53328,11,53356,53356,11,53384,53384,11,53412,53412,11,53440,53440,11,53468,53468,11,53496,53496,11,53524,53524,11,53552,53552,11,53580,53580,11,53608,53608,11,53636,53636,11,53664,53664,11,53692,53692,11,53720,53720,11,53748,53748,11,53776,53776,11,53804,53804,11,53832,53832,11,53860,53860,11,53888,53888,11,53916,53916,11,53944,53944,11,53972,53972,11,54000,54000,11,54028,54028,11,54056,54056,11,54084,54084,11,54112,54112,11,54140,54140,11,54168,54168,11,54196,54196,11,54224,54224,11,54252,54252,11,54280,54280,11,54308,54308,11,54336,54336,11,54364,54364,11,54392,54392,11,54420,54420,11,54448,54448,11,54476,54476,11,54504,54504,11,54532,54532,11,54560,54560,11,54588,54588,11,54616,54616,11,54644,54644,11,54672,54672,11,54700,54700,11,54728,54728,11,54756,54756,11,54784,54784,11,54812,54812,11,54840,54840,11,54868,54868,11,54896,54896,11,54924,54924,11,54952,54952,11,54980,54980,11,55008,55008,11,55036,55036,11,55064,55064,11,55092,55092,11,55120,55120,11,55148,55148,11,55176,55176,11,55216,55238,9,64286,64286,5,65056,65071,5,65438,65439,5,65529,65531,4,66272,66272,5,68097,68099,5,68108,68111,5,68159,68159,5,68900,68903,5,69446,69456,5,69632,69632,7,69634,69634,7,69744,69744,5,69759,69761,5,69808,69810,7,69815,69816,7,69821,69821,1,69837,69837,1,69927,69931,5,69933,69940,5,70003,70003,5,70018,70018,7,70070,70078,5,70082,70083,1,70094,70094,7,70188,70190,7,70194,70195,7,70197,70197,7,70206,70206,5,70368,70370,7,70400,70401,5,70459,70460,5,70463,70463,7,70465,70468,7,70475,70477,7,70498,70499,7,70512,70516,5,70712,70719,5,70722,70724,5,70726,70726,5,70832,70832,5,70835,70840,5,70842,70842,5,70845,70845,5,70847,70848,5,70850,70851,5,71088,71089,7,71096,71099,7,71102,71102,7,71132,71133,5,71219,71226,5,71229,71229,5,71231,71232,5,71340,71340,7,71342,71343,7,71350,71350,7,71453,71455,5,71462,71462,7,71724,71726,7,71736,71736,7,71984,71984,5,71991,71992,7,71997,71997,7,71999,71999,1,72001,72001,1,72003,72003,5,72148,72151,5,72156,72159,7,72164,72164,7,72243,72248,5,72250,72250,1,72263,72263,5,72279,72280,7,72324,72329,1,72343,72343,7,72751,72751,7,72760,72765,5,72767,72767,5,72873,72873,7,72881,72881,7,72884,72884,7,73009,73014,5,73020,73021,5,73030,73030,1,73098,73102,7,73107,73108,7,73110,73110,7,73459,73460,5,78896,78904,4,92976,92982,5,94033,94087,7,94180,94180,5,113821,113822,5,118528,118573,5,119141,119141,5,119143,119145,5,119150,119154,5,119163,119170,5,119210,119213,5,121344,121398,5,121461,121461,5,121499,121503,5,122880,122886,5,122907,122913,5,122918,122922,5,123566,123566,5,125136,125142,5,126976,126979,14,126981,127182,14,127184,127231,14,127279,127279,14,127344,127345,14,127374,127374,14,127405,127461,14,127489,127490,14,127514,127514,14,127538,127546,14,127561,127567,14,127570,127743,14,127757,127758,14,127760,127760,14,127762,127762,14,127766,127768,14,127770,127770,14,127772,127772,14,127775,127776,14,127778,127779,14,127789,127791,14,127794,127795,14,127798,127798,14,127819,127819,14,127824,127824,14,127868,127868,14,127870,127871,14,127892,127893,14,127896,127896,14,127900,127901,14,127904,127940,14,127942,127942,14,127944,127944,14,127946,127946,14,127951,127955,14,127968,127971,14,127973,127984,14,127987,127987,14,127989,127989,14,127991,127991,14,127995,127999,5,128008,128008,14,128012,128014,14,128017,128018,14,128020,128020,14,128022,128022,14,128042,128042,14,128063,128063,14,128065,128065,14,128101,128101,14,128108,128109,14,128173,128173,14,128182,128183,14,128236,128237,14,128239,128239,14,128245,128245,14,128248,128248,14,128253,128253,14,128255,128258,14,128260,128263,14,128265,128265,14,128277,128277,14,128300,128301,14,128326,128328,14,128331,128334,14,128336,128347,14,128360,128366,14,128369,128370,14,128378,128378,14,128391,128391,14,128394,128397,14,128400,128400,14,128405,128406,14,128420,128420,14,128422,128423,14,128425,128432,14,128435,128443,14,128445,128449,14,128453,128464,14,128468,128475,14,128479,128480,14,128482,128482,14,128484,128487,14,128489,128494,14,128496,128498,14,128500,128505,14,128507,128511,14,128513,128518,14,128521,128525,14,128527,128527,14,128529,128529,14,128533,128533,14,128535,128535,14,128537,128537,14]");
      }
      function Bq(s, e) {
        if (s === 0) return 0;
        const t = Fq(s, e);
        if (t !== void 0) return t;
        const i = new GE(e, s);
        return i.prevCodePoint(), i.offset;
      }
      function Fq(s, e) {
        const t = new GE(e, s);
        let i = t.prevCodePoint();
        for (; Vq(i) || i === 65039 || i === 8419; ) {
          if (t.offset === 0) return;
          i = t.prevCodePoint();
        }
        if (!QE(i)) return;
        let n = t.offset;
        return n > 0 && t.prevCodePoint() === 8205 && (n = t.offset), n;
      }
      function Vq(s) {
        return 127995 <= s && s <= 127999;
      }
      const _Wc = class _Wc {
        static getInstance(e) {
          return _Wc.cache.get(Array.from(e));
        }
        static getLocales() {
          return _Wc._locales.value;
        }
        constructor(e) {
          this.confusableDictionary = e;
        }
        isAmbiguous(e) {
          return this.confusableDictionary.has(e);
        }
        getPrimaryConfusable(e) {
          return this.confusableDictionary.get(e);
        }
        getConfusableCodePoints() {
          return new Set(this.confusableDictionary.keys());
        }
      };
      _Wc.ambiguousCharacterData = new iu(() => JSON.parse('{"_common":[8232,32,8233,32,5760,32,8192,32,8193,32,8194,32,8195,32,8196,32,8197,32,8198,32,8200,32,8201,32,8202,32,8287,32,8199,32,8239,32,2042,95,65101,95,65102,95,65103,95,8208,45,8209,45,8210,45,65112,45,1748,45,8259,45,727,45,8722,45,10134,45,11450,45,1549,44,1643,44,8218,44,184,44,42233,44,894,59,2307,58,2691,58,1417,58,1795,58,1796,58,5868,58,65072,58,6147,58,6153,58,8282,58,1475,58,760,58,42889,58,8758,58,720,58,42237,58,451,33,11601,33,660,63,577,63,2429,63,5038,63,42731,63,119149,46,8228,46,1793,46,1794,46,42510,46,68176,46,1632,46,1776,46,42232,46,1373,96,65287,96,8219,96,8242,96,1370,96,1523,96,8175,96,65344,96,900,96,8189,96,8125,96,8127,96,8190,96,697,96,884,96,712,96,714,96,715,96,756,96,699,96,701,96,700,96,702,96,42892,96,1497,96,2036,96,2037,96,5194,96,5836,96,94033,96,94034,96,65339,91,10088,40,10098,40,12308,40,64830,40,65341,93,10089,41,10099,41,12309,41,64831,41,10100,123,119060,123,10101,125,65342,94,8270,42,1645,42,8727,42,66335,42,5941,47,8257,47,8725,47,8260,47,9585,47,10187,47,10744,47,119354,47,12755,47,12339,47,11462,47,20031,47,12035,47,65340,92,65128,92,8726,92,10189,92,10741,92,10745,92,119311,92,119355,92,12756,92,20022,92,12034,92,42872,38,708,94,710,94,5869,43,10133,43,66203,43,8249,60,10094,60,706,60,119350,60,5176,60,5810,60,5120,61,11840,61,12448,61,42239,61,8250,62,10095,62,707,62,119351,62,5171,62,94015,62,8275,126,732,126,8128,126,8764,126,65372,124,65293,45,120784,50,120794,50,120804,50,120814,50,120824,50,130034,50,42842,50,423,50,1000,50,42564,50,5311,50,42735,50,119302,51,120785,51,120795,51,120805,51,120815,51,120825,51,130035,51,42923,51,540,51,439,51,42858,51,11468,51,1248,51,94011,51,71882,51,120786,52,120796,52,120806,52,120816,52,120826,52,130036,52,5070,52,71855,52,120787,53,120797,53,120807,53,120817,53,120827,53,130037,53,444,53,71867,53,120788,54,120798,54,120808,54,120818,54,120828,54,130038,54,11474,54,5102,54,71893,54,119314,55,120789,55,120799,55,120809,55,120819,55,120829,55,130039,55,66770,55,71878,55,2819,56,2538,56,2666,56,125131,56,120790,56,120800,56,120810,56,120820,56,120830,56,130040,56,547,56,546,56,66330,56,2663,57,2920,57,2541,57,3437,57,120791,57,120801,57,120811,57,120821,57,120831,57,130041,57,42862,57,11466,57,71884,57,71852,57,71894,57,9082,97,65345,97,119834,97,119886,97,119938,97,119990,97,120042,97,120094,97,120146,97,120198,97,120250,97,120302,97,120354,97,120406,97,120458,97,593,97,945,97,120514,97,120572,97,120630,97,120688,97,120746,97,65313,65,119808,65,119860,65,119912,65,119964,65,120016,65,120068,65,120120,65,120172,65,120224,65,120276,65,120328,65,120380,65,120432,65,913,65,120488,65,120546,65,120604,65,120662,65,120720,65,5034,65,5573,65,42222,65,94016,65,66208,65,119835,98,119887,98,119939,98,119991,98,120043,98,120095,98,120147,98,120199,98,120251,98,120303,98,120355,98,120407,98,120459,98,388,98,5071,98,5234,98,5551,98,65314,66,8492,66,119809,66,119861,66,119913,66,120017,66,120069,66,120121,66,120173,66,120225,66,120277,66,120329,66,120381,66,120433,66,42932,66,914,66,120489,66,120547,66,120605,66,120663,66,120721,66,5108,66,5623,66,42192,66,66178,66,66209,66,66305,66,65347,99,8573,99,119836,99,119888,99,119940,99,119992,99,120044,99,120096,99,120148,99,120200,99,120252,99,120304,99,120356,99,120408,99,120460,99,7428,99,1010,99,11429,99,43951,99,66621,99,128844,67,71922,67,71913,67,65315,67,8557,67,8450,67,8493,67,119810,67,119862,67,119914,67,119966,67,120018,67,120174,67,120226,67,120278,67,120330,67,120382,67,120434,67,1017,67,11428,67,5087,67,42202,67,66210,67,66306,67,66581,67,66844,67,8574,100,8518,100,119837,100,119889,100,119941,100,119993,100,120045,100,120097,100,120149,100,120201,100,120253,100,120305,100,120357,100,120409,100,120461,100,1281,100,5095,100,5231,100,42194,100,8558,68,8517,68,119811,68,119863,68,119915,68,119967,68,120019,68,120071,68,120123,68,120175,68,120227,68,120279,68,120331,68,120383,68,120435,68,5024,68,5598,68,5610,68,42195,68,8494,101,65349,101,8495,101,8519,101,119838,101,119890,101,119942,101,120046,101,120098,101,120150,101,120202,101,120254,101,120306,101,120358,101,120410,101,120462,101,43826,101,1213,101,8959,69,65317,69,8496,69,119812,69,119864,69,119916,69,120020,69,120072,69,120124,69,120176,69,120228,69,120280,69,120332,69,120384,69,120436,69,917,69,120492,69,120550,69,120608,69,120666,69,120724,69,11577,69,5036,69,42224,69,71846,69,71854,69,66182,69,119839,102,119891,102,119943,102,119995,102,120047,102,120099,102,120151,102,120203,102,120255,102,120307,102,120359,102,120411,102,120463,102,43829,102,42905,102,383,102,7837,102,1412,102,119315,70,8497,70,119813,70,119865,70,119917,70,120021,70,120073,70,120125,70,120177,70,120229,70,120281,70,120333,70,120385,70,120437,70,42904,70,988,70,120778,70,5556,70,42205,70,71874,70,71842,70,66183,70,66213,70,66853,70,65351,103,8458,103,119840,103,119892,103,119944,103,120048,103,120100,103,120152,103,120204,103,120256,103,120308,103,120360,103,120412,103,120464,103,609,103,7555,103,397,103,1409,103,119814,71,119866,71,119918,71,119970,71,120022,71,120074,71,120126,71,120178,71,120230,71,120282,71,120334,71,120386,71,120438,71,1292,71,5056,71,5107,71,42198,71,65352,104,8462,104,119841,104,119945,104,119997,104,120049,104,120101,104,120153,104,120205,104,120257,104,120309,104,120361,104,120413,104,120465,104,1211,104,1392,104,5058,104,65320,72,8459,72,8460,72,8461,72,119815,72,119867,72,119919,72,120023,72,120179,72,120231,72,120283,72,120335,72,120387,72,120439,72,919,72,120494,72,120552,72,120610,72,120668,72,120726,72,11406,72,5051,72,5500,72,42215,72,66255,72,731,105,9075,105,65353,105,8560,105,8505,105,8520,105,119842,105,119894,105,119946,105,119998,105,120050,105,120102,105,120154,105,120206,105,120258,105,120310,105,120362,105,120414,105,120466,105,120484,105,618,105,617,105,953,105,8126,105,890,105,120522,105,120580,105,120638,105,120696,105,120754,105,1110,105,42567,105,1231,105,43893,105,5029,105,71875,105,65354,106,8521,106,119843,106,119895,106,119947,106,119999,106,120051,106,120103,106,120155,106,120207,106,120259,106,120311,106,120363,106,120415,106,120467,106,1011,106,1112,106,65322,74,119817,74,119869,74,119921,74,119973,74,120025,74,120077,74,120129,74,120181,74,120233,74,120285,74,120337,74,120389,74,120441,74,42930,74,895,74,1032,74,5035,74,5261,74,42201,74,119844,107,119896,107,119948,107,120000,107,120052,107,120104,107,120156,107,120208,107,120260,107,120312,107,120364,107,120416,107,120468,107,8490,75,65323,75,119818,75,119870,75,119922,75,119974,75,120026,75,120078,75,120130,75,120182,75,120234,75,120286,75,120338,75,120390,75,120442,75,922,75,120497,75,120555,75,120613,75,120671,75,120729,75,11412,75,5094,75,5845,75,42199,75,66840,75,1472,108,8739,73,9213,73,65512,73,1633,108,1777,73,66336,108,125127,108,120783,73,120793,73,120803,73,120813,73,120823,73,130033,73,65321,73,8544,73,8464,73,8465,73,119816,73,119868,73,119920,73,120024,73,120128,73,120180,73,120232,73,120284,73,120336,73,120388,73,120440,73,65356,108,8572,73,8467,108,119845,108,119897,108,119949,108,120001,108,120053,108,120105,73,120157,73,120209,73,120261,73,120313,73,120365,73,120417,73,120469,73,448,73,120496,73,120554,73,120612,73,120670,73,120728,73,11410,73,1030,73,1216,73,1493,108,1503,108,1575,108,126464,108,126592,108,65166,108,65165,108,1994,108,11599,73,5825,73,42226,73,93992,73,66186,124,66313,124,119338,76,8556,76,8466,76,119819,76,119871,76,119923,76,120027,76,120079,76,120131,76,120183,76,120235,76,120287,76,120339,76,120391,76,120443,76,11472,76,5086,76,5290,76,42209,76,93974,76,71843,76,71858,76,66587,76,66854,76,65325,77,8559,77,8499,77,119820,77,119872,77,119924,77,120028,77,120080,77,120132,77,120184,77,120236,77,120288,77,120340,77,120392,77,120444,77,924,77,120499,77,120557,77,120615,77,120673,77,120731,77,1018,77,11416,77,5047,77,5616,77,5846,77,42207,77,66224,77,66321,77,119847,110,119899,110,119951,110,120003,110,120055,110,120107,110,120159,110,120211,110,120263,110,120315,110,120367,110,120419,110,120471,110,1400,110,1404,110,65326,78,8469,78,119821,78,119873,78,119925,78,119977,78,120029,78,120081,78,120185,78,120237,78,120289,78,120341,78,120393,78,120445,78,925,78,120500,78,120558,78,120616,78,120674,78,120732,78,11418,78,42208,78,66835,78,3074,111,3202,111,3330,111,3458,111,2406,111,2662,111,2790,111,3046,111,3174,111,3302,111,3430,111,3664,111,3792,111,4160,111,1637,111,1781,111,65359,111,8500,111,119848,111,119900,111,119952,111,120056,111,120108,111,120160,111,120212,111,120264,111,120316,111,120368,111,120420,111,120472,111,7439,111,7441,111,43837,111,959,111,120528,111,120586,111,120644,111,120702,111,120760,111,963,111,120532,111,120590,111,120648,111,120706,111,120764,111,11423,111,4351,111,1413,111,1505,111,1607,111,126500,111,126564,111,126596,111,65259,111,65260,111,65258,111,65257,111,1726,111,64428,111,64429,111,64427,111,64426,111,1729,111,64424,111,64425,111,64423,111,64422,111,1749,111,3360,111,4125,111,66794,111,71880,111,71895,111,66604,111,1984,79,2534,79,2918,79,12295,79,70864,79,71904,79,120782,79,120792,79,120802,79,120812,79,120822,79,130032,79,65327,79,119822,79,119874,79,119926,79,119978,79,120030,79,120082,79,120134,79,120186,79,120238,79,120290,79,120342,79,120394,79,120446,79,927,79,120502,79,120560,79,120618,79,120676,79,120734,79,11422,79,1365,79,11604,79,4816,79,2848,79,66754,79,42227,79,71861,79,66194,79,66219,79,66564,79,66838,79,9076,112,65360,112,119849,112,119901,112,119953,112,120005,112,120057,112,120109,112,120161,112,120213,112,120265,112,120317,112,120369,112,120421,112,120473,112,961,112,120530,112,120544,112,120588,112,120602,112,120646,112,120660,112,120704,112,120718,112,120762,112,120776,112,11427,112,65328,80,8473,80,119823,80,119875,80,119927,80,119979,80,120031,80,120083,80,120187,80,120239,80,120291,80,120343,80,120395,80,120447,80,929,80,120504,80,120562,80,120620,80,120678,80,120736,80,11426,80,5090,80,5229,80,42193,80,66197,80,119850,113,119902,113,119954,113,120006,113,120058,113,120110,113,120162,113,120214,113,120266,113,120318,113,120370,113,120422,113,120474,113,1307,113,1379,113,1382,113,8474,81,119824,81,119876,81,119928,81,119980,81,120032,81,120084,81,120188,81,120240,81,120292,81,120344,81,120396,81,120448,81,11605,81,119851,114,119903,114,119955,114,120007,114,120059,114,120111,114,120163,114,120215,114,120267,114,120319,114,120371,114,120423,114,120475,114,43847,114,43848,114,7462,114,11397,114,43905,114,119318,82,8475,82,8476,82,8477,82,119825,82,119877,82,119929,82,120033,82,120189,82,120241,82,120293,82,120345,82,120397,82,120449,82,422,82,5025,82,5074,82,66740,82,5511,82,42211,82,94005,82,65363,115,119852,115,119904,115,119956,115,120008,115,120060,115,120112,115,120164,115,120216,115,120268,115,120320,115,120372,115,120424,115,120476,115,42801,115,445,115,1109,115,43946,115,71873,115,66632,115,65331,83,119826,83,119878,83,119930,83,119982,83,120034,83,120086,83,120138,83,120190,83,120242,83,120294,83,120346,83,120398,83,120450,83,1029,83,1359,83,5077,83,5082,83,42210,83,94010,83,66198,83,66592,83,119853,116,119905,116,119957,116,120009,116,120061,116,120113,116,120165,116,120217,116,120269,116,120321,116,120373,116,120425,116,120477,116,8868,84,10201,84,128872,84,65332,84,119827,84,119879,84,119931,84,119983,84,120035,84,120087,84,120139,84,120191,84,120243,84,120295,84,120347,84,120399,84,120451,84,932,84,120507,84,120565,84,120623,84,120681,84,120739,84,11430,84,5026,84,42196,84,93962,84,71868,84,66199,84,66225,84,66325,84,119854,117,119906,117,119958,117,120010,117,120062,117,120114,117,120166,117,120218,117,120270,117,120322,117,120374,117,120426,117,120478,117,42911,117,7452,117,43854,117,43858,117,651,117,965,117,120534,117,120592,117,120650,117,120708,117,120766,117,1405,117,66806,117,71896,117,8746,85,8899,85,119828,85,119880,85,119932,85,119984,85,120036,85,120088,85,120140,85,120192,85,120244,85,120296,85,120348,85,120400,85,120452,85,1357,85,4608,85,66766,85,5196,85,42228,85,94018,85,71864,85,8744,118,8897,118,65366,118,8564,118,119855,118,119907,118,119959,118,120011,118,120063,118,120115,118,120167,118,120219,118,120271,118,120323,118,120375,118,120427,118,120479,118,7456,118,957,118,120526,118,120584,118,120642,118,120700,118,120758,118,1141,118,1496,118,71430,118,43945,118,71872,118,119309,86,1639,86,1783,86,8548,86,119829,86,119881,86,119933,86,119985,86,120037,86,120089,86,120141,86,120193,86,120245,86,120297,86,120349,86,120401,86,120453,86,1140,86,11576,86,5081,86,5167,86,42719,86,42214,86,93960,86,71840,86,66845,86,623,119,119856,119,119908,119,119960,119,120012,119,120064,119,120116,119,120168,119,120220,119,120272,119,120324,119,120376,119,120428,119,120480,119,7457,119,1121,119,1309,119,1377,119,71434,119,71438,119,71439,119,43907,119,71919,87,71910,87,119830,87,119882,87,119934,87,119986,87,120038,87,120090,87,120142,87,120194,87,120246,87,120298,87,120350,87,120402,87,120454,87,1308,87,5043,87,5076,87,42218,87,5742,120,10539,120,10540,120,10799,120,65368,120,8569,120,119857,120,119909,120,119961,120,120013,120,120065,120,120117,120,120169,120,120221,120,120273,120,120325,120,120377,120,120429,120,120481,120,5441,120,5501,120,5741,88,9587,88,66338,88,71916,88,65336,88,8553,88,119831,88,119883,88,119935,88,119987,88,120039,88,120091,88,120143,88,120195,88,120247,88,120299,88,120351,88,120403,88,120455,88,42931,88,935,88,120510,88,120568,88,120626,88,120684,88,120742,88,11436,88,11613,88,5815,88,42219,88,66192,88,66228,88,66327,88,66855,88,611,121,7564,121,65369,121,119858,121,119910,121,119962,121,120014,121,120066,121,120118,121,120170,121,120222,121,120274,121,120326,121,120378,121,120430,121,120482,121,655,121,7935,121,43866,121,947,121,8509,121,120516,121,120574,121,120632,121,120690,121,120748,121,1199,121,4327,121,71900,121,65337,89,119832,89,119884,89,119936,89,119988,89,120040,89,120092,89,120144,89,120196,89,120248,89,120300,89,120352,89,120404,89,120456,89,933,89,978,89,120508,89,120566,89,120624,89,120682,89,120740,89,11432,89,1198,89,5033,89,5053,89,42220,89,94019,89,71844,89,66226,89,119859,122,119911,122,119963,122,120015,122,120067,122,120119,122,120171,122,120223,122,120275,122,120327,122,120379,122,120431,122,120483,122,7458,122,43923,122,71876,122,66293,90,71909,90,65338,90,8484,90,8488,90,119833,90,119885,90,119937,90,119989,90,120041,90,120197,90,120249,90,120301,90,120353,90,120405,90,120457,90,918,90,120493,90,120551,90,120609,90,120667,90,120725,90,5059,90,42204,90,71849,90,65282,34,65284,36,65285,37,65286,38,65290,42,65291,43,65294,46,65295,47,65296,48,65297,49,65298,50,65299,51,65300,52,65301,53,65302,54,65303,55,65304,56,65305,57,65308,60,65309,61,65310,62,65312,64,65316,68,65318,70,65319,71,65324,76,65329,81,65330,82,65333,85,65334,86,65335,87,65343,95,65346,98,65348,100,65350,102,65355,107,65357,109,65358,110,65361,113,65362,114,65364,116,65365,117,65367,119,65370,122,65371,123,65373,125,119846,109],"_default":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"cs":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"de":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"es":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"fr":[65374,126,65306,58,65281,33,8216,96,8245,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"it":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"ja":[8211,45,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65292,44,65307,59],"ko":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"pl":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"pt-BR":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"qps-ploc":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"ru":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,305,105,921,73,1009,112,215,120,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"tr":[160,32,8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"zh-hans":[65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41],"zh-hant":[8211,45,65374,126,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65307,59]}'));
      _Wc.cache = new Lq({
        getCacheKey: JSON.stringify
      }, (e) => {
        function t(d) {
          const f = /* @__PURE__ */ new Map();
          for (let m = 0; m < d.length; m += 2) f.set(d[m], d[m + 1]);
          return f;
        }
        function i(d, f) {
          const m = new Map(d);
          for (const [_, b] of f) m.set(_, b);
          return m;
        }
        function n(d, f) {
          if (!d) return f;
          const m = /* @__PURE__ */ new Map();
          for (const [_, b] of d) f.has(_) && m.set(_, b);
          return m;
        }
        const o = _Wc.ambiguousCharacterData.value;
        let r = e.filter((d) => !d.startsWith("_") && d in o);
        r.length === 0 && (r = [
          "_default"
        ]);
        let a;
        for (const d of r) {
          const f = t(o[d]);
          a = n(a, f);
        }
        const l = t(o._common), u = i(l, a);
        return new _Wc(u);
      });
      _Wc._locales = new iu(() => Object.keys(_Wc.ambiguousCharacterData.value).filter((e) => !e.startsWith("_")));
      let Wc = _Wc;
      const _vh = class _vh {
        static getRawData() {
          return JSON.parse("[9,10,11,12,13,32,127,160,173,847,1564,4447,4448,6068,6069,6155,6156,6157,6158,7355,7356,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8203,8204,8205,8206,8207,8234,8235,8236,8237,8238,8239,8287,8288,8289,8290,8291,8292,8293,8294,8295,8296,8297,8298,8299,8300,8301,8302,8303,10240,12288,12644,65024,65025,65026,65027,65028,65029,65030,65031,65032,65033,65034,65035,65036,65037,65038,65039,65279,65440,65520,65521,65522,65523,65524,65525,65526,65527,65528,65532,78844,119155,119156,119157,119158,119159,119160,119161,119162,917504,917505,917506,917507,917508,917509,917510,917511,917512,917513,917514,917515,917516,917517,917518,917519,917520,917521,917522,917523,917524,917525,917526,917527,917528,917529,917530,917531,917532,917533,917534,917535,917536,917537,917538,917539,917540,917541,917542,917543,917544,917545,917546,917547,917548,917549,917550,917551,917552,917553,917554,917555,917556,917557,917558,917559,917560,917561,917562,917563,917564,917565,917566,917567,917568,917569,917570,917571,917572,917573,917574,917575,917576,917577,917578,917579,917580,917581,917582,917583,917584,917585,917586,917587,917588,917589,917590,917591,917592,917593,917594,917595,917596,917597,917598,917599,917600,917601,917602,917603,917604,917605,917606,917607,917608,917609,917610,917611,917612,917613,917614,917615,917616,917617,917618,917619,917620,917621,917622,917623,917624,917625,917626,917627,917628,917629,917630,917631,917760,917761,917762,917763,917764,917765,917766,917767,917768,917769,917770,917771,917772,917773,917774,917775,917776,917777,917778,917779,917780,917781,917782,917783,917784,917785,917786,917787,917788,917789,917790,917791,917792,917793,917794,917795,917796,917797,917798,917799,917800,917801,917802,917803,917804,917805,917806,917807,917808,917809,917810,917811,917812,917813,917814,917815,917816,917817,917818,917819,917820,917821,917822,917823,917824,917825,917826,917827,917828,917829,917830,917831,917832,917833,917834,917835,917836,917837,917838,917839,917840,917841,917842,917843,917844,917845,917846,917847,917848,917849,917850,917851,917852,917853,917854,917855,917856,917857,917858,917859,917860,917861,917862,917863,917864,917865,917866,917867,917868,917869,917870,917871,917872,917873,917874,917875,917876,917877,917878,917879,917880,917881,917882,917883,917884,917885,917886,917887,917888,917889,917890,917891,917892,917893,917894,917895,917896,917897,917898,917899,917900,917901,917902,917903,917904,917905,917906,917907,917908,917909,917910,917911,917912,917913,917914,917915,917916,917917,917918,917919,917920,917921,917922,917923,917924,917925,917926,917927,917928,917929,917930,917931,917932,917933,917934,917935,917936,917937,917938,917939,917940,917941,917942,917943,917944,917945,917946,917947,917948,917949,917950,917951,917952,917953,917954,917955,917956,917957,917958,917959,917960,917961,917962,917963,917964,917965,917966,917967,917968,917969,917970,917971,917972,917973,917974,917975,917976,917977,917978,917979,917980,917981,917982,917983,917984,917985,917986,917987,917988,917989,917990,917991,917992,917993,917994,917995,917996,917997,917998,917999]");
        }
        static getData() {
          return this._data || (this._data = new Set(_vh.getRawData())), this._data;
        }
        static isInvisibleCharacter(e) {
          return _vh.getData().has(e);
        }
        static get codePoints() {
          return _vh.getData();
        }
      };
      _vh._data = void 0;
      let vh = _vh;
      const _JE = class _JE {
        constructor() {
          this.mapWindowIdToZoomFactor = /* @__PURE__ */ new Map();
        }
        getZoomFactor(e) {
          return this.mapWindowIdToZoomFactor.get(this.getWindowId(e)) ?? 1;
        }
        getWindowId(e) {
          return e.vscodeWindowId;
        }
      };
      _JE.INSTANCE = new _JE();
      let JE = _JE;
      function T9(s, e, t) {
        typeof e == "string" && (e = s.matchMedia(e)), e.addEventListener("change", t);
      }
      function Wq(s) {
        return JE.INSTANCE.getZoomFactor(s);
      }
      const kg = navigator.userAgent, pr = kg.indexOf("Firefox") >= 0, HC = kg.indexOf("AppleWebKit") >= 0, V_ = kg.indexOf("Chrome") >= 0, su = !V_ && kg.indexOf("Safari") >= 0, N9 = !V_ && !su && HC;
      kg.indexOf("Electron/") >= 0;
      const G4 = kg.indexOf("Android") >= 0;
      let gL = false;
      if (typeof Kt.matchMedia == "function") {
        const s = Kt.matchMedia("(display-mode: standalone) or (display-mode: window-controls-overlay)"), e = Kt.matchMedia("(display-mode: fullscreen)");
        gL = s.matches, T9(Kt, s, ({ matches: t }) => {
          gL && e.matches || (gL = t);
        });
      }
      const I9 = {
        clipboard: {
          writeText: j0 || document.queryCommandSupported && document.queryCommandSupported("copy") || !!(navigator && navigator.clipboard && navigator.clipboard.writeText),
          readText: j0 || !!(navigator && navigator.clipboard && navigator.clipboard.readText)
        },
        pointerEvents: Kt.PointerEvent && ("ontouchstart" in Kt || navigator.maxTouchPoints > 0)
      };
      function Bk(s, e) {
        if (typeof s == "number") {
          if (s === 0) return null;
          const t = (s & 65535) >>> 0, i = (s & 4294901760) >>> 16;
          return i !== 0 ? new mL([
            Lb(t, e),
            Lb(i, e)
          ]) : new mL([
            Lb(t, e)
          ]);
        } else {
          const t = [];
          for (let i = 0; i < s.length; i++) t.push(Lb(s[i], e));
          return new mL(t);
        }
      }
      function Lb(s, e) {
        const t = !!(s & 2048), i = !!(s & 256), n = e === 2 ? i : t, o = !!(s & 1024), r = !!(s & 512), a = e === 2 ? t : i, l = s & 255;
        return new Mh(n, o, r, a, l);
      }
      class Mh {
        constructor(e, t, i, n, o) {
          this.ctrlKey = e, this.shiftKey = t, this.altKey = i, this.metaKey = n, this.keyCode = o;
        }
        equals(e) {
          return e instanceof Mh && this.ctrlKey === e.ctrlKey && this.shiftKey === e.shiftKey && this.altKey === e.altKey && this.metaKey === e.metaKey && this.keyCode === e.keyCode;
        }
        isModifierKey() {
          return this.keyCode === 0 || this.keyCode === 5 || this.keyCode === 57 || this.keyCode === 6 || this.keyCode === 4;
        }
        isDuplicateModifierCase() {
          return this.ctrlKey && this.keyCode === 5 || this.shiftKey && this.keyCode === 4 || this.altKey && this.keyCode === 6 || this.metaKey && this.keyCode === 57;
        }
      }
      class mL {
        constructor(e) {
          if (e.length === 0) throw FC("chords");
          this.chords = e;
        }
      }
      class Hq {
        constructor(e, t, i, n, o, r) {
          this.ctrlKey = e, this.shiftKey = t, this.altKey = i, this.metaKey = n, this.keyLabel = o, this.keyAriaLabel = r;
        }
      }
      class zq {
      }
      function Uq(s) {
        if (s.charCode) {
          const t = String.fromCharCode(s.charCode).toUpperCase();
          return Ll.fromString(t);
        }
        const e = s.keyCode;
        if (e === 3) return 7;
        if (pr) switch (e) {
          case 59:
            return 85;
          case 60:
            if (Is) return 97;
            break;
          case 61:
            return 86;
          case 107:
            return 109;
          case 109:
            return 111;
          case 173:
            return 88;
          case 224:
            if (_t) return 57;
            break;
        }
        else if (HC) {
          if (_t && e === 93) return 57;
          if (!_t && e === 92) return 57;
        }
        return d9[e] || 0;
      }
      const $q = _t ? 256 : 2048, qq = 512, Kq = 1024, jq = _t ? 2048 : 256;
      class si {
        constructor(e) {
          var _a3;
          this._standardKeyboardEventBrand = true;
          const t = e;
          this.browserEvent = t, this.target = t.target, this.ctrlKey = t.ctrlKey, this.shiftKey = t.shiftKey, this.altKey = t.altKey, this.metaKey = t.metaKey, this.altGraphKey = (_a3 = t.getModifierState) == null ? void 0 : _a3.call(t, "AltGraph"), this.keyCode = Uq(t), this.code = t.code, this.ctrlKey = this.ctrlKey || this.keyCode === 5, this.altKey = this.altKey || this.keyCode === 6, this.shiftKey = this.shiftKey || this.keyCode === 4, this.metaKey = this.metaKey || this.keyCode === 57, this._asKeybinding = this._computeKeybinding(), this._asKeyCodeChord = this._computeKeyCodeChord();
        }
        preventDefault() {
          this.browserEvent && this.browserEvent.preventDefault && this.browserEvent.preventDefault();
        }
        stopPropagation() {
          this.browserEvent && this.browserEvent.stopPropagation && this.browserEvent.stopPropagation();
        }
        toKeyCodeChord() {
          return this._asKeyCodeChord;
        }
        equals(e) {
          return this._asKeybinding === e;
        }
        _computeKeybinding() {
          let e = 0;
          this.keyCode !== 5 && this.keyCode !== 4 && this.keyCode !== 6 && this.keyCode !== 57 && (e = this.keyCode);
          let t = 0;
          return this.ctrlKey && (t |= $q), this.altKey && (t |= qq), this.shiftKey && (t |= Kq), this.metaKey && (t |= jq), t |= e, t;
        }
        _computeKeyCodeChord() {
          let e = 0;
          return this.keyCode !== 5 && this.keyCode !== 4 && this.keyCode !== 6 && this.keyCode !== 57 && (e = this.keyCode), new Mh(this.ctrlKey, this.shiftKey, this.altKey, this.metaKey, e);
        }
      }
      const Y4 = /* @__PURE__ */ new WeakMap();
      function Gq(s) {
        if (!s.parent || s.parent === s) return null;
        try {
          const e = s.location, t = s.parent.location;
          if (e.origin !== "null" && t.origin !== "null" && e.origin !== t.origin) return null;
        } catch {
          return null;
        }
        return s.parent;
      }
      class Yq {
        static getSameOriginWindowChain(e) {
          let t = Y4.get(e);
          if (!t) {
            t = [], Y4.set(e, t);
            let i = e, n;
            do
              n = Gq(i), n ? t.push({
                window: new WeakRef(i),
                iframeElement: i.frameElement || null
              }) : t.push({
                window: new WeakRef(i),
                iframeElement: null
              }), i = n;
            while (i);
          }
          return t.slice(0);
        }
        static getPositionOfChildWindowRelativeToAncestorWindow(e, t) {
          if (!t || e === t) return {
            top: 0,
            left: 0
          };
          let i = 0, n = 0;
          const o = this.getSameOriginWindowChain(e);
          for (const r of o) {
            const a = r.window.deref();
            if (i += (a == null ? void 0 : a.scrollY) ?? 0, n += (a == null ? void 0 : a.scrollX) ?? 0, a === t || !r.iframeElement) break;
            const l = r.iframeElement.getBoundingClientRect();
            i += l.top, n += l.left;
          }
          return {
            top: i,
            left: n
          };
        }
      }
      class Vr {
        constructor(e, t) {
          this.timestamp = Date.now(), this.browserEvent = t, this.leftButton = t.button === 0, this.middleButton = t.button === 1, this.rightButton = t.button === 2, this.buttons = t.buttons, this.target = t.target, this.detail = t.detail || 1, t.type === "dblclick" && (this.detail = 2), this.ctrlKey = t.ctrlKey, this.shiftKey = t.shiftKey, this.altKey = t.altKey, this.metaKey = t.metaKey, typeof t.pageX == "number" ? (this.posx = t.pageX, this.posy = t.pageY) : (this.posx = t.clientX + this.target.ownerDocument.body.scrollLeft + this.target.ownerDocument.documentElement.scrollLeft, this.posy = t.clientY + this.target.ownerDocument.body.scrollTop + this.target.ownerDocument.documentElement.scrollTop);
          const i = Yq.getPositionOfChildWindowRelativeToAncestorWindow(e, t.view);
          this.posx -= i.left, this.posy -= i.top;
        }
        preventDefault() {
          this.browserEvent.preventDefault();
        }
        stopPropagation() {
          this.browserEvent.stopPropagation();
        }
      }
      class Ah {
        constructor(e, t = 0, i = 0) {
          var _a3;
          this.browserEvent = e || null, this.target = e ? e.target || e.targetNode || e.srcElement : null, this.deltaY = i, this.deltaX = t;
          let n = false;
          if (V_) {
            const o = navigator.userAgent.match(/Chrome\/(\d+)/);
            n = (o ? parseInt(o[1]) : 123) <= 122;
          }
          if (e) {
            const o = e, r = e, a = ((_a3 = e.view) == null ? void 0 : _a3.devicePixelRatio) || 1;
            if (typeof o.wheelDeltaY < "u") n ? this.deltaY = o.wheelDeltaY / (120 * a) : this.deltaY = o.wheelDeltaY / 120;
            else if (typeof r.VERTICAL_AXIS < "u" && r.axis === r.VERTICAL_AXIS) this.deltaY = -r.detail / 3;
            else if (e.type === "wheel") {
              const l = e;
              l.deltaMode === l.DOM_DELTA_LINE ? pr && !_t ? this.deltaY = -e.deltaY / 3 : this.deltaY = -e.deltaY : this.deltaY = -e.deltaY / 40;
            }
            if (typeof o.wheelDeltaX < "u") su && Ks ? this.deltaX = -(o.wheelDeltaX / 120) : n ? this.deltaX = o.wheelDeltaX / (120 * a) : this.deltaX = o.wheelDeltaX / 120;
            else if (typeof r.HORIZONTAL_AXIS < "u" && r.axis === r.HORIZONTAL_AXIS) this.deltaX = -e.detail / 3;
            else if (e.type === "wheel") {
              const l = e;
              l.deltaMode === l.DOM_DELTA_LINE ? pr && !_t ? this.deltaX = -e.deltaX / 3 : this.deltaX = -e.deltaX : this.deltaX = -e.deltaX / 40;
            }
            this.deltaY === 0 && this.deltaX === 0 && e.wheelDelta && (n ? this.deltaY = e.wheelDelta / (120 * a) : this.deltaY = e.wheelDelta / 120);
          }
        }
        preventDefault() {
          var _a3;
          (_a3 = this.browserEvent) == null ? void 0 : _a3.preventDefault();
        }
        stopPropagation() {
          var _a3;
          (_a3 = this.browserEvent) == null ? void 0 : _a3.stopPropagation();
        }
      }
      const M9 = Symbol("MicrotaskDelay");
      function Fk(s) {
        return !!s && typeof s.then == "function";
      }
      function A9(s) {
        const e = new Lg(), t = s(e.token), i = new Promise((n, o) => {
          const r = e.token.onCancellationRequested(() => {
            r.dispose(), o(new P_());
          });
          Promise.resolve(t).then((a) => {
            r.dispose(), e.dispose(), n(a);
          }, (a) => {
            r.dispose(), e.dispose(), o(a);
          });
        });
        return new class {
          cancel() {
            e.cancel(), e.dispose();
          }
          then(n, o) {
            return i.then(n, o);
          }
          catch(n) {
            return this.then(void 0, n);
          }
          finally(n) {
            return i.finally(n);
          }
        }();
      }
      class Zq {
        constructor() {
          this.isDisposed = false, this.activePromise = null, this.queuedPromise = null, this.queuedPromiseFactory = null;
        }
        queue(e) {
          if (this.isDisposed) return Promise.reject(new Error("Throttler is disposed"));
          if (this.activePromise) {
            if (this.queuedPromiseFactory = e, !this.queuedPromise) {
              const t = () => {
                if (this.queuedPromise = null, this.isDisposed) return;
                const i = this.queue(this.queuedPromiseFactory);
                return this.queuedPromiseFactory = null, i;
              };
              this.queuedPromise = new Promise((i) => {
                this.activePromise.then(t, t).then(i);
              });
            }
            return new Promise((t, i) => {
              this.queuedPromise.then(t, i);
            });
          }
          return this.activePromise = e(), new Promise((t, i) => {
            this.activePromise.then((n) => {
              this.activePromise = null, t(n);
            }, (n) => {
              this.activePromise = null, i(n);
            });
          });
        }
        dispose() {
          this.isDisposed = true;
        }
      }
      const Qq = (s, e) => {
        let t = true;
        const i = setTimeout(() => {
          t = false, e();
        }, s);
        return {
          isTriggered: () => t,
          dispose: () => {
            clearTimeout(i), t = false;
          }
        };
      }, Xq = (s) => {
        let e = true;
        return queueMicrotask(() => {
          e && (e = false, s());
        }), {
          isTriggered: () => e,
          dispose: () => {
            e = false;
          }
        };
      };
      class W_ {
        constructor(e) {
          this.defaultDelay = e, this.deferred = null, this.completionPromise = null, this.doResolve = null, this.doReject = null, this.task = null;
        }
        trigger(e, t = this.defaultDelay) {
          this.task = e, this.cancelTimeout(), this.completionPromise || (this.completionPromise = new Promise((n, o) => {
            this.doResolve = n, this.doReject = o;
          }).then(() => {
            if (this.completionPromise = null, this.doResolve = null, this.task) {
              const n = this.task;
              return this.task = null, n();
            }
          }));
          const i = () => {
            var _a3;
            this.deferred = null, (_a3 = this.doResolve) == null ? void 0 : _a3.call(this, null);
          };
          return this.deferred = t === M9 ? Xq(i) : Qq(t, i), this.completionPromise;
        }
        isTriggered() {
          var _a3;
          return !!((_a3 = this.deferred) == null ? void 0 : _a3.isTriggered());
        }
        cancel() {
          var _a3;
          this.cancelTimeout(), this.completionPromise && ((_a3 = this.doReject) == null ? void 0 : _a3.call(this, new P_()), this.completionPromise = null);
        }
        cancelTimeout() {
          var _a3;
          (_a3 = this.deferred) == null ? void 0 : _a3.dispose(), this.deferred = null;
        }
        dispose() {
          this.cancel();
        }
      }
      class R9 {
        constructor(e) {
          this.delayer = new W_(e), this.throttler = new Zq();
        }
        trigger(e, t) {
          return this.delayer.trigger(() => this.throttler.queue(e), t);
        }
        cancel() {
          this.delayer.cancel();
        }
        dispose() {
          this.delayer.dispose(), this.throttler.dispose();
        }
      }
      function Zp(s, e) {
        return e ? new Promise((t, i) => {
          const n = setTimeout(() => {
            o.dispose(), t();
          }, s), o = e.onCancellationRequested(() => {
            clearTimeout(n), o.dispose(), i(new P_());
          });
        }) : A9((t) => Zp(s, t));
      }
      function Vk(s, e = 0, t) {
        const i = setTimeout(() => {
          s(), t && n.dispose();
        }, e), n = Ze(() => {
          clearTimeout(i), t == null ? void 0 : t.deleteAndLeak(n);
        });
        return t == null ? void 0 : t.add(n), n;
      }
      class Kh {
        constructor(e, t) {
          this._isDisposed = false, this._token = -1, typeof e == "function" && typeof t == "number" && this.setIfNotSet(e, t);
        }
        dispose() {
          this.cancel(), this._isDisposed = true;
        }
        cancel() {
          this._token !== -1 && (clearTimeout(this._token), this._token = -1);
        }
        cancelAndSet(e, t) {
          if (this._isDisposed) throw new It("Calling 'cancelAndSet' on a disposed TimeoutTimer");
          this.cancel(), this._token = setTimeout(() => {
            this._token = -1, e();
          }, t);
        }
        setIfNotSet(e, t) {
          if (this._isDisposed) throw new It("Calling 'setIfNotSet' on a disposed TimeoutTimer");
          this._token === -1 && (this._token = setTimeout(() => {
            this._token = -1, e();
          }, t));
        }
      }
      class eT {
        constructor() {
          this.disposable = void 0, this.isDisposed = false;
        }
        cancel() {
          var _a3;
          (_a3 = this.disposable) == null ? void 0 : _a3.dispose(), this.disposable = void 0;
        }
        cancelAndSet(e, t, i = globalThis) {
          if (this.isDisposed) throw new It("Calling 'cancelAndSet' on a disposed IntervalTimer");
          this.cancel();
          const n = i.setInterval(() => {
            e();
          }, t);
          this.disposable = Ze(() => {
            i.clearInterval(n), this.disposable = void 0;
          });
        }
        dispose() {
          this.cancel(), this.isDisposed = true;
        }
      }
      class ns {
        constructor(e, t) {
          this.timeoutToken = -1, this.runner = e, this.timeout = t, this.timeoutHandler = this.onTimeout.bind(this);
        }
        dispose() {
          this.cancel(), this.runner = null;
        }
        cancel() {
          this.isScheduled() && (clearTimeout(this.timeoutToken), this.timeoutToken = -1);
        }
        schedule(e = this.timeout) {
          this.cancel(), this.timeoutToken = setTimeout(this.timeoutHandler, e);
        }
        get delay() {
          return this.timeout;
        }
        set delay(e) {
          this.timeout = e;
        }
        isScheduled() {
          return this.timeoutToken !== -1;
        }
        onTimeout() {
          this.timeoutToken = -1, this.runner && this.doRun();
        }
        doRun() {
          var _a3;
          (_a3 = this.runner) == null ? void 0 : _a3.call(this);
        }
      }
      let O9, pp;
      (function() {
        typeof globalThis.requestIdleCallback != "function" || typeof globalThis.cancelIdleCallback != "function" ? pp = (s, e) => {
          t9(() => {
            if (t) return;
            const i = Date.now() + 15;
            e(Object.freeze({
              didTimeout: true,
              timeRemaining() {
                return Math.max(0, i - Date.now());
              }
            }));
          });
          let t = false;
          return {
            dispose() {
              t || (t = true);
            }
          };
        } : pp = (s, e, t) => {
          const i = s.requestIdleCallback(e, typeof t == "number" ? {
            timeout: t
          } : void 0);
          let n = false;
          return {
            dispose() {
              n || (n = true, s.cancelIdleCallback(i));
            }
          };
        }, O9 = (s) => pp(globalThis, s);
      })();
      class Jq {
        constructor(e, t) {
          this._didRun = false, this._executor = () => {
            try {
              this._value = t();
            } catch (i) {
              this._error = i;
            } finally {
              this._didRun = true;
            }
          }, this._handle = pp(e, () => this._executor());
        }
        dispose() {
          this._handle.dispose();
        }
        get value() {
          if (this._didRun || (this._handle.dispose(), this._executor()), this._error) throw this._error;
          return this._value;
        }
        get isInitialized() {
          return this._didRun;
        }
      }
      class eK extends Jq {
        constructor(e) {
          super(globalThis, e);
        }
      }
      class P9 {
        get isRejected() {
          var _a3;
          return ((_a3 = this.outcome) == null ? void 0 : _a3.outcome) === 1;
        }
        get isSettled() {
          return !!this.outcome;
        }
        constructor() {
          this.p = new Promise((e, t) => {
            this.completeCallback = e, this.errorCallback = t;
          });
        }
        complete(e) {
          return new Promise((t) => {
            this.completeCallback(e), this.outcome = {
              outcome: 0,
              value: e
            }, t();
          });
        }
        error(e) {
          return new Promise((t) => {
            this.errorCallback(e), this.outcome = {
              outcome: 1,
              value: e
            }, t();
          });
        }
        cancel() {
          return this.error(new P_());
        }
      }
      var Wk;
      (function(s) {
        async function e(i) {
          let n;
          const o = await Promise.all(i.map((r) => r.then((a) => a, (a) => {
            n || (n = a);
          })));
          if (typeof n < "u") throw n;
          return o;
        }
        s.settled = e;
        function t(i) {
          return new Promise(async (n, o) => {
            try {
              await i(n, o);
            } catch (r) {
              o(r);
            }
          });
        }
        s.withAsyncBody = t;
      })(Wk || (Wk = {}));
      const _Do = class _Do {
        static fromArray(e) {
          return new _Do((t) => {
            t.emitMany(e);
          });
        }
        static fromPromise(e) {
          return new _Do(async (t) => {
            t.emitMany(await e);
          });
        }
        static fromPromises(e) {
          return new _Do(async (t) => {
            await Promise.all(e.map(async (i) => t.emitOne(await i)));
          });
        }
        static merge(e) {
          return new _Do(async (t) => {
            await Promise.all(e.map(async (i) => {
              for await (const n of i) t.emitOne(n);
            }));
          });
        }
        constructor(e, t) {
          this._state = 0, this._results = [], this._error = null, this._onReturn = t, this._onStateChanged = new G(), queueMicrotask(async () => {
            const i = {
              emitOne: (n) => this.emitOne(n),
              emitMany: (n) => this.emitMany(n),
              reject: (n) => this.reject(n)
            };
            try {
              await Promise.resolve(e(i)), this.resolve();
            } catch (n) {
              this.reject(n);
            } finally {
              i.emitOne = void 0, i.emitMany = void 0, i.reject = void 0;
            }
          });
        }
        [Symbol.asyncIterator]() {
          let e = 0;
          return {
            next: async () => {
              do {
                if (this._state === 2) throw this._error;
                if (e < this._results.length) return {
                  done: false,
                  value: this._results[e++]
                };
                if (this._state === 1) return {
                  done: true,
                  value: void 0
                };
                await be.toPromise(this._onStateChanged.event);
              } while (true);
            },
            return: async () => {
              var _a3;
              return (_a3 = this._onReturn) == null ? void 0 : _a3.call(this), {
                done: true,
                value: void 0
              };
            }
          };
        }
        static map(e, t) {
          return new _Do(async (i) => {
            for await (const n of e) i.emitOne(t(n));
          });
        }
        map(e) {
          return _Do.map(this, e);
        }
        static filter(e, t) {
          return new _Do(async (i) => {
            for await (const n of e) t(n) && i.emitOne(n);
          });
        }
        filter(e) {
          return _Do.filter(this, e);
        }
        static coalesce(e) {
          return _Do.filter(e, (t) => !!t);
        }
        coalesce() {
          return _Do.coalesce(this);
        }
        static async toPromise(e) {
          const t = [];
          for await (const i of e) t.push(i);
          return t;
        }
        toPromise() {
          return _Do.toPromise(this);
        }
        emitOne(e) {
          this._state === 0 && (this._results.push(e), this._onStateChanged.fire());
        }
        emitMany(e) {
          this._state === 0 && (this._results = this._results.concat(e), this._onStateChanged.fire());
        }
        resolve() {
          this._state === 0 && (this._state = 1, this._onStateChanged.fire());
        }
        reject(e) {
          this._state === 0 && (this._state = 2, this._error = e, this._onStateChanged.fire());
        }
      };
      _Do.EMPTY = _Do.fromArray([]);
      let Do = _Do;
      const { entries: B9, setPrototypeOf: Z4, isFrozen: tK, getPrototypeOf: iK, getOwnPropertyDescriptor: nK } = Object;
      let { freeze: js, seal: _r, create: F9 } = Object, { apply: Hk, construct: zk } = typeof Reflect < "u" && Reflect;
      js || (js = function(e) {
        return e;
      });
      _r || (_r = function(e) {
        return e;
      });
      Hk || (Hk = function(e, t, i) {
        return e.apply(t, i);
      });
      zk || (zk = function(e, t) {
        return new e(...t);
      });
      const xb = zo(Array.prototype.forEach), Q4 = zo(Array.prototype.pop), Nm = zo(Array.prototype.push), _0 = zo(String.prototype.toLowerCase), pL = zo(String.prototype.toString), X4 = zo(String.prototype.match), Im = zo(String.prototype.replace), sK = zo(String.prototype.indexOf), oK = zo(String.prototype.trim), Mr = zo(Object.prototype.hasOwnProperty), Fs = zo(RegExp.prototype.test), Mm = rK(TypeError);
      function zo(s) {
        return function(e) {
          for (var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++) i[n - 1] = arguments[n];
          return Hk(s, e, i);
        };
      }
      function rK(s) {
        return function() {
          for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];
          return zk(s, t);
        };
      }
      function zt(s, e) {
        let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : _0;
        Z4 && Z4(s, null);
        let i = e.length;
        for (; i--; ) {
          let n = e[i];
          if (typeof n == "string") {
            const o = t(n);
            o !== n && (tK(e) || (e[i] = o), n = o);
          }
          s[n] = true;
        }
        return s;
      }
      function aK(s) {
        for (let e = 0; e < s.length; e++) Mr(s, e) || (s[e] = null);
        return s;
      }
      function qu(s) {
        const e = F9(null);
        for (const [t, i] of B9(s)) Mr(s, t) && (Array.isArray(i) ? e[t] = aK(i) : i && typeof i == "object" && i.constructor === Object ? e[t] = qu(i) : e[t] = i);
        return e;
      }
      function Am(s, e) {
        for (; s !== null; ) {
          const i = nK(s, e);
          if (i) {
            if (i.get) return zo(i.get);
            if (typeof i.value == "function") return zo(i.value);
          }
          s = iK(s);
        }
        function t() {
          return null;
        }
        return t;
      }
      const J4 = js([
        "a",
        "abbr",
        "acronym",
        "address",
        "area",
        "article",
        "aside",
        "audio",
        "b",
        "bdi",
        "bdo",
        "big",
        "blink",
        "blockquote",
        "body",
        "br",
        "button",
        "canvas",
        "caption",
        "center",
        "cite",
        "code",
        "col",
        "colgroup",
        "content",
        "data",
        "datalist",
        "dd",
        "decorator",
        "del",
        "details",
        "dfn",
        "dialog",
        "dir",
        "div",
        "dl",
        "dt",
        "element",
        "em",
        "fieldset",
        "figcaption",
        "figure",
        "font",
        "footer",
        "form",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "head",
        "header",
        "hgroup",
        "hr",
        "html",
        "i",
        "img",
        "input",
        "ins",
        "kbd",
        "label",
        "legend",
        "li",
        "main",
        "map",
        "mark",
        "marquee",
        "menu",
        "menuitem",
        "meter",
        "nav",
        "nobr",
        "ol",
        "optgroup",
        "option",
        "output",
        "p",
        "picture",
        "pre",
        "progress",
        "q",
        "rp",
        "rt",
        "ruby",
        "s",
        "samp",
        "section",
        "select",
        "shadow",
        "small",
        "source",
        "spacer",
        "span",
        "strike",
        "strong",
        "style",
        "sub",
        "summary",
        "sup",
        "table",
        "tbody",
        "td",
        "template",
        "textarea",
        "tfoot",
        "th",
        "thead",
        "time",
        "tr",
        "track",
        "tt",
        "u",
        "ul",
        "var",
        "video",
        "wbr"
      ]), _L = js([
        "svg",
        "a",
        "altglyph",
        "altglyphdef",
        "altglyphitem",
        "animatecolor",
        "animatemotion",
        "animatetransform",
        "circle",
        "clippath",
        "defs",
        "desc",
        "ellipse",
        "filter",
        "font",
        "g",
        "glyph",
        "glyphref",
        "hkern",
        "image",
        "line",
        "lineargradient",
        "marker",
        "mask",
        "metadata",
        "mpath",
        "path",
        "pattern",
        "polygon",
        "polyline",
        "radialgradient",
        "rect",
        "stop",
        "style",
        "switch",
        "symbol",
        "text",
        "textpath",
        "title",
        "tref",
        "tspan",
        "view",
        "vkern"
      ]), bL = js([
        "feBlend",
        "feColorMatrix",
        "feComponentTransfer",
        "feComposite",
        "feConvolveMatrix",
        "feDiffuseLighting",
        "feDisplacementMap",
        "feDistantLight",
        "feDropShadow",
        "feFlood",
        "feFuncA",
        "feFuncB",
        "feFuncG",
        "feFuncR",
        "feGaussianBlur",
        "feImage",
        "feMerge",
        "feMergeNode",
        "feMorphology",
        "feOffset",
        "fePointLight",
        "feSpecularLighting",
        "feSpotLight",
        "feTile",
        "feTurbulence"
      ]), lK = js([
        "animate",
        "color-profile",
        "cursor",
        "discard",
        "font-face",
        "font-face-format",
        "font-face-name",
        "font-face-src",
        "font-face-uri",
        "foreignobject",
        "hatch",
        "hatchpath",
        "mesh",
        "meshgradient",
        "meshpatch",
        "meshrow",
        "missing-glyph",
        "script",
        "set",
        "solidcolor",
        "unknown",
        "use"
      ]), vL = js([
        "math",
        "menclose",
        "merror",
        "mfenced",
        "mfrac",
        "mglyph",
        "mi",
        "mlabeledtr",
        "mmultiscripts",
        "mn",
        "mo",
        "mover",
        "mpadded",
        "mphantom",
        "mroot",
        "mrow",
        "ms",
        "mspace",
        "msqrt",
        "mstyle",
        "msub",
        "msup",
        "msubsup",
        "mtable",
        "mtd",
        "mtext",
        "mtr",
        "munder",
        "munderover",
        "mprescripts"
      ]), cK = js([
        "maction",
        "maligngroup",
        "malignmark",
        "mlongdiv",
        "mscarries",
        "mscarry",
        "msgroup",
        "mstack",
        "msline",
        "msrow",
        "semantics",
        "annotation",
        "annotation-xml",
        "mprescripts",
        "none"
      ]), eO = js([
        "#text"
      ]), tO = js([
        "accept",
        "action",
        "align",
        "alt",
        "autocapitalize",
        "autocomplete",
        "autopictureinpicture",
        "autoplay",
        "background",
        "bgcolor",
        "border",
        "capture",
        "cellpadding",
        "cellspacing",
        "checked",
        "cite",
        "class",
        "clear",
        "color",
        "cols",
        "colspan",
        "controls",
        "controlslist",
        "coords",
        "crossorigin",
        "datetime",
        "decoding",
        "default",
        "dir",
        "disabled",
        "disablepictureinpicture",
        "disableremoteplayback",
        "download",
        "draggable",
        "enctype",
        "enterkeyhint",
        "face",
        "for",
        "headers",
        "height",
        "hidden",
        "high",
        "href",
        "hreflang",
        "id",
        "inputmode",
        "integrity",
        "ismap",
        "kind",
        "label",
        "lang",
        "list",
        "loading",
        "loop",
        "low",
        "max",
        "maxlength",
        "media",
        "method",
        "min",
        "minlength",
        "multiple",
        "muted",
        "name",
        "nonce",
        "noshade",
        "novalidate",
        "nowrap",
        "open",
        "optimum",
        "pattern",
        "placeholder",
        "playsinline",
        "popover",
        "popovertarget",
        "popovertargetaction",
        "poster",
        "preload",
        "pubdate",
        "radiogroup",
        "readonly",
        "rel",
        "required",
        "rev",
        "reversed",
        "role",
        "rows",
        "rowspan",
        "spellcheck",
        "scope",
        "selected",
        "shape",
        "size",
        "sizes",
        "span",
        "srclang",
        "start",
        "src",
        "srcset",
        "step",
        "style",
        "summary",
        "tabindex",
        "title",
        "translate",
        "type",
        "usemap",
        "valign",
        "value",
        "width",
        "wrap",
        "xmlns",
        "slot"
      ]), CL = js([
        "accent-height",
        "accumulate",
        "additive",
        "alignment-baseline",
        "amplitude",
        "ascent",
        "attributename",
        "attributetype",
        "azimuth",
        "basefrequency",
        "baseline-shift",
        "begin",
        "bias",
        "by",
        "class",
        "clip",
        "clippathunits",
        "clip-path",
        "clip-rule",
        "color",
        "color-interpolation",
        "color-interpolation-filters",
        "color-profile",
        "color-rendering",
        "cx",
        "cy",
        "d",
        "dx",
        "dy",
        "diffuseconstant",
        "direction",
        "display",
        "divisor",
        "dur",
        "edgemode",
        "elevation",
        "end",
        "exponent",
        "fill",
        "fill-opacity",
        "fill-rule",
        "filter",
        "filterunits",
        "flood-color",
        "flood-opacity",
        "font-family",
        "font-size",
        "font-size-adjust",
        "font-stretch",
        "font-style",
        "font-variant",
        "font-weight",
        "fx",
        "fy",
        "g1",
        "g2",
        "glyph-name",
        "glyphref",
        "gradientunits",
        "gradienttransform",
        "height",
        "href",
        "id",
        "image-rendering",
        "in",
        "in2",
        "intercept",
        "k",
        "k1",
        "k2",
        "k3",
        "k4",
        "kerning",
        "keypoints",
        "keysplines",
        "keytimes",
        "lang",
        "lengthadjust",
        "letter-spacing",
        "kernelmatrix",
        "kernelunitlength",
        "lighting-color",
        "local",
        "marker-end",
        "marker-mid",
        "marker-start",
        "markerheight",
        "markerunits",
        "markerwidth",
        "maskcontentunits",
        "maskunits",
        "max",
        "mask",
        "media",
        "method",
        "mode",
        "min",
        "name",
        "numoctaves",
        "offset",
        "operator",
        "opacity",
        "order",
        "orient",
        "orientation",
        "origin",
        "overflow",
        "paint-order",
        "path",
        "pathlength",
        "patterncontentunits",
        "patterntransform",
        "patternunits",
        "points",
        "preservealpha",
        "preserveaspectratio",
        "primitiveunits",
        "r",
        "rx",
        "ry",
        "radius",
        "refx",
        "refy",
        "repeatcount",
        "repeatdur",
        "restart",
        "result",
        "rotate",
        "scale",
        "seed",
        "shape-rendering",
        "slope",
        "specularconstant",
        "specularexponent",
        "spreadmethod",
        "startoffset",
        "stddeviation",
        "stitchtiles",
        "stop-color",
        "stop-opacity",
        "stroke-dasharray",
        "stroke-dashoffset",
        "stroke-linecap",
        "stroke-linejoin",
        "stroke-miterlimit",
        "stroke-opacity",
        "stroke",
        "stroke-width",
        "style",
        "surfacescale",
        "systemlanguage",
        "tabindex",
        "tablevalues",
        "targetx",
        "targety",
        "transform",
        "transform-origin",
        "text-anchor",
        "text-decoration",
        "text-rendering",
        "textlength",
        "type",
        "u1",
        "u2",
        "unicode",
        "values",
        "viewbox",
        "visibility",
        "version",
        "vert-adv-y",
        "vert-origin-x",
        "vert-origin-y",
        "width",
        "word-spacing",
        "wrap",
        "writing-mode",
        "xchannelselector",
        "ychannelselector",
        "x",
        "x1",
        "x2",
        "xmlns",
        "y",
        "y1",
        "y2",
        "z",
        "zoomandpan"
      ]), iO = js([
        "accent",
        "accentunder",
        "align",
        "bevelled",
        "close",
        "columnsalign",
        "columnlines",
        "columnspan",
        "denomalign",
        "depth",
        "dir",
        "display",
        "displaystyle",
        "encoding",
        "fence",
        "frame",
        "height",
        "href",
        "id",
        "largeop",
        "length",
        "linethickness",
        "lspace",
        "lquote",
        "mathbackground",
        "mathcolor",
        "mathsize",
        "mathvariant",
        "maxsize",
        "minsize",
        "movablelimits",
        "notation",
        "numalign",
        "open",
        "rowalign",
        "rowlines",
        "rowspacing",
        "rowspan",
        "rspace",
        "rquote",
        "scriptlevel",
        "scriptminsize",
        "scriptsizemultiplier",
        "selection",
        "separator",
        "separators",
        "stretchy",
        "subscriptshift",
        "supscriptshift",
        "symmetric",
        "voffset",
        "width",
        "xmlns"
      ]), kb = js([
        "xlink:href",
        "xml:id",
        "xlink:title",
        "xml:space",
        "xmlns:xlink"
      ]), uK = _r(/\{\{[\w\W]*|[\w\W]*\}\}/gm), hK = _r(/<%[\w\W]*|[\w\W]*%>/gm), dK = _r(/\${[\w\W]*}/gm), fK = _r(/^data-[\-\w.\u00B7-\uFFFF]/), gK = _r(/^aria-[\-\w]+$/), V9 = _r(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i), mK = _r(/^(?:\w+script|data):/i), pK = _r(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g), W9 = _r(/^html$/i), _K = _r(/^[a-z][.\w]*(-[.\w]+)+$/i);
      var nO = Object.freeze({
        __proto__: null,
        MUSTACHE_EXPR: uK,
        ERB_EXPR: hK,
        TMPLIT_EXPR: dK,
        DATA_ATTR: fK,
        ARIA_ATTR: gK,
        IS_ALLOWED_URI: V9,
        IS_SCRIPT_OR_DATA: mK,
        ATTR_WHITESPACE: pK,
        DOCTYPE_NAME: W9,
        CUSTOM_ELEMENT: _K
      });
      const Rm = {
        element: 1,
        text: 3,
        progressingInstruction: 7,
        comment: 8,
        document: 9
      }, bK = function() {
        return typeof window > "u" ? null : window;
      }, vK = function(e, t) {
        if (typeof e != "object" || typeof e.createPolicy != "function") return null;
        let i = null;
        const n = "data-tt-policy-suffix";
        t && t.hasAttribute(n) && (i = t.getAttribute(n));
        const o = "dompurify" + (i ? "#" + i : "");
        try {
          return e.createPolicy(o, {
            createHTML(r) {
              return r;
            },
            createScriptURL(r) {
              return r;
            }
          });
        } catch {
          return console.warn("TrustedTypes policy " + o + " could not be created."), null;
        }
      };
      function H9() {
        let s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : bK();
        const e = (je) => H9(je);
        if (e.version = "3.1.7", e.removed = [], !s || !s.document || s.document.nodeType !== Rm.document) return e.isSupported = false, e;
        let { document: t } = s;
        const i = t, n = i.currentScript, { DocumentFragment: o, HTMLTemplateElement: r, Node: a, Element: l, NodeFilter: u, NamedNodeMap: d = s.NamedNodeMap || s.MozNamedAttrMap, HTMLFormElement: f, DOMParser: m, trustedTypes: _ } = s, b = l.prototype, v = Am(b, "cloneNode"), y = Am(b, "remove"), x = Am(b, "nextSibling"), L = Am(b, "childNodes"), D = Am(b, "parentNode");
        if (typeof r == "function") {
          const je = t.createElement("template");
          je.content && je.content.ownerDocument && (t = je.content.ownerDocument);
        }
        let k, T = "";
        const { implementation: M, createNodeIterator: I, createDocumentFragment: R, getElementsByTagName: A } = t, { importNode: Y } = i;
        let U = {};
        e.isSupported = typeof B9 == "function" && typeof D == "function" && M && M.createHTMLDocument !== void 0;
        const { MUSTACHE_EXPR: j, ERB_EXPR: ee, TMPLIT_EXPR: K, DATA_ATTR: te, ARIA_ATTR: H, IS_SCRIPT_OR_DATA: se, ATTR_WHITESPACE: de, CUSTOM_ELEMENT: fe } = nO;
        let { IS_ALLOWED_URI: W } = nO, ne = null;
        const xe = zt({}, [
          ...J4,
          ..._L,
          ...bL,
          ...vL,
          ...eO
        ]);
        let ye = null;
        const Ae = zt({}, [
          ...tO,
          ...CL,
          ...iO,
          ...kb
        ]);
        let Ve = Object.seal(F9(null, {
          tagNameCheck: {
            writable: true,
            configurable: false,
            enumerable: true,
            value: null
          },
          attributeNameCheck: {
            writable: true,
            configurable: false,
            enumerable: true,
            value: null
          },
          allowCustomizedBuiltInElements: {
            writable: true,
            configurable: false,
            enumerable: true,
            value: false
          }
        })), We = null, xi = null, ct = true, hn = true, qo = false, Wa = true, Ko = false, Ha = true, _o2 = false, pu = false, _u = false, Bn = false, Xl = false, za = false, na = true, Ua = false;
        const rd = "user-content-";
        let $a = true, qa = false, jo = {}, Qs = null;
        const Sn = zt({}, [
          "annotation-xml",
          "audio",
          "colgroup",
          "desc",
          "foreignobject",
          "head",
          "iframe",
          "math",
          "mi",
          "mn",
          "mo",
          "ms",
          "mtext",
          "noembed",
          "noframes",
          "noscript",
          "plaintext",
          "script",
          "style",
          "svg",
          "template",
          "thead",
          "title",
          "video",
          "xmp"
        ]);
        let bo = null;
        const dn = zt({}, [
          "audio",
          "video",
          "img",
          "source",
          "image",
          "track"
        ]);
        let yr = null;
        const vs = zt({}, [
          "alt",
          "class",
          "for",
          "id",
          "label",
          "name",
          "pattern",
          "placeholder",
          "role",
          "summary",
          "title",
          "value",
          "style",
          "xmlns"
        ]), Go = "http://www.w3.org/1998/Math/MathML", Xs = "http://www.w3.org/2000/svg", Ri = "http://www.w3.org/1999/xhtml";
        let Ln = Ri, Sr = false, os = null;
        const ei = zt({}, [
          Go,
          Xs,
          Ri
        ], pL);
        let sa = null;
        const ad = [
          "application/xhtml+xml",
          "text/html"
        ], bu = "text/html";
        let Oi = null, oa = null;
        const ld = t.createElement("form"), vu = function(ie) {
          return ie instanceof RegExp || ie instanceof Function;
        }, Ka = function() {
          let ie = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          if (!(oa && oa === ie)) {
            if ((!ie || typeof ie != "object") && (ie = {}), ie = qu(ie), sa = ad.indexOf(ie.PARSER_MEDIA_TYPE) === -1 ? bu : ie.PARSER_MEDIA_TYPE, Oi = sa === "application/xhtml+xml" ? pL : _0, ne = Mr(ie, "ALLOWED_TAGS") ? zt({}, ie.ALLOWED_TAGS, Oi) : xe, ye = Mr(ie, "ALLOWED_ATTR") ? zt({}, ie.ALLOWED_ATTR, Oi) : Ae, os = Mr(ie, "ALLOWED_NAMESPACES") ? zt({}, ie.ALLOWED_NAMESPACES, pL) : ei, yr = Mr(ie, "ADD_URI_SAFE_ATTR") ? zt(qu(vs), ie.ADD_URI_SAFE_ATTR, Oi) : vs, bo = Mr(ie, "ADD_DATA_URI_TAGS") ? zt(qu(dn), ie.ADD_DATA_URI_TAGS, Oi) : dn, Qs = Mr(ie, "FORBID_CONTENTS") ? zt({}, ie.FORBID_CONTENTS, Oi) : Sn, We = Mr(ie, "FORBID_TAGS") ? zt({}, ie.FORBID_TAGS, Oi) : {}, xi = Mr(ie, "FORBID_ATTR") ? zt({}, ie.FORBID_ATTR, Oi) : {}, jo = Mr(ie, "USE_PROFILES") ? ie.USE_PROFILES : false, ct = ie.ALLOW_ARIA_ATTR !== false, hn = ie.ALLOW_DATA_ATTR !== false, qo = ie.ALLOW_UNKNOWN_PROTOCOLS || false, Wa = ie.ALLOW_SELF_CLOSE_IN_ATTR !== false, Ko = ie.SAFE_FOR_TEMPLATES || false, Ha = ie.SAFE_FOR_XML !== false, _o2 = ie.WHOLE_DOCUMENT || false, Bn = ie.RETURN_DOM || false, Xl = ie.RETURN_DOM_FRAGMENT || false, za = ie.RETURN_TRUSTED_TYPE || false, _u = ie.FORCE_BODY || false, na = ie.SANITIZE_DOM !== false, Ua = ie.SANITIZE_NAMED_PROPS || false, $a = ie.KEEP_CONTENT !== false, qa = ie.IN_PLACE || false, W = ie.ALLOWED_URI_REGEXP || V9, Ln = ie.NAMESPACE || Ri, Ve = ie.CUSTOM_ELEMENT_HANDLING || {}, ie.CUSTOM_ELEMENT_HANDLING && vu(ie.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (Ve.tagNameCheck = ie.CUSTOM_ELEMENT_HANDLING.tagNameCheck), ie.CUSTOM_ELEMENT_HANDLING && vu(ie.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (Ve.attributeNameCheck = ie.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), ie.CUSTOM_ELEMENT_HANDLING && typeof ie.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (Ve.allowCustomizedBuiltInElements = ie.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), Ko && (hn = false), Xl && (Bn = true), jo && (ne = zt({}, eO), ye = [], jo.html === true && (zt(ne, J4), zt(ye, tO)), jo.svg === true && (zt(ne, _L), zt(ye, CL), zt(ye, kb)), jo.svgFilters === true && (zt(ne, bL), zt(ye, CL), zt(ye, kb)), jo.mathMl === true && (zt(ne, vL), zt(ye, iO), zt(ye, kb))), ie.ADD_TAGS && (ne === xe && (ne = qu(ne)), zt(ne, ie.ADD_TAGS, Oi)), ie.ADD_ATTR && (ye === Ae && (ye = qu(ye)), zt(ye, ie.ADD_ATTR, Oi)), ie.ADD_URI_SAFE_ATTR && zt(yr, ie.ADD_URI_SAFE_ATTR, Oi), ie.FORBID_CONTENTS && (Qs === Sn && (Qs = qu(Qs)), zt(Qs, ie.FORBID_CONTENTS, Oi)), $a && (ne["#text"] = true), _o2 && zt(ne, [
              "html",
              "head",
              "body"
            ]), ne.table && (zt(ne, [
              "tbody"
            ]), delete We.tbody), ie.TRUSTED_TYPES_POLICY) {
              if (typeof ie.TRUSTED_TYPES_POLICY.createHTML != "function") throw Mm('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
              if (typeof ie.TRUSTED_TYPES_POLICY.createScriptURL != "function") throw Mm('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
              k = ie.TRUSTED_TYPES_POLICY, T = k.createHTML("");
            } else k === void 0 && (k = vK(_, n)), k !== null && typeof T == "string" && (T = k.createHTML(""));
            js && js(ie), oa = ie;
          }
        }, nt = zt({}, [
          "mi",
          "mo",
          "mn",
          "ms",
          "mtext"
        ]), P = zt({}, [
          "annotation-xml"
        ]), F = zt({}, [
          "title",
          "style",
          "font",
          "a",
          "script"
        ]), V = zt({}, [
          ..._L,
          ...bL,
          ...lK
        ]), $ = zt({}, [
          ...vL,
          ...cK
        ]), Z = function(ie) {
          let De = D(ie);
          (!De || !De.tagName) && (De = {
            namespaceURI: Ln,
            tagName: "template"
          });
          const ze = _0(ie.tagName), _i2 = _0(De.tagName);
          return os[ie.namespaceURI] ? ie.namespaceURI === Xs ? De.namespaceURI === Ri ? ze === "svg" : De.namespaceURI === Go ? ze === "svg" && (_i2 === "annotation-xml" || nt[_i2]) : !!V[ze] : ie.namespaceURI === Go ? De.namespaceURI === Ri ? ze === "math" : De.namespaceURI === Xs ? ze === "math" && P[_i2] : !!$[ze] : ie.namespaceURI === Ri ? De.namespaceURI === Xs && !P[_i2] || De.namespaceURI === Go && !nt[_i2] ? false : !$[ze] && (F[ze] || !V[ze]) : !!(sa === "application/xhtml+xml" && os[ie.namespaceURI]) : false;
        }, ce = function(ie) {
          Nm(e.removed, {
            element: ie
          });
          try {
            D(ie).removeChild(ie);
          } catch {
            y(ie);
          }
        }, _e2 = function(ie, De) {
          try {
            Nm(e.removed, {
              attribute: De.getAttributeNode(ie),
              from: De
            });
          } catch {
            Nm(e.removed, {
              attribute: null,
              from: De
            });
          }
          if (De.removeAttribute(ie), ie === "is" && !ye[ie]) if (Bn || Xl) try {
            ce(De);
          } catch {
          }
          else try {
            De.setAttribute(ie, "");
          } catch {
          }
        }, Re = function(ie) {
          let De = null, ze = null;
          if (_u) ie = "<remove></remove>" + ie;
          else {
            const kn = X4(ie, /^[\r\n\t ]+/);
            ze = kn && kn[0];
          }
          sa === "application/xhtml+xml" && Ln === Ri && (ie = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + ie + "</body></html>");
          const _i2 = k ? k.createHTML(ie) : ie;
          if (Ln === Ri) try {
            De = new m().parseFromString(_i2, sa);
          } catch {
          }
          if (!De || !De.documentElement) {
            De = M.createDocument(Ln, "template", null);
            try {
              De.documentElement.innerHTML = Sr ? T : _i2;
            } catch {
            }
          }
          const Fn = De.body || De.documentElement;
          return ie && ze && Fn.insertBefore(t.createTextNode(ze), Fn.childNodes[0] || null), Ln === Ri ? A.call(De, _o2 ? "html" : "body")[0] : _o2 ? De.documentElement : Fn;
        }, Fe = function(ie) {
          return I.call(ie.ownerDocument || ie, ie, u.SHOW_ELEMENT | u.SHOW_COMMENT | u.SHOW_TEXT | u.SHOW_PROCESSING_INSTRUCTION | u.SHOW_CDATA_SECTION, null);
        }, tt = function(ie) {
          return ie instanceof f && (typeof ie.nodeName != "string" || typeof ie.textContent != "string" || typeof ie.removeChild != "function" || !(ie.attributes instanceof d) || typeof ie.removeAttribute != "function" || typeof ie.setAttribute != "function" || typeof ie.namespaceURI != "string" || typeof ie.insertBefore != "function" || typeof ie.hasChildNodes != "function");
        }, xt = function(ie) {
          return typeof a == "function" && ie instanceof a;
        }, At = function(ie, De, ze) {
          U[ie] && xb(U[ie], (_i2) => {
            _i2.call(e, De, ze, oa);
          });
        }, fi = function(ie) {
          let De = null;
          if (At("beforeSanitizeElements", ie, null), tt(ie)) return ce(ie), true;
          const ze = Oi(ie.nodeName);
          if (At("uponSanitizeElement", ie, {
            tagName: ze,
            allowedTags: ne
          }), ie.hasChildNodes() && !xt(ie.firstElementChild) && Fs(/<[/\w]/g, ie.innerHTML) && Fs(/<[/\w]/g, ie.textContent) || ie.nodeType === Rm.progressingInstruction || Ha && ie.nodeType === Rm.comment && Fs(/<[/\w]/g, ie.data)) return ce(ie), true;
          if (!ne[ze] || We[ze]) {
            if (!We[ze] && fn(ze) && (Ve.tagNameCheck instanceof RegExp && Fs(Ve.tagNameCheck, ze) || Ve.tagNameCheck instanceof Function && Ve.tagNameCheck(ze))) return false;
            if ($a && !Qs[ze]) {
              const _i2 = D(ie) || ie.parentNode, Fn = L(ie) || ie.childNodes;
              if (Fn && _i2) {
                const kn = Fn.length;
                for (let Cs = kn - 1; Cs >= 0; --Cs) {
                  const Ps = v(Fn[Cs], true);
                  Ps.__removalCount = (ie.__removalCount || 0) + 1, _i2.insertBefore(Ps, x(ie));
                }
              }
            }
            return ce(ie), true;
          }
          return ie instanceof l && !Z(ie) || (ze === "noscript" || ze === "noembed" || ze === "noframes") && Fs(/<\/no(script|embed|frames)/i, ie.innerHTML) ? (ce(ie), true) : (Ko && ie.nodeType === Rm.text && (De = ie.textContent, xb([
            j,
            ee,
            K
          ], (_i2) => {
            De = Im(De, _i2, " ");
          }), ie.textContent !== De && (Nm(e.removed, {
            element: ie.cloneNode()
          }), ie.textContent = De)), At("afterSanitizeElements", ie, null), false);
        }, Gt = function(ie, De, ze) {
          if (na && (De === "id" || De === "name") && (ze in t || ze in ld)) return false;
          if (!(hn && !xi[De] && Fs(te, De))) {
            if (!(ct && Fs(H, De))) {
              if (!ye[De] || xi[De]) {
                if (!(fn(ie) && (Ve.tagNameCheck instanceof RegExp && Fs(Ve.tagNameCheck, ie) || Ve.tagNameCheck instanceof Function && Ve.tagNameCheck(ie)) && (Ve.attributeNameCheck instanceof RegExp && Fs(Ve.attributeNameCheck, De) || Ve.attributeNameCheck instanceof Function && Ve.attributeNameCheck(De)) || De === "is" && Ve.allowCustomizedBuiltInElements && (Ve.tagNameCheck instanceof RegExp && Fs(Ve.tagNameCheck, ze) || Ve.tagNameCheck instanceof Function && Ve.tagNameCheck(ze)))) return false;
              } else if (!yr[De]) {
                if (!Fs(W, Im(ze, de, ""))) {
                  if (!((De === "src" || De === "xlink:href" || De === "href") && ie !== "script" && sK(ze, "data:") === 0 && bo[ie])) {
                    if (!(qo && !Fs(se, Im(ze, de, "")))) {
                      if (ze) return false;
                    }
                  }
                }
              }
            }
          }
          return true;
        }, fn = function(ie) {
          return ie !== "annotation-xml" && X4(ie, fe);
        }, xn = function(ie) {
          At("beforeSanitizeAttributes", ie, null);
          const { attributes: De } = ie;
          if (!De) return;
          const ze = {
            attrName: "",
            attrValue: "",
            keepAttr: true,
            allowedAttributes: ye
          };
          let _i2 = De.length;
          for (; _i2--; ) {
            const Fn = De[_i2], { name: kn, namespaceURI: Cs, value: Ps } = Fn, ra = Oi(kn);
            let Vi = kn === "value" ? Ps : oK(Ps);
            if (ze.attrName = ra, ze.attrValue = Vi, ze.keepAttr = true, ze.forceKeepAttr = void 0, At("uponSanitizeAttribute", ie, ze), Vi = ze.attrValue, ze.forceKeepAttr || (_e2(kn, ie), !ze.keepAttr)) continue;
            if (!Wa && Fs(/\/>/i, Vi)) {
              _e2(kn, ie);
              continue;
            }
            Ko && xb([
              j,
              ee,
              K
            ], (Og) => {
              Vi = Im(Vi, Og, " ");
            });
            const cd = Oi(ie.nodeName);
            if (Gt(cd, ra, Vi)) {
              if (Ua && (ra === "id" || ra === "name") && (_e2(kn, ie), Vi = rd + Vi), Ha && Fs(/((--!?|])>)|<\/(style|title)/i, Vi)) {
                _e2(kn, ie);
                continue;
              }
              if (k && typeof _ == "object" && typeof _.getAttributeType == "function" && !Cs) switch (_.getAttributeType(cd, ra)) {
                case "TrustedHTML": {
                  Vi = k.createHTML(Vi);
                  break;
                }
                case "TrustedScriptURL": {
                  Vi = k.createScriptURL(Vi);
                  break;
                }
              }
              try {
                Cs ? ie.setAttributeNS(Cs, kn, Vi) : ie.setAttribute(kn, Vi), tt(ie) ? ce(ie) : Q4(e.removed);
              } catch {
              }
            }
          }
          At("afterSanitizeAttributes", ie, null);
        }, Hi = function je(ie) {
          let De = null;
          const ze = Fe(ie);
          for (At("beforeSanitizeShadowDOM", ie, null); De = ze.nextNode(); ) At("uponSanitizeShadowNode", De, null), !fi(De) && (De.content instanceof o && je(De.content), xn(De));
          At("afterSanitizeShadowDOM", ie, null);
        };
        return e.sanitize = function(je) {
          let ie = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, De = null, ze = null, _i2 = null, Fn = null;
          if (Sr = !je, Sr && (je = "<!-->"), typeof je != "string" && !xt(je)) if (typeof je.toString == "function") {
            if (je = je.toString(), typeof je != "string") throw Mm("dirty is not a string, aborting");
          } else throw Mm("toString is not a function");
          if (!e.isSupported) return je;
          if (pu || Ka(ie), e.removed = [], typeof je == "string" && (qa = false), qa) {
            if (je.nodeName) {
              const Ps = Oi(je.nodeName);
              if (!ne[Ps] || We[Ps]) throw Mm("root node is forbidden and cannot be sanitized in-place");
            }
          } else if (je instanceof a) De = Re("<!---->"), ze = De.ownerDocument.importNode(je, true), ze.nodeType === Rm.element && ze.nodeName === "BODY" || ze.nodeName === "HTML" ? De = ze : De.appendChild(ze);
          else {
            if (!Bn && !Ko && !_o2 && je.indexOf("<") === -1) return k && za ? k.createHTML(je) : je;
            if (De = Re(je), !De) return Bn ? null : za ? T : "";
          }
          De && _u && ce(De.firstChild);
          const kn = Fe(qa ? je : De);
          for (; _i2 = kn.nextNode(); ) fi(_i2) || (_i2.content instanceof o && Hi(_i2.content), xn(_i2));
          if (qa) return je;
          if (Bn) {
            if (Xl) for (Fn = R.call(De.ownerDocument); De.firstChild; ) Fn.appendChild(De.firstChild);
            else Fn = De;
            return (ye.shadowroot || ye.shadowrootmode) && (Fn = Y.call(i, Fn, true)), Fn;
          }
          let Cs = _o2 ? De.outerHTML : De.innerHTML;
          return _o2 && ne["!doctype"] && De.ownerDocument && De.ownerDocument.doctype && De.ownerDocument.doctype.name && Fs(W9, De.ownerDocument.doctype.name) && (Cs = "<!DOCTYPE " + De.ownerDocument.doctype.name + `>
` + Cs), Ko && xb([
            j,
            ee,
            K
          ], (Ps) => {
            Cs = Im(Cs, Ps, " ");
          }), k && za ? k.createHTML(Cs) : Cs;
        }, e.setConfig = function() {
          let je = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          Ka(je), pu = true;
        }, e.clearConfig = function() {
          oa = null, pu = false;
        }, e.isValidAttribute = function(je, ie, De) {
          oa || Ka({});
          const ze = Oi(je), _i2 = Oi(ie);
          return Gt(ze, _i2, De);
        }, e.addHook = function(je, ie) {
          typeof ie == "function" && (U[je] = U[je] || [], Nm(U[je], ie));
        }, e.removeHook = function(je) {
          if (U[je]) return Q4(U[je]);
        }, e.removeHooks = function(je) {
          U[je] && (U[je] = []);
        }, e.removeAllHooks = function() {
          U = {};
        }, e;
      }
      var Oa = H9();
      Oa.version;
      Oa.isSupported;
      const z9 = Oa.sanitize;
      Oa.setConfig;
      Oa.clearConfig;
      Oa.isValidAttribute;
      const U9 = Oa.addHook, $9 = Oa.removeHook;
      Oa.removeHooks;
      Oa.removeAllHooks;
      var it;
      (function(s) {
        s.inMemory = "inmemory", s.vscode = "vscode", s.internal = "private", s.walkThrough = "walkThrough", s.walkThroughSnippet = "walkThroughSnippet", s.http = "http", s.https = "https", s.file = "file", s.mailto = "mailto", s.untitled = "untitled", s.data = "data", s.command = "command", s.vscodeRemote = "vscode-remote", s.vscodeRemoteResource = "vscode-remote-resource", s.vscodeManagedRemoteResource = "vscode-managed-remote-resource", s.vscodeUserData = "vscode-userdata", s.vscodeCustomEditor = "vscode-custom-editor", s.vscodeNotebookCell = "vscode-notebook-cell", s.vscodeNotebookCellMetadata = "vscode-notebook-cell-metadata", s.vscodeNotebookCellMetadataDiff = "vscode-notebook-cell-metadata-diff", s.vscodeNotebookCellOutput = "vscode-notebook-cell-output", s.vscodeNotebookCellOutputDiff = "vscode-notebook-cell-output-diff", s.vscodeNotebookMetadata = "vscode-notebook-metadata", s.vscodeInteractiveInput = "vscode-interactive-input", s.vscodeSettings = "vscode-settings", s.vscodeWorkspaceTrust = "vscode-workspace-trust", s.vscodeTerminal = "vscode-terminal", s.vscodeChatCodeBlock = "vscode-chat-code-block", s.vscodeChatCodeCompareBlock = "vscode-chat-code-compare-block", s.vscodeChatSesssion = "vscode-chat-editor", s.webviewPanel = "webview-panel", s.vscodeWebview = "vscode-webview", s.extension = "extension", s.vscodeFileResource = "vscode-file", s.tmp = "tmp", s.vsls = "vsls", s.vscodeSourceControl = "vscode-scm", s.commentsInput = "comment", s.codeSetting = "code-setting", s.outputChannel = "output";
      })(it || (it = {}));
      function tT(s, e) {
        return st.isUri(s) ? uf(s.scheme, e) : KE(s, e + ":");
      }
      function sO(s, ...e) {
        return e.some((t) => tT(s, t));
      }
      const CK = "tkn";
      class wK {
        constructor() {
          this._hosts = /* @__PURE__ */ Object.create(null), this._ports = /* @__PURE__ */ Object.create(null), this._connectionTokens = /* @__PURE__ */ Object.create(null), this._preferredWebSchema = "http", this._delegate = null, this._serverRootPath = "/";
        }
        setPreferredWebSchema(e) {
          this._preferredWebSchema = e;
        }
        get _remoteResourcesPath() {
          return Ii.join(this._serverRootPath, it.vscodeRemoteResource);
        }
        rewrite(e) {
          if (this._delegate) try {
            return this._delegate(e);
          } catch (a) {
            return qt(a), e;
          }
          const t = e.authority;
          let i = this._hosts[t];
          i && i.indexOf(":") !== -1 && i.indexOf("[") === -1 && (i = `[${i}]`);
          const n = this._ports[t], o = this._connectionTokens[t];
          let r = `path=${encodeURIComponent(e.path)}`;
          return typeof o == "string" && (r += `&${CK}=${encodeURIComponent(o)}`), st.from({
            scheme: yg ? this._preferredWebSchema : it.vscodeRemoteResource,
            authority: `${i}:${n}`,
            path: this._remoteResourcesPath,
            query: r
          });
        }
      }
      const q9 = new wK(), yK = "vscode-app";
      const _iv = class _iv {
        asBrowserUri(e) {
          const t = this.toUri(e);
          return this.uriToBrowserUri(t);
        }
        uriToBrowserUri(e) {
          return e.scheme === it.vscodeRemote ? q9.rewrite(e) : e.scheme === it.file && (j0 || RU === `${it.vscodeFileResource}://${_iv.FALLBACK_AUTHORITY}`) ? e.with({
            scheme: it.vscodeFileResource,
            authority: e.authority || _iv.FALLBACK_AUTHORITY,
            query: null,
            fragment: null
          }) : e;
        }
        toUri(e, t) {
          if (st.isUri(e)) return e;
          if (globalThis._VSCODE_FILE_ROOT) {
            const i = globalThis._VSCODE_FILE_ROOT;
            if (/^\w[\w\d+.-]*:\/\//.test(i)) return st.joinPath(st.parse(i, true), e);
            const n = sq(i, e);
            return st.file(n);
          }
          return st.parse(t.toUrl(e));
        }
      };
      _iv.FALLBACK_AUTHORITY = yK;
      let iv = _iv;
      const zC = new iv();
      var Uk;
      (function(s) {
        const e = /* @__PURE__ */ new Map([
          [
            "1",
            {
              "Cross-Origin-Opener-Policy": "same-origin"
            }
          ],
          [
            "2",
            {
              "Cross-Origin-Embedder-Policy": "require-corp"
            }
          ],
          [
            "3",
            {
              "Cross-Origin-Opener-Policy": "same-origin",
              "Cross-Origin-Embedder-Policy": "require-corp"
            }
          ]
        ]);
        s.CoopAndCoep = Object.freeze(e.get("3"));
        const t = "vscode-coi";
        function i(o) {
          let r;
          typeof o == "string" ? r = new URL(o).searchParams : o instanceof URL ? r = o.searchParams : st.isUri(o) && (r = new URL(o.toString(true)).searchParams);
          const a = r == null ? void 0 : r.get(t);
          if (a) return e.get(a);
        }
        s.getHeadersFromQuery = i;
        function n(o, r, a) {
          if (!globalThis.crossOriginIsolated) return;
          const l = r && a ? "3" : a ? "2" : "1";
          o instanceof URLSearchParams ? o.set(t, l) : o[t] = l;
        }
        s.addSearchParam = n;
      })(Uk || (Uk = {}));
      function K9(s) {
        return UC(s, 0);
      }
      function UC(s, e) {
        switch (typeof s) {
          case "object":
            return s === null ? Nl(349, e) : Array.isArray(s) ? LK(s, e) : xK(s, e);
          case "string":
            return iT(s, e);
          case "boolean":
            return SK(s, e);
          case "number":
            return Nl(s, e);
          case "undefined":
            return Nl(937, e);
          default:
            return Nl(617, e);
        }
      }
      function Nl(s, e) {
        return (e << 5) - e + s | 0;
      }
      function SK(s, e) {
        return Nl(s ? 433 : 863, e);
      }
      function iT(s, e) {
        e = Nl(149417, e);
        for (let t = 0, i = s.length; t < i; t++) e = Nl(s.charCodeAt(t), e);
        return e;
      }
      function LK(s, e) {
        return e = Nl(104579, e), s.reduce((t, i) => UC(i, t), e);
      }
      function xK(s, e) {
        return e = Nl(181387, e), Object.keys(s).sort().reduce((t, i) => (t = iT(i, t), UC(s[i], t)), e);
      }
      function wL(s, e, t = 32) {
        const i = t - e, n = ~((1 << i) - 1);
        return (s << e | (n & s) >>> i) >>> 0;
      }
      function oO(s, e = 0, t = s.byteLength, i = 0) {
        for (let n = 0; n < t; n++) s[e + n] = i;
      }
      function kK(s, e, t = "0") {
        for (; s.length < e; ) s = t + s;
        return s;
      }
      function Om(s, e = 32) {
        return s instanceof ArrayBuffer ? Array.from(new Uint8Array(s)).map((t) => t.toString(16).padStart(2, "0")).join("") : kK((s >>> 0).toString(16), e / 4);
      }
      const _nT = class _nT {
        constructor() {
          this._h0 = 1732584193, this._h1 = 4023233417, this._h2 = 2562383102, this._h3 = 271733878, this._h4 = 3285377520, this._buff = new Uint8Array(67), this._buffDV = new DataView(this._buff.buffer), this._buffLen = 0, this._totalLen = 0, this._leftoverHighSurrogate = 0, this._finished = false;
        }
        update(e) {
          const t = e.length;
          if (t === 0) return;
          const i = this._buff;
          let n = this._buffLen, o = this._leftoverHighSurrogate, r, a;
          for (o !== 0 ? (r = o, a = -1, o = 0) : (r = e.charCodeAt(0), a = 0); ; ) {
            let l = r;
            if (on(r)) if (a + 1 < t) {
              const u = e.charCodeAt(a + 1);
              ig(u) ? (a++, l = jE(r, u)) : l = 65533;
            } else {
              o = r;
              break;
            }
            else ig(r) && (l = 65533);
            if (n = this._push(i, n, l), a++, a < t) r = e.charCodeAt(a);
            else break;
          }
          this._buffLen = n, this._leftoverHighSurrogate = o;
        }
        _push(e, t, i) {
          return i < 128 ? e[t++] = i : i < 2048 ? (e[t++] = 192 | (i & 1984) >>> 6, e[t++] = 128 | (i & 63) >>> 0) : i < 65536 ? (e[t++] = 224 | (i & 61440) >>> 12, e[t++] = 128 | (i & 4032) >>> 6, e[t++] = 128 | (i & 63) >>> 0) : (e[t++] = 240 | (i & 1835008) >>> 18, e[t++] = 128 | (i & 258048) >>> 12, e[t++] = 128 | (i & 4032) >>> 6, e[t++] = 128 | (i & 63) >>> 0), t >= 64 && (this._step(), t -= 64, this._totalLen += 64, e[0] = e[64], e[1] = e[65], e[2] = e[66]), t;
        }
        digest() {
          return this._finished || (this._finished = true, this._leftoverHighSurrogate && (this._leftoverHighSurrogate = 0, this._buffLen = this._push(this._buff, this._buffLen, 65533)), this._totalLen += this._buffLen, this._wrapUp()), Om(this._h0) + Om(this._h1) + Om(this._h2) + Om(this._h3) + Om(this._h4);
        }
        _wrapUp() {
          this._buff[this._buffLen++] = 128, oO(this._buff, this._buffLen), this._buffLen > 56 && (this._step(), oO(this._buff));
          const e = 8 * this._totalLen;
          this._buffDV.setUint32(56, Math.floor(e / 4294967296), false), this._buffDV.setUint32(60, e % 4294967296, false), this._step();
        }
        _step() {
          const e = _nT._bigBlock32, t = this._buffDV;
          for (let f = 0; f < 64; f += 4) e.setUint32(f, t.getUint32(f, false), false);
          for (let f = 64; f < 320; f += 4) e.setUint32(f, wL(e.getUint32(f - 12, false) ^ e.getUint32(f - 32, false) ^ e.getUint32(f - 56, false) ^ e.getUint32(f - 64, false), 1), false);
          let i = this._h0, n = this._h1, o = this._h2, r = this._h3, a = this._h4, l, u, d;
          for (let f = 0; f < 80; f++) f < 20 ? (l = n & o | ~n & r, u = 1518500249) : f < 40 ? (l = n ^ o ^ r, u = 1859775393) : f < 60 ? (l = n & o | n & r | o & r, u = 2400959708) : (l = n ^ o ^ r, u = 3395469782), d = wL(i, 5) + l + a + u + e.getUint32(f * 4, false) & 4294967295, a = r, r = o, o = wL(n, 30), n = i, i = d;
          this._h0 = this._h0 + i & 4294967295, this._h1 = this._h1 + n & 4294967295, this._h2 = this._h2 + o & 4294967295, this._h3 = this._h3 + r & 4294967295, this._h4 = this._h4 + a & 4294967295;
        }
      };
      _nT._bigBlock32 = new DataView(new ArrayBuffer(320));
      let nT = _nT;
      const { getWindow: Oe, getWindows: j9, getWindowsCount: DK, getWindowId: nv, getWindowById: rO, onDidRegisterWindow: $C, onWillUnregisterWindow: EK, onDidUnregisterWindow: TK } = function() {
        const s = /* @__PURE__ */ new Map();
        Sq(Kt, 1);
        const e = {
          window: Kt,
          disposables: new Me()
        };
        s.set(Kt.vscodeWindowId, e);
        const t = new G(), i = new G(), n = new G();
        function o(r, a) {
          return (typeof r == "number" ? s.get(r) : void 0) ?? (a ? e : void 0);
        }
        return {
          onDidRegisterWindow: t.event,
          onWillUnregisterWindow: n.event,
          onDidUnregisterWindow: i.event,
          registerWindow(r) {
            if (s.has(r.vscodeWindowId)) return he.None;
            const a = new Me(), l = {
              window: r,
              disposables: a.add(new Me())
            };
            return s.set(r.vscodeWindowId, l), a.add(Ze(() => {
              s.delete(r.vscodeWindowId), i.fire(r);
            })), a.add(re(r, Ce.BEFORE_UNLOAD, () => {
              n.fire(r);
            })), t.fire(l), a;
          },
          getWindows() {
            return s.values();
          },
          getWindowsCount() {
            return s.size;
          },
          getWindowId(r) {
            return r.vscodeWindowId;
          },
          hasWindow(r) {
            return s.has(r);
          },
          getWindowById: o,
          getWindow(r) {
            var _a3;
            const a = r;
            if ((_a3 = a == null ? void 0 : a.ownerDocument) == null ? void 0 : _a3.defaultView) return a.ownerDocument.defaultView.window;
            const l = r;
            return (l == null ? void 0 : l.view) ? l.view.window : Kt;
          },
          getDocument(r) {
            return Oe(r).document;
          }
        };
      }();
      function $r(s) {
        for (; s.firstChild; ) s.firstChild.remove();
      }
      class NK {
        constructor(e, t, i, n) {
          this._node = e, this._type = t, this._handler = i, this._options = n || false, this._node.addEventListener(this._type, this._handler, this._options);
        }
        dispose() {
          this._handler && (this._node.removeEventListener(this._type, this._handler, this._options), this._node = null, this._handler = null);
        }
      }
      function re(s, e, t, i) {
        return new NK(s, e, t, i);
      }
      function IK(s, e) {
        return function(t) {
          return e(new Vr(s, t));
        };
      }
      function MK(s) {
        return function(e) {
          return s(new si(e));
        };
      }
      const ln = function(e, t, i, n) {
        let o = i;
        return t === "click" || t === "mousedown" || t === "contextmenu" ? o = IK(Oe(e), i) : (t === "keydown" || t === "keypress" || t === "keyup") && (o = MK(i)), re(e, t, o, n);
      };
      function Db(s, e, t) {
        return pp(s, e, t);
      }
      let G9, Gs;
      class sT extends eT {
        constructor(e) {
          super(), this.defaultTarget = e && Oe(e);
        }
        cancelAndSet(e, t, i) {
          return super.cancelAndSet(e, t, i ?? this.defaultTarget);
        }
      }
      class yL {
        constructor(e, t = 0) {
          this._runner = e, this.priority = t, this._canceled = false;
        }
        dispose() {
          this._canceled = true;
        }
        execute() {
          if (!this._canceled) try {
            this._runner();
          } catch (e) {
            qt(e);
          }
        }
        static sort(e, t) {
          return t.priority - e.priority;
        }
      }
      (function() {
        const s = /* @__PURE__ */ new Map(), e = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), n = (o) => {
          t.set(o, false);
          const r = s.get(o) ?? [];
          for (e.set(o, r), s.set(o, []), i.set(o, true); r.length > 0; ) r.sort(yL.sort), r.shift().execute();
          i.set(o, false);
        };
        Gs = (o, r, a = 0) => {
          const l = nv(o), u = new yL(r, a);
          let d = s.get(l);
          return d || (d = [], s.set(l, d)), d.push(u), t.get(l) || (t.set(l, true), o.requestAnimationFrame(() => n(l))), u;
        }, G9 = (o, r, a) => {
          const l = nv(o);
          if (i.get(l)) {
            const u = new yL(r, a);
            let d = e.get(l);
            return d || (d = [], e.set(l, d)), d.push(u), u;
          } else return Gs(o, r, a);
        };
      })();
      function oT(s) {
        return Oe(s).getComputedStyle(s, null);
      }
      function $k(s, e) {
        const t = Oe(s), i = t.document;
        if (s !== i.body) return new lr(s.clientWidth, s.clientHeight);
        if (Ih && (t == null ? void 0 : t.visualViewport)) return new lr(t.visualViewport.width, t.visualViewport.height);
        if ((t == null ? void 0 : t.innerWidth) && t.innerHeight) return new lr(t.innerWidth, t.innerHeight);
        if (i.body && i.body.clientWidth && i.body.clientHeight) return new lr(i.body.clientWidth, i.body.clientHeight);
        if (i.documentElement && i.documentElement.clientWidth && i.documentElement.clientHeight) return new lr(i.documentElement.clientWidth, i.documentElement.clientHeight);
        throw new Error("Unable to figure out browser width and height");
      }
      class wi {
        static convertToPixels(e, t) {
          return parseFloat(t) || 0;
        }
        static getDimension(e, t, i) {
          const n = oT(e), o = n ? n.getPropertyValue(t) : "0";
          return wi.convertToPixels(e, o);
        }
        static getBorderLeftWidth(e) {
          return wi.getDimension(e, "border-left-width", "borderLeftWidth");
        }
        static getBorderRightWidth(e) {
          return wi.getDimension(e, "border-right-width", "borderRightWidth");
        }
        static getBorderTopWidth(e) {
          return wi.getDimension(e, "border-top-width", "borderTopWidth");
        }
        static getBorderBottomWidth(e) {
          return wi.getDimension(e, "border-bottom-width", "borderBottomWidth");
        }
        static getPaddingLeft(e) {
          return wi.getDimension(e, "padding-left", "paddingLeft");
        }
        static getPaddingRight(e) {
          return wi.getDimension(e, "padding-right", "paddingRight");
        }
        static getPaddingTop(e) {
          return wi.getDimension(e, "padding-top", "paddingTop");
        }
        static getPaddingBottom(e) {
          return wi.getDimension(e, "padding-bottom", "paddingBottom");
        }
        static getMarginLeft(e) {
          return wi.getDimension(e, "margin-left", "marginLeft");
        }
        static getMarginTop(e) {
          return wi.getDimension(e, "margin-top", "marginTop");
        }
        static getMarginRight(e) {
          return wi.getDimension(e, "margin-right", "marginRight");
        }
        static getMarginBottom(e) {
          return wi.getDimension(e, "margin-bottom", "marginBottom");
        }
      }
      const _lr = class _lr {
        constructor(e, t) {
          this.width = e, this.height = t;
        }
        with(e = this.width, t = this.height) {
          return e !== this.width || t !== this.height ? new _lr(e, t) : this;
        }
        static is(e) {
          return typeof e == "object" && typeof e.height == "number" && typeof e.width == "number";
        }
        static lift(e) {
          return e instanceof _lr ? e : new _lr(e.width, e.height);
        }
        static equals(e, t) {
          return e === t ? true : !e || !t ? false : e.width === t.width && e.height === t.height;
        }
      };
      _lr.None = new _lr(0, 0);
      let lr = _lr;
      function AK(s) {
        let e = s.offsetParent, t = s.offsetTop, i = s.offsetLeft;
        for (; (s = s.parentNode) !== null && s !== s.ownerDocument.body && s !== s.ownerDocument.documentElement; ) {
          t -= s.scrollTop;
          const n = Z9(s) ? null : oT(s);
          n && (i -= n.direction !== "rtl" ? s.scrollLeft : -s.scrollLeft), s === e && (i += wi.getBorderLeftWidth(s), t += wi.getBorderTopWidth(s), t += s.offsetTop, i += s.offsetLeft, e = s.offsetParent);
        }
        return {
          left: i,
          top: t
        };
      }
      function Bo(s) {
        const e = s.getBoundingClientRect(), t = Oe(s);
        return {
          left: e.left + t.scrollX,
          top: e.top + t.scrollY,
          width: e.width,
          height: e.height
        };
      }
      function Y9(s) {
        let e = s, t = 1;
        do {
          const i = oT(e).zoom;
          i != null && i !== "1" && (t *= i), e = e.parentElement;
        } while (e !== null && e !== e.ownerDocument.documentElement);
        return t;
      }
      function rT(s) {
        const e = wi.getMarginLeft(s) + wi.getMarginRight(s);
        return s.offsetWidth + e;
      }
      function SL(s) {
        const e = wi.getBorderLeftWidth(s) + wi.getBorderRightWidth(s), t = wi.getPaddingLeft(s) + wi.getPaddingRight(s);
        return s.offsetWidth - e - t;
      }
      function RK(s) {
        const e = wi.getBorderTopWidth(s) + wi.getBorderBottomWidth(s), t = wi.getPaddingTop(s) + wi.getPaddingBottom(s);
        return s.offsetHeight - e - t;
      }
      function qk(s) {
        const e = wi.getMarginTop(s) + wi.getMarginBottom(s);
        return s.offsetHeight + e;
      }
      function an(s, e) {
        return !!(e == null ? void 0 : e.contains(s));
      }
      function OK(s, e, t) {
        for (; s && s.nodeType === s.ELEMENT_NODE; ) {
          if (s.classList.contains(e)) return s;
          if (t) {
            if (typeof t == "string") {
              if (s.classList.contains(t)) return null;
            } else if (s === t) return null;
          }
          s = s.parentNode;
        }
        return null;
      }
      function LL(s, e, t) {
        return !!OK(s, e, t);
      }
      function Z9(s) {
        return s && !!s.host && !!s.mode;
      }
      function sv(s) {
        return !!ng(s);
      }
      function ng(s) {
        var _a3;
        for (; s.parentNode; ) {
          if (s === ((_a3 = s.ownerDocument) == null ? void 0 : _a3.body)) return null;
          s = s.parentNode;
        }
        return Z9(s) ? s : null;
      }
      function ss() {
        let s = lT().activeElement;
        for (; s == null ? void 0 : s.shadowRoot; ) s = s.shadowRoot.activeElement;
        return s;
      }
      function aT(s) {
        return ss() === s;
      }
      function Q9(s) {
        return an(ss(), s);
      }
      function lT() {
        return DK() <= 1 ? Kt.document : Array.from(j9()).map(({ window: e }) => e.document).find((e) => e.hasFocus()) ?? Kt.document;
      }
      function Jm() {
        var _a3;
        return ((_a3 = lT().defaultView) == null ? void 0 : _a3.window) ?? Kt;
      }
      const X9 = /* @__PURE__ */ new Map();
      function Uo(s = Kt.document.head, e, t) {
        const i = document.createElement("style");
        if (i.type = "text/css", i.media = "screen", e == null ? void 0 : e(i), s.appendChild(i), t && t.add(Ze(() => i.remove())), s === Kt.document.head) {
          const n = /* @__PURE__ */ new Set();
          X9.set(i, n);
          for (const { window: o, disposables: r } of j9()) {
            if (o === Kt) continue;
            const a = r.add(PK(i, n, o));
            t == null ? void 0 : t.add(a);
          }
        }
        return i;
      }
      function PK(s, e, t) {
        var _a3, _b3;
        const i = new Me(), n = s.cloneNode(true);
        t.document.head.appendChild(n), i.add(Ze(() => n.remove()));
        for (const o of VK(s)) (_b3 = n.sheet) == null ? void 0 : _b3.insertRule(o.cssText, (_a3 = n.sheet) == null ? void 0 : _a3.cssRules.length);
        return i.add(BK.observe(s, i, {
          childList: true
        })(() => {
          n.textContent = s.textContent;
        })), e.add(n), i.add(Ze(() => e.delete(n))), i;
      }
      const BK = new class {
        constructor() {
          this.mutationObservers = /* @__PURE__ */ new Map();
        }
        observe(s, e, t) {
          let i = this.mutationObservers.get(s);
          i || (i = /* @__PURE__ */ new Map(), this.mutationObservers.set(s, i));
          const n = K9(t);
          let o = i.get(n);
          if (o) o.users += 1;
          else {
            const r = new G(), a = new MutationObserver((u) => r.fire(u));
            a.observe(s, t);
            const l = o = {
              users: 1,
              observer: a,
              onDidMutate: r.event
            };
            e.add(Ze(() => {
              l.users -= 1, l.users === 0 && (r.dispose(), a.disconnect(), i == null ? void 0 : i.delete(n), (i == null ? void 0 : i.size) === 0 && this.mutationObservers.delete(s));
            })), i.set(n, o);
          }
          return o.onDidMutate;
        }
      }();
      let xL = null;
      function FK() {
        return xL || (xL = Uo()), xL;
      }
      function VK(s) {
        var _a3, _b3;
        return ((_a3 = s == null ? void 0 : s.sheet) == null ? void 0 : _a3.rules) ? s.sheet.rules : ((_b3 = s == null ? void 0 : s.sheet) == null ? void 0 : _b3.cssRules) ? s.sheet.cssRules : [];
      }
      function Kk(s, e, t = FK()) {
        var _a3;
        if (!(!t || !e)) {
          (_a3 = t.sheet) == null ? void 0 : _a3.insertRule(`${s} {${e}}`, 0);
          for (const i of X9.get(t) ?? []) Kk(s, e, i);
        }
      }
      function wn(s) {
        return s instanceof HTMLElement || s instanceof Oe(s).HTMLElement;
      }
      function aO(s) {
        return s instanceof HTMLAnchorElement || s instanceof Oe(s).HTMLAnchorElement;
      }
      function WK(s) {
        return s instanceof SVGElement || s instanceof Oe(s).SVGElement;
      }
      function cT(s) {
        return s instanceof MouseEvent || s instanceof Oe(s).MouseEvent;
      }
      function Cl(s) {
        return s instanceof KeyboardEvent || s instanceof Oe(s).KeyboardEvent;
      }
      const Ce = {
        CLICK: "click",
        AUXCLICK: "auxclick",
        DBLCLICK: "dblclick",
        MOUSE_UP: "mouseup",
        MOUSE_DOWN: "mousedown",
        MOUSE_OVER: "mouseover",
        MOUSE_MOVE: "mousemove",
        MOUSE_OUT: "mouseout",
        MOUSE_LEAVE: "mouseleave",
        MOUSE_WHEEL: "wheel",
        POINTER_UP: "pointerup",
        POINTER_DOWN: "pointerdown",
        POINTER_MOVE: "pointermove",
        POINTER_LEAVE: "pointerleave",
        CONTEXT_MENU: "contextmenu",
        KEY_DOWN: "keydown",
        KEY_UP: "keyup",
        BEFORE_UNLOAD: "beforeunload",
        CHANGE: "change",
        FOCUS: "focus",
        FOCUS_IN: "focusin",
        FOCUS_OUT: "focusout",
        BLUR: "blur",
        INPUT: "input",
        DRAG_START: "dragstart",
        DRAG: "drag",
        DRAG_ENTER: "dragenter",
        DRAG_LEAVE: "dragleave",
        DRAG_OVER: "dragover",
        DROP: "drop",
        DRAG_END: "dragend"
      };
      function HK(s) {
        const e = s;
        return !!(e && typeof e.preventDefault == "function" && typeof e.stopPropagation == "function");
      }
      const dt = {
        stop: (s, e) => (s.preventDefault(), e && s.stopPropagation(), s)
      };
      function zK(s) {
        const e = [];
        for (let t = 0; s && s.nodeType === s.ELEMENT_NODE; t++) e[t] = s.scrollTop, s = s.parentNode;
        return e;
      }
      function UK(s, e) {
        for (let t = 0; s && s.nodeType === s.ELEMENT_NODE; t++) s.scrollTop !== e[t] && (s.scrollTop = e[t]), s = s.parentNode;
      }
      class ov extends he {
        static hasFocusWithin(e) {
          if (wn(e)) {
            const t = ng(e), i = t ? t.activeElement : e.ownerDocument.activeElement;
            return an(i, e);
          } else {
            const t = e;
            return an(t.document.activeElement, t.document);
          }
        }
        constructor(e) {
          super(), this._onDidFocus = this._register(new G()), this.onDidFocus = this._onDidFocus.event, this._onDidBlur = this._register(new G()), this.onDidBlur = this._onDidBlur.event;
          let t = ov.hasFocusWithin(e), i = false;
          const n = () => {
            i = false, t || (t = true, this._onDidFocus.fire());
          }, o = () => {
            t && (i = true, (wn(e) ? Oe(e) : e).setTimeout(() => {
              i && (i = false, t = false, this._onDidBlur.fire());
            }, 0));
          };
          this._refreshStateHandler = () => {
            ov.hasFocusWithin(e) !== t && (t ? o() : n());
          }, this._register(re(e, Ce.FOCUS, n, true)), this._register(re(e, Ce.BLUR, o, true)), wn(e) && (this._register(re(e, Ce.FOCUS_IN, () => this._refreshStateHandler())), this._register(re(e, Ce.FOCUS_OUT, () => this._refreshStateHandler())));
        }
      }
      function Qp(s) {
        return new ov(s);
      }
      function $K(s, e) {
        return s.after(e), e;
      }
      function Ne(s, ...e) {
        if (s.append(...e), e.length === 1 && typeof e[0] != "string") return e[0];
      }
      function uT(s, e) {
        return s.insertBefore(e, s.firstChild), e;
      }
      function gs(s, ...e) {
        s.innerText = "", Ne(s, ...e);
      }
      const qK = /([\w\-]+)?(#([\w\-]+))?((\.([\w\-]+))*)/;
      var Xp;
      (function(s) {
        s.HTML = "http://www.w3.org/1999/xhtml", s.SVG = "http://www.w3.org/2000/svg";
      })(Xp || (Xp = {}));
      function J9(s, e, t, ...i) {
        const n = qK.exec(e);
        if (!n) throw new Error("Bad use of emmet");
        const o = n[1] || "div";
        let r;
        return s !== Xp.HTML ? r = document.createElementNS(s, o) : r = document.createElement(o), n[3] && (r.id = n[3]), n[4] && (r.className = n[4].replace(/\./g, " ").trim()), t && Object.entries(t).forEach(([a, l]) => {
          typeof l > "u" || (/^on\w+$/.test(a) ? r[a] = l : a === "selected" ? l && r.setAttribute(a, "true") : r.setAttribute(a, l));
        }), r.append(...i), r;
      }
      function He(s, e, ...t) {
        return J9(Xp.HTML, s, e, ...t);
      }
      He.SVG = function(s, e, ...t) {
        return J9(Xp.SVG, s, e, ...t);
      };
      function e8(...s) {
        for (const e of s) e.style.display = "", e.removeAttribute("aria-hidden");
      }
      function lO(...s) {
        for (const e of s) e.style.display = "none", e.setAttribute("aria-hidden", "true");
      }
      function cO(s, e) {
        const t = s.devicePixelRatio * e;
        return Math.max(1, Math.floor(t)) / s.devicePixelRatio;
      }
      function t8(s) {
        Kt.open(s, "_blank", "noopener");
      }
      function KK(s, e) {
        const t = () => {
          e(), i = Gs(s, t);
        };
        let i = Gs(s, t);
        return Ze(() => i.dispose());
      }
      q9.setPreferredWebSchema(/^https:/.test(Kt.location.href) ? "https" : "http");
      function ql(s) {
        return s ? `url('${zC.uriToBrowserUri(s).toString(true).replace(/'/g, "%27")}')` : "url('')";
      }
      function kL(s) {
        return `'${s.replace(/'/g, "%27")}'`;
      }
      function Pl(s, e) {
        if (s !== void 0) {
          const t = s.match(/^\s*var\((.+)\)$/);
          if (t) {
            const i = t[1].split(",", 2);
            return i.length === 2 && (e = Pl(i[1].trim(), e)), `var(${i[0]}, ${e})`;
          }
          return s;
        }
        return e;
      }
      function jK(s, e = false) {
        const t = document.createElement("a");
        return U9("afterSanitizeAttributes", (i) => {
          for (const n of [
            "href",
            "src"
          ]) if (i.hasAttribute(n)) {
            const o = i.getAttribute(n);
            if (n === "href" && o.startsWith("#")) continue;
            if (t.href = o, !s.includes(t.protocol.replace(/:$/, ""))) {
              if (e && n === "src" && t.href.startsWith("data:")) continue;
              i.removeAttribute(n);
            }
          }
        }), Ze(() => {
          $9("afterSanitizeAttributes");
        });
      }
      const GK = Object.freeze([
        "a",
        "abbr",
        "b",
        "bdo",
        "blockquote",
        "br",
        "caption",
        "cite",
        "code",
        "col",
        "colgroup",
        "dd",
        "del",
        "details",
        "dfn",
        "div",
        "dl",
        "dt",
        "em",
        "figcaption",
        "figure",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "hr",
        "i",
        "img",
        "input",
        "ins",
        "kbd",
        "label",
        "li",
        "mark",
        "ol",
        "p",
        "pre",
        "q",
        "rp",
        "rt",
        "ruby",
        "samp",
        "small",
        "small",
        "source",
        "span",
        "strike",
        "strong",
        "sub",
        "summary",
        "sup",
        "table",
        "tbody",
        "td",
        "tfoot",
        "th",
        "thead",
        "time",
        "tr",
        "tt",
        "u",
        "ul",
        "var",
        "video",
        "wbr"
      ]);
      class Hc extends G {
        constructor() {
          super(), this._subscriptions = new Me(), this._keyStatus = {
            altKey: false,
            shiftKey: false,
            ctrlKey: false,
            metaKey: false
          }, this._subscriptions.add(be.runAndSubscribe($C, ({ window: e, disposables: t }) => this.registerListeners(e, t), {
            window: Kt,
            disposables: this._subscriptions
          }));
        }
        registerListeners(e, t) {
          t.add(re(e, "keydown", (i) => {
            if (i.defaultPrevented) return;
            const n = new si(i);
            if (!(n.keyCode === 6 && i.repeat)) {
              if (i.altKey && !this._keyStatus.altKey) this._keyStatus.lastKeyPressed = "alt";
              else if (i.ctrlKey && !this._keyStatus.ctrlKey) this._keyStatus.lastKeyPressed = "ctrl";
              else if (i.metaKey && !this._keyStatus.metaKey) this._keyStatus.lastKeyPressed = "meta";
              else if (i.shiftKey && !this._keyStatus.shiftKey) this._keyStatus.lastKeyPressed = "shift";
              else if (n.keyCode !== 6) this._keyStatus.lastKeyPressed = void 0;
              else return;
              this._keyStatus.altKey = i.altKey, this._keyStatus.ctrlKey = i.ctrlKey, this._keyStatus.metaKey = i.metaKey, this._keyStatus.shiftKey = i.shiftKey, this._keyStatus.lastKeyPressed && (this._keyStatus.event = i, this.fire(this._keyStatus));
            }
          }, true)), t.add(re(e, "keyup", (i) => {
            i.defaultPrevented || (!i.altKey && this._keyStatus.altKey ? this._keyStatus.lastKeyReleased = "alt" : !i.ctrlKey && this._keyStatus.ctrlKey ? this._keyStatus.lastKeyReleased = "ctrl" : !i.metaKey && this._keyStatus.metaKey ? this._keyStatus.lastKeyReleased = "meta" : !i.shiftKey && this._keyStatus.shiftKey ? this._keyStatus.lastKeyReleased = "shift" : this._keyStatus.lastKeyReleased = void 0, this._keyStatus.lastKeyPressed !== this._keyStatus.lastKeyReleased && (this._keyStatus.lastKeyPressed = void 0), this._keyStatus.altKey = i.altKey, this._keyStatus.ctrlKey = i.ctrlKey, this._keyStatus.metaKey = i.metaKey, this._keyStatus.shiftKey = i.shiftKey, this._keyStatus.lastKeyReleased && (this._keyStatus.event = i, this.fire(this._keyStatus)));
          }, true)), t.add(re(e.document.body, "mousedown", () => {
            this._keyStatus.lastKeyPressed = void 0;
          }, true)), t.add(re(e.document.body, "mouseup", () => {
            this._keyStatus.lastKeyPressed = void 0;
          }, true)), t.add(re(e.document.body, "mousemove", (i) => {
            i.buttons && (this._keyStatus.lastKeyPressed = void 0);
          }, true)), t.add(re(e, "blur", () => {
            this.resetKeyStatus();
          }));
        }
        get keyStatus() {
          return this._keyStatus;
        }
        resetKeyStatus() {
          this.doResetKeyStatus(), this.fire(this._keyStatus);
        }
        doResetKeyStatus() {
          this._keyStatus = {
            altKey: false,
            shiftKey: false,
            ctrlKey: false,
            metaKey: false
          };
        }
        static getInstance() {
          return Hc.instance || (Hc.instance = new Hc()), Hc.instance;
        }
        dispose() {
          super.dispose(), this._subscriptions.dispose();
        }
      }
      class YK extends he {
        constructor(e, t) {
          super(), this.element = e, this.callbacks = t, this.counter = 0, this.dragStartTime = 0, this.registerListeners();
        }
        registerListeners() {
          this.callbacks.onDragStart && this._register(re(this.element, Ce.DRAG_START, (e) => {
            var _a3, _b3;
            (_b3 = (_a3 = this.callbacks).onDragStart) == null ? void 0 : _b3.call(_a3, e);
          })), this.callbacks.onDrag && this._register(re(this.element, Ce.DRAG, (e) => {
            var _a3, _b3;
            (_b3 = (_a3 = this.callbacks).onDrag) == null ? void 0 : _b3.call(_a3, e);
          })), this._register(re(this.element, Ce.DRAG_ENTER, (e) => {
            var _a3, _b3;
            this.counter++, this.dragStartTime = e.timeStamp, (_b3 = (_a3 = this.callbacks).onDragEnter) == null ? void 0 : _b3.call(_a3, e);
          })), this._register(re(this.element, Ce.DRAG_OVER, (e) => {
            var _a3, _b3;
            e.preventDefault(), (_b3 = (_a3 = this.callbacks).onDragOver) == null ? void 0 : _b3.call(_a3, e, e.timeStamp - this.dragStartTime);
          })), this._register(re(this.element, Ce.DRAG_LEAVE, (e) => {
            var _a3, _b3;
            this.counter--, this.counter === 0 && (this.dragStartTime = 0, (_b3 = (_a3 = this.callbacks).onDragLeave) == null ? void 0 : _b3.call(_a3, e));
          })), this._register(re(this.element, Ce.DRAG_END, (e) => {
            var _a3, _b3;
            this.counter = 0, this.dragStartTime = 0, (_b3 = (_a3 = this.callbacks).onDragEnd) == null ? void 0 : _b3.call(_a3, e);
          })), this._register(re(this.element, Ce.DROP, (e) => {
            var _a3, _b3;
            this.counter = 0, this.dragStartTime = 0, (_b3 = (_a3 = this.callbacks).onDrop) == null ? void 0 : _b3.call(_a3, e);
          }));
        }
      }
      const ZK = /(?<tag>[\w\-]+)?(?:#(?<id>[\w\-]+))?(?<class>(?:\.(?:[\w\-]+))*)(?:@(?<name>(?:[\w\_])+))?/;
      function vt(s, ...e) {
        let t, i;
        Array.isArray(e[0]) ? (t = {}, i = e[0]) : (t = e[0] || {}, i = e[1]);
        const n = ZK.exec(s);
        if (!n || !n.groups) throw new Error("Bad use of h");
        const o = n.groups.tag || "div", r = document.createElement(o);
        n.groups.id && (r.id = n.groups.id);
        const a = [];
        if (n.groups.class) for (const u of n.groups.class.split(".")) u !== "" && a.push(u);
        if (t.className !== void 0) for (const u of t.className.split(".")) u !== "" && a.push(u);
        a.length > 0 && (r.className = a.join(" "));
        const l = {};
        if (n.groups.name && (l[n.groups.name] = r), i) for (const u of i) wn(u) ? r.appendChild(u) : typeof u == "string" ? r.append(u) : "root" in u && (Object.assign(l, u), r.appendChild(u.root));
        for (const [u, d] of Object.entries(t)) if (u !== "className") if (u === "style") for (const [f, m] of Object.entries(d)) r.style.setProperty(uO(f), typeof m == "number" ? m + "px" : "" + m);
        else u === "tabIndex" ? r.tabIndex = d : r.setAttribute(uO(u), d.toString());
        return l.root = r, l;
      }
      function uO(s) {
        return s.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
      }
      class QK extends he {
        constructor(e) {
          super(), this._onDidChange = this._register(new G()), this.onDidChange = this._onDidChange.event, this._listener = () => this._handleChange(e, true), this._mediaQueryList = null, this._handleChange(e, false);
        }
        _handleChange(e, t) {
          var _a3;
          (_a3 = this._mediaQueryList) == null ? void 0 : _a3.removeEventListener("change", this._listener), this._mediaQueryList = e.matchMedia(`(resolution: ${e.devicePixelRatio}dppx)`), this._mediaQueryList.addEventListener("change", this._listener), t && this._onDidChange.fire();
        }
      }
      class XK extends he {
        get value() {
          return this._value;
        }
        constructor(e) {
          super(), this._onDidChange = this._register(new G()), this.onDidChange = this._onDidChange.event, this._value = this._getPixelRatio(e);
          const t = this._register(new QK(e));
          this._register(t.onDidChange(() => {
            this._value = this._getPixelRatio(e), this._onDidChange.fire(this._value);
          }));
        }
        _getPixelRatio(e) {
          const t = document.createElement("canvas").getContext("2d"), i = e.devicePixelRatio || 1, n = t.webkitBackingStorePixelRatio || t.mozBackingStorePixelRatio || t.msBackingStorePixelRatio || t.oBackingStorePixelRatio || t.backingStorePixelRatio || 1;
          return i / n;
        }
      }
      class JK {
        constructor() {
          this.mapWindowIdToPixelRatioMonitor = /* @__PURE__ */ new Map();
        }
        _getOrCreatePixelRatioMonitor(e) {
          const t = nv(e);
          let i = this.mapWindowIdToPixelRatioMonitor.get(t);
          return i || (i = new XK(e), this.mapWindowIdToPixelRatioMonitor.set(t, i), be.once(TK)(({ vscodeWindowId: n }) => {
            n === t && (i == null ? void 0 : i.dispose(), this.mapWindowIdToPixelRatioMonitor.delete(t));
          })), i;
        }
        getInstance(e) {
          return this._getOrCreatePixelRatioMonitor(e);
        }
      }
      const rv = new JK();
      class i8 {
        constructor(e) {
          this.domNode = e, this._maxWidth = "", this._width = "", this._height = "", this._top = "", this._left = "", this._bottom = "", this._right = "", this._paddingLeft = "", this._fontFamily = "", this._fontWeight = "", this._fontSize = "", this._fontStyle = "", this._fontFeatureSettings = "", this._fontVariationSettings = "", this._textDecoration = "", this._lineHeight = "", this._letterSpacing = "", this._className = "", this._display = "", this._position = "", this._visibility = "", this._color = "", this._backgroundColor = "", this._layerHint = false, this._contain = "none", this._boxShadow = "";
        }
        setMaxWidth(e) {
          const t = Er(e);
          this._maxWidth !== t && (this._maxWidth = t, this.domNode.style.maxWidth = this._maxWidth);
        }
        setWidth(e) {
          const t = Er(e);
          this._width !== t && (this._width = t, this.domNode.style.width = this._width);
        }
        setHeight(e) {
          const t = Er(e);
          this._height !== t && (this._height = t, this.domNode.style.height = this._height);
        }
        setTop(e) {
          const t = Er(e);
          this._top !== t && (this._top = t, this.domNode.style.top = this._top);
        }
        setLeft(e) {
          const t = Er(e);
          this._left !== t && (this._left = t, this.domNode.style.left = this._left);
        }
        setBottom(e) {
          const t = Er(e);
          this._bottom !== t && (this._bottom = t, this.domNode.style.bottom = this._bottom);
        }
        setRight(e) {
          const t = Er(e);
          this._right !== t && (this._right = t, this.domNode.style.right = this._right);
        }
        setPaddingLeft(e) {
          const t = Er(e);
          this._paddingLeft !== t && (this._paddingLeft = t, this.domNode.style.paddingLeft = this._paddingLeft);
        }
        setFontFamily(e) {
          this._fontFamily !== e && (this._fontFamily = e, this.domNode.style.fontFamily = this._fontFamily);
        }
        setFontWeight(e) {
          this._fontWeight !== e && (this._fontWeight = e, this.domNode.style.fontWeight = this._fontWeight);
        }
        setFontSize(e) {
          const t = Er(e);
          this._fontSize !== t && (this._fontSize = t, this.domNode.style.fontSize = this._fontSize);
        }
        setFontStyle(e) {
          this._fontStyle !== e && (this._fontStyle = e, this.domNode.style.fontStyle = this._fontStyle);
        }
        setFontFeatureSettings(e) {
          this._fontFeatureSettings !== e && (this._fontFeatureSettings = e, this.domNode.style.fontFeatureSettings = this._fontFeatureSettings);
        }
        setFontVariationSettings(e) {
          this._fontVariationSettings !== e && (this._fontVariationSettings = e, this.domNode.style.fontVariationSettings = this._fontVariationSettings);
        }
        setTextDecoration(e) {
          this._textDecoration !== e && (this._textDecoration = e, this.domNode.style.textDecoration = this._textDecoration);
        }
        setLineHeight(e) {
          const t = Er(e);
          this._lineHeight !== t && (this._lineHeight = t, this.domNode.style.lineHeight = this._lineHeight);
        }
        setLetterSpacing(e) {
          const t = Er(e);
          this._letterSpacing !== t && (this._letterSpacing = t, this.domNode.style.letterSpacing = this._letterSpacing);
        }
        setClassName(e) {
          this._className !== e && (this._className = e, this.domNode.className = this._className);
        }
        toggleClassName(e, t) {
          this.domNode.classList.toggle(e, t), this._className = this.domNode.className;
        }
        setDisplay(e) {
          this._display !== e && (this._display = e, this.domNode.style.display = this._display);
        }
        setPosition(e) {
          this._position !== e && (this._position = e, this.domNode.style.position = this._position);
        }
        setVisibility(e) {
          this._visibility !== e && (this._visibility = e, this.domNode.style.visibility = this._visibility);
        }
        setColor(e) {
          this._color !== e && (this._color = e, this.domNode.style.color = this._color);
        }
        setBackgroundColor(e) {
          this._backgroundColor !== e && (this._backgroundColor = e, this.domNode.style.backgroundColor = this._backgroundColor);
        }
        setLayerHinting(e) {
          this._layerHint !== e && (this._layerHint = e, this.domNode.style.transform = this._layerHint ? "translate3d(0px, 0px, 0px)" : "");
        }
        setBoxShadow(e) {
          this._boxShadow !== e && (this._boxShadow = e, this.domNode.style.boxShadow = e);
        }
        setContain(e) {
          this._contain !== e && (this._contain = e, this.domNode.style.contain = this._contain);
        }
        setAttribute(e, t) {
          this.domNode.setAttribute(e, t);
        }
        removeAttribute(e) {
          this.domNode.removeAttribute(e);
        }
        appendChild(e) {
          this.domNode.appendChild(e.domNode);
        }
        removeChild(e) {
          this.domNode.removeChild(e.domNode);
        }
      }
      function Er(s) {
        return typeof s == "number" ? `${s}px` : s;
      }
      function St(s) {
        return new i8(s);
      }
      function Un(s, e) {
        s instanceof i8 ? (s.setFontFamily(e.getMassagedFontFamily()), s.setFontWeight(e.fontWeight), s.setFontSize(e.fontSize), s.setFontFeatureSettings(e.fontFeatureSettings), s.setFontVariationSettings(e.fontVariationSettings), s.setLineHeight(e.lineHeight), s.setLetterSpacing(e.letterSpacing)) : (s.style.fontFamily = e.getMassagedFontFamily(), s.style.fontWeight = e.fontWeight, s.style.fontSize = e.fontSize + "px", s.style.fontFeatureSettings = e.fontFeatureSettings, s.style.fontVariationSettings = e.fontVariationSettings, s.style.lineHeight = e.lineHeight + "px", s.style.letterSpacing = e.letterSpacing + "px");
      }
      class ej {
        constructor(e, t) {
          this.chr = e, this.type = t, this.width = 0;
        }
        fulfill(e) {
          this.width = e;
        }
      }
      class hT {
        constructor(e, t) {
          this._bareFontInfo = e, this._requests = t, this._container = null, this._testElements = null;
        }
        read(e) {
          var _a3;
          this._createDomElements(), e.document.body.appendChild(this._container), this._readFromDomElements(), (_a3 = this._container) == null ? void 0 : _a3.remove(), this._container = null, this._testElements = null;
        }
        _createDomElements() {
          const e = document.createElement("div");
          e.style.position = "absolute", e.style.top = "-50000px", e.style.width = "50000px";
          const t = document.createElement("div");
          Un(t, this._bareFontInfo), e.appendChild(t);
          const i = document.createElement("div");
          Un(i, this._bareFontInfo), i.style.fontWeight = "bold", e.appendChild(i);
          const n = document.createElement("div");
          Un(n, this._bareFontInfo), n.style.fontStyle = "italic", e.appendChild(n);
          const o = [];
          for (const r of this._requests) {
            let a;
            r.type === 0 && (a = t), r.type === 2 && (a = i), r.type === 1 && (a = n), a.appendChild(document.createElement("br"));
            const l = document.createElement("span");
            hT._render(l, r), a.appendChild(l), o.push(l);
          }
          this._container = e, this._testElements = o;
        }
        static _render(e, t) {
          if (t.chr === " ") {
            let i = "\xA0";
            for (let n = 0; n < 8; n++) i += i;
            e.innerText = i;
          } else {
            let i = t.chr;
            for (let n = 0; n < 8; n++) i += i;
            e.textContent = i;
          }
        }
        _readFromDomElements() {
          for (let e = 0, t = this._requests.length; e < t; e++) {
            const i = this._requests[e], n = this._testElements[e];
            i.fulfill(n.offsetWidth / 256);
          }
        }
      }
      function tj(s, e, t) {
        new hT(e, t).read(s);
      }
      const Ic = new class {
        constructor() {
          this._zoomLevel = 0, this._onDidChangeZoomLevel = new G(), this.onDidChangeZoomLevel = this._onDidChangeZoomLevel.event;
        }
        getZoomLevel() {
          return this._zoomLevel;
        }
        setZoomLevel(s) {
          s = Math.min(Math.max(-5, s), 20), this._zoomLevel !== s && (this._zoomLevel = s, this._onDidChangeZoomLevel.fire(this._zoomLevel));
        }
      }(), ij = _t ? 1.5 : 1.35, DL = 8;
      class Ch {
        static createFromValidatedSettings(e, t, i) {
          const n = e.get(49), o = e.get(53), r = e.get(52), a = e.get(51), l = e.get(54), u = e.get(67), d = e.get(64);
          return Ch._create(n, o, r, a, l, u, d, t, i);
        }
        static _create(e, t, i, n, o, r, a, l, u) {
          r === 0 ? r = ij * i : r < DL && (r = r * i), r = Math.round(r), r < DL && (r = DL);
          const d = 1 + (u ? 0 : Ic.getZoomLevel() * 0.1);
          return i *= d, r *= d, o === Sl.TRANSLATE && (t === "normal" || t === "bold" ? o = Sl.OFF : (o = `'wght' ${parseInt(t, 10)}`, t = "normal")), new Ch({
            pixelRatio: l,
            fontFamily: e,
            fontWeight: t,
            fontSize: i,
            fontFeatureSettings: n,
            fontVariationSettings: o,
            lineHeight: r,
            letterSpacing: a
          });
        }
        constructor(e) {
          this._bareFontInfoBrand = void 0, this.pixelRatio = e.pixelRatio, this.fontFamily = String(e.fontFamily), this.fontWeight = String(e.fontWeight), this.fontSize = e.fontSize, this.fontFeatureSettings = e.fontFeatureSettings, this.fontVariationSettings = e.fontVariationSettings, this.lineHeight = e.lineHeight | 0, this.letterSpacing = e.letterSpacing;
        }
        getId() {
          return `${this.pixelRatio}-${this.fontFamily}-${this.fontWeight}-${this.fontSize}-${this.fontFeatureSettings}-${this.fontVariationSettings}-${this.lineHeight}-${this.letterSpacing}`;
        }
        getMassagedFontFamily() {
          const e = fo.fontFamily, t = Ch._wrapInQuotes(this.fontFamily);
          return e && this.fontFamily !== e ? `${t}, ${e}` : t;
        }
        static _wrapInQuotes(e) {
          return /[,"']/.test(e) ? e : /[+ ]/.test(e) ? `"${e}"` : e;
        }
      }
      const nj = 2;
      class jk extends Ch {
        constructor(e, t) {
          super(e), this._editorStylingBrand = void 0, this.version = nj, this.isTrusted = t, this.isMonospace = e.isMonospace, this.typicalHalfwidthCharacterWidth = e.typicalHalfwidthCharacterWidth, this.typicalFullwidthCharacterWidth = e.typicalFullwidthCharacterWidth, this.canUseHalfwidthRightwardsArrow = e.canUseHalfwidthRightwardsArrow, this.spaceWidth = e.spaceWidth, this.middotWidth = e.middotWidth, this.wsmiddotWidth = e.wsmiddotWidth, this.maxDigitWidth = e.maxDigitWidth;
        }
        equals(e) {
          return this.fontFamily === e.fontFamily && this.fontWeight === e.fontWeight && this.fontSize === e.fontSize && this.fontFeatureSettings === e.fontFeatureSettings && this.fontVariationSettings === e.fontVariationSettings && this.lineHeight === e.lineHeight && this.letterSpacing === e.letterSpacing && this.typicalHalfwidthCharacterWidth === e.typicalHalfwidthCharacterWidth && this.typicalFullwidthCharacterWidth === e.typicalFullwidthCharacterWidth && this.canUseHalfwidthRightwardsArrow === e.canUseHalfwidthRightwardsArrow && this.spaceWidth === e.spaceWidth && this.middotWidth === e.middotWidth && this.wsmiddotWidth === e.wsmiddotWidth && this.maxDigitWidth === e.maxDigitWidth;
        }
      }
      class sj extends he {
        constructor() {
          super(...arguments), this._cache = /* @__PURE__ */ new Map(), this._evictUntrustedReadingsTimeout = -1, this._onDidChange = this._register(new G()), this.onDidChange = this._onDidChange.event;
        }
        dispose() {
          this._evictUntrustedReadingsTimeout !== -1 && (clearTimeout(this._evictUntrustedReadingsTimeout), this._evictUntrustedReadingsTimeout = -1), super.dispose();
        }
        clearAllFontInfos() {
          this._cache.clear(), this._onDidChange.fire();
        }
        _ensureCache(e) {
          const t = nv(e);
          let i = this._cache.get(t);
          return i || (i = new oj(), this._cache.set(t, i)), i;
        }
        _writeToCache(e, t, i) {
          this._ensureCache(e).put(t, i), !i.isTrusted && this._evictUntrustedReadingsTimeout === -1 && (this._evictUntrustedReadingsTimeout = e.setTimeout(() => {
            this._evictUntrustedReadingsTimeout = -1, this._evictUntrustedReadings(e);
          }, 5e3));
        }
        _evictUntrustedReadings(e) {
          const t = this._ensureCache(e), i = t.getValues();
          let n = false;
          for (const o of i) o.isTrusted || (n = true, t.remove(o));
          n && this._onDidChange.fire();
        }
        readFontInfo(e, t) {
          const i = this._ensureCache(e);
          if (!i.has(t)) {
            let n = this._actualReadFontInfo(e, t);
            (n.typicalHalfwidthCharacterWidth <= 2 || n.typicalFullwidthCharacterWidth <= 2 || n.spaceWidth <= 2 || n.maxDigitWidth <= 2) && (n = new jk({
              pixelRatio: rv.getInstance(e).value,
              fontFamily: n.fontFamily,
              fontWeight: n.fontWeight,
              fontSize: n.fontSize,
              fontFeatureSettings: n.fontFeatureSettings,
              fontVariationSettings: n.fontVariationSettings,
              lineHeight: n.lineHeight,
              letterSpacing: n.letterSpacing,
              isMonospace: n.isMonospace,
              typicalHalfwidthCharacterWidth: Math.max(n.typicalHalfwidthCharacterWidth, 5),
              typicalFullwidthCharacterWidth: Math.max(n.typicalFullwidthCharacterWidth, 5),
              canUseHalfwidthRightwardsArrow: n.canUseHalfwidthRightwardsArrow,
              spaceWidth: Math.max(n.spaceWidth, 5),
              middotWidth: Math.max(n.middotWidth, 5),
              wsmiddotWidth: Math.max(n.wsmiddotWidth, 5),
              maxDigitWidth: Math.max(n.maxDigitWidth, 5)
            }, false)), this._writeToCache(e, t, n);
          }
          return i.get(t);
        }
        _createRequest(e, t, i, n) {
          const o = new ej(e, t);
          return i.push(o), n == null ? void 0 : n.push(o), o;
        }
        _actualReadFontInfo(e, t) {
          const i = [], n = [], o = this._createRequest("n", 0, i, n), r = this._createRequest("\uFF4D", 0, i, null), a = this._createRequest(" ", 0, i, n), l = this._createRequest("0", 0, i, n), u = this._createRequest("1", 0, i, n), d = this._createRequest("2", 0, i, n), f = this._createRequest("3", 0, i, n), m = this._createRequest("4", 0, i, n), _ = this._createRequest("5", 0, i, n), b = this._createRequest("6", 0, i, n), v = this._createRequest("7", 0, i, n), y = this._createRequest("8", 0, i, n), x = this._createRequest("9", 0, i, n), L = this._createRequest("\u2192", 0, i, n), D = this._createRequest("\uFFEB", 0, i, null), k = this._createRequest("\xB7", 0, i, n), T = this._createRequest("\u2E31", 0, i, null), M = "|/-_ilm%";
          for (let U = 0, j = M.length; U < j; U++) this._createRequest(M.charAt(U), 0, i, n), this._createRequest(M.charAt(U), 1, i, n), this._createRequest(M.charAt(U), 2, i, n);
          tj(e, t, i);
          const I = Math.max(l.width, u.width, d.width, f.width, m.width, _.width, b.width, v.width, y.width, x.width);
          let R = t.fontFeatureSettings === Fr.OFF;
          const A = n[0].width;
          for (let U = 1, j = n.length; R && U < j; U++) {
            const ee = A - n[U].width;
            if (ee < -1e-3 || ee > 1e-3) {
              R = false;
              break;
            }
          }
          let Y = true;
          return R && D.width !== A && (Y = false), D.width > L.width && (Y = false), new jk({
            pixelRatio: rv.getInstance(e).value,
            fontFamily: t.fontFamily,
            fontWeight: t.fontWeight,
            fontSize: t.fontSize,
            fontFeatureSettings: t.fontFeatureSettings,
            fontVariationSettings: t.fontVariationSettings,
            lineHeight: t.lineHeight,
            letterSpacing: t.letterSpacing,
            isMonospace: R,
            typicalHalfwidthCharacterWidth: o.width,
            typicalFullwidthCharacterWidth: r.width,
            canUseHalfwidthRightwardsArrow: Y,
            spaceWidth: a.width,
            middotWidth: k.width,
            wsmiddotWidth: T.width,
            maxDigitWidth: I
          }, true);
        }
      }
      class oj {
        constructor() {
          this._keys = /* @__PURE__ */ Object.create(null), this._values = /* @__PURE__ */ Object.create(null);
        }
        has(e) {
          const t = e.getId();
          return !!this._values[t];
        }
        get(e) {
          const t = e.getId();
          return this._values[t];
        }
        put(e, t) {
          const i = e.getId();
          this._keys[i] = e, this._values[i] = t;
        }
        remove(e) {
          const t = e.getId();
          delete this._keys[t], delete this._values[t];
        }
        getValues() {
          return Object.keys(this._keys).map((e) => this._values[e]);
        }
      }
      const Gk = new sj();
      var Wr;
      (function(s) {
        s.serviceIds = /* @__PURE__ */ new Map(), s.DI_TARGET = "$di$target", s.DI_DEPENDENCIES = "$di$dependencies";
        function e(t) {
          return t[s.DI_DEPENDENCIES] || [];
        }
        s.getServiceDependencies = e;
      })(Wr || (Wr = {}));
      const Ft = pt("instantiationService");
      function rj(s, e, t) {
        e[Wr.DI_TARGET] === e ? e[Wr.DI_DEPENDENCIES].push({
          id: s,
          index: t
        }) : (e[Wr.DI_DEPENDENCIES] = [
          {
            id: s,
            index: t
          }
        ], e[Wr.DI_TARGET] = e);
      }
      function pt(s) {
        if (Wr.serviceIds.has(s)) return Wr.serviceIds.get(s);
        const e = function(t, i, n) {
          if (arguments.length !== 3) throw new Error("@IServiceName-decorator can only be used to decorate a parameter");
          rj(e, t, n);
        };
        return e.toString = () => s, Wr.serviceIds.set(s, e), e;
      }
      const Xi = pt("codeEditorService"), _s = pt("modelService"), qC = pt("textModelService");
      class Bl extends he {
        constructor(e, t = "", i = "", n = true, o) {
          super(), this._onDidChange = this._register(new G()), this.onDidChange = this._onDidChange.event, this._enabled = true, this._id = e, this._label = t, this._cssClass = i, this._enabled = n, this._actionCallback = o;
        }
        get id() {
          return this._id;
        }
        get label() {
          return this._label;
        }
        set label(e) {
          this._setLabel(e);
        }
        _setLabel(e) {
          this._label !== e && (this._label = e, this._onDidChange.fire({
            label: e
          }));
        }
        get tooltip() {
          return this._tooltip || "";
        }
        set tooltip(e) {
          this._setTooltip(e);
        }
        _setTooltip(e) {
          this._tooltip !== e && (this._tooltip = e, this._onDidChange.fire({
            tooltip: e
          }));
        }
        get class() {
          return this._cssClass;
        }
        set class(e) {
          this._setClass(e);
        }
        _setClass(e) {
          this._cssClass !== e && (this._cssClass = e, this._onDidChange.fire({
            class: e
          }));
        }
        get enabled() {
          return this._enabled;
        }
        set enabled(e) {
          this._setEnabled(e);
        }
        _setEnabled(e) {
          this._enabled !== e && (this._enabled = e, this._onDidChange.fire({
            enabled: e
          }));
        }
        get checked() {
          return this._checked;
        }
        set checked(e) {
          this._setChecked(e);
        }
        _setChecked(e) {
          this._checked !== e && (this._checked = e, this._onDidChange.fire({
            checked: e
          }));
        }
        async run(e, t) {
          this._actionCallback && await this._actionCallback(e);
        }
      }
      class Rh extends he {
        constructor() {
          super(...arguments), this._onWillRun = this._register(new G()), this.onWillRun = this._onWillRun.event, this._onDidRun = this._register(new G()), this.onDidRun = this._onDidRun.event;
        }
        async run(e, t) {
          if (!e.enabled) return;
          this._onWillRun.fire({
            action: e
          });
          let i;
          try {
            await this.runAction(e, t);
          } catch (n) {
            i = n;
          }
          this._onDidRun.fire({
            action: e,
            error: i
          });
        }
        async runAction(e, t) {
          await e.run(t);
        }
      }
      const _$n = class _$n {
        constructor() {
          this.id = _$n.ID, this.label = "", this.tooltip = "", this.class = "separator", this.enabled = false, this.checked = false;
        }
        static join(...e) {
          let t = [];
          for (const i of e) i.length && (t.length ? t = [
            ...t,
            new _$n(),
            ...i
          ] : t = i);
          return t;
        }
        async run() {
        }
      };
      _$n.ID = "vs.actions.separator";
      let $n = _$n;
      class KC {
        get actions() {
          return this._actions;
        }
        constructor(e, t, i, n) {
          this.tooltip = "", this.enabled = true, this.checked = void 0, this.id = e, this.label = t, this.class = n, this._actions = i;
        }
        async run() {
        }
      }
      const _dT = class _dT extends Bl {
        constructor() {
          super(_dT.ID, C("submenu.empty", "(empty)"), void 0, false);
        }
      };
      _dT.ID = "vs.actions.empty";
      let dT = _dT;
      function Af(s) {
        return {
          id: s.id,
          label: s.label,
          tooltip: s.tooltip ?? s.label,
          class: s.class,
          enabled: s.enabled ?? true,
          checked: s.checked,
          run: async (...e) => s.run(...e)
        };
      }
      var Yk;
      (function(s) {
        function e(t) {
          return t && typeof t == "object" && typeof t.id == "string";
        }
        s.isThemeColor = e;
      })(Yk || (Yk = {}));
      var wt;
      (function(s) {
        s.iconNameSegment = "[A-Za-z0-9]+", s.iconNameExpression = "[A-Za-z0-9-]+", s.iconModifierExpression = "~[A-Za-z]+", s.iconNameCharacter = "[A-Za-z0-9~-]";
        const e = new RegExp(`^(${s.iconNameExpression})(${s.iconModifierExpression})?$`);
        function t(m) {
          const _ = e.exec(m.id);
          if (!_) return t(Te.error);
          const [, b, v] = _, y = [
            "codicon",
            "codicon-" + b
          ];
          return v && y.push("codicon-modifier-" + v.substring(1)), y;
        }
        s.asClassNameArray = t;
        function i(m) {
          return t(m).join(" ");
        }
        s.asClassName = i;
        function n(m) {
          return "." + t(m).join(".");
        }
        s.asCSSSelector = n;
        function o(m) {
          return m && typeof m == "object" && typeof m.id == "string" && (typeof m.color > "u" || Yk.isThemeColor(m.color));
        }
        s.isThemeIcon = o;
        const r = new RegExp(`^\\$\\((${s.iconNameExpression}(?:${s.iconModifierExpression})?)\\)$`);
        function a(m) {
          const _ = r.exec(m);
          if (!_) return;
          const [, b] = _;
          return {
            id: b
          };
        }
        s.fromString = a;
        function l(m) {
          return {
            id: m
          };
        }
        s.fromId = l;
        function u(m, _) {
          let b = m.id;
          const v = b.lastIndexOf("~");
          return v !== -1 && (b = b.substring(0, v)), _ && (b = `${b}~${_}`), {
            id: b
          };
        }
        s.modify = u;
        function d(m) {
          const _ = m.id.lastIndexOf("~");
          if (_ !== -1) return m.id.substring(_ + 1);
        }
        s.getModifier = d;
        function f(m, _) {
          var _a3, _b3;
          return m.id === _.id && ((_a3 = m.color) == null ? void 0 : _a3.id) === ((_b3 = _.color) == null ? void 0 : _b3.id);
        }
        s.isEqual = f;
      })(wt || (wt = {}));
      const po = pt("commandService"), Os = new class {
        constructor() {
          this._commands = /* @__PURE__ */ new Map(), this._onDidRegisterCommand = new G(), this.onDidRegisterCommand = this._onDidRegisterCommand.event;
        }
        registerCommand(s, e) {
          if (!s) throw new Error("invalid command");
          if (typeof s == "string") {
            if (!e) throw new Error("invalid command");
            return this.registerCommand({
              id: s,
              handler: e
            });
          }
          if (s.metadata && Array.isArray(s.metadata.args)) {
            const r = [];
            for (const l of s.metadata.args) r.push(l.constraint);
            const a = s.handler;
            s.handler = function(l, ...u) {
              return SU(u, r), a(l, ...u);
            };
          }
          const { id: t } = s;
          let i = this._commands.get(t);
          i || (i = new Us(), this._commands.set(t, i));
          const n = i.unshift(s), o = Ze(() => {
            var _a3;
            n(), ((_a3 = this._commands.get(t)) == null ? void 0 : _a3.isEmpty()) && this._commands.delete(t);
          });
          return this._onDidRegisterCommand.fire(t), o;
        }
        registerCommandAlias(s, e) {
          return Os.registerCommand(s, (t, ...i) => t.get(po).executeCommand(e, ...i));
        }
        getCommand(s) {
          const e = this._commands.get(s);
          if (!(!e || e.isEmpty())) return kt.first(e);
        }
        getCommands() {
          const s = /* @__PURE__ */ new Map();
          for (const e of this._commands.keys()) {
            const t = this.getCommand(e);
            t && s.set(e, t);
          }
          return s;
        }
      }();
      Os.registerCommand("noop", () => {
      });
      function EL(...s) {
        switch (s.length) {
          case 1:
            return C("contextkey.scanner.hint.didYouMean1", "Did you mean {0}?", s[0]);
          case 2:
            return C("contextkey.scanner.hint.didYouMean2", "Did you mean {0} or {1}?", s[0], s[1]);
          case 3:
            return C("contextkey.scanner.hint.didYouMean3", "Did you mean {0}, {1} or {2}?", s[0], s[1], s[2]);
          default:
            return;
        }
      }
      const aj = C("contextkey.scanner.hint.didYouForgetToOpenOrCloseQuote", "Did you forget to open or close the quote?"), lj = C("contextkey.scanner.hint.didYouForgetToEscapeSlash", "Did you forget to escape the '/' (slash) character? Put two backslashes before it to escape, e.g., '\\\\/'.");
      const _Mc = class _Mc {
        constructor() {
          this._input = "", this._start = 0, this._current = 0, this._tokens = [], this._errors = [], this.stringRe = /[a-zA-Z0-9_<>\-\./\\:\*\?\+\[\]\^,#@;"%\$\p{L}-]+/uy;
        }
        static getLexeme(e) {
          switch (e.type) {
            case 0:
              return "(";
            case 1:
              return ")";
            case 2:
              return "!";
            case 3:
              return e.isTripleEq ? "===" : "==";
            case 4:
              return e.isTripleEq ? "!==" : "!=";
            case 5:
              return "<";
            case 6:
              return "<=";
            case 7:
              return ">=";
            case 8:
              return ">=";
            case 9:
              return "=~";
            case 10:
              return e.lexeme;
            case 11:
              return "true";
            case 12:
              return "false";
            case 13:
              return "in";
            case 14:
              return "not";
            case 15:
              return "&&";
            case 16:
              return "||";
            case 17:
              return e.lexeme;
            case 18:
              return e.lexeme;
            case 19:
              return e.lexeme;
            case 20:
              return "EOF";
            default:
              throw FE(`unhandled token type: ${JSON.stringify(e)}; have you forgotten to add a case?`);
          }
        }
        reset(e) {
          return this._input = e, this._start = 0, this._current = 0, this._tokens = [], this._errors = [], this;
        }
        scan() {
          for (; !this._isAtEnd(); ) switch (this._start = this._current, this._advance()) {
            case 40:
              this._addToken(0);
              break;
            case 41:
              this._addToken(1);
              break;
            case 33:
              if (this._match(61)) {
                const t = this._match(61);
                this._tokens.push({
                  type: 4,
                  offset: this._start,
                  isTripleEq: t
                });
              } else this._addToken(2);
              break;
            case 39:
              this._quotedString();
              break;
            case 47:
              this._regex();
              break;
            case 61:
              if (this._match(61)) {
                const t = this._match(61);
                this._tokens.push({
                  type: 3,
                  offset: this._start,
                  isTripleEq: t
                });
              } else this._match(126) ? this._addToken(9) : this._error(EL("==", "=~"));
              break;
            case 60:
              this._addToken(this._match(61) ? 6 : 5);
              break;
            case 62:
              this._addToken(this._match(61) ? 8 : 7);
              break;
            case 38:
              this._match(38) ? this._addToken(15) : this._error(EL("&&"));
              break;
            case 124:
              this._match(124) ? this._addToken(16) : this._error(EL("||"));
              break;
            case 32:
            case 13:
            case 9:
            case 10:
            case 160:
              break;
            default:
              this._string();
          }
          return this._start = this._current, this._addToken(20), Array.from(this._tokens);
        }
        _match(e) {
          return this._isAtEnd() || this._input.charCodeAt(this._current) !== e ? false : (this._current++, true);
        }
        _advance() {
          return this._input.charCodeAt(this._current++);
        }
        _peek() {
          return this._isAtEnd() ? 0 : this._input.charCodeAt(this._current);
        }
        _addToken(e) {
          this._tokens.push({
            type: e,
            offset: this._start
          });
        }
        _error(e) {
          const t = this._start, i = this._input.substring(this._start, this._current), n = {
            type: 19,
            offset: this._start,
            lexeme: i
          };
          this._errors.push({
            offset: t,
            lexeme: i,
            additionalInfo: e
          }), this._tokens.push(n);
        }
        _string() {
          this.stringRe.lastIndex = this._start;
          const e = this.stringRe.exec(this._input);
          if (e) {
            this._current = this._start + e[0].length;
            const t = this._input.substring(this._start, this._current), i = _Mc._keywords.get(t);
            i ? this._addToken(i) : this._tokens.push({
              type: 17,
              lexeme: t,
              offset: this._start
            });
          }
        }
        _quotedString() {
          for (; this._peek() !== 39 && !this._isAtEnd(); ) this._advance();
          if (this._isAtEnd()) {
            this._error(aj);
            return;
          }
          this._advance(), this._tokens.push({
            type: 18,
            lexeme: this._input.substring(this._start + 1, this._current - 1),
            offset: this._start + 1
          });
        }
        _regex() {
          let e = this._current, t = false, i = false;
          for (; ; ) {
            if (e >= this._input.length) {
              this._current = e, this._error(lj);
              return;
            }
            const o = this._input.charCodeAt(e);
            if (t) t = false;
            else if (o === 47 && !i) {
              e++;
              break;
            } else o === 91 ? i = true : o === 92 ? t = true : o === 93 && (i = false);
            e++;
          }
          for (; e < this._input.length && _Mc._regexFlags.has(this._input.charCodeAt(e)); ) e++;
          this._current = e;
          const n = this._input.substring(this._start, this._current);
          this._tokens.push({
            type: 10,
            lexeme: n,
            offset: this._start
          });
        }
        _isAtEnd() {
          return this._current >= this._input.length;
        }
      };
      _Mc._regexFlags = new Set([
        "i",
        "g",
        "s",
        "m",
        "y",
        "u"
      ].map((e) => e.charCodeAt(0)));
      _Mc._keywords = /* @__PURE__ */ new Map([
        [
          "not",
          14
        ],
        [
          "in",
          13
        ],
        [
          "false",
          12
        ],
        [
          "true",
          11
        ]
      ]);
      let Mc = _Mc;
      const qn = /* @__PURE__ */ new Map();
      qn.set("false", false);
      qn.set("true", true);
      qn.set("isMac", _t);
      qn.set("isLinux", Is);
      qn.set("isWindows", Ks);
      qn.set("isWeb", yg);
      qn.set("isMacNative", _t && !yg);
      qn.set("isEdge", VU);
      qn.set("isFirefox", BU);
      qn.set("isChrome", i9);
      qn.set("isSafari", FU);
      const cj = Object.prototype.hasOwnProperty, uj = {
        regexParsingWithErrorRecovery: true
      }, hj = C("contextkey.parser.error.emptyString", "Empty context key expression"), dj = C("contextkey.parser.error.emptyString.hint", "Did you forget to write an expression? You can also put 'false' or 'true' to always evaluate to false or true, respectively."), fj = C("contextkey.parser.error.noInAfterNot", "'in' after 'not'."), hO = C("contextkey.parser.error.closingParenthesis", "closing parenthesis ')'"), gj = C("contextkey.parser.error.unexpectedToken", "Unexpected token"), mj = C("contextkey.parser.error.unexpectedToken.hint", "Did you forget to put && or || before the token?"), pj = C("contextkey.parser.error.unexpectedEOF", "Unexpected end of expression"), _j = C("contextkey.parser.error.unexpectedEOF.hint", "Did you forget to put a context key?");
      let bj = (_f2 = class {
        constructor(e = uj) {
          this._config = e, this._scanner = new Mc(), this._tokens = [], this._current = 0, this._parsingErrors = [], this._flagsGYRe = /g|y/g;
        }
        parse(e) {
          if (e === "") {
            this._parsingErrors.push({
              message: hj,
              offset: 0,
              lexeme: "",
              additionalInfo: dj
            });
            return;
          }
          this._tokens = this._scanner.reset(e).scan(), this._current = 0, this._parsingErrors = [];
          try {
            const t = this._expr();
            if (!this._isAtEnd()) {
              const i = this._peek(), n = i.type === 17 ? mj : void 0;
              throw this._parsingErrors.push({
                message: gj,
                offset: i.offset,
                lexeme: Mc.getLexeme(i),
                additionalInfo: n
              }), _f2._parseError;
            }
            return t;
          } catch (t) {
            if (t !== _f2._parseError) throw t;
            return;
          }
        }
        _expr() {
          return this._or();
        }
        _or() {
          const e = [
            this._and()
          ];
          for (; this._matchOne(16); ) {
            const t = this._and();
            e.push(t);
          }
          return e.length === 1 ? e[0] : Ot.or(...e);
        }
        _and() {
          const e = [
            this._term()
          ];
          for (; this._matchOne(15); ) {
            const t = this._term();
            e.push(t);
          }
          return e.length === 1 ? e[0] : Ot.and(...e);
        }
        _term() {
          if (this._matchOne(2)) {
            const e = this._peek();
            switch (e.type) {
              case 11:
                return this._advance(), ms.INSTANCE;
              case 12:
                return this._advance(), Ms.INSTANCE;
              case 0: {
                this._advance();
                const t = this._expr();
                return this._consume(1, hO), t == null ? void 0 : t.negate();
              }
              case 17:
                return this._advance(), Gh.create(e.lexeme);
              default:
                throw this._errExpectedButGot("KEY | true | false | '(' expression ')'", e);
            }
          }
          return this._primary();
        }
        _primary() {
          const e = this._peek();
          switch (e.type) {
            case 11:
              return this._advance(), Ot.true();
            case 12:
              return this._advance(), Ot.false();
            case 0: {
              this._advance();
              const t = this._expr();
              return this._consume(1, hO), t;
            }
            case 17: {
              const t = e.lexeme;
              if (this._advance(), this._matchOne(9)) {
                const n = this._peek();
                if (!this._config.regexParsingWithErrorRecovery) {
                  if (this._advance(), n.type !== 10) throw this._errExpectedButGot("REGEX", n);
                  const o = n.lexeme, r = o.lastIndexOf("/"), a = r === o.length - 1 ? void 0 : this._removeFlagsGY(o.substring(r + 1));
                  let l;
                  try {
                    l = new RegExp(o.substring(1, r), a);
                  } catch {
                    throw this._errExpectedButGot("REGEX", n);
                  }
                  return Jp.create(t, l);
                }
                switch (n.type) {
                  case 10:
                  case 19: {
                    const o = [
                      n.lexeme
                    ];
                    this._advance();
                    let r = this._peek(), a = 0;
                    for (let m = 0; m < n.lexeme.length; m++) n.lexeme.charCodeAt(m) === 40 ? a++ : n.lexeme.charCodeAt(m) === 41 && a--;
                    for (; !this._isAtEnd() && r.type !== 15 && r.type !== 16; ) {
                      switch (r.type) {
                        case 0:
                          a++;
                          break;
                        case 1:
                          a--;
                          break;
                        case 10:
                        case 18:
                          for (let m = 0; m < r.lexeme.length; m++) r.lexeme.charCodeAt(m) === 40 ? a++ : n.lexeme.charCodeAt(m) === 41 && a--;
                      }
                      if (a < 0) break;
                      o.push(Mc.getLexeme(r)), this._advance(), r = this._peek();
                    }
                    const l = o.join(""), u = l.lastIndexOf("/"), d = u === l.length - 1 ? void 0 : this._removeFlagsGY(l.substring(u + 1));
                    let f;
                    try {
                      f = new RegExp(l.substring(1, u), d);
                    } catch {
                      throw this._errExpectedButGot("REGEX", n);
                    }
                    return Ot.regex(t, f);
                  }
                  case 18: {
                    const o = n.lexeme;
                    this._advance();
                    let r = null;
                    if (!xq(o)) {
                      const a = o.indexOf("/"), l = o.lastIndexOf("/");
                      if (a !== l && a >= 0) {
                        const u = o.slice(a + 1, l), d = o[l + 1] === "i" ? "i" : "";
                        try {
                          r = new RegExp(u, d);
                        } catch {
                          throw this._errExpectedButGot("REGEX", n);
                        }
                      }
                    }
                    if (r === null) throw this._errExpectedButGot("REGEX", n);
                    return Jp.create(t, r);
                  }
                  default:
                    throw this._errExpectedButGot("REGEX", this._peek());
                }
              }
              if (this._matchOne(14)) {
                this._consume(13, fj);
                const n = this._value();
                return Ot.notIn(t, n);
              }
              switch (this._peek().type) {
                case 3: {
                  this._advance();
                  const n = this._value();
                  if (this._previous().type === 18) return Ot.equals(t, n);
                  switch (n) {
                    case "true":
                      return Ot.has(t);
                    case "false":
                      return Ot.not(t);
                    default:
                      return Ot.equals(t, n);
                  }
                }
                case 4: {
                  this._advance();
                  const n = this._value();
                  if (this._previous().type === 18) return Ot.notEquals(t, n);
                  switch (n) {
                    case "true":
                      return Ot.not(t);
                    case "false":
                      return Ot.has(t);
                    default:
                      return Ot.notEquals(t, n);
                  }
                }
                case 5:
                  return this._advance(), JC.create(t, this._value());
                case 6:
                  return this._advance(), ew.create(t, this._value());
                case 7:
                  return this._advance(), QC.create(t, this._value());
                case 8:
                  return this._advance(), XC.create(t, this._value());
                case 13:
                  return this._advance(), Ot.in(t, this._value());
                default:
                  return Ot.has(t);
              }
            }
            case 20:
              throw this._parsingErrors.push({
                message: pj,
                offset: e.offset,
                lexeme: "",
                additionalInfo: _j
              }), _f2._parseError;
            default:
              throw this._errExpectedButGot(`true | false | KEY 
	| KEY '=~' REGEX 
	| KEY ('==' | '!=' | '<' | '<=' | '>' | '>=' | 'in' | 'not' 'in') value`, this._peek());
          }
        }
        _value() {
          const e = this._peek();
          switch (e.type) {
            case 17:
            case 18:
              return this._advance(), e.lexeme;
            case 11:
              return this._advance(), "true";
            case 12:
              return this._advance(), "false";
            case 13:
              return this._advance(), "in";
            default:
              return "";
          }
        }
        _removeFlagsGY(e) {
          return e.replaceAll(this._flagsGYRe, "");
        }
        _previous() {
          return this._tokens[this._current - 1];
        }
        _matchOne(e) {
          return this._check(e) ? (this._advance(), true) : false;
        }
        _advance() {
          return this._isAtEnd() || this._current++, this._previous();
        }
        _consume(e, t) {
          if (this._check(e)) return this._advance();
          throw this._errExpectedButGot(t, this._peek());
        }
        _errExpectedButGot(e, t, i) {
          const n = C("contextkey.parser.error.expectedButGot", `Expected: {0}
Received: '{1}'.`, e, Mc.getLexeme(t)), o = t.offset, r = Mc.getLexeme(t);
          return this._parsingErrors.push({
            message: n,
            offset: o,
            lexeme: r,
            additionalInfo: i
          }), _f2._parseError;
        }
        _check(e) {
          return this._peek().type === e;
        }
        _peek() {
          return this._tokens[this._current];
        }
        _isAtEnd() {
          return this._peek().type === 20;
        }
      }, _f2._parseError = new Error(), _f2);
      const _Ot = class _Ot {
        static false() {
          return ms.INSTANCE;
        }
        static true() {
          return Ms.INSTANCE;
        }
        static has(e) {
          return jh.create(e);
        }
        static equals(e, t) {
          return H_.create(e, t);
        }
        static notEquals(e, t) {
          return YC.create(e, t);
        }
        static regex(e, t) {
          return Jp.create(e, t);
        }
        static in(e, t) {
          return jC.create(e, t);
        }
        static notIn(e, t) {
          return GC.create(e, t);
        }
        static not(e) {
          return Gh.create(e);
        }
        static and(...e) {
          return fh.create(e, null, true);
        }
        static or(...e) {
          return xl.create(e, null, true);
        }
        static deserialize(e) {
          return e == null ? void 0 : this._parser.parse(e);
        }
      };
      _Ot._parser = new bj({
        regexParsingWithErrorRecovery: false
      });
      let Ot = _Ot;
      function vj(s, e) {
        const t = s ? s.substituteConstants() : void 0, i = e ? e.substituteConstants() : void 0;
        return !t && !i ? true : !t || !i ? false : t.equals(i);
      }
      function _p(s, e) {
        return s.cmp(e);
      }
      const _ms = class _ms {
        constructor() {
          this.type = 0;
        }
        cmp(e) {
          return this.type - e.type;
        }
        equals(e) {
          return e.type === this.type;
        }
        substituteConstants() {
          return this;
        }
        evaluate(e) {
          return false;
        }
        serialize() {
          return "false";
        }
        keys() {
          return [];
        }
        negate() {
          return Ms.INSTANCE;
        }
      };
      _ms.INSTANCE = new _ms();
      let ms = _ms;
      const _Ms = class _Ms {
        constructor() {
          this.type = 1;
        }
        cmp(e) {
          return this.type - e.type;
        }
        equals(e) {
          return e.type === this.type;
        }
        substituteConstants() {
          return this;
        }
        evaluate(e) {
          return true;
        }
        serialize() {
          return "true";
        }
        keys() {
          return [];
        }
        negate() {
          return ms.INSTANCE;
        }
      };
      _Ms.INSTANCE = new _Ms();
      let Ms = _Ms;
      class jh {
        static create(e, t = null) {
          const i = qn.get(e);
          return typeof i == "boolean" ? i ? Ms.INSTANCE : ms.INSTANCE : new jh(e, t);
        }
        constructor(e, t) {
          this.key = e, this.negated = t, this.type = 2;
        }
        cmp(e) {
          return e.type !== this.type ? this.type - e.type : s8(this.key, e.key);
        }
        equals(e) {
          return e.type === this.type ? this.key === e.key : false;
        }
        substituteConstants() {
          const e = qn.get(this.key);
          return typeof e == "boolean" ? e ? Ms.INSTANCE : ms.INSTANCE : this;
        }
        evaluate(e) {
          return !!e.getValue(this.key);
        }
        serialize() {
          return this.key;
        }
        keys() {
          return [
            this.key
          ];
        }
        negate() {
          return this.negated || (this.negated = Gh.create(this.key, this)), this.negated;
        }
      }
      class H_ {
        static create(e, t, i = null) {
          if (typeof t == "boolean") return t ? jh.create(e, i) : Gh.create(e, i);
          const n = qn.get(e);
          return typeof n == "boolean" ? t === (n ? "true" : "false") ? Ms.INSTANCE : ms.INSTANCE : new H_(e, t, i);
        }
        constructor(e, t, i) {
          this.key = e, this.value = t, this.negated = i, this.type = 4;
        }
        cmp(e) {
          return e.type !== this.type ? this.type - e.type : Yh(this.key, this.value, e.key, e.value);
        }
        equals(e) {
          return e.type === this.type ? this.key === e.key && this.value === e.value : false;
        }
        substituteConstants() {
          const e = qn.get(this.key);
          if (typeof e == "boolean") {
            const t = e ? "true" : "false";
            return this.value === t ? Ms.INSTANCE : ms.INSTANCE;
          }
          return this;
        }
        evaluate(e) {
          return e.getValue(this.key) == this.value;
        }
        serialize() {
          return `${this.key} == '${this.value}'`;
        }
        keys() {
          return [
            this.key
          ];
        }
        negate() {
          return this.negated || (this.negated = YC.create(this.key, this.value, this)), this.negated;
        }
      }
      class jC {
        static create(e, t) {
          return new jC(e, t);
        }
        constructor(e, t) {
          this.key = e, this.valueKey = t, this.type = 10, this.negated = null;
        }
        cmp(e) {
          return e.type !== this.type ? this.type - e.type : Yh(this.key, this.valueKey, e.key, e.valueKey);
        }
        equals(e) {
          return e.type === this.type ? this.key === e.key && this.valueKey === e.valueKey : false;
        }
        substituteConstants() {
          return this;
        }
        evaluate(e) {
          const t = e.getValue(this.valueKey), i = e.getValue(this.key);
          return Array.isArray(t) ? t.includes(i) : typeof i == "string" && typeof t == "object" && t !== null ? cj.call(t, i) : false;
        }
        serialize() {
          return `${this.key} in '${this.valueKey}'`;
        }
        keys() {
          return [
            this.key,
            this.valueKey
          ];
        }
        negate() {
          return this.negated || (this.negated = GC.create(this.key, this.valueKey)), this.negated;
        }
      }
      class GC {
        static create(e, t) {
          return new GC(e, t);
        }
        constructor(e, t) {
          this.key = e, this.valueKey = t, this.type = 11, this._negated = jC.create(e, t);
        }
        cmp(e) {
          return e.type !== this.type ? this.type - e.type : this._negated.cmp(e._negated);
        }
        equals(e) {
          return e.type === this.type ? this._negated.equals(e._negated) : false;
        }
        substituteConstants() {
          return this;
        }
        evaluate(e) {
          return !this._negated.evaluate(e);
        }
        serialize() {
          return `${this.key} not in '${this.valueKey}'`;
        }
        keys() {
          return this._negated.keys();
        }
        negate() {
          return this._negated;
        }
      }
      class YC {
        static create(e, t, i = null) {
          if (typeof t == "boolean") return t ? Gh.create(e, i) : jh.create(e, i);
          const n = qn.get(e);
          return typeof n == "boolean" ? t === (n ? "true" : "false") ? ms.INSTANCE : Ms.INSTANCE : new YC(e, t, i);
        }
        constructor(e, t, i) {
          this.key = e, this.value = t, this.negated = i, this.type = 5;
        }
        cmp(e) {
          return e.type !== this.type ? this.type - e.type : Yh(this.key, this.value, e.key, e.value);
        }
        equals(e) {
          return e.type === this.type ? this.key === e.key && this.value === e.value : false;
        }
        substituteConstants() {
          const e = qn.get(this.key);
          if (typeof e == "boolean") {
            const t = e ? "true" : "false";
            return this.value === t ? ms.INSTANCE : Ms.INSTANCE;
          }
          return this;
        }
        evaluate(e) {
          return e.getValue(this.key) != this.value;
        }
        serialize() {
          return `${this.key} != '${this.value}'`;
        }
        keys() {
          return [
            this.key
          ];
        }
        negate() {
          return this.negated || (this.negated = H_.create(this.key, this.value, this)), this.negated;
        }
      }
      class Gh {
        static create(e, t = null) {
          const i = qn.get(e);
          return typeof i == "boolean" ? i ? ms.INSTANCE : Ms.INSTANCE : new Gh(e, t);
        }
        constructor(e, t) {
          this.key = e, this.negated = t, this.type = 3;
        }
        cmp(e) {
          return e.type !== this.type ? this.type - e.type : s8(this.key, e.key);
        }
        equals(e) {
          return e.type === this.type ? this.key === e.key : false;
        }
        substituteConstants() {
          const e = qn.get(this.key);
          return typeof e == "boolean" ? e ? ms.INSTANCE : Ms.INSTANCE : this;
        }
        evaluate(e) {
          return !e.getValue(this.key);
        }
        serialize() {
          return `!${this.key}`;
        }
        keys() {
          return [
            this.key
          ];
        }
        negate() {
          return this.negated || (this.negated = jh.create(this.key, this)), this.negated;
        }
      }
      function ZC(s, e) {
        if (typeof s == "string") {
          const t = parseFloat(s);
          isNaN(t) || (s = t);
        }
        return typeof s == "string" || typeof s == "number" ? e(s) : ms.INSTANCE;
      }
      class QC {
        static create(e, t, i = null) {
          return ZC(t, (n) => new QC(e, n, i));
        }
        constructor(e, t, i) {
          this.key = e, this.value = t, this.negated = i, this.type = 12;
        }
        cmp(e) {
          return e.type !== this.type ? this.type - e.type : Yh(this.key, this.value, e.key, e.value);
        }
        equals(e) {
          return e.type === this.type ? this.key === e.key && this.value === e.value : false;
        }
        substituteConstants() {
          return this;
        }
        evaluate(e) {
          return typeof this.value == "string" ? false : parseFloat(e.getValue(this.key)) > this.value;
        }
        serialize() {
          return `${this.key} > ${this.value}`;
        }
        keys() {
          return [
            this.key
          ];
        }
        negate() {
          return this.negated || (this.negated = ew.create(this.key, this.value, this)), this.negated;
        }
      }
      class XC {
        static create(e, t, i = null) {
          return ZC(t, (n) => new XC(e, n, i));
        }
        constructor(e, t, i) {
          this.key = e, this.value = t, this.negated = i, this.type = 13;
        }
        cmp(e) {
          return e.type !== this.type ? this.type - e.type : Yh(this.key, this.value, e.key, e.value);
        }
        equals(e) {
          return e.type === this.type ? this.key === e.key && this.value === e.value : false;
        }
        substituteConstants() {
          return this;
        }
        evaluate(e) {
          return typeof this.value == "string" ? false : parseFloat(e.getValue(this.key)) >= this.value;
        }
        serialize() {
          return `${this.key} >= ${this.value}`;
        }
        keys() {
          return [
            this.key
          ];
        }
        negate() {
          return this.negated || (this.negated = JC.create(this.key, this.value, this)), this.negated;
        }
      }
      class JC {
        static create(e, t, i = null) {
          return ZC(t, (n) => new JC(e, n, i));
        }
        constructor(e, t, i) {
          this.key = e, this.value = t, this.negated = i, this.type = 14;
        }
        cmp(e) {
          return e.type !== this.type ? this.type - e.type : Yh(this.key, this.value, e.key, e.value);
        }
        equals(e) {
          return e.type === this.type ? this.key === e.key && this.value === e.value : false;
        }
        substituteConstants() {
          return this;
        }
        evaluate(e) {
          return typeof this.value == "string" ? false : parseFloat(e.getValue(this.key)) < this.value;
        }
        serialize() {
          return `${this.key} < ${this.value}`;
        }
        keys() {
          return [
            this.key
          ];
        }
        negate() {
          return this.negated || (this.negated = XC.create(this.key, this.value, this)), this.negated;
        }
      }
      class ew {
        static create(e, t, i = null) {
          return ZC(t, (n) => new ew(e, n, i));
        }
        constructor(e, t, i) {
          this.key = e, this.value = t, this.negated = i, this.type = 15;
        }
        cmp(e) {
          return e.type !== this.type ? this.type - e.type : Yh(this.key, this.value, e.key, e.value);
        }
        equals(e) {
          return e.type === this.type ? this.key === e.key && this.value === e.value : false;
        }
        substituteConstants() {
          return this;
        }
        evaluate(e) {
          return typeof this.value == "string" ? false : parseFloat(e.getValue(this.key)) <= this.value;
        }
        serialize() {
          return `${this.key} <= ${this.value}`;
        }
        keys() {
          return [
            this.key
          ];
        }
        negate() {
          return this.negated || (this.negated = QC.create(this.key, this.value, this)), this.negated;
        }
      }
      class Jp {
        static create(e, t) {
          return new Jp(e, t);
        }
        constructor(e, t) {
          this.key = e, this.regexp = t, this.type = 7, this.negated = null;
        }
        cmp(e) {
          if (e.type !== this.type) return this.type - e.type;
          if (this.key < e.key) return -1;
          if (this.key > e.key) return 1;
          const t = this.regexp ? this.regexp.source : "", i = e.regexp ? e.regexp.source : "";
          return t < i ? -1 : t > i ? 1 : 0;
        }
        equals(e) {
          if (e.type === this.type) {
            const t = this.regexp ? this.regexp.source : "", i = e.regexp ? e.regexp.source : "";
            return this.key === e.key && t === i;
          }
          return false;
        }
        substituteConstants() {
          return this;
        }
        evaluate(e) {
          const t = e.getValue(this.key);
          return this.regexp ? this.regexp.test(t) : false;
        }
        serialize() {
          const e = this.regexp ? `/${this.regexp.source}/${this.regexp.flags}` : "/invalid/";
          return `${this.key} =~ ${e}`;
        }
        keys() {
          return [
            this.key
          ];
        }
        negate() {
          return this.negated || (this.negated = fT.create(this)), this.negated;
        }
      }
      class fT {
        static create(e) {
          return new fT(e);
        }
        constructor(e) {
          this._actual = e, this.type = 8;
        }
        cmp(e) {
          return e.type !== this.type ? this.type - e.type : this._actual.cmp(e._actual);
        }
        equals(e) {
          return e.type === this.type ? this._actual.equals(e._actual) : false;
        }
        substituteConstants() {
          return this;
        }
        evaluate(e) {
          return !this._actual.evaluate(e);
        }
        serialize() {
          return `!(${this._actual.serialize()})`;
        }
        keys() {
          return this._actual.keys();
        }
        negate() {
          return this._actual;
        }
      }
      function n8(s) {
        let e = null;
        for (let t = 0, i = s.length; t < i; t++) {
          const n = s[t].substituteConstants();
          if (s[t] !== n && e === null) {
            e = [];
            for (let o = 0; o < t; o++) e[o] = s[o];
          }
          e !== null && (e[t] = n);
        }
        return e === null ? s : e;
      }
      class fh {
        static create(e, t, i) {
          return fh._normalizeArr(e, t, i);
        }
        constructor(e, t) {
          this.expr = e, this.negated = t, this.type = 6;
        }
        cmp(e) {
          if (e.type !== this.type) return this.type - e.type;
          if (this.expr.length < e.expr.length) return -1;
          if (this.expr.length > e.expr.length) return 1;
          for (let t = 0, i = this.expr.length; t < i; t++) {
            const n = _p(this.expr[t], e.expr[t]);
            if (n !== 0) return n;
          }
          return 0;
        }
        equals(e) {
          if (e.type === this.type) {
            if (this.expr.length !== e.expr.length) return false;
            for (let t = 0, i = this.expr.length; t < i; t++) if (!this.expr[t].equals(e.expr[t])) return false;
            return true;
          }
          return false;
        }
        substituteConstants() {
          const e = n8(this.expr);
          return e === this.expr ? this : fh.create(e, this.negated, false);
        }
        evaluate(e) {
          for (let t = 0, i = this.expr.length; t < i; t++) if (!this.expr[t].evaluate(e)) return false;
          return true;
        }
        static _normalizeArr(e, t, i) {
          const n = [];
          let o = false;
          for (const r of e) if (r) {
            if (r.type === 1) {
              o = true;
              continue;
            }
            if (r.type === 0) return ms.INSTANCE;
            if (r.type === 6) {
              n.push(...r.expr);
              continue;
            }
            n.push(r);
          }
          if (n.length === 0 && o) return Ms.INSTANCE;
          if (n.length !== 0) {
            if (n.length === 1) return n[0];
            n.sort(_p);
            for (let r = 1; r < n.length; r++) n[r - 1].equals(n[r]) && (n.splice(r, 1), r--);
            if (n.length === 1) return n[0];
            for (; n.length > 1; ) {
              const r = n[n.length - 1];
              if (r.type !== 9) break;
              n.pop();
              const a = n.pop(), l = n.length === 0, u = xl.create(r.expr.map((d) => fh.create([
                d,
                a
              ], null, i)), null, l);
              u && (n.push(u), n.sort(_p));
            }
            if (n.length === 1) return n[0];
            if (i) {
              for (let r = 0; r < n.length; r++) for (let a = r + 1; a < n.length; a++) if (n[r].negate().equals(n[a])) return ms.INSTANCE;
              if (n.length === 1) return n[0];
            }
            return new fh(n, t);
          }
        }
        serialize() {
          return this.expr.map((e) => e.serialize()).join(" && ");
        }
        keys() {
          const e = [];
          for (const t of this.expr) e.push(...t.keys());
          return e;
        }
        negate() {
          if (!this.negated) {
            const e = [];
            for (const t of this.expr) e.push(t.negate());
            this.negated = xl.create(e, this, true);
          }
          return this.negated;
        }
      }
      class xl {
        static create(e, t, i) {
          return xl._normalizeArr(e, t, i);
        }
        constructor(e, t) {
          this.expr = e, this.negated = t, this.type = 9;
        }
        cmp(e) {
          if (e.type !== this.type) return this.type - e.type;
          if (this.expr.length < e.expr.length) return -1;
          if (this.expr.length > e.expr.length) return 1;
          for (let t = 0, i = this.expr.length; t < i; t++) {
            const n = _p(this.expr[t], e.expr[t]);
            if (n !== 0) return n;
          }
          return 0;
        }
        equals(e) {
          if (e.type === this.type) {
            if (this.expr.length !== e.expr.length) return false;
            for (let t = 0, i = this.expr.length; t < i; t++) if (!this.expr[t].equals(e.expr[t])) return false;
            return true;
          }
          return false;
        }
        substituteConstants() {
          const e = n8(this.expr);
          return e === this.expr ? this : xl.create(e, this.negated, false);
        }
        evaluate(e) {
          for (let t = 0, i = this.expr.length; t < i; t++) if (this.expr[t].evaluate(e)) return true;
          return false;
        }
        static _normalizeArr(e, t, i) {
          let n = [], o = false;
          if (e) {
            for (let r = 0, a = e.length; r < a; r++) {
              const l = e[r];
              if (l) {
                if (l.type === 0) {
                  o = true;
                  continue;
                }
                if (l.type === 1) return Ms.INSTANCE;
                if (l.type === 9) {
                  n = n.concat(l.expr);
                  continue;
                }
                n.push(l);
              }
            }
            if (n.length === 0 && o) return ms.INSTANCE;
            n.sort(_p);
          }
          if (n.length !== 0) {
            if (n.length === 1) return n[0];
            for (let r = 1; r < n.length; r++) n[r - 1].equals(n[r]) && (n.splice(r, 1), r--);
            if (n.length === 1) return n[0];
            if (i) {
              for (let r = 0; r < n.length; r++) for (let a = r + 1; a < n.length; a++) if (n[r].negate().equals(n[a])) return Ms.INSTANCE;
              if (n.length === 1) return n[0];
            }
            return new xl(n, t);
          }
        }
        serialize() {
          return this.expr.map((e) => e.serialize()).join(" || ");
        }
        keys() {
          const e = [];
          for (const t of this.expr) e.push(...t.keys());
          return e;
        }
        negate() {
          if (!this.negated) {
            const e = [];
            for (const t of this.expr) e.push(t.negate());
            for (; e.length > 1; ) {
              const t = e.shift(), i = e.shift(), n = [];
              for (const o of fO(t)) for (const r of fO(i)) n.push(fh.create([
                o,
                r
              ], null, false));
              e.unshift(xl.create(n, null, false));
            }
            this.negated = xl.create(e, this, true);
          }
          return this.negated;
        }
      }
      const _Ie = class _Ie extends jh {
        static all() {
          return _Ie._info.values();
        }
        constructor(e, t, i) {
          super(e, null), this._defaultValue = t, typeof i == "object" ? _Ie._info.push({
            ...i,
            key: e
          }) : i !== true && _Ie._info.push({
            key: e,
            description: i,
            type: t != null ? typeof t : void 0
          });
        }
        bindTo(e) {
          return e.createKey(this.key, this._defaultValue);
        }
        getValue(e) {
          return e.getContextKeyValue(this.key);
        }
        toNegated() {
          return this.negate();
        }
        isEqualTo(e) {
          return H_.create(this.key, e);
        }
      };
      _Ie._info = [];
      let Ie = _Ie;
      const Mt = pt("contextKeyService");
      function s8(s, e) {
        return s < e ? -1 : s > e ? 1 : 0;
      }
      function Yh(s, e, t, i) {
        return s < t ? -1 : s > t ? 1 : e < i ? -1 : e > i ? 1 : 0;
      }
      function Zk(s, e) {
        if (s.type === 0 || e.type === 1) return true;
        if (s.type === 9) return e.type === 9 ? dO(s.expr, e.expr) : false;
        if (e.type === 9) {
          for (const t of e.expr) if (Zk(s, t)) return true;
          return false;
        }
        if (s.type === 6) {
          if (e.type === 6) return dO(e.expr, s.expr);
          for (const t of s.expr) if (Zk(t, e)) return true;
          return false;
        }
        return s.equals(e);
      }
      function dO(s, e) {
        let t = 0, i = 0;
        for (; t < s.length && i < e.length; ) {
          const n = s[t].cmp(e[i]);
          if (n < 0) return false;
          n === 0 && t++, i++;
        }
        return t === s.length;
      }
      function fO(s) {
        return s.type === 9 ? s.expr : [
          s
        ];
      }
      function TL(s, e) {
        if (!s) throw new Error(e ? `Assertion failed (${e})` : "Assertion Failed");
      }
      function gT(s, e = "Unreachable") {
        throw new Error(e);
      }
      function gO(s) {
        s || qt(new It("Soft Assertion Failed"));
      }
      function Oh(s) {
        if (!s()) {
          debugger;
          s(), qt(new It("Assertion Failed"));
        }
      }
      function mT(s, e) {
        let t = 0;
        for (; t < s.length - 1; ) {
          const i = s[t], n = s[t + 1];
          if (!e(i, n)) return false;
          t++;
        }
        return true;
      }
      class Cj {
        constructor() {
          this.data = /* @__PURE__ */ new Map();
        }
        add(e, t) {
          TL(ho(e)), TL(Es(t)), TL(!this.data.has(e), "There is already an extension with this id"), this.data.set(e, t);
        }
        as(e) {
          return this.data.get(e) || null;
        }
      }
      const yn = new Cj();
      class pT {
        constructor() {
          this._coreKeybindings = new Us(), this._extensionKeybindings = [], this._cachedMergedKeybindings = null;
        }
        static bindToCurrentPlatform(e) {
          if (ur === 1) {
            if (e && e.win) return e.win;
          } else if (ur === 2) {
            if (e && e.mac) return e.mac;
          } else if (e && e.linux) return e.linux;
          return e;
        }
        registerKeybindingRule(e) {
          const t = pT.bindToCurrentPlatform(e), i = new Me();
          if (t && t.primary) {
            const n = Bk(t.primary, ur);
            n && i.add(this._registerDefaultKeybinding(n, e.id, e.args, e.weight, 0, e.when));
          }
          if (t && Array.isArray(t.secondary)) for (let n = 0, o = t.secondary.length; n < o; n++) {
            const r = t.secondary[n], a = Bk(r, ur);
            a && i.add(this._registerDefaultKeybinding(a, e.id, e.args, e.weight, -n - 1, e.when));
          }
          return i;
        }
        registerCommandAndKeybindingRule(e) {
          return ka(this.registerKeybindingRule(e), Os.registerCommand(e));
        }
        _registerDefaultKeybinding(e, t, i, n, o, r) {
          const a = this._coreKeybindings.push({
            keybinding: e,
            command: t,
            commandArgs: i,
            when: r,
            weight1: n,
            weight2: o,
            extensionId: null,
            isBuiltinExtension: false
          });
          return this._cachedMergedKeybindings = null, Ze(() => {
            a(), this._cachedMergedKeybindings = null;
          });
        }
        getDefaultKeybindings() {
          return this._cachedMergedKeybindings || (this._cachedMergedKeybindings = Array.from(this._coreKeybindings).concat(this._extensionKeybindings), this._cachedMergedKeybindings.sort(yj)), this._cachedMergedKeybindings.slice(0);
        }
      }
      const z_ = new pT(), wj = {
        EditorModes: "platform.keybindingsRegistry"
      };
      yn.add(wj.EditorModes, z_);
      function yj(s, e) {
        if (s.weight1 !== e.weight1) return s.weight1 - e.weight1;
        if (s.command && e.command) {
          if (s.command < e.command) return -1;
          if (s.command > e.command) return 1;
        }
        return s.weight2 - e.weight2;
      }
      var Sj = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      }, mO = function(s, e) {
        return function(t, i) {
          e(t, i, s);
        };
      }, b0;
      function bp(s) {
        return s.command !== void 0;
      }
      function Lj(s) {
        return s.submenu !== void 0;
      }
      const _Q2 = class _Q2 {
        constructor(e) {
          if (_Q2._instances.has(e)) throw new TypeError(`MenuId with identifier '${e}' already exists. Use MenuId.for(ident) or a unique identifier`);
          _Q2._instances.set(e, this), this.id = e;
        }
      };
      _Q2._instances = /* @__PURE__ */ new Map();
      _Q2.CommandPalette = new _Q2("CommandPalette");
      _Q2.DebugBreakpointsContext = new _Q2("DebugBreakpointsContext");
      _Q2.DebugCallStackContext = new _Q2("DebugCallStackContext");
      _Q2.DebugConsoleContext = new _Q2("DebugConsoleContext");
      _Q2.DebugVariablesContext = new _Q2("DebugVariablesContext");
      _Q2.NotebookVariablesContext = new _Q2("NotebookVariablesContext");
      _Q2.DebugHoverContext = new _Q2("DebugHoverContext");
      _Q2.DebugWatchContext = new _Q2("DebugWatchContext");
      _Q2.DebugToolBar = new _Q2("DebugToolBar");
      _Q2.DebugToolBarStop = new _Q2("DebugToolBarStop");
      _Q2.DebugCallStackToolbar = new _Q2("DebugCallStackToolbar");
      _Q2.DebugCreateConfiguration = new _Q2("DebugCreateConfiguration");
      _Q2.EditorContext = new _Q2("EditorContext");
      _Q2.SimpleEditorContext = new _Q2("SimpleEditorContext");
      _Q2.EditorContent = new _Q2("EditorContent");
      _Q2.EditorLineNumberContext = new _Q2("EditorLineNumberContext");
      _Q2.EditorContextCopy = new _Q2("EditorContextCopy");
      _Q2.EditorContextPeek = new _Q2("EditorContextPeek");
      _Q2.EditorContextShare = new _Q2("EditorContextShare");
      _Q2.EditorTitle = new _Q2("EditorTitle");
      _Q2.EditorTitleRun = new _Q2("EditorTitleRun");
      _Q2.EditorTitleContext = new _Q2("EditorTitleContext");
      _Q2.EditorTitleContextShare = new _Q2("EditorTitleContextShare");
      _Q2.EmptyEditorGroup = new _Q2("EmptyEditorGroup");
      _Q2.EmptyEditorGroupContext = new _Q2("EmptyEditorGroupContext");
      _Q2.EditorTabsBarContext = new _Q2("EditorTabsBarContext");
      _Q2.EditorTabsBarShowTabsSubmenu = new _Q2("EditorTabsBarShowTabsSubmenu");
      _Q2.EditorTabsBarShowTabsZenModeSubmenu = new _Q2("EditorTabsBarShowTabsZenModeSubmenu");
      _Q2.EditorActionsPositionSubmenu = new _Q2("EditorActionsPositionSubmenu");
      _Q2.ExplorerContext = new _Q2("ExplorerContext");
      _Q2.ExplorerContextShare = new _Q2("ExplorerContextShare");
      _Q2.ExtensionContext = new _Q2("ExtensionContext");
      _Q2.GlobalActivity = new _Q2("GlobalActivity");
      _Q2.CommandCenter = new _Q2("CommandCenter");
      _Q2.CommandCenterCenter = new _Q2("CommandCenterCenter");
      _Q2.LayoutControlMenuSubmenu = new _Q2("LayoutControlMenuSubmenu");
      _Q2.LayoutControlMenu = new _Q2("LayoutControlMenu");
      _Q2.MenubarMainMenu = new _Q2("MenubarMainMenu");
      _Q2.MenubarAppearanceMenu = new _Q2("MenubarAppearanceMenu");
      _Q2.MenubarDebugMenu = new _Q2("MenubarDebugMenu");
      _Q2.MenubarEditMenu = new _Q2("MenubarEditMenu");
      _Q2.MenubarCopy = new _Q2("MenubarCopy");
      _Q2.MenubarFileMenu = new _Q2("MenubarFileMenu");
      _Q2.MenubarGoMenu = new _Q2("MenubarGoMenu");
      _Q2.MenubarHelpMenu = new _Q2("MenubarHelpMenu");
      _Q2.MenubarLayoutMenu = new _Q2("MenubarLayoutMenu");
      _Q2.MenubarNewBreakpointMenu = new _Q2("MenubarNewBreakpointMenu");
      _Q2.PanelAlignmentMenu = new _Q2("PanelAlignmentMenu");
      _Q2.PanelPositionMenu = new _Q2("PanelPositionMenu");
      _Q2.ActivityBarPositionMenu = new _Q2("ActivityBarPositionMenu");
      _Q2.MenubarPreferencesMenu = new _Q2("MenubarPreferencesMenu");
      _Q2.MenubarRecentMenu = new _Q2("MenubarRecentMenu");
      _Q2.MenubarSelectionMenu = new _Q2("MenubarSelectionMenu");
      _Q2.MenubarShare = new _Q2("MenubarShare");
      _Q2.MenubarSwitchEditorMenu = new _Q2("MenubarSwitchEditorMenu");
      _Q2.MenubarSwitchGroupMenu = new _Q2("MenubarSwitchGroupMenu");
      _Q2.MenubarTerminalMenu = new _Q2("MenubarTerminalMenu");
      _Q2.MenubarViewMenu = new _Q2("MenubarViewMenu");
      _Q2.MenubarHomeMenu = new _Q2("MenubarHomeMenu");
      _Q2.OpenEditorsContext = new _Q2("OpenEditorsContext");
      _Q2.OpenEditorsContextShare = new _Q2("OpenEditorsContextShare");
      _Q2.ProblemsPanelContext = new _Q2("ProblemsPanelContext");
      _Q2.SCMInputBox = new _Q2("SCMInputBox");
      _Q2.SCMChangesSeparator = new _Q2("SCMChangesSeparator");
      _Q2.SCMChangesContext = new _Q2("SCMChangesContext");
      _Q2.SCMIncomingChanges = new _Q2("SCMIncomingChanges");
      _Q2.SCMIncomingChangesContext = new _Q2("SCMIncomingChangesContext");
      _Q2.SCMIncomingChangesSetting = new _Q2("SCMIncomingChangesSetting");
      _Q2.SCMOutgoingChanges = new _Q2("SCMOutgoingChanges");
      _Q2.SCMOutgoingChangesContext = new _Q2("SCMOutgoingChangesContext");
      _Q2.SCMOutgoingChangesSetting = new _Q2("SCMOutgoingChangesSetting");
      _Q2.SCMIncomingChangesAllChangesContext = new _Q2("SCMIncomingChangesAllChangesContext");
      _Q2.SCMIncomingChangesHistoryItemContext = new _Q2("SCMIncomingChangesHistoryItemContext");
      _Q2.SCMOutgoingChangesAllChangesContext = new _Q2("SCMOutgoingChangesAllChangesContext");
      _Q2.SCMOutgoingChangesHistoryItemContext = new _Q2("SCMOutgoingChangesHistoryItemContext");
      _Q2.SCMChangeContext = new _Q2("SCMChangeContext");
      _Q2.SCMResourceContext = new _Q2("SCMResourceContext");
      _Q2.SCMResourceContextShare = new _Q2("SCMResourceContextShare");
      _Q2.SCMResourceFolderContext = new _Q2("SCMResourceFolderContext");
      _Q2.SCMResourceGroupContext = new _Q2("SCMResourceGroupContext");
      _Q2.SCMSourceControl = new _Q2("SCMSourceControl");
      _Q2.SCMSourceControlInline = new _Q2("SCMSourceControlInline");
      _Q2.SCMSourceControlTitle = new _Q2("SCMSourceControlTitle");
      _Q2.SCMHistoryTitle = new _Q2("SCMHistoryTitle");
      _Q2.SCMTitle = new _Q2("SCMTitle");
      _Q2.SearchContext = new _Q2("SearchContext");
      _Q2.SearchActionMenu = new _Q2("SearchActionContext");
      _Q2.StatusBarWindowIndicatorMenu = new _Q2("StatusBarWindowIndicatorMenu");
      _Q2.StatusBarRemoteIndicatorMenu = new _Q2("StatusBarRemoteIndicatorMenu");
      _Q2.StickyScrollContext = new _Q2("StickyScrollContext");
      _Q2.TestItem = new _Q2("TestItem");
      _Q2.TestItemGutter = new _Q2("TestItemGutter");
      _Q2.TestProfilesContext = new _Q2("TestProfilesContext");
      _Q2.TestMessageContext = new _Q2("TestMessageContext");
      _Q2.TestMessageContent = new _Q2("TestMessageContent");
      _Q2.TestPeekElement = new _Q2("TestPeekElement");
      _Q2.TestPeekTitle = new _Q2("TestPeekTitle");
      _Q2.TestCallStack = new _Q2("TestCallStack");
      _Q2.TouchBarContext = new _Q2("TouchBarContext");
      _Q2.TitleBarContext = new _Q2("TitleBarContext");
      _Q2.TitleBarTitleContext = new _Q2("TitleBarTitleContext");
      _Q2.TunnelContext = new _Q2("TunnelContext");
      _Q2.TunnelPrivacy = new _Q2("TunnelPrivacy");
      _Q2.TunnelProtocol = new _Q2("TunnelProtocol");
      _Q2.TunnelPortInline = new _Q2("TunnelInline");
      _Q2.TunnelTitle = new _Q2("TunnelTitle");
      _Q2.TunnelLocalAddressInline = new _Q2("TunnelLocalAddressInline");
      _Q2.TunnelOriginInline = new _Q2("TunnelOriginInline");
      _Q2.ViewItemContext = new _Q2("ViewItemContext");
      _Q2.ViewContainerTitle = new _Q2("ViewContainerTitle");
      _Q2.ViewContainerTitleContext = new _Q2("ViewContainerTitleContext");
      _Q2.ViewTitle = new _Q2("ViewTitle");
      _Q2.ViewTitleContext = new _Q2("ViewTitleContext");
      _Q2.CommentEditorActions = new _Q2("CommentEditorActions");
      _Q2.CommentThreadTitle = new _Q2("CommentThreadTitle");
      _Q2.CommentThreadActions = new _Q2("CommentThreadActions");
      _Q2.CommentThreadAdditionalActions = new _Q2("CommentThreadAdditionalActions");
      _Q2.CommentThreadTitleContext = new _Q2("CommentThreadTitleContext");
      _Q2.CommentThreadCommentContext = new _Q2("CommentThreadCommentContext");
      _Q2.CommentTitle = new _Q2("CommentTitle");
      _Q2.CommentActions = new _Q2("CommentActions");
      _Q2.CommentsViewThreadActions = new _Q2("CommentsViewThreadActions");
      _Q2.InteractiveToolbar = new _Q2("InteractiveToolbar");
      _Q2.InteractiveCellTitle = new _Q2("InteractiveCellTitle");
      _Q2.InteractiveCellDelete = new _Q2("InteractiveCellDelete");
      _Q2.InteractiveCellExecute = new _Q2("InteractiveCellExecute");
      _Q2.InteractiveInputExecute = new _Q2("InteractiveInputExecute");
      _Q2.InteractiveInputConfig = new _Q2("InteractiveInputConfig");
      _Q2.ReplInputExecute = new _Q2("ReplInputExecute");
      _Q2.IssueReporter = new _Q2("IssueReporter");
      _Q2.NotebookToolbar = new _Q2("NotebookToolbar");
      _Q2.NotebookStickyScrollContext = new _Q2("NotebookStickyScrollContext");
      _Q2.NotebookCellTitle = new _Q2("NotebookCellTitle");
      _Q2.NotebookCellDelete = new _Q2("NotebookCellDelete");
      _Q2.NotebookCellInsert = new _Q2("NotebookCellInsert");
      _Q2.NotebookCellBetween = new _Q2("NotebookCellBetween");
      _Q2.NotebookCellListTop = new _Q2("NotebookCellTop");
      _Q2.NotebookCellExecute = new _Q2("NotebookCellExecute");
      _Q2.NotebookCellExecuteGoTo = new _Q2("NotebookCellExecuteGoTo");
      _Q2.NotebookCellExecutePrimary = new _Q2("NotebookCellExecutePrimary");
      _Q2.NotebookDiffCellInputTitle = new _Q2("NotebookDiffCellInputTitle");
      _Q2.NotebookDiffCellMetadataTitle = new _Q2("NotebookDiffCellMetadataTitle");
      _Q2.NotebookDiffCellOutputsTitle = new _Q2("NotebookDiffCellOutputsTitle");
      _Q2.NotebookOutputToolbar = new _Q2("NotebookOutputToolbar");
      _Q2.NotebookOutlineFilter = new _Q2("NotebookOutlineFilter");
      _Q2.NotebookOutlineActionMenu = new _Q2("NotebookOutlineActionMenu");
      _Q2.NotebookEditorLayoutConfigure = new _Q2("NotebookEditorLayoutConfigure");
      _Q2.NotebookKernelSource = new _Q2("NotebookKernelSource");
      _Q2.BulkEditTitle = new _Q2("BulkEditTitle");
      _Q2.BulkEditContext = new _Q2("BulkEditContext");
      _Q2.TimelineItemContext = new _Q2("TimelineItemContext");
      _Q2.TimelineTitle = new _Q2("TimelineTitle");
      _Q2.TimelineTitleContext = new _Q2("TimelineTitleContext");
      _Q2.TimelineFilterSubMenu = new _Q2("TimelineFilterSubMenu");
      _Q2.AccountsContext = new _Q2("AccountsContext");
      _Q2.SidebarTitle = new _Q2("SidebarTitle");
      _Q2.PanelTitle = new _Q2("PanelTitle");
      _Q2.AuxiliaryBarTitle = new _Q2("AuxiliaryBarTitle");
      _Q2.AuxiliaryBarHeader = new _Q2("AuxiliaryBarHeader");
      _Q2.TerminalInstanceContext = new _Q2("TerminalInstanceContext");
      _Q2.TerminalEditorInstanceContext = new _Q2("TerminalEditorInstanceContext");
      _Q2.TerminalNewDropdownContext = new _Q2("TerminalNewDropdownContext");
      _Q2.TerminalTabContext = new _Q2("TerminalTabContext");
      _Q2.TerminalTabEmptyAreaContext = new _Q2("TerminalTabEmptyAreaContext");
      _Q2.TerminalStickyScrollContext = new _Q2("TerminalStickyScrollContext");
      _Q2.WebviewContext = new _Q2("WebviewContext");
      _Q2.InlineCompletionsActions = new _Q2("InlineCompletionsActions");
      _Q2.InlineEditsActions = new _Q2("InlineEditsActions");
      _Q2.InlineEditActions = new _Q2("InlineEditActions");
      _Q2.NewFile = new _Q2("NewFile");
      _Q2.MergeInput1Toolbar = new _Q2("MergeToolbar1Toolbar");
      _Q2.MergeInput2Toolbar = new _Q2("MergeToolbar2Toolbar");
      _Q2.MergeBaseToolbar = new _Q2("MergeBaseToolbar");
      _Q2.MergeInputResultToolbar = new _Q2("MergeToolbarResultToolbar");
      _Q2.InlineSuggestionToolbar = new _Q2("InlineSuggestionToolbar");
      _Q2.InlineEditToolbar = new _Q2("InlineEditToolbar");
      _Q2.ChatContext = new _Q2("ChatContext");
      _Q2.ChatCodeBlock = new _Q2("ChatCodeblock");
      _Q2.ChatCompareBlock = new _Q2("ChatCompareBlock");
      _Q2.ChatMessageTitle = new _Q2("ChatMessageTitle");
      _Q2.ChatExecute = new _Q2("ChatExecute");
      _Q2.ChatExecuteSecondary = new _Q2("ChatExecuteSecondary");
      _Q2.ChatInputSide = new _Q2("ChatInputSide");
      _Q2.AccessibleView = new _Q2("AccessibleView");
      _Q2.MultiDiffEditorFileToolbar = new _Q2("MultiDiffEditorFileToolbar");
      _Q2.DiffEditorHunkToolbar = new _Q2("DiffEditorHunkToolbar");
      _Q2.DiffEditorSelectionToolbar = new _Q2("DiffEditorSelectionToolbar");
      let Q = _Q2;
      const Zh = pt("menuService");
      const _Ac = class _Ac {
        static for(e) {
          let t = this._all.get(e);
          return t || (t = new _Ac(e), this._all.set(e, t)), t;
        }
        static merge(e) {
          const t = /* @__PURE__ */ new Set();
          for (const i of e) i instanceof _Ac && t.add(i.id);
          return t;
        }
        constructor(e) {
          this.id = e, this.has = (t) => t === e;
        }
      };
      _Ac._all = /* @__PURE__ */ new Map();
      let Ac = _Ac;
      const sg = new class {
        constructor() {
          this._commands = /* @__PURE__ */ new Map(), this._menuItems = /* @__PURE__ */ new Map(), this._onDidChangeMenu = new $$({
            merge: Ac.merge
          }), this.onDidChangeMenu = this._onDidChangeMenu.event;
        }
        addCommand(s) {
          return this._commands.set(s.id, s), this._onDidChangeMenu.fire(Ac.for(Q.CommandPalette)), Ze(() => {
            this._commands.delete(s.id) && this._onDidChangeMenu.fire(Ac.for(Q.CommandPalette));
          });
        }
        getCommand(s) {
          return this._commands.get(s);
        }
        getCommands() {
          const s = /* @__PURE__ */ new Map();
          return this._commands.forEach((e, t) => s.set(t, e)), s;
        }
        appendMenuItem(s, e) {
          let t = this._menuItems.get(s);
          t || (t = new Us(), this._menuItems.set(s, t));
          const i = t.push(e);
          return this._onDidChangeMenu.fire(Ac.for(s)), Ze(() => {
            i(), this._onDidChangeMenu.fire(Ac.for(s));
          });
        }
        appendMenuItems(s) {
          const e = new Me();
          for (const { id: t, item: i } of s) e.add(this.appendMenuItem(t, i));
          return e;
        }
        getMenuItems(s) {
          let e;
          return this._menuItems.has(s) ? e = [
            ...this._menuItems.get(s)
          ] : e = [], s === Q.CommandPalette && this._appendImplicitItems(e), e;
        }
        _appendImplicitItems(s) {
          const e = /* @__PURE__ */ new Set();
          for (const t of s) bp(t) && (e.add(t.command.id), t.alt && e.add(t.alt.id));
          this._commands.forEach((t, i) => {
            e.has(i) || s.push({
              command: t
            });
          });
        }
      }();
      class vp extends KC {
        constructor(e, t, i) {
          super(`submenuitem.${e.submenu.id}`, typeof e.title == "string" ? e.title : e.title.value, i, "submenu"), this.item = e, this.hideActions = t;
        }
      }
      let Fl = b0 = class {
        static label(e, t) {
          return (t == null ? void 0 : t.renderShortTitle) && e.shortTitle ? typeof e.shortTitle == "string" ? e.shortTitle : e.shortTitle.value : typeof e.title == "string" ? e.title : e.title.value;
        }
        constructor(e, t, i, n, o, r, a) {
          var _a3;
          this.hideActions = n, this.menuKeybinding = o, this._commandService = a, this.id = e.id, this.label = b0.label(e, i), this.tooltip = (typeof e.tooltip == "string" ? e.tooltip : (_a3 = e.tooltip) == null ? void 0 : _a3.value) ?? "", this.enabled = !e.precondition || r.contextMatchesRules(e.precondition), this.checked = void 0;
          let l;
          if (e.toggled) {
            const u = e.toggled.condition ? e.toggled : {
              condition: e.toggled
            };
            this.checked = r.contextMatchesRules(u.condition), this.checked && u.tooltip && (this.tooltip = typeof u.tooltip == "string" ? u.tooltip : u.tooltip.value), this.checked && wt.isThemeIcon(u.icon) && (l = u.icon), this.checked && u.title && (this.label = typeof u.title == "string" ? u.title : u.title.value);
          }
          l || (l = wt.isThemeIcon(e.icon) ? e.icon : void 0), this.item = e, this.alt = t ? new b0(t, void 0, i, n, void 0, r, a) : void 0, this._options = i, this.class = l && wt.asClassName(l);
        }
        run(...e) {
          var _a3, _b3;
          let t = [];
          return ((_a3 = this._options) == null ? void 0 : _a3.arg) && (t = [
            ...t,
            this._options.arg
          ]), ((_b3 = this._options) == null ? void 0 : _b3.shouldForwardArgs) && (t = [
            ...t,
            ...e
          ]), this._commandService.executeCommand(this.id, ...t);
        }
      };
      Fl = b0 = Sj([
        mO(5, Mt),
        mO(6, po)
      ], Fl);
      const Qh = pt("telemetryService"), Xr = pt("logService");
      var ks;
      (function(s) {
        s[s.Off = 0] = "Off", s[s.Trace = 1] = "Trace", s[s.Debug = 2] = "Debug", s[s.Info = 3] = "Info", s[s.Warning = 4] = "Warning", s[s.Error = 5] = "Error";
      })(ks || (ks = {}));
      const o8 = ks.Info;
      class r8 extends he {
        constructor() {
          super(...arguments), this.level = o8, this._onDidChangeLogLevel = this._register(new G()), this.onDidChangeLogLevel = this._onDidChangeLogLevel.event;
        }
        setLevel(e) {
          this.level !== e && (this.level = e, this._onDidChangeLogLevel.fire(this.level));
        }
        getLevel() {
          return this.level;
        }
        checkLogLevel(e) {
          return this.level !== ks.Off && this.level <= e;
        }
      }
      class xj extends r8 {
        constructor(e = o8, t = true) {
          super(), this.useColors = t, this.setLevel(e);
        }
        trace(e, ...t) {
          this.checkLogLevel(ks.Trace) && (this.useColors ? console.log("%cTRACE", "color: #888", e, ...t) : console.log(e, ...t));
        }
        debug(e, ...t) {
          this.checkLogLevel(ks.Debug) && (this.useColors ? console.log("%cDEBUG", "background: #eee; color: #888", e, ...t) : console.log(e, ...t));
        }
        info(e, ...t) {
          this.checkLogLevel(ks.Info) && (this.useColors ? console.log("%c INFO", "color: #33f", e, ...t) : console.log(e, ...t));
        }
        warn(e, ...t) {
          this.checkLogLevel(ks.Warning) && (this.useColors ? console.log("%c WARN", "color: #993", e, ...t) : console.log(e, ...t));
        }
        error(e, ...t) {
          this.checkLogLevel(ks.Error) && (this.useColors ? console.log("%c  ERR", "color: #f33", e, ...t) : console.error(e, ...t));
        }
      }
      class kj extends r8 {
        constructor(e) {
          super(), this.loggers = e, e.length && this.setLevel(e[0].getLevel());
        }
        setLevel(e) {
          for (const t of this.loggers) t.setLevel(e);
          super.setLevel(e);
        }
        trace(e, ...t) {
          for (const i of this.loggers) i.trace(e, ...t);
        }
        debug(e, ...t) {
          for (const i of this.loggers) i.debug(e, ...t);
        }
        info(e, ...t) {
          for (const i of this.loggers) i.info(e, ...t);
        }
        warn(e, ...t) {
          for (const i of this.loggers) i.warn(e, ...t);
        }
        error(e, ...t) {
          for (const i of this.loggers) i.error(e, ...t);
        }
        dispose() {
          for (const e of this.loggers) e.dispose();
          super.dispose();
        }
      }
      function Dj(s) {
        switch (s) {
          case ks.Trace:
            return "trace";
          case ks.Debug:
            return "debug";
          case ks.Info:
            return "info";
          case ks.Warning:
            return "warn";
          case ks.Error:
            return "error";
          case ks.Off:
            return "off";
        }
      }
      new Ie("logLevel", Dj(ks.Info));
      class tw {
        constructor(e) {
          this.id = e.id, this.precondition = e.precondition, this._kbOpts = e.kbOpts, this._menuOpts = e.menuOpts, this.metadata = e.metadata;
        }
        register() {
          if (Array.isArray(this._menuOpts) ? this._menuOpts.forEach(this._registerMenuItem, this) : this._menuOpts && this._registerMenuItem(this._menuOpts), this._kbOpts) {
            const e = Array.isArray(this._kbOpts) ? this._kbOpts : [
              this._kbOpts
            ];
            for (const t of e) {
              let i = t.kbExpr;
              this.precondition && (i ? i = Ot.and(i, this.precondition) : i = this.precondition);
              const n = {
                id: this.id,
                weight: t.weight,
                args: t.args,
                when: i,
                primary: t.primary,
                secondary: t.secondary,
                win: t.win,
                linux: t.linux,
                mac: t.mac
              };
              z_.registerKeybindingRule(n);
            }
          }
          Os.registerCommand({
            id: this.id,
            handler: (e, t) => this.runCommand(e, t),
            metadata: this.metadata
          });
        }
        _registerMenuItem(e) {
          sg.appendMenuItem(e.menuId, {
            group: e.group,
            command: {
              id: this.id,
              title: e.title,
              icon: e.icon,
              precondition: this.precondition
            },
            when: e.when,
            order: e.order
          });
        }
      }
      class _T extends tw {
        constructor() {
          super(...arguments), this._implementations = [];
        }
        addImplementation(e, t, i, n) {
          return this._implementations.push({
            priority: e,
            name: t,
            implementation: i,
            when: n
          }), this._implementations.sort((o, r) => r.priority - o.priority), {
            dispose: () => {
              for (let o = 0; o < this._implementations.length; o++) if (this._implementations[o].implementation === i) {
                this._implementations.splice(o, 1);
                return;
              }
            }
          };
        }
        runCommand(e, t) {
          const i = e.get(Xr), n = e.get(Mt);
          i.trace(`Executing Command '${this.id}' which has ${this._implementations.length} bound.`);
          for (const o of this._implementations) {
            if (o.when) {
              const a = n.getContext(ss());
              if (!o.when.evaluate(a)) continue;
            }
            const r = o.implementation(e, t);
            if (r) return i.trace(`Command '${this.id}' was handled by '${o.name}'.`), typeof r == "boolean" ? void 0 : r;
          }
          i.trace(`The Command '${this.id}' was not handled by any implementation.`);
        }
      }
      class a8 extends tw {
        constructor(e, t) {
          super(t), this.command = e;
        }
        runCommand(e, t) {
          return this.command.runCommand(e, t);
        }
      }
      class Ph extends tw {
        static bindToContribution(e) {
          return class extends Ph {
            constructor(i) {
              super(i), this._callback = i.handler;
            }
            runEditorCommand(i, n, o) {
              const r = e(n);
              r && this._callback(r, o);
            }
          };
        }
        static runEditorCommand(e, t, i, n) {
          const o = e.get(Xi), r = o.getFocusedCodeEditor() || o.getActiveCodeEditor();
          if (r) return r.invokeWithinContext((a) => {
            if (a.get(Mt).contextMatchesRules(i ?? void 0)) return n(a, r, t);
          });
        }
        runCommand(e, t) {
          return Ph.runEditorCommand(e, t, this.precondition, (i, n, o) => this.runEditorCommand(i, n, o));
        }
      }
      function Ge(s) {
        return La.INSTANCE.registerEditorCommand(s), s;
      }
      function l8(s, e, t) {
        La.INSTANCE.registerEditorContribution(s, e, t);
      }
      var Rf;
      (function(s) {
        function e(r) {
          return La.INSTANCE.getEditorCommand(r);
        }
        s.getEditorCommand = e;
        function t() {
          return La.INSTANCE.getEditorActions();
        }
        s.getEditorActions = t;
        function i() {
          return La.INSTANCE.getEditorContributions();
        }
        s.getEditorContributions = i;
        function n(r) {
          return La.INSTANCE.getEditorContributions().filter((a) => r.indexOf(a.id) >= 0);
        }
        s.getSomeEditorContributions = n;
        function o() {
          return La.INSTANCE.getDiffEditorContributions();
        }
        s.getDiffEditorContributions = o;
      })(Rf || (Rf = {}));
      const Ej = {
        EditorCommonContributions: "editor.contributions"
      };
      const _La = class _La {
        constructor() {
          this.editorContributions = [], this.diffEditorContributions = [], this.editorActions = [], this.editorCommands = /* @__PURE__ */ Object.create(null);
        }
        registerEditorContribution(e, t, i) {
          this.editorContributions.push({
            id: e,
            ctor: t,
            instantiation: i
          });
        }
        getEditorContributions() {
          return this.editorContributions.slice(0);
        }
        getDiffEditorContributions() {
          return this.diffEditorContributions.slice(0);
        }
        registerEditorAction(e) {
          e.register(), this.editorActions.push(e);
        }
        getEditorActions() {
          return this.editorActions;
        }
        registerEditorCommand(e) {
          e.register(), this.editorCommands[e.id] = e;
        }
        getEditorCommand(e) {
          return this.editorCommands[e] || null;
        }
      };
      _La.INSTANCE = new _La();
      let La = _La;
      yn.add(Ej.EditorCommonContributions, La.INSTANCE);
      function U_(s) {
        return s.register(), s;
      }
      const c8 = U_(new _T({
        id: "undo",
        precondition: void 0,
        kbOpts: {
          weight: 0,
          primary: 2104
        },
        menuOpts: [
          {
            menuId: Q.MenubarEditMenu,
            group: "1_do",
            title: C({
              key: "miUndo",
              comment: [
                "&& denotes a mnemonic"
              ]
            }, "&&Undo"),
            order: 1
          },
          {
            menuId: Q.CommandPalette,
            group: "",
            title: C("undo", "Undo"),
            order: 1
          }
        ]
      }));
      U_(new a8(c8, {
        id: "default:undo",
        precondition: void 0
      }));
      const u8 = U_(new _T({
        id: "redo",
        precondition: void 0,
        kbOpts: {
          weight: 0,
          primary: 2103,
          secondary: [
            3128
          ],
          mac: {
            primary: 3128
          }
        },
        menuOpts: [
          {
            menuId: Q.MenubarEditMenu,
            group: "1_do",
            title: C({
              key: "miRedo",
              comment: [
                "&& denotes a mnemonic"
              ]
            }, "&&Redo"),
            order: 2
          },
          {
            menuId: Q.CommandPalette,
            group: "",
            title: C("redo", "Redo"),
            order: 1
          }
        ]
      }));
      U_(new a8(u8, {
        id: "default:redo",
        precondition: void 0
      }));
      const Tj = U_(new _T({
        id: "editor.action.selectAll",
        precondition: void 0,
        kbOpts: {
          weight: 0,
          kbExpr: null,
          primary: 2079
        },
        menuOpts: [
          {
            menuId: Q.MenubarSelectionMenu,
            group: "1_basic",
            title: C({
              key: "miSelectAll",
              comment: [
                "&& denotes a mnemonic"
              ]
            }, "&&Select All"),
            order: 1
          },
          {
            menuId: Q.CommandPalette,
            group: "",
            title: C("selectAll", "Select All"),
            order: 1
          }
        ]
      })), pO = "default", Nj = "$initialize";
      let _O = false;
      function Qk(s) {
        yg && (_O || (_O = true, console.warn("Could not create web worker(s). Falling back to loading web worker code in main thread, which might cause UI freezes. Please see https://github.com/microsoft/monaco-editor#faq")), console.warn(s.message));
      }
      class Ij {
        constructor(e, t, i, n, o) {
          this.vsWorker = e, this.req = t, this.channel = i, this.method = n, this.args = o, this.type = 0;
        }
      }
      class bO {
        constructor(e, t, i, n) {
          this.vsWorker = e, this.seq = t, this.res = i, this.err = n, this.type = 1;
        }
      }
      class Mj {
        constructor(e, t, i, n, o) {
          this.vsWorker = e, this.req = t, this.channel = i, this.eventName = n, this.arg = o, this.type = 2;
        }
      }
      class Aj {
        constructor(e, t, i) {
          this.vsWorker = e, this.req = t, this.event = i, this.type = 3;
        }
      }
      class Rj {
        constructor(e, t) {
          this.vsWorker = e, this.req = t, this.type = 4;
        }
      }
      class Oj {
        constructor(e) {
          this._workerId = -1, this._handler = e, this._lastSentReq = 0, this._pendingReplies = /* @__PURE__ */ Object.create(null), this._pendingEmitters = /* @__PURE__ */ new Map(), this._pendingEvents = /* @__PURE__ */ new Map();
        }
        setWorkerId(e) {
          this._workerId = e;
        }
        sendMessage(e, t, i) {
          const n = String(++this._lastSentReq);
          return new Promise((o, r) => {
            this._pendingReplies[n] = {
              resolve: o,
              reject: r
            }, this._send(new Ij(this._workerId, n, e, t, i));
          });
        }
        listen(e, t, i) {
          let n = null;
          const o = new G({
            onWillAddFirstListener: () => {
              n = String(++this._lastSentReq), this._pendingEmitters.set(n, o), this._send(new Mj(this._workerId, n, e, t, i));
            },
            onDidRemoveLastListener: () => {
              this._pendingEmitters.delete(n), this._send(new Rj(this._workerId, n)), n = null;
            }
          });
          return o.event;
        }
        handleMessage(e) {
          !e || !e.vsWorker || this._workerId !== -1 && e.vsWorker !== this._workerId || this._handleMessage(e);
        }
        createProxyToRemoteChannel(e, t) {
          const i = {
            get: (n, o) => (typeof o == "string" && !n[o] && (d8(o) ? n[o] = (r) => this.listen(e, o, r) : h8(o) ? n[o] = this.listen(e, o, void 0) : o.charCodeAt(0) === 36 && (n[o] = async (...r) => (await (t == null ? void 0 : t()), this.sendMessage(e, o, r)))), n[o])
          };
          return new Proxy(/* @__PURE__ */ Object.create(null), i);
        }
        _handleMessage(e) {
          switch (e.type) {
            case 1:
              return this._handleReplyMessage(e);
            case 0:
              return this._handleRequestMessage(e);
            case 2:
              return this._handleSubscribeEventMessage(e);
            case 3:
              return this._handleEventMessage(e);
            case 4:
              return this._handleUnsubscribeEventMessage(e);
          }
        }
        _handleReplyMessage(e) {
          if (!this._pendingReplies[e.seq]) {
            console.warn("Got reply to unknown seq");
            return;
          }
          const t = this._pendingReplies[e.seq];
          if (delete this._pendingReplies[e.seq], e.err) {
            let i = e.err;
            e.err.$isError && (i = new Error(), i.name = e.err.name, i.message = e.err.message, i.stack = e.err.stack), t.reject(i);
            return;
          }
          t.resolve(e.res);
        }
        _handleRequestMessage(e) {
          const t = e.req;
          this._handler.handleMessage(e.channel, e.method, e.args).then((n) => {
            this._send(new bO(this._workerId, t, n, void 0));
          }, (n) => {
            n.detail instanceof Error && (n.detail = T4(n.detail)), this._send(new bO(this._workerId, t, void 0, T4(n)));
          });
        }
        _handleSubscribeEventMessage(e) {
          const t = e.req, i = this._handler.handleEvent(e.channel, e.eventName, e.arg)((n) => {
            this._send(new Aj(this._workerId, t, n));
          });
          this._pendingEvents.set(t, i);
        }
        _handleEventMessage(e) {
          if (!this._pendingEmitters.has(e.req)) {
            console.warn("Got event for unknown req");
            return;
          }
          this._pendingEmitters.get(e.req).fire(e.event);
        }
        _handleUnsubscribeEventMessage(e) {
          if (!this._pendingEvents.has(e.req)) {
            console.warn("Got unsubscribe for unknown req");
            return;
          }
          this._pendingEvents.get(e.req).dispose(), this._pendingEvents.delete(e.req);
        }
        _send(e) {
          const t = [];
          if (e.type === 0) for (let i = 0; i < e.args.length; i++) e.args[i] instanceof ArrayBuffer && t.push(e.args[i]);
          else e.type === 1 && e.res instanceof ArrayBuffer && t.push(e.res);
          this._handler.sendMessage(e, t);
        }
      }
      class Pj extends he {
        constructor(e, t) {
          super(), this._localChannels = /* @__PURE__ */ new Map(), this._worker = this._register(e.create({
            amdModuleId: "vs/base/common/worker/simpleWorker",
            esmModuleLocation: t.esmModuleLocation,
            label: t.label
          }, (o) => {
            this._protocol.handleMessage(o);
          }, (o) => {
            qt(o);
          })), this._protocol = new Oj({
            sendMessage: (o, r) => {
              this._worker.postMessage(o, r);
            },
            handleMessage: (o, r, a) => this._handleMessage(o, r, a),
            handleEvent: (o, r, a) => this._handleEvent(o, r, a)
          }), this._protocol.setWorkerId(this._worker.getId());
          let i = null;
          const n = globalThis.require;
          typeof n < "u" && typeof n.getConfig == "function" ? i = n.getConfig() : typeof globalThis.requirejs < "u" && (i = globalThis.requirejs.s.contexts._.config), this._onModuleLoaded = this._protocol.sendMessage(pO, Nj, [
            this._worker.getId(),
            JSON.parse(JSON.stringify(i)),
            t.amdModuleId
          ]), this.proxy = this._protocol.createProxyToRemoteChannel(pO, async () => {
            await this._onModuleLoaded;
          }), this._onModuleLoaded.catch((o) => {
            this._onError("Worker failed to load " + t.amdModuleId, o);
          });
        }
        _handleMessage(e, t, i) {
          const n = this._localChannels.get(e);
          if (!n) return Promise.reject(new Error(`Missing channel ${e} on main thread`));
          if (typeof n[t] != "function") return Promise.reject(new Error(`Missing method ${t} on main thread channel ${e}`));
          try {
            return Promise.resolve(n[t].apply(n, i));
          } catch (o) {
            return Promise.reject(o);
          }
        }
        _handleEvent(e, t, i) {
          const n = this._localChannels.get(e);
          if (!n) throw new Error(`Missing channel ${e} on main thread`);
          if (d8(t)) {
            const o = n[t].call(n, i);
            if (typeof o != "function") throw new Error(`Missing dynamic event ${t} on main thread channel ${e}.`);
            return o;
          }
          if (h8(t)) {
            const o = n[t];
            if (typeof o != "function") throw new Error(`Missing event ${t} on main thread channel ${e}.`);
            return o;
          }
          throw new Error(`Malformed event name ${t}`);
        }
        setChannel(e, t) {
          this._localChannels.set(e, t);
        }
        _onError(e, t) {
          console.error(e), console.info(t);
        }
      }
      function h8(s) {
        return s[0] === "o" && s[1] === "n" && Ec(s.charCodeAt(2));
      }
      function d8(s) {
        return /^onDynamic/.test(s) && Ec(s.charCodeAt(9));
      }
      function Xh(s, e) {
        var _a3;
        const t = globalThis.MonacoEnvironment;
        if (t == null ? void 0 : t.createTrustedTypesPolicy) try {
          return t.createTrustedTypesPolicy(s, e);
        } catch (i) {
          qt(i);
          return;
        }
        try {
          return (_a3 = globalThis.trustedTypes) == null ? void 0 : _a3.createPolicy(s, e);
        } catch (i) {
          qt(i);
          return;
        }
      }
      let hf;
      typeof self == "object" && self.constructor && self.constructor.name === "DedicatedWorkerGlobalScope" && globalThis.workerttPolicy !== void 0 ? hf = globalThis.workerttPolicy : hf = Xh("defaultWorkerFactory", {
        createScriptURL: (s) => s
      });
      function Bj(s, e) {
        const t = globalThis.MonacoEnvironment;
        if (t) {
          if (typeof t.getWorker == "function") return t.getWorker("workerMain.js", e);
          if (typeof t.getWorkerUrl == "function") {
            const i = t.getWorkerUrl("workerMain.js", e);
            return new Worker(hf ? hf.createScriptURL(i) : i, {
              name: e,
              type: "module"
            });
          }
        }
        if (s) {
          const i = Fj(e, s.toString(true)), n = new Worker(hf ? hf.createScriptURL(i) : i, {
            name: e,
            type: "module"
          });
          return Vj(n);
        }
        throw new Error("You must define a function MonacoEnvironment.getWorkerUrl or MonacoEnvironment.getWorker");
      }
      function Fj(s, e, t) {
        if (!(/^((http:)|(https:)|(file:)|(vscode-file:))/.test(e) && e.substring(0, globalThis.origin.length) !== globalThis.origin)) {
          const o = e.lastIndexOf("?"), r = e.lastIndexOf("#", o), a = o > 0 ? new URLSearchParams(e.substring(o + 1, ~r ? r : void 0)) : new URLSearchParams();
          Uk.addSearchParam(a, true, true), a.toString() ? e = `${e}?${a.toString()}#${s}` : e = `${e}#${s}`;
        }
        const n = new Blob([
          NE([
            `/*${s}*/`,
            void 0,
            `globalThis._VSCODE_NLS_MESSAGES = ${JSON.stringify(Q7())};`,
            `globalThis._VSCODE_NLS_LANGUAGE = ${JSON.stringify(ME())};`,
            `globalThis._VSCODE_FILE_ROOT = '${globalThis._VSCODE_FILE_ROOT}';`,
            "const ttPolicy = globalThis.trustedTypes?.createPolicy('defaultWorkerFactory', { createScriptURL: value => value });",
            "globalThis.workerttPolicy = ttPolicy;",
            `await import(ttPolicy?.createScriptURL('${e}') ?? '${e}');`,
            "globalThis.postMessage({ type: 'vscode-worker-ready' });",
            `/*${s}*/`
          ]).join("")
        ], {
          type: "application/javascript"
        });
        return URL.createObjectURL(n);
      }
      function Vj(s) {
        return new Promise((e, t) => {
          s.onmessage = function(i) {
            i.data.type === "vscode-worker-ready" && (s.onmessage = null, e(s));
          }, s.onerror = t;
        });
      }
      function Wj(s) {
        return typeof s.then == "function";
      }
      class Hj extends he {
        constructor(e, t, i, n, o, r) {
          super(), this.id = i, this.label = n;
          const a = Bj(e, n);
          Wj(a) ? this.worker = a : this.worker = Promise.resolve(a), this.postMessage(t, []), this.worker.then((l) => {
            l.onmessage = function(u) {
              o(u.data);
            }, l.onmessageerror = r, typeof l.addEventListener == "function" && l.addEventListener("error", r);
          }), this._register(Ze(() => {
            var _a3;
            (_a3 = this.worker) == null ? void 0 : _a3.then((l) => {
              l.onmessage = null, l.onmessageerror = null, l.removeEventListener("error", r), l.terminate();
            }), this.worker = null;
          }));
        }
        getId() {
          return this.id;
        }
        postMessage(e, t) {
          var _a3;
          (_a3 = this.worker) == null ? void 0 : _a3.then((i) => {
            try {
              i.postMessage(e, t);
            } catch (n) {
              qt(n), qt(new Error(`FAILED to post message to '${this.label}'-worker`, {
                cause: n
              }));
            }
          });
        }
      }
      class zj {
        constructor(e, t) {
          this.amdModuleId = e, this.label = t, this.esmModuleLocation = zC.asBrowserUri(`${e}.esm.js`);
        }
      }
      const _bT = class _bT {
        constructor() {
          this._webWorkerFailedBeforeError = false;
        }
        create(e, t, i) {
          const n = ++_bT.LAST_WORKER_ID;
          if (this._webWorkerFailedBeforeError) throw this._webWorkerFailedBeforeError;
          return new Hj(e.esmModuleLocation, e.amdModuleId, n, e.label || "anonymous" + n, t, (o) => {
            Qk(o), this._webWorkerFailedBeforeError = o, i(o);
          });
        }
      };
      _bT.LAST_WORKER_ID = 0;
      let bT = _bT;
      function Uj(s, e) {
        const t = typeof s == "string" ? new zj(s, e) : s;
        return new Pj(new bT(), t);
      }
      var ds;
      (function(s) {
        s[s.None = 0] = "None", s[s.Indent = 1] = "Indent", s[s.IndentOutdent = 2] = "IndentOutdent", s[s.Outdent = 3] = "Outdent";
      })(ds || (ds = {}));
      class NL {
        constructor(e) {
          if (this._neutralCharacter = null, this._neutralCharacterSearched = false, this.open = e.open, this.close = e.close, this._inString = true, this._inComment = true, this._inRegEx = true, Array.isArray(e.notIn)) for (let t = 0, i = e.notIn.length; t < i; t++) switch (e.notIn[t]) {
            case "string":
              this._inString = false;
              break;
            case "comment":
              this._inComment = false;
              break;
            case "regex":
              this._inRegEx = false;
              break;
          }
        }
        isOK(e) {
          switch (e) {
            case 0:
              return true;
            case 1:
              return this._inComment;
            case 2:
              return this._inString;
            case 3:
              return this._inRegEx;
          }
        }
        shouldAutoClose(e, t) {
          if (e.getTokenCount() === 0) return true;
          const i = e.findTokenIndexAtOffset(t - 2), n = e.getStandardTokenType(i);
          return this.isOK(n);
        }
        _findNeutralCharacterInRange(e, t) {
          for (let i = e; i <= t; i++) {
            const n = String.fromCharCode(i);
            if (!this.open.includes(n) && !this.close.includes(n)) return n;
          }
          return null;
        }
        findNeutralCharacter() {
          return this._neutralCharacterSearched || (this._neutralCharacterSearched = true, this._neutralCharacter || (this._neutralCharacter = this._findNeutralCharacterInRange(48, 57)), this._neutralCharacter || (this._neutralCharacter = this._findNeutralCharacterInRange(97, 122)), this._neutralCharacter || (this._neutralCharacter = this._findNeutralCharacterInRange(65, 90))), this._neutralCharacter;
        }
      }
      class $j {
        constructor(e) {
          this.autoClosingPairsOpenByStart = /* @__PURE__ */ new Map(), this.autoClosingPairsOpenByEnd = /* @__PURE__ */ new Map(), this.autoClosingPairsCloseByStart = /* @__PURE__ */ new Map(), this.autoClosingPairsCloseByEnd = /* @__PURE__ */ new Map(), this.autoClosingPairsCloseSingleChar = /* @__PURE__ */ new Map();
          for (const t of e) Pm(this.autoClosingPairsOpenByStart, t.open.charAt(0), t), Pm(this.autoClosingPairsOpenByEnd, t.open.charAt(t.open.length - 1), t), Pm(this.autoClosingPairsCloseByStart, t.close.charAt(0), t), Pm(this.autoClosingPairsCloseByEnd, t.close.charAt(t.close.length - 1), t), t.close.length === 1 && t.open.length === 1 && Pm(this.autoClosingPairsCloseSingleChar, t.close, t);
        }
      }
      function Pm(s, e, t) {
        s.has(e) ? s.get(e).push(t) : s.set(e, [
          t
        ]);
      }
      const _av = class _av {
        constructor(e) {
          if (e.autoClosingPairs ? this._autoClosingPairs = e.autoClosingPairs.map((t) => new NL(t)) : e.brackets ? this._autoClosingPairs = e.brackets.map((t) => new NL({
            open: t[0],
            close: t[1]
          })) : this._autoClosingPairs = [], e.__electricCharacterSupport && e.__electricCharacterSupport.docComment) {
            const t = e.__electricCharacterSupport.docComment;
            this._autoClosingPairs.push(new NL({
              open: t.open,
              close: t.close || ""
            }));
          }
          this._autoCloseBeforeForQuotes = typeof e.autoCloseBefore == "string" ? e.autoCloseBefore : _av.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_QUOTES, this._autoCloseBeforeForBrackets = typeof e.autoCloseBefore == "string" ? e.autoCloseBefore : _av.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_BRACKETS, this._surroundingPairs = e.surroundingPairs || this._autoClosingPairs;
        }
        getAutoClosingPairs() {
          return this._autoClosingPairs;
        }
        getAutoCloseBeforeSet(e) {
          return e ? this._autoCloseBeforeForQuotes : this._autoCloseBeforeForBrackets;
        }
        getSurroundingPairs() {
          return this._surroundingPairs;
        }
      };
      _av.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_QUOTES = `;:.,=}])> 
	`;
      _av.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_BRACKETS = `'"\`;:.,=}])> 
	`;
      let av = _av;
      function gh(s, e) {
        const t = s.getCount(), i = s.findTokenIndexAtOffset(e), n = s.getLanguageId(i);
        let o = i;
        for (; o + 1 < t && s.getLanguageId(o + 1) === n; ) o++;
        let r = i;
        for (; r > 0 && s.getLanguageId(r - 1) === n; ) r--;
        return new qj(s, n, r, o + 1, s.getStartOffset(r), s.getEndOffset(o));
      }
      class qj {
        constructor(e, t, i, n, o, r) {
          this._scopedLineTokensBrand = void 0, this._actual = e, this.languageId = t, this._firstTokenIndex = i, this._lastTokenIndex = n, this.firstCharOffset = o, this._lastCharOffset = r, this.languageIdCodec = e.languageIdCodec;
        }
        getLineContent() {
          return this._actual.getLineContent().substring(this.firstCharOffset, this._lastCharOffset);
        }
        getLineLength() {
          return this._lastCharOffset - this.firstCharOffset;
        }
        getActualLineContentBefore(e) {
          return this._actual.getLineContent().substring(0, this.firstCharOffset + e);
        }
        getTokenCount() {
          return this._lastTokenIndex - this._firstTokenIndex;
        }
        findTokenIndexAtOffset(e) {
          return this._actual.findTokenIndexAtOffset(e + this.firstCharOffset) - this._firstTokenIndex;
        }
        getStandardTokenType(e) {
          return this._actual.getStandardTokenType(e + this._firstTokenIndex);
        }
        toIViewLineTokens() {
          return this._actual.sliceAndInflate(this.firstCharOffset, this._lastCharOffset, 0);
        }
      }
      function pa(s) {
        return (s & 3) !== 0;
      }
      const vO = typeof Buffer < "u";
      let IL;
      class vT {
        static wrap(e) {
          return vO && !Buffer.isBuffer(e) && (e = Buffer.from(e.buffer, e.byteOffset, e.byteLength)), new vT(e);
        }
        constructor(e) {
          this.buffer = e, this.byteLength = this.buffer.byteLength;
        }
        toString() {
          return vO ? this.buffer.toString() : (IL || (IL = new TextDecoder()), IL.decode(this.buffer));
        }
      }
      function Kj(s, e) {
        return s[e + 0] << 0 >>> 0 | s[e + 1] << 8 >>> 0;
      }
      function jj(s, e, t) {
        s[t + 0] = e & 255, e = e >>> 8, s[t + 1] = e & 255;
      }
      function Ar(s, e) {
        return s[e] * 2 ** 24 + s[e + 1] * 2 ** 16 + s[e + 2] * 2 ** 8 + s[e + 3];
      }
      function Rr(s, e, t) {
        s[t + 3] = e, e = e >>> 8, s[t + 2] = e, e = e >>> 8, s[t + 1] = e, e = e >>> 8, s[t] = e;
      }
      function CO(s, e) {
        return s[e];
      }
      function wO(s, e, t) {
        s[t] = e;
      }
      let ML;
      function f8() {
        return ML || (ML = new TextDecoder("UTF-16LE")), ML;
      }
      let AL;
      function Gj() {
        return AL || (AL = new TextDecoder("UTF-16BE")), AL;
      }
      let RL;
      function g8() {
        return RL || (RL = PU() ? f8() : Gj()), RL;
      }
      function Yj(s, e, t) {
        const i = new Uint16Array(s.buffer, e, t);
        return t > 0 && (i[0] === 65279 || i[0] === 65534) ? Zj(s, e, t) : f8().decode(i);
      }
      function Zj(s, e, t) {
        const i = [];
        let n = 0;
        for (let o = 0; o < t; o++) {
          const r = Kj(s, e);
          e += 2, i[n++] = String.fromCharCode(r);
        }
        return i.join("");
      }
      class iw {
        constructor(e) {
          this._capacity = e | 0, this._buffer = new Uint16Array(this._capacity), this._completedStrings = null, this._bufferLength = 0;
        }
        reset() {
          this._completedStrings = null, this._bufferLength = 0;
        }
        build() {
          return this._completedStrings !== null ? (this._flushBuffer(), this._completedStrings.join("")) : this._buildBuffer();
        }
        _buildBuffer() {
          if (this._bufferLength === 0) return "";
          const e = new Uint16Array(this._buffer.buffer, 0, this._bufferLength);
          return g8().decode(e);
        }
        _flushBuffer() {
          const e = this._buildBuffer();
          this._bufferLength = 0, this._completedStrings === null ? this._completedStrings = [
            e
          ] : this._completedStrings[this._completedStrings.length] = e;
        }
        appendCharCode(e) {
          const t = this._capacity - this._bufferLength;
          t <= 1 && (t === 0 || on(e)) && this._flushBuffer(), this._buffer[this._bufferLength++] = e;
        }
        appendASCIICharCode(e) {
          this._bufferLength === this._capacity && this._flushBuffer(), this._buffer[this._bufferLength++] = e;
        }
        appendString(e) {
          const t = e.length;
          if (this._bufferLength + t >= this._capacity) {
            this._flushBuffer(), this._completedStrings[this._completedStrings.length] = e;
            return;
          }
          for (let i = 0; i < t; i++) this._buffer[this._bufferLength++] = e.charCodeAt(i);
        }
      }
      class lv {
        constructor(e, t, i, n, o, r) {
          this._richEditBracketBrand = void 0, this.languageId = e, this.index = t, this.open = i, this.close = n, this.forwardRegex = o, this.reversedRegex = r, this._openSet = lv._toSet(this.open), this._closeSet = lv._toSet(this.close);
        }
        isOpen(e) {
          return this._openSet.has(e);
        }
        isClose(e) {
          return this._closeSet.has(e);
        }
        static _toSet(e) {
          const t = /* @__PURE__ */ new Set();
          for (const i of e) t.add(i);
          return t;
        }
      }
      function Qj(s) {
        const e = s.length;
        s = s.map((r) => [
          r[0].toLowerCase(),
          r[1].toLowerCase()
        ]);
        const t = [];
        for (let r = 0; r < e; r++) t[r] = r;
        const i = (r, a) => {
          const [l, u] = r, [d, f] = a;
          return l === d || l === f || u === d || u === f;
        }, n = (r, a) => {
          const l = Math.min(r, a), u = Math.max(r, a);
          for (let d = 0; d < e; d++) t[d] === u && (t[d] = l);
        };
        for (let r = 0; r < e; r++) {
          const a = s[r];
          for (let l = r + 1; l < e; l++) {
            const u = s[l];
            i(a, u) && n(t[r], t[l]);
          }
        }
        const o = [];
        for (let r = 0; r < e; r++) {
          const a = [], l = [];
          for (let u = 0; u < e; u++) if (t[u] === r) {
            const [d, f] = s[u];
            a.push(d), l.push(f);
          }
          a.length > 0 && o.push({
            open: a,
            close: l
          });
        }
        return o;
      }
      class Xj {
        constructor(e, t) {
          this._richEditBracketsBrand = void 0;
          const i = Qj(t);
          this.brackets = i.map((n, o) => new lv(e, o, n.open, n.close, Jj(n.open, n.close, i, o), eG(n.open, n.close, i, o))), this.forwardRegex = tG(this.brackets), this.reversedRegex = iG(this.brackets), this.textIsBracket = {}, this.textIsOpenBracket = {}, this.maxBracketLength = 0;
          for (const n of this.brackets) {
            for (const o of n.open) this.textIsBracket[o] = n, this.textIsOpenBracket[o] = true, this.maxBracketLength = Math.max(this.maxBracketLength, o.length);
            for (const o of n.close) this.textIsBracket[o] = n, this.textIsOpenBracket[o] = false, this.maxBracketLength = Math.max(this.maxBracketLength, o.length);
          }
        }
      }
      function m8(s, e, t, i) {
        for (let n = 0, o = e.length; n < o; n++) {
          if (n === t) continue;
          const r = e[n];
          for (const a of r.open) a.indexOf(s) >= 0 && i.push(a);
          for (const a of r.close) a.indexOf(s) >= 0 && i.push(a);
        }
      }
      function p8(s, e) {
        return s.length - e.length;
      }
      function nw(s) {
        if (s.length <= 1) return s;
        const e = [], t = /* @__PURE__ */ new Set();
        for (const i of s) t.has(i) || (e.push(i), t.add(i));
        return e;
      }
      function Jj(s, e, t, i) {
        let n = [];
        n = n.concat(s), n = n.concat(e);
        for (let o = 0, r = n.length; o < r; o++) m8(n[o], t, i, n);
        return n = nw(n), n.sort(p8), n.reverse(), $_(n);
      }
      function eG(s, e, t, i) {
        let n = [];
        n = n.concat(s), n = n.concat(e);
        for (let o = 0, r = n.length; o < r; o++) m8(n[o], t, i, n);
        return n = nw(n), n.sort(p8), n.reverse(), $_(n.map(CT));
      }
      function tG(s) {
        let e = [];
        for (const t of s) {
          for (const i of t.open) e.push(i);
          for (const i of t.close) e.push(i);
        }
        return e = nw(e), $_(e);
      }
      function iG(s) {
        let e = [];
        for (const t of s) {
          for (const i of t.open) e.push(i);
          for (const i of t.close) e.push(i);
        }
        return e = nw(e), $_(e.map(CT));
      }
      function nG(s) {
        const e = /^[\w ]+$/.test(s);
        return s = $l(s), e ? `\\b${s}\\b` : s;
      }
      function $_(s, e) {
        const t = `(${s.map(nG).join(")|(")})`;
        return L9(t, true, e);
      }
      const CT = /* @__PURE__ */ function() {
        function s(i) {
          const n = new Uint16Array(i.length);
          let o = 0;
          for (let r = i.length - 1; r >= 0; r--) n[o++] = i.charCodeAt(r);
          return g8().decode(n);
        }
        let e = null, t = null;
        return function(n) {
          return e !== n && (e = n, t = s(e)), t;
        };
      }();
      class sr {
        static _findPrevBracketInText(e, t, i, n) {
          const o = i.match(e);
          if (!o) return null;
          const r = i.length - (o.index || 0), a = o[0].length, l = n + r;
          return new z(t, l - a + 1, t, l + 1);
        }
        static findPrevBracketInRange(e, t, i, n, o) {
          const a = CT(i).substring(i.length - o, i.length - n);
          return this._findPrevBracketInText(e, t, a, n);
        }
        static findNextBracketInText(e, t, i, n) {
          const o = i.match(e);
          if (!o) return null;
          const r = o.index || 0, a = o[0].length;
          if (a === 0) return null;
          const l = n + r;
          return new z(t, l + 1, t, l + 1 + a);
        }
        static findNextBracketInRange(e, t, i, n, o) {
          const r = i.substring(n, o);
          return this.findNextBracketInText(e, t, r, n);
        }
      }
      class sG {
        constructor(e) {
          this._richEditBrackets = e;
        }
        getElectricCharacters() {
          const e = [];
          if (this._richEditBrackets) for (const t of this._richEditBrackets.brackets) for (const i of t.close) {
            const n = i.charAt(i.length - 1);
            e.push(n);
          }
          return Nh(e);
        }
        onElectricCharacter(e, t, i) {
          if (!this._richEditBrackets || this._richEditBrackets.brackets.length === 0) return null;
          const n = t.findTokenIndexAtOffset(i - 1);
          if (pa(t.getStandardTokenType(n))) return null;
          const o = this._richEditBrackets.reversedRegex, r = t.getLineContent().substring(0, i - 1) + e, a = sr.findPrevBracketInRange(o, 1, r, 0, r.length);
          if (!a) return null;
          const l = r.substring(a.startColumn - 1, a.endColumn - 1).toLowerCase();
          if (this._richEditBrackets.textIsOpenBracket[l]) return null;
          const d = t.getActualLineContentBefore(a.startColumn - 1);
          return /^\s*$/.test(d) ? {
            matchOpenBracket: l
          } : null;
        }
      }
      function Eb(s) {
        return s.global && (s.lastIndex = 0), true;
      }
      class oG {
        constructor(e) {
          this._indentationRules = e;
        }
        shouldIncrease(e) {
          return !!(this._indentationRules && this._indentationRules.increaseIndentPattern && Eb(this._indentationRules.increaseIndentPattern) && this._indentationRules.increaseIndentPattern.test(e));
        }
        shouldDecrease(e) {
          return !!(this._indentationRules && this._indentationRules.decreaseIndentPattern && Eb(this._indentationRules.decreaseIndentPattern) && this._indentationRules.decreaseIndentPattern.test(e));
        }
        shouldIndentNextLine(e) {
          return !!(this._indentationRules && this._indentationRules.indentNextLinePattern && Eb(this._indentationRules.indentNextLinePattern) && this._indentationRules.indentNextLinePattern.test(e));
        }
        shouldIgnore(e) {
          return !!(this._indentationRules && this._indentationRules.unIndentedLinePattern && Eb(this._indentationRules.unIndentedLinePattern) && this._indentationRules.unIndentedLinePattern.test(e));
        }
        getIndentMetadata(e) {
          let t = 0;
          return this.shouldIncrease(e) && (t += 1), this.shouldDecrease(e) && (t += 2), this.shouldIndentNextLine(e) && (t += 4), this.shouldIgnore(e) && (t += 8), t;
        }
      }
      class df {
        constructor(e) {
          e = e || {}, e.brackets = e.brackets || [
            [
              "(",
              ")"
            ],
            [
              "{",
              "}"
            ],
            [
              "[",
              "]"
            ]
          ], this._brackets = [], e.brackets.forEach((t) => {
            const i = df._createOpenBracketRegExp(t[0]), n = df._createCloseBracketRegExp(t[1]);
            i && n && this._brackets.push({
              open: t[0],
              openRegExp: i,
              close: t[1],
              closeRegExp: n
            });
          }), this._regExpRules = e.onEnterRules || [];
        }
        onEnter(e, t, i, n) {
          if (e >= 3) for (let o = 0, r = this._regExpRules.length; o < r; o++) {
            const a = this._regExpRules[o];
            if ([
              {
                reg: a.beforeText,
                text: i
              },
              {
                reg: a.afterText,
                text: n
              },
              {
                reg: a.previousLineText,
                text: t
              }
            ].every((u) => u.reg ? (u.reg.lastIndex = 0, u.reg.test(u.text)) : true)) return a.action;
          }
          if (e >= 2 && i.length > 0 && n.length > 0) for (let o = 0, r = this._brackets.length; o < r; o++) {
            const a = this._brackets[o];
            if (a.openRegExp.test(i) && a.closeRegExp.test(n)) return {
              indentAction: ds.IndentOutdent
            };
          }
          if (e >= 2 && i.length > 0) {
            for (let o = 0, r = this._brackets.length; o < r; o++) if (this._brackets[o].openRegExp.test(i)) return {
              indentAction: ds.Indent
            };
          }
          return null;
        }
        static _createOpenBracketRegExp(e) {
          let t = $l(e);
          return /\B/.test(t.charAt(0)) || (t = "\\b" + t), t += "\\s*$", df._safeRegExp(t);
        }
        static _createCloseBracketRegExp(e) {
          let t = $l(e);
          return /\B/.test(t.charAt(t.length - 1)) || (t = t + "\\b"), t = "^\\s*" + t, df._safeRegExp(t);
        }
        static _safeRegExp(e) {
          try {
            return new RegExp(e);
          } catch (t) {
            return qt(t), null;
          }
        }
      }
      const Si = pt("configurationService");
      function Xk(s, e) {
        const t = /* @__PURE__ */ Object.create(null);
        for (const i in s) _8(t, i, s[i], e);
        return t;
      }
      function _8(s, e, t, i) {
        const n = e.split("."), o = n.pop();
        let r = s;
        for (let a = 0; a < n.length; a++) {
          const l = n[a];
          let u = r[l];
          switch (typeof u) {
            case "undefined":
              u = r[l] = /* @__PURE__ */ Object.create(null);
              break;
            case "object":
              if (u === null) {
                i(`Ignoring ${e} as ${n.slice(0, a + 1).join(".")} is null`);
                return;
              }
              break;
            default:
              i(`Ignoring ${e} as ${n.slice(0, a + 1).join(".")} is ${JSON.stringify(u)}`);
              return;
          }
          r = u;
        }
        if (typeof r == "object" && r !== null) try {
          r[o] = t;
        } catch {
          i(`Ignoring ${e} as ${n.join(".")} is ${JSON.stringify(r)}`);
        }
        else i(`Ignoring ${e} as ${n.join(".")} is ${JSON.stringify(r)}`);
      }
      function rG(s, e) {
        const t = e.split(".");
        b8(s, t);
      }
      function b8(s, e) {
        const t = e.shift();
        if (e.length === 0) {
          delete s[t];
          return;
        }
        if (Object.keys(s).indexOf(t) !== -1) {
          const i = s[t];
          typeof i == "object" && !Array.isArray(i) && (b8(i, e), Object.keys(i).length === 0 && delete s[t]);
        }
      }
      function yO(s, e, t) {
        function i(r, a) {
          let l = r;
          for (const u of a) {
            if (typeof l != "object" || l === null) return;
            l = l[u];
          }
          return l;
        }
        const n = e.split("."), o = i(s, n);
        return typeof o > "u" ? t : o;
      }
      function aG(s) {
        return s.replace(/[\[\]]/g, "");
      }
      const un = pt("languageService");
      class ya {
        constructor(e, t = [], i = false) {
          this.ctor = e, this.staticArguments = t, this.supportsDelayedInstantiation = i;
        }
      }
      const v8 = [];
      function Lt(s, e, t) {
        e instanceof ya || (e = new ya(e, [], !!t)), v8.push([
          s,
          e
        ]);
      }
      function SO() {
        return v8;
      }
      const kl = Object.freeze({
        text: "text/plain",
        binary: "application/octet-stream",
        unknown: "application/unknown",
        markdown: "text/markdown",
        latex: "text/latex",
        uriList: "text/uri-list"
      }), sw = {
        JSONContribution: "base.contributions.json"
      };
      function lG(s) {
        return s.length > 0 && s.charAt(s.length - 1) === "#" ? s.substring(0, s.length - 1) : s;
      }
      class cG {
        constructor() {
          this._onDidChangeSchema = new G(), this.schemasById = {};
        }
        registerSchema(e, t) {
          this.schemasById[lG(e)] = t, this._onDidChangeSchema.fire(e);
        }
        notifySchemaChanged(e) {
          this._onDidChangeSchema.fire(e);
        }
      }
      const uG = new cG();
      yn.add(sw.JSONContribution, uG);
      const Jh = {
        Configuration: "base.contributions.configuration"
      }, Tb = "vscode://schemas/settings/resourceLanguage", LO = yn.as(sw.JSONContribution);
      class hG {
        constructor() {
          this.registeredConfigurationDefaults = [], this.overrideIdentifiers = /* @__PURE__ */ new Set(), this._onDidSchemaChange = new G(), this._onDidUpdateConfiguration = new G(), this.configurationDefaultsOverrides = /* @__PURE__ */ new Map(), this.defaultLanguageConfigurationOverridesNode = {
            id: "defaultOverrides",
            title: C("defaultLanguageConfigurationOverrides.title", "Default Language Configuration Overrides"),
            properties: {}
          }, this.configurationContributors = [
            this.defaultLanguageConfigurationOverridesNode
          ], this.resourceLanguageSettingsSchema = {
            properties: {},
            patternProperties: {},
            additionalProperties: true,
            allowTrailingCommas: true,
            allowComments: true
          }, this.configurationProperties = {}, this.policyConfigurations = /* @__PURE__ */ new Map(), this.excludedConfigurationProperties = {}, LO.registerSchema(Tb, this.resourceLanguageSettingsSchema), this.registerOverridePropertyPatternKey();
        }
        registerConfiguration(e, t = true) {
          this.registerConfigurations([
            e
          ], t);
        }
        registerConfigurations(e, t = true) {
          const i = /* @__PURE__ */ new Set();
          this.doRegisterConfigurations(e, t, i), LO.registerSchema(Tb, this.resourceLanguageSettingsSchema), this._onDidSchemaChange.fire(), this._onDidUpdateConfiguration.fire({
            properties: i
          });
        }
        registerDefaultConfigurations(e) {
          const t = /* @__PURE__ */ new Set();
          this.doRegisterDefaultConfigurations(e, t), this._onDidSchemaChange.fire(), this._onDidUpdateConfiguration.fire({
            properties: t,
            defaultsOverrides: true
          });
        }
        doRegisterDefaultConfigurations(e, t) {
          this.registeredConfigurationDefaults.push(...e);
          const i = [];
          for (const { overrides: n, source: o } of e) for (const r in n) {
            t.add(r);
            const a = this.configurationDefaultsOverrides.get(r) ?? this.configurationDefaultsOverrides.set(r, {
              configurationDefaultOverrides: []
            }).get(r), l = n[r];
            if (a.configurationDefaultOverrides.push({
              value: l,
              source: o
            }), ou.test(r)) {
              const u = this.mergeDefaultConfigurationsForOverrideIdentifier(r, l, o, a.configurationDefaultOverrideValue);
              if (!u) continue;
              a.configurationDefaultOverrideValue = u, this.updateDefaultOverrideProperty(r, u, o), i.push(...cv(r));
            } else {
              const u = this.mergeDefaultConfigurationsForConfigurationProperty(r, l, o, a.configurationDefaultOverrideValue);
              if (!u) continue;
              a.configurationDefaultOverrideValue = u;
              const d = this.configurationProperties[r];
              d && (this.updatePropertyDefaultValue(r, d), this.updateSchema(r, d));
            }
          }
          this.doRegisterOverrideIdentifiers(i);
        }
        updateDefaultOverrideProperty(e, t, i) {
          const n = {
            type: "object",
            default: t.value,
            description: C("defaultLanguageConfiguration.description", "Configure settings to be overridden for the {0} language.", aG(e)),
            $ref: Tb,
            defaultDefaultValue: t.value,
            source: i,
            defaultValueSource: i
          };
          this.configurationProperties[e] = n, this.defaultLanguageConfigurationOverridesNode.properties[e] = n;
        }
        mergeDefaultConfigurationsForOverrideIdentifier(e, t, i, n) {
          const o = (n == null ? void 0 : n.value) || {}, r = (n == null ? void 0 : n.source) ?? /* @__PURE__ */ new Map();
          if (!(r instanceof Map)) {
            console.error("objectConfigurationSources is not a Map");
            return;
          }
          for (const a of Object.keys(t)) {
            const l = t[a];
            if (Es(l) && (Po(o[a]) || Es(o[a]))) {
              if (o[a] = {
                ...o[a] ?? {},
                ...l
              }, i) for (const d in l) r.set(`${a}.${d}`, i);
            } else o[a] = l, i ? r.set(a, i) : r.delete(a);
          }
          return {
            value: o,
            source: r
          };
        }
        mergeDefaultConfigurationsForConfigurationProperty(e, t, i, n) {
          const o = this.configurationProperties[e], r = (n == null ? void 0 : n.value) ?? (o == null ? void 0 : o.defaultDefaultValue);
          let a = i;
          if (Es(t) && (o !== void 0 && o.type === "object" || o === void 0 && (Po(r) || Es(r)))) {
            if (a = (n == null ? void 0 : n.source) ?? /* @__PURE__ */ new Map(), !(a instanceof Map)) {
              console.error("defaultValueSource is not a Map");
              return;
            }
            for (const u in t) i && a.set(`${e}.${u}`, i);
            t = {
              ...Es(r) ? r : {},
              ...t
            };
          }
          return {
            value: t,
            source: a
          };
        }
        registerOverrideIdentifiers(e) {
          this.doRegisterOverrideIdentifiers(e), this._onDidSchemaChange.fire();
        }
        doRegisterOverrideIdentifiers(e) {
          for (const t of e) this.overrideIdentifiers.add(t);
          this.updateOverridePropertyPatternKey();
        }
        doRegisterConfigurations(e, t, i) {
          e.forEach((n) => {
            this.validateAndRegisterProperties(n, t, n.extensionInfo, n.restrictedProperties, void 0, i), this.configurationContributors.push(n), this.registerJSONConfiguration(n);
          });
        }
        validateAndRegisterProperties(e, t = true, i, n, o = 3, r) {
          var _a3;
          o = ao(e.scope) ? o : e.scope;
          const a = e.properties;
          if (a) for (const u in a) {
            const d = a[u];
            if (t && gG(u, d)) {
              delete a[u];
              continue;
            }
            if (d.source = i, d.defaultDefaultValue = a[u].default, this.updatePropertyDefaultValue(u, d), ou.test(u) ? d.scope = void 0 : (d.scope = ao(d.scope) ? o : d.scope, d.restricted = ao(d.restricted) ? !!(n == null ? void 0 : n.includes(u)) : d.restricted), a[u].hasOwnProperty("included") && !a[u].included) {
              this.excludedConfigurationProperties[u] = a[u], delete a[u];
              continue;
            } else this.configurationProperties[u] = a[u], ((_a3 = a[u].policy) == null ? void 0 : _a3.name) && this.policyConfigurations.set(a[u].policy.name, u);
            !a[u].deprecationMessage && a[u].markdownDeprecationMessage && (a[u].deprecationMessage = a[u].markdownDeprecationMessage), r.add(u);
          }
          const l = e.allOf;
          if (l) for (const u of l) this.validateAndRegisterProperties(u, t, i, n, o, r);
        }
        getConfigurationProperties() {
          return this.configurationProperties;
        }
        getPolicyConfigurations() {
          return this.policyConfigurations;
        }
        registerJSONConfiguration(e) {
          const t = (i) => {
            var _a3;
            const n = i.properties;
            if (n) for (const r in n) this.updateSchema(r, n[r]);
            (_a3 = i.allOf) == null ? void 0 : _a3.forEach(t);
          };
          t(e);
        }
        updateSchema(e, t) {
          switch (t.scope) {
            case 1:
              break;
            case 2:
              break;
            case 6:
              break;
            case 3:
              break;
            case 4:
              break;
            case 5:
              this.resourceLanguageSettingsSchema.properties[e] = t;
              break;
          }
        }
        updateOverridePropertyPatternKey() {
          for (const e of this.overrideIdentifiers.values()) {
            const t = `[${e}]`, i = {
              type: "object",
              description: C("overrideSettings.defaultDescription", "Configure editor settings to be overridden for a language."),
              errorMessage: C("overrideSettings.errorMessage", "This setting does not support per-language configuration."),
              $ref: Tb
            };
            this.updatePropertyDefaultValue(t, i);
          }
        }
        registerOverridePropertyPatternKey() {
          C("overrideSettings.defaultDescription", "Configure editor settings to be overridden for a language."), C("overrideSettings.errorMessage", "This setting does not support per-language configuration."), this._onDidSchemaChange.fire();
        }
        updatePropertyDefaultValue(e, t) {
          var _a3;
          const i = (_a3 = this.configurationDefaultsOverrides.get(e)) == null ? void 0 : _a3.configurationDefaultOverrideValue;
          let n, o;
          i && (!t.disallowConfigurationDefault || !i.source) && (n = i.value, o = i.source), Po(n) && (n = t.defaultDefaultValue, o = void 0), Po(n) && (n = fG(t.type)), t.default = n, t.defaultValueSource = o;
        }
      }
      const C8 = "\\[([^\\]]+)\\]", xO = new RegExp(C8, "g"), dG = `^(${C8})+$`, ou = new RegExp(dG);
      function cv(s) {
        const e = [];
        if (ou.test(s)) {
          let t = xO.exec(s);
          for (; t == null ? void 0 : t.length; ) {
            const i = t[1].trim();
            i && e.push(i), t = xO.exec(s);
          }
        }
        return Nh(e);
      }
      function fG(s) {
        switch (Array.isArray(s) ? s[0] : s) {
          case "boolean":
            return false;
          case "integer":
          case "number":
            return 0;
          case "string":
            return "";
          case "array":
            return [];
          case "object":
            return {};
          default:
            return null;
        }
      }
      const v0 = new hG();
      yn.add(Jh.Configuration, v0);
      function gG(s, e) {
        var _a3, _b3, _c2, _d2;
        return s.trim() ? ou.test(s) ? C("config.property.languageDefault", "Cannot register '{0}'. This matches property pattern '\\\\[.*\\\\]$' for describing language specific editor settings. Use 'configurationDefaults' contribution.", s) : v0.getConfigurationProperties()[s] !== void 0 ? C("config.property.duplicate", "Cannot register '{0}'. This property is already registered.", s) : ((_a3 = e.policy) == null ? void 0 : _a3.name) && v0.getPolicyConfigurations().get((_b3 = e.policy) == null ? void 0 : _b3.name) !== void 0 ? C("config.policy.duplicate", "Cannot register '{0}'. The associated policy {1} is already registered with {2}.", s, (_c2 = e.policy) == null ? void 0 : _c2.name, v0.getPolicyConfigurations().get((_d2 = e.policy) == null ? void 0 : _d2.name)) : null : C("config.property.empty", "Cannot register an empty property");
      }
      const mG = {
        ModesRegistry: "editor.modesRegistry"
      };
      class pG {
        constructor() {
          this._onDidChangeLanguages = new G(), this.onDidChangeLanguages = this._onDidChangeLanguages.event, this._languages = [];
        }
        registerLanguage(e) {
          return this._languages.push(e), this._onDidChangeLanguages.fire(void 0), {
            dispose: () => {
              for (let t = 0, i = this._languages.length; t < i; t++) if (this._languages[t] === e) {
                this._languages.splice(t, 1);
                return;
              }
            }
          };
        }
        getLanguages() {
          return this._languages;
        }
      }
      const og = new pG();
      yn.add(mG.ModesRegistry, og);
      const gr = "plaintext", _G = ".txt";
      og.registerLanguage({
        id: gr,
        extensions: [
          _G
        ],
        aliases: [
          C("plainText.alias", "Plain Text"),
          "text"
        ],
        mimetypes: [
          kl.text
        ]
      });
      yn.as(Jh.Configuration).registerDefaultConfigurations([
        {
          overrides: {
            "[plaintext]": {
              "editor.unicodeHighlight.ambiguousCharacters": false,
              "editor.unicodeHighlight.invisibleCharacters": false
            }
          }
        }
      ]);
      class bG {
        constructor(e, t) {
          this.languageId = e;
          const i = t.brackets ? kO(t.brackets) : [], n = new q4((a) => {
            const l = /* @__PURE__ */ new Set();
            return {
              info: new vG(this, a, l),
              closing: l
            };
          }), o = new q4((a) => {
            const l = /* @__PURE__ */ new Set(), u = /* @__PURE__ */ new Set();
            return {
              info: new CG(this, a, l, u),
              opening: l,
              openingColorized: u
            };
          });
          for (const [a, l] of i) {
            const u = n.get(a), d = o.get(l);
            u.closing.add(d.info), d.opening.add(u.info);
          }
          const r = t.colorizedBracketPairs ? kO(t.colorizedBracketPairs) : i.filter((a) => !(a[0] === "<" && a[1] === ">"));
          for (const [a, l] of r) {
            const u = n.get(a), d = o.get(l);
            u.closing.add(d.info), d.openingColorized.add(u.info), d.opening.add(u.info);
          }
          this._openingBrackets = new Map([
            ...n.cachedValues
          ].map(([a, l]) => [
            a,
            l.info
          ])), this._closingBrackets = new Map([
            ...o.cachedValues
          ].map(([a, l]) => [
            a,
            l.info
          ]));
        }
        get openingBrackets() {
          return [
            ...this._openingBrackets.values()
          ];
        }
        get closingBrackets() {
          return [
            ...this._closingBrackets.values()
          ];
        }
        getOpeningBracketInfo(e) {
          return this._openingBrackets.get(e);
        }
        getClosingBracketInfo(e) {
          return this._closingBrackets.get(e);
        }
        getBracketInfo(e) {
          return this.getOpeningBracketInfo(e) || this.getClosingBracketInfo(e);
        }
        getBracketRegExp(e) {
          const t = Array.from([
            ...this._openingBrackets.keys(),
            ...this._closingBrackets.keys()
          ]);
          return $_(t, e);
        }
      }
      function kO(s) {
        return s.filter(([e, t]) => e !== "" && t !== "");
      }
      class w8 {
        constructor(e, t) {
          this.config = e, this.bracketText = t;
        }
        get languageId() {
          return this.config.languageId;
        }
      }
      class vG extends w8 {
        constructor(e, t, i) {
          super(e, t), this.openedBrackets = i, this.isOpeningBracket = true;
        }
      }
      class CG extends w8 {
        constructor(e, t, i, n) {
          super(e, t), this.openingBrackets = i, this.openingColorizedBrackets = n, this.isOpeningBracket = false;
        }
        closes(e) {
          return e.config !== this.config ? false : this.openingBrackets.has(e);
        }
        closesColorized(e) {
          return e.config !== this.config ? false : this.openingColorizedBrackets.has(e);
        }
        getOpeningBrackets() {
          return [
            ...this.openingBrackets
          ];
        }
      }
      var wG = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      }, DO = function(s, e) {
        return function(t, i) {
          e(t, i, s);
        };
      };
      class OL {
        constructor(e) {
          this.languageId = e;
        }
        affects(e) {
          return this.languageId ? this.languageId === e : true;
        }
      }
      const Pa = pt("languageConfigurationService");
      let Jk = class extends he {
        constructor(e, t) {
          super(), this.configurationService = e, this.languageService = t, this._registry = this._register(new xG()), this.onDidChangeEmitter = this._register(new G()), this.onDidChange = this.onDidChangeEmitter.event, this.configurations = /* @__PURE__ */ new Map();
          const i = new Set(Object.values(eD));
          this._register(this.configurationService.onDidChangeConfiguration((n) => {
            const o = n.change.keys.some((a) => i.has(a)), r = n.change.overrides.filter(([a, l]) => l.some((u) => i.has(u))).map(([a]) => a);
            if (o) this.configurations.clear(), this.onDidChangeEmitter.fire(new OL(void 0));
            else for (const a of r) this.languageService.isRegisteredLanguageId(a) && (this.configurations.delete(a), this.onDidChangeEmitter.fire(new OL(a)));
          })), this._register(this._registry.onDidChange((n) => {
            this.configurations.delete(n.languageId), this.onDidChangeEmitter.fire(new OL(n.languageId));
          }));
        }
        register(e, t, i) {
          return this._registry.register(e, t, i);
        }
        getLanguageConfiguration(e) {
          let t = this.configurations.get(e);
          return t || (t = yG(e, this._registry, this.configurationService, this.languageService), this.configurations.set(e, t)), t;
        }
      };
      Jk = wG([
        DO(0, Si),
        DO(1, un)
      ], Jk);
      function yG(s, e, t, i) {
        let n = e.getLanguageConfiguration(s);
        if (!n) {
          if (!i.isRegisteredLanguageId(s)) return new Of(s, {});
          n = new Of(s, {});
        }
        const o = SG(n.languageId, t), r = S8([
          n.underlyingConfig,
          o
        ]);
        return new Of(n.languageId, r);
      }
      const eD = {
        brackets: "editor.language.brackets",
        colorizedBracketPairs: "editor.language.colorizedBracketPairs"
      };
      function SG(s, e) {
        const t = e.getValue(eD.brackets, {
          overrideIdentifier: s
        }), i = e.getValue(eD.colorizedBracketPairs, {
          overrideIdentifier: s
        });
        return {
          brackets: EO(t),
          colorizedBracketPairs: EO(i)
        };
      }
      function EO(s) {
        if (Array.isArray(s)) return s.map((e) => {
          if (!(!Array.isArray(e) || e.length !== 2)) return [
            e[0],
            e[1]
          ];
        }).filter((e) => !!e);
      }
      function y8(s, e, t) {
        const i = s.getLineContent(e);
        let n = us(i);
        return n.length > t - 1 && (n = n.substring(0, t - 1)), n;
      }
      class LG {
        constructor(e) {
          this.languageId = e, this._resolved = null, this._entries = [], this._order = 0, this._resolved = null;
        }
        register(e, t) {
          const i = new TO(e, t, ++this._order);
          return this._entries.push(i), this._resolved = null, Ze(() => {
            for (let n = 0; n < this._entries.length; n++) if (this._entries[n] === i) {
              this._entries.splice(n, 1), this._resolved = null;
              break;
            }
          });
        }
        getResolvedConfiguration() {
          if (!this._resolved) {
            const e = this._resolve();
            e && (this._resolved = new Of(this.languageId, e));
          }
          return this._resolved;
        }
        _resolve() {
          return this._entries.length === 0 ? null : (this._entries.sort(TO.cmp), S8(this._entries.map((e) => e.configuration)));
        }
      }
      function S8(s) {
        let e = {
          comments: void 0,
          brackets: void 0,
          wordPattern: void 0,
          indentationRules: void 0,
          onEnterRules: void 0,
          autoClosingPairs: void 0,
          surroundingPairs: void 0,
          autoCloseBefore: void 0,
          folding: void 0,
          colorizedBracketPairs: void 0,
          __electricCharacterSupport: void 0
        };
        for (const t of s) e = {
          comments: t.comments || e.comments,
          brackets: t.brackets || e.brackets,
          wordPattern: t.wordPattern || e.wordPattern,
          indentationRules: t.indentationRules || e.indentationRules,
          onEnterRules: t.onEnterRules || e.onEnterRules,
          autoClosingPairs: t.autoClosingPairs || e.autoClosingPairs,
          surroundingPairs: t.surroundingPairs || e.surroundingPairs,
          autoCloseBefore: t.autoCloseBefore || e.autoCloseBefore,
          folding: t.folding || e.folding,
          colorizedBracketPairs: t.colorizedBracketPairs || e.colorizedBracketPairs,
          __electricCharacterSupport: t.__electricCharacterSupport || e.__electricCharacterSupport
        };
        return e;
      }
      class TO {
        constructor(e, t, i) {
          this.configuration = e, this.priority = t, this.order = i;
        }
        static cmp(e, t) {
          return e.priority === t.priority ? e.order - t.order : e.priority - t.priority;
        }
      }
      class NO {
        constructor(e) {
          this.languageId = e;
        }
      }
      class xG extends he {
        constructor() {
          super(), this._entries = /* @__PURE__ */ new Map(), this._onDidChange = this._register(new G()), this.onDidChange = this._onDidChange.event, this._register(this.register(gr, {
            brackets: [
              [
                "(",
                ")"
              ],
              [
                "[",
                "]"
              ],
              [
                "{",
                "}"
              ]
            ],
            surroundingPairs: [
              {
                open: "{",
                close: "}"
              },
              {
                open: "[",
                close: "]"
              },
              {
                open: "(",
                close: ")"
              },
              {
                open: "<",
                close: ">"
              },
              {
                open: '"',
                close: '"'
              },
              {
                open: "'",
                close: "'"
              },
              {
                open: "`",
                close: "`"
              }
            ],
            colorizedBracketPairs: [],
            folding: {
              offSide: true
            }
          }, 0));
        }
        register(e, t, i = 0) {
          let n = this._entries.get(e);
          n || (n = new LG(e), this._entries.set(e, n));
          const o = n.register(t, i);
          return this._onDidChange.fire(new NO(e)), Ze(() => {
            o.dispose(), this._onDidChange.fire(new NO(e));
          });
        }
        getLanguageConfiguration(e) {
          var _a3;
          return ((_a3 = this._entries.get(e)) == null ? void 0 : _a3.getResolvedConfiguration()) || null;
        }
      }
      class Of {
        constructor(e, t) {
          this.languageId = e, this.underlyingConfig = t, this._brackets = null, this._electricCharacter = null, this._onEnterSupport = this.underlyingConfig.brackets || this.underlyingConfig.indentationRules || this.underlyingConfig.onEnterRules ? new df(this.underlyingConfig) : null, this.comments = Of._handleComments(this.underlyingConfig), this.characterPair = new av(this.underlyingConfig), this.wordDefinition = this.underlyingConfig.wordPattern || OE, this.indentationRules = this.underlyingConfig.indentationRules, this.underlyingConfig.indentationRules ? this.indentRulesSupport = new oG(this.underlyingConfig.indentationRules) : this.indentRulesSupport = null, this.foldingRules = this.underlyingConfig.folding || {}, this.bracketsNew = new bG(e, this.underlyingConfig);
        }
        getWordDefinition() {
          return PE(this.wordDefinition);
        }
        get brackets() {
          return !this._brackets && this.underlyingConfig.brackets && (this._brackets = new Xj(this.languageId, this.underlyingConfig.brackets)), this._brackets;
        }
        get electricCharacter() {
          return this._electricCharacter || (this._electricCharacter = new sG(this.brackets)), this._electricCharacter;
        }
        onEnter(e, t, i, n) {
          return this._onEnterSupport ? this._onEnterSupport.onEnter(e, t, i, n) : null;
        }
        getAutoClosingPairs() {
          return new $j(this.characterPair.getAutoClosingPairs());
        }
        getAutoCloseBeforeSet(e) {
          return this.characterPair.getAutoCloseBeforeSet(e);
        }
        getSurroundingPairs() {
          return this.characterPair.getSurroundingPairs();
        }
        static _handleComments(e) {
          const t = e.comments;
          if (!t) return null;
          const i = {};
          if (t.lineComment && (i.lineCommentToken = t.lineComment), t.blockComment) {
            const [n, o] = t.blockComment;
            i.blockCommentStartToken = n, i.blockCommentEndToken = o;
          }
          return i;
        }
      }
      Lt(Pa, Jk, 1);
      class Lc {
        constructor(e, t, i, n) {
          this.originalStart = e, this.originalLength = t, this.modifiedStart = i, this.modifiedLength = n;
        }
        getOriginalEnd() {
          return this.originalStart + this.originalLength;
        }
        getModifiedEnd() {
          return this.modifiedStart + this.modifiedLength;
        }
      }
      class IO {
        constructor(e) {
          this.source = e;
        }
        getElements() {
          const e = this.source, t = new Int32Array(e.length);
          for (let i = 0, n = e.length; i < n; i++) t[i] = e.charCodeAt(i);
          return t;
        }
      }
      function kG(s, e, t) {
        return new Dl(new IO(s), new IO(e)).ComputeDiff(t).changes;
      }
      class Kd {
        static Assert(e, t) {
          if (!e) throw new Error(t);
        }
      }
      class jd {
        static Copy(e, t, i, n, o) {
          for (let r = 0; r < o; r++) i[n + r] = e[t + r];
        }
        static Copy2(e, t, i, n, o) {
          for (let r = 0; r < o; r++) i[n + r] = e[t + r];
        }
      }
      class MO {
        constructor() {
          this.m_changes = [], this.m_originalStart = 1073741824, this.m_modifiedStart = 1073741824, this.m_originalCount = 0, this.m_modifiedCount = 0;
        }
        MarkNextChange() {
          (this.m_originalCount > 0 || this.m_modifiedCount > 0) && this.m_changes.push(new Lc(this.m_originalStart, this.m_originalCount, this.m_modifiedStart, this.m_modifiedCount)), this.m_originalCount = 0, this.m_modifiedCount = 0, this.m_originalStart = 1073741824, this.m_modifiedStart = 1073741824;
        }
        AddOriginalElement(e, t) {
          this.m_originalStart = Math.min(this.m_originalStart, e), this.m_modifiedStart = Math.min(this.m_modifiedStart, t), this.m_originalCount++;
        }
        AddModifiedElement(e, t) {
          this.m_originalStart = Math.min(this.m_originalStart, e), this.m_modifiedStart = Math.min(this.m_modifiedStart, t), this.m_modifiedCount++;
        }
        getChanges() {
          return (this.m_originalCount > 0 || this.m_modifiedCount > 0) && this.MarkNextChange(), this.m_changes;
        }
        getReverseChanges() {
          return (this.m_originalCount > 0 || this.m_modifiedCount > 0) && this.MarkNextChange(), this.m_changes.reverse(), this.m_changes;
        }
      }
      class Dl {
        constructor(e, t, i = null) {
          this.ContinueProcessingPredicate = i, this._originalSequence = e, this._modifiedSequence = t;
          const [n, o, r] = Dl._getElements(e), [a, l, u] = Dl._getElements(t);
          this._hasStrings = r && u, this._originalStringElements = n, this._originalElementsOrHash = o, this._modifiedStringElements = a, this._modifiedElementsOrHash = l, this.m_forwardHistory = [], this.m_reverseHistory = [];
        }
        static _isStringArray(e) {
          return e.length > 0 && typeof e[0] == "string";
        }
        static _getElements(e) {
          const t = e.getElements();
          if (Dl._isStringArray(t)) {
            const i = new Int32Array(t.length);
            for (let n = 0, o = t.length; n < o; n++) i[n] = iT(t[n], 0);
            return [
              t,
              i,
              true
            ];
          }
          return t instanceof Int32Array ? [
            [],
            t,
            false
          ] : [
            [],
            new Int32Array(t),
            false
          ];
        }
        ElementsAreEqual(e, t) {
          return this._originalElementsOrHash[e] !== this._modifiedElementsOrHash[t] ? false : this._hasStrings ? this._originalStringElements[e] === this._modifiedStringElements[t] : true;
        }
        ElementsAreStrictEqual(e, t) {
          if (!this.ElementsAreEqual(e, t)) return false;
          const i = Dl._getStrictElement(this._originalSequence, e), n = Dl._getStrictElement(this._modifiedSequence, t);
          return i === n;
        }
        static _getStrictElement(e, t) {
          return typeof e.getStrictElement == "function" ? e.getStrictElement(t) : null;
        }
        OriginalElementsAreEqual(e, t) {
          return this._originalElementsOrHash[e] !== this._originalElementsOrHash[t] ? false : this._hasStrings ? this._originalStringElements[e] === this._originalStringElements[t] : true;
        }
        ModifiedElementsAreEqual(e, t) {
          return this._modifiedElementsOrHash[e] !== this._modifiedElementsOrHash[t] ? false : this._hasStrings ? this._modifiedStringElements[e] === this._modifiedStringElements[t] : true;
        }
        ComputeDiff(e) {
          return this._ComputeDiff(0, this._originalElementsOrHash.length - 1, 0, this._modifiedElementsOrHash.length - 1, e);
        }
        _ComputeDiff(e, t, i, n, o) {
          const r = [
            false
          ];
          let a = this.ComputeDiffRecursive(e, t, i, n, r);
          return o && (a = this.PrettifyChanges(a)), {
            quitEarly: r[0],
            changes: a
          };
        }
        ComputeDiffRecursive(e, t, i, n, o) {
          for (o[0] = false; e <= t && i <= n && this.ElementsAreEqual(e, i); ) e++, i++;
          for (; t >= e && n >= i && this.ElementsAreEqual(t, n); ) t--, n--;
          if (e > t || i > n) {
            let f;
            return i <= n ? (Kd.Assert(e === t + 1, "originalStart should only be one more than originalEnd"), f = [
              new Lc(e, 0, i, n - i + 1)
            ]) : e <= t ? (Kd.Assert(i === n + 1, "modifiedStart should only be one more than modifiedEnd"), f = [
              new Lc(e, t - e + 1, i, 0)
            ]) : (Kd.Assert(e === t + 1, "originalStart should only be one more than originalEnd"), Kd.Assert(i === n + 1, "modifiedStart should only be one more than modifiedEnd"), f = []), f;
          }
          const r = [
            0
          ], a = [
            0
          ], l = this.ComputeRecursionPoint(e, t, i, n, r, a, o), u = r[0], d = a[0];
          if (l !== null) return l;
          if (!o[0]) {
            const f = this.ComputeDiffRecursive(e, u, i, d, o);
            let m = [];
            return o[0] ? m = [
              new Lc(u + 1, t - (u + 1) + 1, d + 1, n - (d + 1) + 1)
            ] : m = this.ComputeDiffRecursive(u + 1, t, d + 1, n, o), this.ConcatenateChanges(f, m);
          }
          return [
            new Lc(e, t - e + 1, i, n - i + 1)
          ];
        }
        WALKTRACE(e, t, i, n, o, r, a, l, u, d, f, m, _, b, v, y, x, L) {
          let D = null, k = null, T = new MO(), M = t, I = i, R = _[0] - y[0] - n, A = -1073741824, Y = this.m_forwardHistory.length - 1;
          do {
            const U = R + e;
            U === M || U < I && u[U - 1] < u[U + 1] ? (f = u[U + 1], b = f - R - n, f < A && T.MarkNextChange(), A = f, T.AddModifiedElement(f + 1, b), R = U + 1 - e) : (f = u[U - 1] + 1, b = f - R - n, f < A && T.MarkNextChange(), A = f - 1, T.AddOriginalElement(f, b + 1), R = U - 1 - e), Y >= 0 && (u = this.m_forwardHistory[Y], e = u[0], M = 1, I = u.length - 1);
          } while (--Y >= -1);
          if (D = T.getReverseChanges(), L[0]) {
            let U = _[0] + 1, j = y[0] + 1;
            if (D !== null && D.length > 0) {
              const ee = D[D.length - 1];
              U = Math.max(U, ee.getOriginalEnd()), j = Math.max(j, ee.getModifiedEnd());
            }
            k = [
              new Lc(U, m - U + 1, j, v - j + 1)
            ];
          } else {
            T = new MO(), M = r, I = a, R = _[0] - y[0] - l, A = 1073741824, Y = x ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;
            do {
              const U = R + o;
              U === M || U < I && d[U - 1] >= d[U + 1] ? (f = d[U + 1] - 1, b = f - R - l, f > A && T.MarkNextChange(), A = f + 1, T.AddOriginalElement(f + 1, b + 1), R = U + 1 - o) : (f = d[U - 1], b = f - R - l, f > A && T.MarkNextChange(), A = f, T.AddModifiedElement(f + 1, b + 1), R = U - 1 - o), Y >= 0 && (d = this.m_reverseHistory[Y], o = d[0], M = 1, I = d.length - 1);
            } while (--Y >= -1);
            k = T.getChanges();
          }
          return this.ConcatenateChanges(D, k);
        }
        ComputeRecursionPoint(e, t, i, n, o, r, a) {
          let l = 0, u = 0, d = 0, f = 0, m = 0, _ = 0;
          e--, i--, o[0] = 0, r[0] = 0, this.m_forwardHistory = [], this.m_reverseHistory = [];
          const b = t - e + (n - i), v = b + 1, y = new Int32Array(v), x = new Int32Array(v), L = n - i, D = t - e, k = e - i, T = t - n, I = (D - L) % 2 === 0;
          y[L] = e, x[D] = t, a[0] = false;
          for (let R = 1; R <= b / 2 + 1; R++) {
            let A = 0, Y = 0;
            d = this.ClipDiagonalBound(L - R, R, L, v), f = this.ClipDiagonalBound(L + R, R, L, v);
            for (let j = d; j <= f; j += 2) {
              j === d || j < f && y[j - 1] < y[j + 1] ? l = y[j + 1] : l = y[j - 1] + 1, u = l - (j - L) - k;
              const ee = l;
              for (; l < t && u < n && this.ElementsAreEqual(l + 1, u + 1); ) l++, u++;
              if (y[j] = l, l + u > A + Y && (A = l, Y = u), !I && Math.abs(j - D) <= R - 1 && l >= x[j]) return o[0] = l, r[0] = u, ee <= x[j] && R <= 1448 ? this.WALKTRACE(L, d, f, k, D, m, _, T, y, x, l, t, o, u, n, r, I, a) : null;
            }
            const U = (A - e + (Y - i) - R) / 2;
            if (this.ContinueProcessingPredicate !== null && !this.ContinueProcessingPredicate(A, U)) return a[0] = true, o[0] = A, r[0] = Y, U > 0 && R <= 1448 ? this.WALKTRACE(L, d, f, k, D, m, _, T, y, x, l, t, o, u, n, r, I, a) : (e++, i++, [
              new Lc(e, t - e + 1, i, n - i + 1)
            ]);
            m = this.ClipDiagonalBound(D - R, R, D, v), _ = this.ClipDiagonalBound(D + R, R, D, v);
            for (let j = m; j <= _; j += 2) {
              j === m || j < _ && x[j - 1] >= x[j + 1] ? l = x[j + 1] - 1 : l = x[j - 1], u = l - (j - D) - T;
              const ee = l;
              for (; l > e && u > i && this.ElementsAreEqual(l, u); ) l--, u--;
              if (x[j] = l, I && Math.abs(j - L) <= R && l <= y[j]) return o[0] = l, r[0] = u, ee >= y[j] && R <= 1448 ? this.WALKTRACE(L, d, f, k, D, m, _, T, y, x, l, t, o, u, n, r, I, a) : null;
            }
            if (R <= 1447) {
              let j = new Int32Array(f - d + 2);
              j[0] = L - d + 1, jd.Copy2(y, d, j, 1, f - d + 1), this.m_forwardHistory.push(j), j = new Int32Array(_ - m + 2), j[0] = D - m + 1, jd.Copy2(x, m, j, 1, _ - m + 1), this.m_reverseHistory.push(j);
            }
          }
          return this.WALKTRACE(L, d, f, k, D, m, _, T, y, x, l, t, o, u, n, r, I, a);
        }
        PrettifyChanges(e) {
          for (let t = 0; t < e.length; t++) {
            const i = e[t], n = t < e.length - 1 ? e[t + 1].originalStart : this._originalElementsOrHash.length, o = t < e.length - 1 ? e[t + 1].modifiedStart : this._modifiedElementsOrHash.length, r = i.originalLength > 0, a = i.modifiedLength > 0;
            for (; i.originalStart + i.originalLength < n && i.modifiedStart + i.modifiedLength < o && (!r || this.OriginalElementsAreEqual(i.originalStart, i.originalStart + i.originalLength)) && (!a || this.ModifiedElementsAreEqual(i.modifiedStart, i.modifiedStart + i.modifiedLength)); ) {
              const u = this.ElementsAreStrictEqual(i.originalStart, i.modifiedStart);
              if (this.ElementsAreStrictEqual(i.originalStart + i.originalLength, i.modifiedStart + i.modifiedLength) && !u) break;
              i.originalStart++, i.modifiedStart++;
            }
            const l = [
              null
            ];
            if (t < e.length - 1 && this.ChangesOverlap(e[t], e[t + 1], l)) {
              e[t] = l[0], e.splice(t + 1, 1), t--;
              continue;
            }
          }
          for (let t = e.length - 1; t >= 0; t--) {
            const i = e[t];
            let n = 0, o = 0;
            if (t > 0) {
              const f = e[t - 1];
              n = f.originalStart + f.originalLength, o = f.modifiedStart + f.modifiedLength;
            }
            const r = i.originalLength > 0, a = i.modifiedLength > 0;
            let l = 0, u = this._boundaryScore(i.originalStart, i.originalLength, i.modifiedStart, i.modifiedLength);
            for (let f = 1; ; f++) {
              const m = i.originalStart - f, _ = i.modifiedStart - f;
              if (m < n || _ < o || r && !this.OriginalElementsAreEqual(m, m + i.originalLength) || a && !this.ModifiedElementsAreEqual(_, _ + i.modifiedLength)) break;
              const v = (m === n && _ === o ? 5 : 0) + this._boundaryScore(m, i.originalLength, _, i.modifiedLength);
              v > u && (u = v, l = f);
            }
            i.originalStart -= l, i.modifiedStart -= l;
            const d = [
              null
            ];
            if (t > 0 && this.ChangesOverlap(e[t - 1], e[t], d)) {
              e[t - 1] = d[0], e.splice(t, 1), t++;
              continue;
            }
          }
          if (this._hasStrings) for (let t = 1, i = e.length; t < i; t++) {
            const n = e[t - 1], o = e[t], r = o.originalStart - n.originalStart - n.originalLength, a = n.originalStart, l = o.originalStart + o.originalLength, u = l - a, d = n.modifiedStart, f = o.modifiedStart + o.modifiedLength, m = f - d;
            if (r < 5 && u < 20 && m < 20) {
              const _ = this._findBetterContiguousSequence(a, u, d, m, r);
              if (_) {
                const [b, v] = _;
                (b !== n.originalStart + n.originalLength || v !== n.modifiedStart + n.modifiedLength) && (n.originalLength = b - n.originalStart, n.modifiedLength = v - n.modifiedStart, o.originalStart = b + r, o.modifiedStart = v + r, o.originalLength = l - o.originalStart, o.modifiedLength = f - o.modifiedStart);
              }
            }
          }
          return e;
        }
        _findBetterContiguousSequence(e, t, i, n, o) {
          if (t < o || n < o) return null;
          const r = e + t - o + 1, a = i + n - o + 1;
          let l = 0, u = 0, d = 0;
          for (let f = e; f < r; f++) for (let m = i; m < a; m++) {
            const _ = this._contiguousSequenceScore(f, m, o);
            _ > 0 && _ > l && (l = _, u = f, d = m);
          }
          return l > 0 ? [
            u,
            d
          ] : null;
        }
        _contiguousSequenceScore(e, t, i) {
          let n = 0;
          for (let o = 0; o < i; o++) {
            if (!this.ElementsAreEqual(e + o, t + o)) return 0;
            n += this._originalStringElements[e + o].length;
          }
          return n;
        }
        _OriginalIsBoundary(e) {
          return e <= 0 || e >= this._originalElementsOrHash.length - 1 ? true : this._hasStrings && /^\s*$/.test(this._originalStringElements[e]);
        }
        _OriginalRegionIsBoundary(e, t) {
          if (this._OriginalIsBoundary(e) || this._OriginalIsBoundary(e - 1)) return true;
          if (t > 0) {
            const i = e + t;
            if (this._OriginalIsBoundary(i - 1) || this._OriginalIsBoundary(i)) return true;
          }
          return false;
        }
        _ModifiedIsBoundary(e) {
          return e <= 0 || e >= this._modifiedElementsOrHash.length - 1 ? true : this._hasStrings && /^\s*$/.test(this._modifiedStringElements[e]);
        }
        _ModifiedRegionIsBoundary(e, t) {
          if (this._ModifiedIsBoundary(e) || this._ModifiedIsBoundary(e - 1)) return true;
          if (t > 0) {
            const i = e + t;
            if (this._ModifiedIsBoundary(i - 1) || this._ModifiedIsBoundary(i)) return true;
          }
          return false;
        }
        _boundaryScore(e, t, i, n) {
          const o = this._OriginalRegionIsBoundary(e, t) ? 1 : 0, r = this._ModifiedRegionIsBoundary(i, n) ? 1 : 0;
          return o + r;
        }
        ConcatenateChanges(e, t) {
          const i = [];
          if (e.length === 0 || t.length === 0) return t.length > 0 ? t : e;
          if (this.ChangesOverlap(e[e.length - 1], t[0], i)) {
            const n = new Array(e.length + t.length - 1);
            return jd.Copy(e, 0, n, 0, e.length - 1), n[e.length - 1] = i[0], jd.Copy(t, 1, n, e.length, t.length - 1), n;
          } else {
            const n = new Array(e.length + t.length);
            return jd.Copy(e, 0, n, 0, e.length), jd.Copy(t, 0, n, e.length, t.length), n;
          }
        }
        ChangesOverlap(e, t, i) {
          if (Kd.Assert(e.originalStart <= t.originalStart, "Left change is not less than or equal to right change"), Kd.Assert(e.modifiedStart <= t.modifiedStart, "Left change is not less than or equal to right change"), e.originalStart + e.originalLength >= t.originalStart || e.modifiedStart + e.modifiedLength >= t.modifiedStart) {
            const n = e.originalStart;
            let o = e.originalLength;
            const r = e.modifiedStart;
            let a = e.modifiedLength;
            return e.originalStart + e.originalLength >= t.originalStart && (o = t.originalStart + t.originalLength - e.originalStart), e.modifiedStart + e.modifiedLength >= t.modifiedStart && (a = t.modifiedStart + t.modifiedLength - e.modifiedStart), i[0] = new Lc(n, o, r, a), true;
          } else return i[0] = null, false;
        }
        ClipDiagonalBound(e, t, i, n) {
          if (e >= 0 && e < n) return e;
          const o = i, r = n - i - 1, a = t % 2 === 0;
          if (e < 0) {
            const l = o % 2 === 0;
            return a === l ? 0 : 1;
          } else {
            const l = r % 2 === 0;
            return a === l ? n - 1 : n - 2;
          }
        }
      }
      function uv(s) {
        return s < 0 ? 0 : s > 255 ? 255 : s | 0;
      }
      function Gd(s) {
        return s < 0 ? 0 : s > 4294967295 ? 4294967295 : s | 0;
      }
      class q_ {
        constructor(e) {
          const t = uv(e);
          this._defaultValue = t, this._asciiMap = q_._createAsciiMap(t), this._map = /* @__PURE__ */ new Map();
        }
        static _createAsciiMap(e) {
          const t = new Uint8Array(256);
          return t.fill(e), t;
        }
        set(e, t) {
          const i = uv(t);
          e >= 0 && e < 256 ? this._asciiMap[e] = i : this._map.set(e, i);
        }
        get(e) {
          return e >= 0 && e < 256 ? this._asciiMap[e] : this._map.get(e) || this._defaultValue;
        }
        clear() {
          this._asciiMap.fill(this._defaultValue), this._map.clear();
        }
      }
      class DG {
        constructor(e, t, i) {
          const n = new Uint8Array(e * t);
          for (let o = 0, r = e * t; o < r; o++) n[o] = i;
          this._data = n, this.rows = e, this.cols = t;
        }
        get(e, t) {
          return this._data[e * this.cols + t];
        }
        set(e, t, i) {
          this._data[e * this.cols + t] = i;
        }
      }
      class EG {
        constructor(e) {
          let t = 0, i = 0;
          for (let o = 0, r = e.length; o < r; o++) {
            const [a, l, u] = e[o];
            l > t && (t = l), a > i && (i = a), u > i && (i = u);
          }
          t++, i++;
          const n = new DG(i, t, 0);
          for (let o = 0, r = e.length; o < r; o++) {
            const [a, l, u] = e[o];
            n.set(a, l, u);
          }
          this._states = n, this._maxCharCode = t;
        }
        nextState(e, t) {
          return t < 0 || t >= this._maxCharCode ? 0 : this._states.get(e, t);
        }
      }
      let PL = null;
      function TG() {
        return PL === null && (PL = new EG([
          [
            1,
            104,
            2
          ],
          [
            1,
            72,
            2
          ],
          [
            1,
            102,
            6
          ],
          [
            1,
            70,
            6
          ],
          [
            2,
            116,
            3
          ],
          [
            2,
            84,
            3
          ],
          [
            3,
            116,
            4
          ],
          [
            3,
            84,
            4
          ],
          [
            4,
            112,
            5
          ],
          [
            4,
            80,
            5
          ],
          [
            5,
            115,
            9
          ],
          [
            5,
            83,
            9
          ],
          [
            5,
            58,
            10
          ],
          [
            6,
            105,
            7
          ],
          [
            6,
            73,
            7
          ],
          [
            7,
            108,
            8
          ],
          [
            7,
            76,
            8
          ],
          [
            8,
            101,
            9
          ],
          [
            8,
            69,
            9
          ],
          [
            9,
            58,
            10
          ],
          [
            10,
            47,
            11
          ],
          [
            11,
            47,
            12
          ]
        ])), PL;
      }
      let Bm = null;
      function NG() {
        if (Bm === null) {
          Bm = new q_(0);
          const s = ` 	<>'"\u3001\u3002\uFF61\uFF64\uFF0C\uFF0E\uFF1A\uFF1B\u2018\u3008\u300C\u300E\u3014\uFF08\uFF3B\uFF5B\uFF62\uFF63\uFF5D\uFF3D\uFF09\u3015\u300F\u300D\u3009\u2019\uFF40\uFF5E\u2026`;
          for (let t = 0; t < s.length; t++) Bm.set(s.charCodeAt(t), 1);
          const e = ".,;:";
          for (let t = 0; t < e.length; t++) Bm.set(e.charCodeAt(t), 2);
        }
        return Bm;
      }
      class hv {
        static _createLink(e, t, i, n, o) {
          let r = o - 1;
          do {
            const a = t.charCodeAt(r);
            if (e.get(a) !== 2) break;
            r--;
          } while (r > n);
          if (n > 0) {
            const a = t.charCodeAt(n - 1), l = t.charCodeAt(r);
            (a === 40 && l === 41 || a === 91 && l === 93 || a === 123 && l === 125) && r--;
          }
          return {
            range: {
              startLineNumber: i,
              startColumn: n + 1,
              endLineNumber: i,
              endColumn: r + 2
            },
            url: t.substring(n, r + 1)
          };
        }
        static computeLinks(e, t = TG()) {
          const i = NG(), n = [];
          for (let o = 1, r = e.getLineCount(); o <= r; o++) {
            const a = e.getLineContent(o), l = a.length;
            let u = 0, d = 0, f = 0, m = 1, _ = false, b = false, v = false, y = false;
            for (; u < l; ) {
              let x = false;
              const L = a.charCodeAt(u);
              if (m === 13) {
                let D;
                switch (L) {
                  case 40:
                    _ = true, D = 0;
                    break;
                  case 41:
                    D = _ ? 0 : 1;
                    break;
                  case 91:
                    v = true, b = true, D = 0;
                    break;
                  case 93:
                    v = false, D = b ? 0 : 1;
                    break;
                  case 123:
                    y = true, D = 0;
                    break;
                  case 125:
                    D = y ? 0 : 1;
                    break;
                  case 39:
                  case 34:
                  case 96:
                    f === L ? D = 1 : f === 39 || f === 34 || f === 96 ? D = 0 : D = 1;
                    break;
                  case 42:
                    D = f === 42 ? 1 : 0;
                    break;
                  case 124:
                    D = f === 124 ? 1 : 0;
                    break;
                  case 32:
                    D = v ? 0 : 1;
                    break;
                  default:
                    D = i.get(L);
                }
                D === 1 && (n.push(hv._createLink(i, a, o, d, u)), x = true);
              } else if (m === 12) {
                let D;
                L === 91 ? (b = true, D = 0) : D = i.get(L), D === 1 ? x = true : m = 13;
              } else m = t.nextState(m, L), m === 0 && (x = true);
              x && (m = 1, _ = false, b = false, y = false, d = u + 1, f = L), u++;
            }
            m === 13 && n.push(hv._createLink(i, a, o, d, l));
          }
          return n;
        }
      }
      function IG(s) {
        return !s || typeof s.getLineCount != "function" || typeof s.getLineContent != "function" ? [] : hv.computeLinks(s);
      }
      const _wT = class _wT {
        constructor() {
          this._defaultValueSet = [
            [
              "true",
              "false"
            ],
            [
              "True",
              "False"
            ],
            [
              "Private",
              "Public",
              "Friend",
              "ReadOnly",
              "Partial",
              "Protected",
              "WriteOnly"
            ],
            [
              "public",
              "protected",
              "private"
            ]
          ];
        }
        navigateValueSet(e, t, i, n, o) {
          if (e && t) {
            const r = this.doNavigateValueSet(t, o);
            if (r) return {
              range: e,
              value: r
            };
          }
          if (i && n) {
            const r = this.doNavigateValueSet(n, o);
            if (r) return {
              range: i,
              value: r
            };
          }
          return null;
        }
        doNavigateValueSet(e, t) {
          const i = this.numberReplace(e, t);
          return i !== null ? i : this.textReplace(e, t);
        }
        numberReplace(e, t) {
          const i = Math.pow(10, e.length - (e.lastIndexOf(".") + 1));
          let n = Number(e);
          const o = parseFloat(e);
          return !isNaN(n) && !isNaN(o) && n === o ? n === 0 && !t ? null : (n = Math.floor(n * i), n += t ? i : -i, String(n / i)) : null;
        }
        textReplace(e, t) {
          return this.valueSetsReplace(this._defaultValueSet, e, t);
        }
        valueSetsReplace(e, t, i) {
          let n = null;
          for (let o = 0, r = e.length; n === null && o < r; o++) n = this.valueSetReplace(e[o], t, i);
          return n;
        }
        valueSetReplace(e, t, i) {
          let n = e.indexOf(t);
          return n >= 0 ? (n += i ? 1 : -1, n < 0 ? n = e.length - 1 : n %= e.length, e[n]) : null;
        }
      };
      _wT.INSTANCE = new _wT();
      let wT = _wT;
      const _dv = class _dv {
        static getChannel(e) {
          return e.getChannel(_dv.CHANNEL_NAME);
        }
        static setChannel(e, t) {
          e.setChannel(_dv.CHANNEL_NAME, t);
        }
      };
      _dv.CHANNEL_NAME = "editorWorkerHost";
      let dv = _dv;
      var AO, RO;
      class MG {
        constructor(e, t) {
          this.uri = e, this.value = t;
        }
      }
      function AG(s) {
        return Array.isArray(s);
      }
      const _fs = class _fs {
        constructor(e, t) {
          if (this[AO] = "ResourceMap", e instanceof _fs) this.map = new Map(e.map), this.toKey = t ?? _fs.defaultToKey;
          else if (AG(e)) {
            this.map = /* @__PURE__ */ new Map(), this.toKey = t ?? _fs.defaultToKey;
            for (const [i, n] of e) this.set(i, n);
          } else this.map = /* @__PURE__ */ new Map(), this.toKey = e ?? _fs.defaultToKey;
        }
        set(e, t) {
          return this.map.set(this.toKey(e), new MG(e, t)), this;
        }
        get(e) {
          var _a3;
          return (_a3 = this.map.get(this.toKey(e))) == null ? void 0 : _a3.value;
        }
        has(e) {
          return this.map.has(this.toKey(e));
        }
        get size() {
          return this.map.size;
        }
        clear() {
          this.map.clear();
        }
        delete(e) {
          return this.map.delete(this.toKey(e));
        }
        forEach(e, t) {
          typeof t < "u" && (e = e.bind(t));
          for (const [i, n] of this.map) e(n.value, n.uri, this);
        }
        *values() {
          for (const e of this.map.values()) yield e.value;
        }
        *keys() {
          for (const e of this.map.values()) yield e.uri;
        }
        *entries() {
          for (const e of this.map.values()) yield [
            e.uri,
            e.value
          ];
        }
        *[(AO = Symbol.toStringTag, Symbol.iterator)]() {
          for (const [, e] of this.map) yield [
            e.uri,
            e.value
          ];
        }
      };
      _fs.defaultToKey = (e) => e.toString();
      let fs = _fs;
      class RG {
        constructor() {
          this[RO] = "LinkedMap", this._map = /* @__PURE__ */ new Map(), this._head = void 0, this._tail = void 0, this._size = 0, this._state = 0;
        }
        clear() {
          this._map.clear(), this._head = void 0, this._tail = void 0, this._size = 0, this._state++;
        }
        isEmpty() {
          return !this._head && !this._tail;
        }
        get size() {
          return this._size;
        }
        get first() {
          var _a3;
          return (_a3 = this._head) == null ? void 0 : _a3.value;
        }
        get last() {
          var _a3;
          return (_a3 = this._tail) == null ? void 0 : _a3.value;
        }
        has(e) {
          return this._map.has(e);
        }
        get(e, t = 0) {
          const i = this._map.get(e);
          if (i) return t !== 0 && this.touch(i, t), i.value;
        }
        set(e, t, i = 0) {
          let n = this._map.get(e);
          if (n) n.value = t, i !== 0 && this.touch(n, i);
          else {
            switch (n = {
              key: e,
              value: t,
              next: void 0,
              previous: void 0
            }, i) {
              case 0:
                this.addItemLast(n);
                break;
              case 1:
                this.addItemFirst(n);
                break;
              case 2:
                this.addItemLast(n);
                break;
              default:
                this.addItemLast(n);
                break;
            }
            this._map.set(e, n), this._size++;
          }
          return this;
        }
        delete(e) {
          return !!this.remove(e);
        }
        remove(e) {
          const t = this._map.get(e);
          if (t) return this._map.delete(e), this.removeItem(t), this._size--, t.value;
        }
        shift() {
          if (!this._head && !this._tail) return;
          if (!this._head || !this._tail) throw new Error("Invalid list");
          const e = this._head;
          return this._map.delete(e.key), this.removeItem(e), this._size--, e.value;
        }
        forEach(e, t) {
          const i = this._state;
          let n = this._head;
          for (; n; ) {
            if (t ? e.bind(t)(n.value, n.key, this) : e(n.value, n.key, this), this._state !== i) throw new Error("LinkedMap got modified during iteration.");
            n = n.next;
          }
        }
        keys() {
          const e = this, t = this._state;
          let i = this._head;
          const n = {
            [Symbol.iterator]() {
              return n;
            },
            next() {
              if (e._state !== t) throw new Error("LinkedMap got modified during iteration.");
              if (i) {
                const o = {
                  value: i.key,
                  done: false
                };
                return i = i.next, o;
              } else return {
                value: void 0,
                done: true
              };
            }
          };
          return n;
        }
        values() {
          const e = this, t = this._state;
          let i = this._head;
          const n = {
            [Symbol.iterator]() {
              return n;
            },
            next() {
              if (e._state !== t) throw new Error("LinkedMap got modified during iteration.");
              if (i) {
                const o = {
                  value: i.value,
                  done: false
                };
                return i = i.next, o;
              } else return {
                value: void 0,
                done: true
              };
            }
          };
          return n;
        }
        entries() {
          const e = this, t = this._state;
          let i = this._head;
          const n = {
            [Symbol.iterator]() {
              return n;
            },
            next() {
              if (e._state !== t) throw new Error("LinkedMap got modified during iteration.");
              if (i) {
                const o = {
                  value: [
                    i.key,
                    i.value
                  ],
                  done: false
                };
                return i = i.next, o;
              } else return {
                value: void 0,
                done: true
              };
            }
          };
          return n;
        }
        [(RO = Symbol.toStringTag, Symbol.iterator)]() {
          return this.entries();
        }
        trimOld(e) {
          if (e >= this.size) return;
          if (e === 0) {
            this.clear();
            return;
          }
          let t = this._head, i = this.size;
          for (; t && i > e; ) this._map.delete(t.key), t = t.next, i--;
          this._head = t, this._size = i, t && (t.previous = void 0), this._state++;
        }
        trimNew(e) {
          if (e >= this.size) return;
          if (e === 0) {
            this.clear();
            return;
          }
          let t = this._tail, i = this.size;
          for (; t && i > e; ) this._map.delete(t.key), t = t.previous, i--;
          this._tail = t, this._size = i, t && (t.next = void 0), this._state++;
        }
        addItemFirst(e) {
          if (!this._head && !this._tail) this._tail = e;
          else if (this._head) e.next = this._head, this._head.previous = e;
          else throw new Error("Invalid list");
          this._head = e, this._state++;
        }
        addItemLast(e) {
          if (!this._head && !this._tail) this._head = e;
          else if (this._tail) e.previous = this._tail, this._tail.next = e;
          else throw new Error("Invalid list");
          this._tail = e, this._state++;
        }
        removeItem(e) {
          if (e === this._head && e === this._tail) this._head = void 0, this._tail = void 0;
          else if (e === this._head) {
            if (!e.next) throw new Error("Invalid list");
            e.next.previous = void 0, this._head = e.next;
          } else if (e === this._tail) {
            if (!e.previous) throw new Error("Invalid list");
            e.previous.next = void 0, this._tail = e.previous;
          } else {
            const t = e.next, i = e.previous;
            if (!t || !i) throw new Error("Invalid list");
            t.previous = i, i.next = t;
          }
          e.next = void 0, e.previous = void 0, this._state++;
        }
        touch(e, t) {
          if (!this._head || !this._tail) throw new Error("Invalid list");
          if (!(t !== 1 && t !== 2)) {
            if (t === 1) {
              if (e === this._head) return;
              const i = e.next, n = e.previous;
              e === this._tail ? (n.next = void 0, this._tail = n) : (i.previous = n, n.next = i), e.previous = void 0, e.next = this._head, this._head.previous = e, this._head = e, this._state++;
            } else if (t === 2) {
              if (e === this._tail) return;
              const i = e.next, n = e.previous;
              e === this._head ? (i.previous = void 0, this._head = i) : (i.previous = n, n.next = i), e.next = void 0, e.previous = this._tail, this._tail.next = e, this._tail = e, this._state++;
            }
          }
        }
        toJSON() {
          const e = [];
          return this.forEach((t, i) => {
            e.push([
              i,
              t
            ]);
          }), e;
        }
        fromJSON(e) {
          this.clear();
          for (const [t, i] of e) this.set(t, i);
        }
      }
      class OG extends RG {
        constructor(e, t = 1) {
          super(), this._limit = e, this._ratio = Math.min(Math.max(0, t), 1);
        }
        get limit() {
          return this._limit;
        }
        set limit(e) {
          this._limit = e, this.checkTrim();
        }
        get(e, t = 2) {
          return super.get(e, t);
        }
        peek(e) {
          return super.get(e, 0);
        }
        set(e, t) {
          return super.set(e, t, 2), this;
        }
        checkTrim() {
          this.size > this._limit && this.trim(Math.round(this._limit * this._ratio));
        }
      }
      class K_ extends OG {
        constructor(e, t = 1) {
          super(e, t);
        }
        trim(e) {
          this.trimOld(e);
        }
        set(e, t) {
          return super.set(e, t), this.checkTrim(), this;
        }
      }
      class PG {
        constructor(e) {
          if (this._m1 = /* @__PURE__ */ new Map(), this._m2 = /* @__PURE__ */ new Map(), e) for (const [t, i] of e) this.set(t, i);
        }
        clear() {
          this._m1.clear(), this._m2.clear();
        }
        set(e, t) {
          this._m1.set(e, t), this._m2.set(t, e);
        }
        get(e) {
          return this._m1.get(e);
        }
        getKey(e) {
          return this._m2.get(e);
        }
        delete(e) {
          const t = this._m1.get(e);
          return t === void 0 ? false : (this._m1.delete(e), this._m2.delete(t), true);
        }
        keys() {
          return this._m1.keys();
        }
        values() {
          return this._m1.values();
        }
      }
      class L8 {
        constructor() {
          this.map = /* @__PURE__ */ new Map();
        }
        add(e, t) {
          let i = this.map.get(e);
          i || (i = /* @__PURE__ */ new Set(), this.map.set(e, i)), i.add(t);
        }
        delete(e, t) {
          const i = this.map.get(e);
          i && (i.delete(t), i.size === 0 && this.map.delete(e));
        }
        forEach(e, t) {
          const i = this.map.get(e);
          i && i.forEach(t);
        }
        get(e) {
          const t = this.map.get(e);
          return t || /* @__PURE__ */ new Set();
        }
      }
      class BG extends q_ {
        constructor(e, t) {
          super(0), this._segmenter = null, this._cachedLine = null, this._cachedSegments = [], this.intlSegmenterLocales = t, this.intlSegmenterLocales.length > 0 ? this._segmenter = new Intl.Segmenter(this.intlSegmenterLocales, {
            granularity: "word"
          }) : this._segmenter = null;
          for (let i = 0, n = e.length; i < n; i++) this.set(e.charCodeAt(i), 2);
          this.set(32, 1), this.set(9, 1);
        }
        findPrevIntlWordBeforeOrAtOffset(e, t) {
          let i = null;
          for (const n of this._getIntlSegmenterWordsOnLine(e)) {
            if (n.index > t) break;
            i = n;
          }
          return i;
        }
        findNextIntlWordAtOrAfterOffset(e, t) {
          for (const i of this._getIntlSegmenterWordsOnLine(e)) if (!(i.index < t)) return i;
          return null;
        }
        _getIntlSegmenterWordsOnLine(e) {
          return this._segmenter ? this._cachedLine === e ? this._cachedSegments : (this._cachedLine = e, this._cachedSegments = this._filterWordSegments(this._segmenter.segment(e)), this._cachedSegments) : [];
        }
        _filterWordSegments(e) {
          const t = [];
          for (const i of e) this._isWordLike(i) && t.push(i);
          return t;
        }
        _isWordLike(e) {
          return !!e.isWordLike;
        }
      }
      const OO = new K_(10);
      function rg(s, e) {
        const t = `${s}/${e.join(",")}`;
        let i = OO.get(t);
        return i || (i = new BG(s, e), OO.set(t, i)), i;
      }
      var fv;
      (function(s) {
        s[s.Left = 1] = "Left", s[s.Center = 2] = "Center", s[s.Right = 4] = "Right", s[s.Full = 7] = "Full";
      })(fv || (fv = {}));
      var ru;
      (function(s) {
        s[s.Left = 1] = "Left", s[s.Center = 2] = "Center", s[s.Right = 3] = "Right";
      })(ru || (ru = {}));
      var ag;
      (function(s) {
        s[s.Both = 0] = "Both", s[s.Right = 1] = "Right", s[s.Left = 2] = "Left", s[s.None = 3] = "None";
      })(ag || (ag = {}));
      class C0 {
        get originalIndentSize() {
          return this._indentSizeIsTabSize ? "tabSize" : this.indentSize;
        }
        constructor(e) {
          this._textModelResolvedOptionsBrand = void 0, this.tabSize = Math.max(1, e.tabSize | 0), e.indentSize === "tabSize" ? (this.indentSize = this.tabSize, this._indentSizeIsTabSize = true) : (this.indentSize = Math.max(1, e.indentSize | 0), this._indentSizeIsTabSize = false), this.insertSpaces = !!e.insertSpaces, this.defaultEOL = e.defaultEOL | 0, this.trimAutoWhitespace = !!e.trimAutoWhitespace, this.bracketPairColorizationOptions = e.bracketPairColorizationOptions;
        }
        equals(e) {
          return this.tabSize === e.tabSize && this._indentSizeIsTabSize === e._indentSizeIsTabSize && this.indentSize === e.indentSize && this.insertSpaces === e.insertSpaces && this.defaultEOL === e.defaultEOL && this.trimAutoWhitespace === e.trimAutoWhitespace && $s(this.bracketPairColorizationOptions, e.bracketPairColorizationOptions);
        }
        createChangeEvent(e) {
          return {
            tabSize: this.tabSize !== e.tabSize,
            indentSize: this.indentSize !== e.indentSize,
            insertSpaces: this.insertSpaces !== e.insertSpaces,
            trimAutoWhitespace: this.trimAutoWhitespace !== e.trimAutoWhitespace
          };
        }
      }
      class e_ {
        constructor(e, t) {
          this._findMatchBrand = void 0, this.range = e, this.matches = t;
        }
      }
      function FG(s) {
        return s && typeof s.read == "function";
      }
      class BL {
        constructor(e, t, i, n, o, r) {
          this.identifier = e, this.range = t, this.text = i, this.forceMoveMarkers = n, this.isAutoWhitespaceEdit = o, this._isTracked = r;
        }
      }
      class VG {
        constructor(e, t, i) {
          this.regex = e, this.wordSeparators = t, this.simpleSearch = i;
        }
      }
      class WG {
        constructor(e, t, i) {
          this.reverseEdits = e, this.changes = t, this.trimAutoWhitespaceLineNumbers = i;
        }
      }
      function HG(s) {
        return !s.isTooLargeForSyncing() && !s.isForSimpleWidget;
      }
      const zG = 999;
      class Yd {
        constructor(e, t, i, n) {
          this.searchString = e, this.isRegex = t, this.matchCase = i, this.wordSeparators = n;
        }
        parseSearchRequest() {
          if (this.searchString === "") return null;
          let e;
          this.isRegex ? e = UG(this.searchString) : e = this.searchString.indexOf(`
`) >= 0;
          let t = null;
          try {
            t = L9(this.searchString, this.isRegex, {
              matchCase: this.matchCase,
              wholeWord: false,
              multiline: e,
              global: true,
              unicode: true
            });
          } catch {
            return null;
          }
          if (!t) return null;
          let i = !this.isRegex && !e;
          return i && this.searchString.toLowerCase() !== this.searchString.toUpperCase() && (i = this.matchCase), new VG(t, this.wordSeparators ? rg(this.wordSeparators, []) : null, i ? this.searchString : null);
        }
      }
      function UG(s) {
        if (!s || s.length === 0) return false;
        for (let e = 0, t = s.length; e < t; e++) {
          const i = s.charCodeAt(e);
          if (i === 10) return true;
          if (i === 92) {
            if (e++, e >= t) break;
            const n = s.charCodeAt(e);
            if (n === 110 || n === 114 || n === 87) return true;
          }
        }
        return false;
      }
      function Xu(s, e, t) {
        if (!t) return new e_(s, null);
        const i = [];
        for (let n = 0, o = e.length; n < o; n++) i[n] = e[n];
        return new e_(s, i);
      }
      class PO {
        constructor(e) {
          const t = [];
          let i = 0;
          for (let n = 0, o = e.length; n < o; n++) e.charCodeAt(n) === 10 && (t[i++] = n);
          this._lineFeedsOffsets = t;
        }
        findLineFeedCountBeforeOffset(e) {
          const t = this._lineFeedsOffsets;
          let i = 0, n = t.length - 1;
          if (n === -1 || e <= t[0]) return 0;
          for (; i < n; ) {
            const o = i + ((n - i) / 2 >> 0);
            t[o] >= e ? n = o - 1 : t[o + 1] >= e ? (i = o, n = o) : i = o + 1;
          }
          return i + 1;
        }
      }
      class Nb {
        static findMatches(e, t, i, n, o) {
          const r = t.parseSearchRequest();
          return r ? r.regex.multiline ? this._doFindMatchesMultiline(e, i, new ff(r.wordSeparators, r.regex), n, o) : this._doFindMatchesLineByLine(e, i, r, n, o) : [];
        }
        static _getMultilineMatchRange(e, t, i, n, o, r) {
          let a, l = 0;
          n ? (l = n.findLineFeedCountBeforeOffset(o), a = t + o + l) : a = t + o;
          let u;
          if (n) {
            const _ = n.findLineFeedCountBeforeOffset(o + r.length) - l;
            u = a + r.length + _;
          } else u = a + r.length;
          const d = e.getPositionAt(a), f = e.getPositionAt(u);
          return new z(d.lineNumber, d.column, f.lineNumber, f.column);
        }
        static _doFindMatchesMultiline(e, t, i, n, o) {
          const r = e.getOffsetAt(t.getStartPosition()), a = e.getValueInRange(t, 1), l = e.getEOL() === `\r
` ? new PO(a) : null, u = [];
          let d = 0, f;
          for (i.reset(0); f = i.next(a); ) if (u[d++] = Xu(this._getMultilineMatchRange(e, r, a, l, f.index, f[0]), f, n), d >= o) return u;
          return u;
        }
        static _doFindMatchesLineByLine(e, t, i, n, o) {
          const r = [];
          let a = 0;
          if (t.startLineNumber === t.endLineNumber) {
            const u = e.getLineContent(t.startLineNumber).substring(t.startColumn - 1, t.endColumn - 1);
            return a = this._findMatchesInLine(i, u, t.startLineNumber, t.startColumn - 1, a, r, n, o), r;
          }
          const l = e.getLineContent(t.startLineNumber).substring(t.startColumn - 1);
          a = this._findMatchesInLine(i, l, t.startLineNumber, t.startColumn - 1, a, r, n, o);
          for (let u = t.startLineNumber + 1; u < t.endLineNumber && a < o; u++) a = this._findMatchesInLine(i, e.getLineContent(u), u, 0, a, r, n, o);
          if (a < o) {
            const u = e.getLineContent(t.endLineNumber).substring(0, t.endColumn - 1);
            a = this._findMatchesInLine(i, u, t.endLineNumber, 0, a, r, n, o);
          }
          return r;
        }
        static _findMatchesInLine(e, t, i, n, o, r, a, l) {
          const u = e.wordSeparators;
          if (!a && e.simpleSearch) {
            const m = e.simpleSearch, _ = m.length, b = t.length;
            let v = -_;
            for (; (v = t.indexOf(m, v + _)) !== -1; ) if ((!u || yT(u, t, b, v, _)) && (r[o++] = new e_(new z(i, v + 1 + n, i, v + 1 + _ + n), null), o >= l)) return o;
            return o;
          }
          const d = new ff(e.wordSeparators, e.regex);
          let f;
          d.reset(0);
          do
            if (f = d.next(t), f && (r[o++] = Xu(new z(i, f.index + 1 + n, i, f.index + 1 + f[0].length + n), f, a), o >= l)) return o;
          while (f);
          return o;
        }
        static findNextMatch(e, t, i, n) {
          const o = t.parseSearchRequest();
          if (!o) return null;
          const r = new ff(o.wordSeparators, o.regex);
          return o.regex.multiline ? this._doFindNextMatchMultiline(e, i, r, n) : this._doFindNextMatchLineByLine(e, i, r, n);
        }
        static _doFindNextMatchMultiline(e, t, i, n) {
          const o = new X(t.lineNumber, 1), r = e.getOffsetAt(o), a = e.getLineCount(), l = e.getValueInRange(new z(o.lineNumber, o.column, a, e.getLineMaxColumn(a)), 1), u = e.getEOL() === `\r
` ? new PO(l) : null;
          i.reset(t.column - 1);
          const d = i.next(l);
          return d ? Xu(this._getMultilineMatchRange(e, r, l, u, d.index, d[0]), d, n) : t.lineNumber !== 1 || t.column !== 1 ? this._doFindNextMatchMultiline(e, new X(1, 1), i, n) : null;
        }
        static _doFindNextMatchLineByLine(e, t, i, n) {
          const o = e.getLineCount(), r = t.lineNumber, a = e.getLineContent(r), l = this._findFirstMatchInLine(i, a, r, t.column, n);
          if (l) return l;
          for (let u = 1; u <= o; u++) {
            const d = (r + u - 1) % o, f = e.getLineContent(d + 1), m = this._findFirstMatchInLine(i, f, d + 1, 1, n);
            if (m) return m;
          }
          return null;
        }
        static _findFirstMatchInLine(e, t, i, n, o) {
          e.reset(n - 1);
          const r = e.next(t);
          return r ? Xu(new z(i, r.index + 1, i, r.index + 1 + r[0].length), r, o) : null;
        }
        static findPreviousMatch(e, t, i, n) {
          const o = t.parseSearchRequest();
          if (!o) return null;
          const r = new ff(o.wordSeparators, o.regex);
          return o.regex.multiline ? this._doFindPreviousMatchMultiline(e, i, r, n) : this._doFindPreviousMatchLineByLine(e, i, r, n);
        }
        static _doFindPreviousMatchMultiline(e, t, i, n) {
          const o = this._doFindMatchesMultiline(e, new z(1, 1, t.lineNumber, t.column), i, n, 10 * zG);
          if (o.length > 0) return o[o.length - 1];
          const r = e.getLineCount();
          return t.lineNumber !== r || t.column !== e.getLineMaxColumn(r) ? this._doFindPreviousMatchMultiline(e, new X(r, e.getLineMaxColumn(r)), i, n) : null;
        }
        static _doFindPreviousMatchLineByLine(e, t, i, n) {
          const o = e.getLineCount(), r = t.lineNumber, a = e.getLineContent(r).substring(0, t.column - 1), l = this._findLastMatchInLine(i, a, r, n);
          if (l) return l;
          for (let u = 1; u <= o; u++) {
            const d = (o + r - u - 1) % o, f = e.getLineContent(d + 1), m = this._findLastMatchInLine(i, f, d + 1, n);
            if (m) return m;
          }
          return null;
        }
        static _findLastMatchInLine(e, t, i, n) {
          let o = null, r;
          for (e.reset(0); r = e.next(t); ) o = Xu(new z(i, r.index + 1, i, r.index + 1 + r[0].length), r, n);
          return o;
        }
      }
      function $G(s, e, t, i, n) {
        if (i === 0) return true;
        const o = e.charCodeAt(i - 1);
        if (s.get(o) !== 0 || o === 13 || o === 10) return true;
        if (n > 0) {
          const r = e.charCodeAt(i);
          if (s.get(r) !== 0) return true;
        }
        return false;
      }
      function qG(s, e, t, i, n) {
        if (i + n === t) return true;
        const o = e.charCodeAt(i + n);
        if (s.get(o) !== 0 || o === 13 || o === 10) return true;
        if (n > 0) {
          const r = e.charCodeAt(i + n - 1);
          if (s.get(r) !== 0) return true;
        }
        return false;
      }
      function yT(s, e, t, i, n) {
        return $G(s, e, t, i, n) && qG(s, e, t, i, n);
      }
      class ff {
        constructor(e, t) {
          this._wordSeparators = e, this._searchRegex = t, this._prevMatchStartIndex = -1, this._prevMatchLength = 0;
        }
        reset(e) {
          this._searchRegex.lastIndex = e, this._prevMatchStartIndex = -1, this._prevMatchLength = 0;
        }
        next(e) {
          const t = e.length;
          let i;
          do {
            if (this._prevMatchStartIndex + this._prevMatchLength === t || (i = this._searchRegex.exec(e), !i)) return null;
            const n = i.index, o = i[0].length;
            if (n === this._prevMatchStartIndex && o === this._prevMatchLength) {
              if (o === 0) {
                ev(e, t, this._searchRegex.lastIndex) > 65535 ? this._searchRegex.lastIndex += 2 : this._searchRegex.lastIndex += 1;
                continue;
              }
              return null;
            }
            if (this._prevMatchStartIndex = n, this._prevMatchLength = o, !this._wordSeparators || yT(this._wordSeparators, e, t, n, o)) return i;
          } while (i);
          return null;
        }
      }
      class KG {
        static computeUnicodeHighlights(e, t, i) {
          const n = i ? i.startLineNumber : 1, o = i ? i.endLineNumber : e.getLineCount(), r = new BO(t), a = r.getCandidateCodePoints();
          let l;
          a === "allNonBasicAscii" ? l = new RegExp("[^\\t\\n\\r\\x20-\\x7E]", "g") : l = new RegExp(`${jG(Array.from(a))}`, "g");
          const u = new ff(null, l), d = [];
          let f = false, m, _ = 0, b = 0, v = 0;
          e: for (let y = n, x = o; y <= x; y++) {
            const L = e.getLineContent(y), D = L.length;
            u.reset(0);
            do
              if (m = u.next(L), m) {
                let k = m.index, T = m.index + m[0].length;
                if (k > 0) {
                  const A = L.charCodeAt(k - 1);
                  on(A) && k--;
                }
                if (T + 1 < D) {
                  const A = L.charCodeAt(T - 1);
                  on(A) && T++;
                }
                const M = L.substring(k, T);
                let I = Kp(k + 1, OE, L, 0);
                I && I.endColumn <= k + 1 && (I = null);
                const R = r.shouldHighlightNonBasicASCII(M, I ? I.word : null);
                if (R !== 0) {
                  if (R === 3 ? _++ : R === 2 ? b++ : R === 1 ? v++ : gT(), d.length >= 1e3) {
                    f = true;
                    break e;
                  }
                  d.push(new z(y, k + 1, y, T + 1));
                }
              }
            while (m);
          }
          return {
            ranges: d,
            hasMore: f,
            ambiguousCharacterCount: _,
            invisibleCharacterCount: b,
            nonBasicAsciiCharacterCount: v
          };
        }
        static computeUnicodeHighlightReason(e, t) {
          const i = new BO(t);
          switch (i.shouldHighlightNonBasicASCII(e, null)) {
            case 0:
              return null;
            case 2:
              return {
                kind: 1
              };
            case 3: {
              const o = e.codePointAt(0), r = i.ambiguousCharacters.getPrimaryConfusable(o), a = Wc.getLocales().filter((l) => !Wc.getInstance(/* @__PURE__ */ new Set([
                ...t.allowedLocales,
                l
              ])).isAmbiguous(o));
              return {
                kind: 0,
                confusableWith: String.fromCodePoint(r),
                notAmbiguousInLocales: a
              };
            }
            case 1:
              return {
                kind: 2
              };
          }
        }
      }
      function jG(s, e) {
        return `[${$l(s.map((i) => String.fromCodePoint(i)).join(""))}]`;
      }
      class BO {
        constructor(e) {
          this.options = e, this.allowedCodePoints = new Set(e.allowedCodePoints), this.ambiguousCharacters = Wc.getInstance(new Set(e.allowedLocales));
        }
        getCandidateCodePoints() {
          if (this.options.nonBasicASCII) return "allNonBasicAscii";
          const e = /* @__PURE__ */ new Set();
          if (this.options.invisibleCharacters) for (const t of vh.codePoints) FO(String.fromCodePoint(t)) || e.add(t);
          if (this.options.ambiguousCharacters) for (const t of this.ambiguousCharacters.getConfusableCodePoints()) e.add(t);
          for (const t of this.allowedCodePoints) e.delete(t);
          return e;
        }
        shouldHighlightNonBasicASCII(e, t) {
          const i = e.codePointAt(0);
          if (this.allowedCodePoints.has(i)) return 0;
          if (this.options.nonBasicASCII) return 1;
          let n = false, o = false;
          if (t) for (const r of t) {
            const a = r.codePointAt(0), l = ZE(r);
            n = n || l, !l && !this.ambiguousCharacters.isAmbiguous(a) && !vh.isInvisibleCharacter(a) && (o = true);
          }
          return !n && o ? 0 : this.options.invisibleCharacters && !FO(e) && vh.isInvisibleCharacter(i) ? 2 : this.options.ambiguousCharacters && this.ambiguousCharacters.isAmbiguous(i) ? 3 : 0;
        }
      }
      function FO(s) {
        return s === " " || s === `
` || s === "	";
      }
      class w0 {
        constructor(e, t, i) {
          this.changes = e, this.moves = t, this.hitTimeout = i;
        }
      }
      class x8 {
        constructor(e, t) {
          this.lineRangeMapping = e, this.changes = t;
        }
      }
      class Qe {
        static addRange(e, t) {
          let i = 0;
          for (; i < t.length && t[i].endExclusive < e.start; ) i++;
          let n = i;
          for (; n < t.length && t[n].start <= e.endExclusive; ) n++;
          if (i === n) t.splice(i, 0, e);
          else {
            const o = Math.min(e.start, t[i].start), r = Math.max(e.endExclusive, t[n - 1].endExclusive);
            t.splice(i, n - i, new Qe(o, r));
          }
        }
        static tryCreate(e, t) {
          if (!(e > t)) return new Qe(e, t);
        }
        static ofLength(e) {
          return new Qe(0, e);
        }
        static ofStartAndLength(e, t) {
          return new Qe(e, e + t);
        }
        constructor(e, t) {
          if (this.start = e, this.endExclusive = t, e > t) throw new It(`Invalid range: ${this.toString()}`);
        }
        get isEmpty() {
          return this.start === this.endExclusive;
        }
        delta(e) {
          return new Qe(this.start + e, this.endExclusive + e);
        }
        deltaStart(e) {
          return new Qe(this.start + e, this.endExclusive);
        }
        deltaEnd(e) {
          return new Qe(this.start, this.endExclusive + e);
        }
        get length() {
          return this.endExclusive - this.start;
        }
        toString() {
          return `[${this.start}, ${this.endExclusive})`;
        }
        contains(e) {
          return this.start <= e && e < this.endExclusive;
        }
        join(e) {
          return new Qe(Math.min(this.start, e.start), Math.max(this.endExclusive, e.endExclusive));
        }
        intersect(e) {
          const t = Math.max(this.start, e.start), i = Math.min(this.endExclusive, e.endExclusive);
          if (t <= i) return new Qe(t, i);
        }
        intersects(e) {
          const t = Math.max(this.start, e.start), i = Math.min(this.endExclusive, e.endExclusive);
          return t < i;
        }
        isBefore(e) {
          return this.endExclusive <= e.start;
        }
        isAfter(e) {
          return this.start >= e.endExclusive;
        }
        slice(e) {
          return e.slice(this.start, this.endExclusive);
        }
        substring(e) {
          return e.substring(this.start, this.endExclusive);
        }
        clip(e) {
          if (this.isEmpty) throw new It(`Invalid clipping range: ${this.toString()}`);
          return Math.max(this.start, Math.min(this.endExclusive - 1, e));
        }
        clipCyclic(e) {
          if (this.isEmpty) throw new It(`Invalid clipping range: ${this.toString()}`);
          return e < this.start ? this.endExclusive - (this.start - e) % this.length : e >= this.endExclusive ? this.start + (e - this.start) % this.length : e;
        }
        forEach(e) {
          for (let t = this.start; t < this.endExclusive; t++) e(t);
        }
      }
      class ST {
        constructor() {
          this._sortedRanges = [];
        }
        addRange(e) {
          let t = 0;
          for (; t < this._sortedRanges.length && this._sortedRanges[t].endExclusive < e.start; ) t++;
          let i = t;
          for (; i < this._sortedRanges.length && this._sortedRanges[i].start <= e.endExclusive; ) i++;
          if (t === i) this._sortedRanges.splice(t, 0, e);
          else {
            const n = Math.min(e.start, this._sortedRanges[t].start), o = Math.max(e.endExclusive, this._sortedRanges[i - 1].endExclusive);
            this._sortedRanges.splice(t, i - t, new Qe(n, o));
          }
        }
        toString() {
          return this._sortedRanges.map((e) => e.toString()).join(", ");
        }
        intersectsStrict(e) {
          let t = 0;
          for (; t < this._sortedRanges.length && this._sortedRanges[t].endExclusive <= e.start; ) t++;
          return t < this._sortedRanges.length && this._sortedRanges[t].start < e.endExclusive;
        }
        intersectWithRange(e) {
          const t = new ST();
          for (const i of this._sortedRanges) {
            const n = i.intersect(e);
            n && t.addRange(n);
          }
          return t;
        }
        intersectWithRangeLength(e) {
          return this.intersectWithRange(e).length;
        }
        get length() {
          return this._sortedRanges.reduce((e, t) => e + t.length, 0);
        }
      }
      function gv(s, e) {
        const t = GG(s, e);
        if (t !== -1) return s[t];
      }
      function GG(s, e, t = s.length - 1) {
        for (let i = t; i >= 0; i--) {
          const n = s[i];
          if (e(n)) return i;
        }
        return -1;
      }
      function lg(s, e) {
        const t = t_(s, e);
        return t === -1 ? void 0 : s[t];
      }
      function t_(s, e, t = 0, i = s.length) {
        let n = t, o = i;
        for (; n < o; ) {
          const r = Math.floor((n + o) / 2);
          e(s[r]) ? n = r + 1 : o = r;
        }
        return n - 1;
      }
      function YG(s, e) {
        const t = tD(s, e);
        return t === s.length ? void 0 : s[t];
      }
      function tD(s, e, t = 0, i = s.length) {
        let n = t, o = i;
        for (; n < o; ) {
          const r = Math.floor((n + o) / 2);
          e(s[r]) ? o = r : n = r + 1;
        }
        return n;
      }
      const _ow = class _ow {
        constructor(e) {
          this._array = e, this._findLastMonotonousLastIdx = 0;
        }
        findLastMonotonous(e) {
          if (_ow.assertInvariants) {
            if (this._prevFindLastPredicate) {
              for (const i of this._array) if (this._prevFindLastPredicate(i) && !e(i)) throw new Error("MonotonousArray: current predicate must be weaker than (or equal to) the previous predicate.");
            }
            this._prevFindLastPredicate = e;
          }
          const t = t_(this._array, e, this._findLastMonotonousLastIdx);
          return this._findLastMonotonousLastIdx = t + 1, t === -1 ? void 0 : this._array[t];
        }
      };
      _ow.assertInvariants = false;
      let ow = _ow;
      function k8(s, e) {
        if (s.length === 0) return;
        let t = s[0];
        for (let i = 1; i < s.length; i++) {
          const n = s[i];
          e(n, t) > 0 && (t = n);
        }
        return t;
      }
      function ZG(s, e) {
        if (s.length === 0) return;
        let t = s[0];
        for (let i = 1; i < s.length; i++) {
          const n = s[i];
          e(n, t) >= 0 && (t = n);
        }
        return t;
      }
      function QG(s, e) {
        return k8(s, (t, i) => -e(t, i));
      }
      function XG(s, e) {
        if (s.length === 0) return -1;
        let t = 0;
        for (let i = 1; i < s.length; i++) {
          const n = s[i];
          e(n, s[t]) > 0 && (t = i);
        }
        return t;
      }
      let qe = class fl {
        static fromRangeInclusive(e) {
          return new fl(e.startLineNumber, e.endLineNumber + 1);
        }
        static joinMany(e) {
          if (e.length === 0) return [];
          let t = new Mo(e[0].slice());
          for (let i = 1; i < e.length; i++) t = t.getUnion(new Mo(e[i].slice()));
          return t.ranges;
        }
        static join(e) {
          if (e.length === 0) throw new It("lineRanges cannot be empty");
          let t = e[0].startLineNumber, i = e[0].endLineNumberExclusive;
          for (let n = 1; n < e.length; n++) t = Math.min(t, e[n].startLineNumber), i = Math.max(i, e[n].endLineNumberExclusive);
          return new fl(t, i);
        }
        static ofLength(e, t) {
          return new fl(e, e + t);
        }
        static deserialize(e) {
          return new fl(e[0], e[1]);
        }
        constructor(e, t) {
          if (e > t) throw new It(`startLineNumber ${e} cannot be after endLineNumberExclusive ${t}`);
          this.startLineNumber = e, this.endLineNumberExclusive = t;
        }
        contains(e) {
          return this.startLineNumber <= e && e < this.endLineNumberExclusive;
        }
        get isEmpty() {
          return this.startLineNumber === this.endLineNumberExclusive;
        }
        delta(e) {
          return new fl(this.startLineNumber + e, this.endLineNumberExclusive + e);
        }
        deltaLength(e) {
          return new fl(this.startLineNumber, this.endLineNumberExclusive + e);
        }
        get length() {
          return this.endLineNumberExclusive - this.startLineNumber;
        }
        join(e) {
          return new fl(Math.min(this.startLineNumber, e.startLineNumber), Math.max(this.endLineNumberExclusive, e.endLineNumberExclusive));
        }
        toString() {
          return `[${this.startLineNumber},${this.endLineNumberExclusive})`;
        }
        intersect(e) {
          const t = Math.max(this.startLineNumber, e.startLineNumber), i = Math.min(this.endLineNumberExclusive, e.endLineNumberExclusive);
          if (t <= i) return new fl(t, i);
        }
        intersectsStrict(e) {
          return this.startLineNumber < e.endLineNumberExclusive && e.startLineNumber < this.endLineNumberExclusive;
        }
        overlapOrTouch(e) {
          return this.startLineNumber <= e.endLineNumberExclusive && e.startLineNumber <= this.endLineNumberExclusive;
        }
        equals(e) {
          return this.startLineNumber === e.startLineNumber && this.endLineNumberExclusive === e.endLineNumberExclusive;
        }
        toInclusiveRange() {
          return this.isEmpty ? null : new z(this.startLineNumber, 1, this.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER);
        }
        toExclusiveRange() {
          return new z(this.startLineNumber, 1, this.endLineNumberExclusive, 1);
        }
        mapToLineArray(e) {
          const t = [];
          for (let i = this.startLineNumber; i < this.endLineNumberExclusive; i++) t.push(e(i));
          return t;
        }
        forEach(e) {
          for (let t = this.startLineNumber; t < this.endLineNumberExclusive; t++) e(t);
        }
        serialize() {
          return [
            this.startLineNumber,
            this.endLineNumberExclusive
          ];
        }
        includes(e) {
          return this.startLineNumber <= e && e < this.endLineNumberExclusive;
        }
        toOffsetRange() {
          return new Qe(this.startLineNumber - 1, this.endLineNumberExclusive - 1);
        }
      };
      class Mo {
        constructor(e = []) {
          this._normalizedRanges = e;
        }
        get ranges() {
          return this._normalizedRanges;
        }
        addRange(e) {
          if (e.length === 0) return;
          const t = tD(this._normalizedRanges, (n) => n.endLineNumberExclusive >= e.startLineNumber), i = t_(this._normalizedRanges, (n) => n.startLineNumber <= e.endLineNumberExclusive) + 1;
          if (t === i) this._normalizedRanges.splice(t, 0, e);
          else if (t === i - 1) {
            const n = this._normalizedRanges[t];
            this._normalizedRanges[t] = n.join(e);
          } else {
            const n = this._normalizedRanges[t].join(this._normalizedRanges[i - 1]).join(e);
            this._normalizedRanges.splice(t, i - t, n);
          }
        }
        contains(e) {
          const t = lg(this._normalizedRanges, (i) => i.startLineNumber <= e);
          return !!t && t.endLineNumberExclusive > e;
        }
        intersects(e) {
          const t = lg(this._normalizedRanges, (i) => i.startLineNumber < e.endLineNumberExclusive);
          return !!t && t.endLineNumberExclusive > e.startLineNumber;
        }
        getUnion(e) {
          if (this._normalizedRanges.length === 0) return e;
          if (e._normalizedRanges.length === 0) return this;
          const t = [];
          let i = 0, n = 0, o = null;
          for (; i < this._normalizedRanges.length || n < e._normalizedRanges.length; ) {
            let r = null;
            if (i < this._normalizedRanges.length && n < e._normalizedRanges.length) {
              const a = this._normalizedRanges[i], l = e._normalizedRanges[n];
              a.startLineNumber < l.startLineNumber ? (r = a, i++) : (r = l, n++);
            } else i < this._normalizedRanges.length ? (r = this._normalizedRanges[i], i++) : (r = e._normalizedRanges[n], n++);
            o === null ? o = r : o.endLineNumberExclusive >= r.startLineNumber ? o = new qe(o.startLineNumber, Math.max(o.endLineNumberExclusive, r.endLineNumberExclusive)) : (t.push(o), o = r);
          }
          return o !== null && t.push(o), new Mo(t);
        }
        subtractFrom(e) {
          const t = tD(this._normalizedRanges, (r) => r.endLineNumberExclusive >= e.startLineNumber), i = t_(this._normalizedRanges, (r) => r.startLineNumber <= e.endLineNumberExclusive) + 1;
          if (t === i) return new Mo([
            e
          ]);
          const n = [];
          let o = e.startLineNumber;
          for (let r = t; r < i; r++) {
            const a = this._normalizedRanges[r];
            a.startLineNumber > o && n.push(new qe(o, a.startLineNumber)), o = a.endLineNumberExclusive;
          }
          return o < e.endLineNumberExclusive && n.push(new qe(o, e.endLineNumberExclusive)), new Mo(n);
        }
        toString() {
          return this._normalizedRanges.map((e) => e.toString()).join(", ");
        }
        getIntersection(e) {
          const t = [];
          let i = 0, n = 0;
          for (; i < this._normalizedRanges.length && n < e._normalizedRanges.length; ) {
            const o = this._normalizedRanges[i], r = e._normalizedRanges[n], a = o.intersect(r);
            a && !a.isEmpty && t.push(a), o.endLineNumberExclusive < r.endLineNumberExclusive ? i++ : n++;
          }
          return new Mo(t);
        }
        getWithDelta(e) {
          return new Mo(this._normalizedRanges.map((t) => t.delta(e)));
        }
      }
      const _cr = class _cr {
        static betweenPositions(e, t) {
          return e.lineNumber === t.lineNumber ? new _cr(0, t.column - e.column) : new _cr(t.lineNumber - e.lineNumber, t.column - 1);
        }
        static ofRange(e) {
          return _cr.betweenPositions(e.getStartPosition(), e.getEndPosition());
        }
        static ofText(e) {
          let t = 0, i = 0;
          for (const n of e) n === `
` ? (t++, i = 0) : i++;
          return new _cr(t, i);
        }
        constructor(e, t) {
          this.lineCount = e, this.columnCount = t;
        }
        isGreaterThanOrEqualTo(e) {
          return this.lineCount !== e.lineCount ? this.lineCount > e.lineCount : this.columnCount >= e.columnCount;
        }
        createRange(e) {
          return this.lineCount === 0 ? new z(e.lineNumber, e.column, e.lineNumber, e.column + this.columnCount) : new z(e.lineNumber, e.column, e.lineNumber + this.lineCount, this.columnCount + 1);
        }
        addToPosition(e) {
          return this.lineCount === 0 ? new X(e.lineNumber, e.column + this.columnCount) : new X(e.lineNumber + this.lineCount, this.columnCount + 1);
        }
        toString() {
          return `${this.lineCount},${this.columnCount}`;
        }
      };
      _cr.zero = new _cr(0, 0);
      let cr = _cr;
      class JG {
        constructor(e) {
          this.text = e, this.lineStartOffsetByLineIdx = [], this.lineStartOffsetByLineIdx.push(0);
          for (let t = 0; t < e.length; t++) e.charAt(t) === `
` && this.lineStartOffsetByLineIdx.push(t + 1);
        }
        getOffset(e) {
          return this.lineStartOffsetByLineIdx[e.lineNumber - 1] + e.column - 1;
        }
        getOffsetRange(e) {
          return new Qe(this.getOffset(e.getStartPosition()), this.getOffset(e.getEndPosition()));
        }
        get textLength() {
          const e = this.lineStartOffsetByLineIdx.length - 1;
          return new cr(e, this.text.length - this.lineStartOffsetByLineIdx[e]);
        }
      }
      class eY {
        constructor(e) {
          this.edits = e, Oh(() => mT(e, (t, i) => t.range.getEndPosition().isBeforeOrEqual(i.range.getStartPosition())));
        }
        apply(e) {
          let t = "", i = new X(1, 1);
          for (const o of this.edits) {
            const r = o.range, a = r.getStartPosition(), l = r.getEndPosition(), u = VO(i, a);
            u.isEmpty() || (t += e.getValueOfRange(u)), t += o.text, i = l;
          }
          const n = VO(i, e.endPositionExclusive);
          return n.isEmpty() || (t += e.getValueOfRange(n)), t;
        }
        applyToString(e) {
          const t = new iY(e);
          return this.apply(t);
        }
        getNewRanges() {
          const e = [];
          let t = 0, i = 0, n = 0;
          for (const o of this.edits) {
            const r = cr.ofText(o.text), a = X.lift({
              lineNumber: o.range.startLineNumber + i,
              column: o.range.startColumn + (o.range.startLineNumber === t ? n : 0)
            }), l = r.createRange(a);
            e.push(l), i = l.endLineNumber - o.range.endLineNumber, n = l.endColumn - o.range.endColumn, t = o.range.endLineNumber;
          }
          return e;
        }
      }
      class tY {
        constructor(e, t) {
          this.range = e, this.text = t;
        }
        toSingleEditOperation() {
          return {
            range: this.range,
            text: this.text
          };
        }
      }
      function VO(s, e) {
        if (s.lineNumber === e.lineNumber && s.column === Number.MAX_SAFE_INTEGER) return z.fromPositions(e, e);
        if (!s.isBeforeOrEqual(e)) throw new It("start must be before end");
        return new z(s.lineNumber, s.column, e.lineNumber, e.column);
      }
      class D8 {
        get endPositionExclusive() {
          return this.length.addToPosition(new X(1, 1));
        }
      }
      class iY extends D8 {
        constructor(e) {
          super(), this.value = e, this._t = new JG(this.value);
        }
        getValueOfRange(e) {
          return this._t.getOffsetRange(e).substring(this.value);
        }
        get length() {
          return this._t.textLength;
        }
      }
      class is {
        static inverse(e, t, i) {
          const n = [];
          let o = 1, r = 1;
          for (const l of e) {
            const u = new is(new qe(o, l.original.startLineNumber), new qe(r, l.modified.startLineNumber));
            u.modified.isEmpty || n.push(u), o = l.original.endLineNumberExclusive, r = l.modified.endLineNumberExclusive;
          }
          const a = new is(new qe(o, t + 1), new qe(r, i + 1));
          return a.modified.isEmpty || n.push(a), n;
        }
        static clip(e, t, i) {
          const n = [];
          for (const o of e) {
            const r = o.original.intersect(t), a = o.modified.intersect(i);
            r && !r.isEmpty && a && !a.isEmpty && n.push(new is(r, a));
          }
          return n;
        }
        constructor(e, t) {
          this.original = e, this.modified = t;
        }
        toString() {
          return `{${this.original.toString()}->${this.modified.toString()}}`;
        }
        flip() {
          return new is(this.modified, this.original);
        }
        join(e) {
          return new is(this.original.join(e.original), this.modified.join(e.modified));
        }
        toRangeMapping() {
          const e = this.original.toInclusiveRange(), t = this.modified.toInclusiveRange();
          if (e && t) return new ro(e, t);
          if (this.original.startLineNumber === 1 || this.modified.startLineNumber === 1) {
            if (!(this.modified.startLineNumber === 1 && this.original.startLineNumber === 1)) throw new It("not a valid diff");
            return new ro(new z(this.original.startLineNumber, 1, this.original.endLineNumberExclusive, 1), new z(this.modified.startLineNumber, 1, this.modified.endLineNumberExclusive, 1));
          } else return new ro(new z(this.original.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), new z(this.modified.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER));
        }
        toRangeMapping2(e, t) {
          if (WO(this.original.endLineNumberExclusive, e) && WO(this.modified.endLineNumberExclusive, t)) return new ro(new z(this.original.startLineNumber, 1, this.original.endLineNumberExclusive, 1), new z(this.modified.startLineNumber, 1, this.modified.endLineNumberExclusive, 1));
          if (!this.original.isEmpty && !this.modified.isEmpty) return new ro(z.fromPositions(new X(this.original.startLineNumber, 1), Zd(new X(this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), e)), z.fromPositions(new X(this.modified.startLineNumber, 1), Zd(new X(this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), t)));
          if (this.original.startLineNumber > 1 && this.modified.startLineNumber > 1) return new ro(z.fromPositions(Zd(new X(this.original.startLineNumber - 1, Number.MAX_SAFE_INTEGER), e), Zd(new X(this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), e)), z.fromPositions(Zd(new X(this.modified.startLineNumber - 1, Number.MAX_SAFE_INTEGER), t), Zd(new X(this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), t)));
          throw new It();
        }
      }
      function Zd(s, e) {
        if (s.lineNumber < 1) return new X(1, 1);
        if (s.lineNumber > e.length) return new X(e.length, e[e.length - 1].length + 1);
        const t = e[s.lineNumber - 1];
        return s.column > t.length + 1 ? new X(s.lineNumber, t.length + 1) : s;
      }
      function WO(s, e) {
        return s >= 1 && s <= e.length;
      }
      class go extends is {
        static fromRangeMappings(e) {
          const t = qe.join(e.map((n) => qe.fromRangeInclusive(n.originalRange))), i = qe.join(e.map((n) => qe.fromRangeInclusive(n.modifiedRange)));
          return new go(t, i, e);
        }
        constructor(e, t, i) {
          super(e, t), this.innerChanges = i;
        }
        flip() {
          var _a3;
          return new go(this.modified, this.original, (_a3 = this.innerChanges) == null ? void 0 : _a3.map((e) => e.flip()));
        }
        withInnerChangesFromLineRanges() {
          return new go(this.original, this.modified, [
            this.toRangeMapping()
          ]);
        }
      }
      class ro {
        static assertSorted(e) {
          for (let t = 1; t < e.length; t++) {
            const i = e[t - 1], n = e[t];
            if (!(i.originalRange.getEndPosition().isBeforeOrEqual(n.originalRange.getStartPosition()) && i.modifiedRange.getEndPosition().isBeforeOrEqual(n.modifiedRange.getStartPosition()))) throw new It("Range mappings must be sorted");
          }
        }
        constructor(e, t) {
          this.originalRange = e, this.modifiedRange = t;
        }
        toString() {
          return `{${this.originalRange.toString()}->${this.modifiedRange.toString()}}`;
        }
        flip() {
          return new ro(this.modifiedRange, this.originalRange);
        }
        toTextEdit(e) {
          const t = e.getValueOfRange(this.modifiedRange);
          return new tY(this.originalRange, t);
        }
      }
      const nY = 3;
      class sY {
        computeDiff(e, t, i) {
          var _a3;
          const o = new aY(e, t, {
            maxComputationTime: i.maxComputationTimeMs,
            shouldIgnoreTrimWhitespace: i.ignoreTrimWhitespace,
            shouldComputeCharChanges: true,
            shouldMakePrettyDiff: true,
            shouldPostProcessCharChanges: true
          }).computeDiff(), r = [];
          let a = null;
          for (const l of o.changes) {
            let u;
            l.originalEndLineNumber === 0 ? u = new qe(l.originalStartLineNumber + 1, l.originalStartLineNumber + 1) : u = new qe(l.originalStartLineNumber, l.originalEndLineNumber + 1);
            let d;
            l.modifiedEndLineNumber === 0 ? d = new qe(l.modifiedStartLineNumber + 1, l.modifiedStartLineNumber + 1) : d = new qe(l.modifiedStartLineNumber, l.modifiedEndLineNumber + 1);
            let f = new go(u, d, (_a3 = l.charChanges) == null ? void 0 : _a3.map((m) => new ro(new z(m.originalStartLineNumber, m.originalStartColumn, m.originalEndLineNumber, m.originalEndColumn), new z(m.modifiedStartLineNumber, m.modifiedStartColumn, m.modifiedEndLineNumber, m.modifiedEndColumn))));
            a && (a.modified.endLineNumberExclusive === f.modified.startLineNumber || a.original.endLineNumberExclusive === f.original.startLineNumber) && (f = new go(a.original.join(f.original), a.modified.join(f.modified), a.innerChanges && f.innerChanges ? a.innerChanges.concat(f.innerChanges) : void 0), r.pop()), r.push(f), a = f;
          }
          return Oh(() => mT(r, (l, u) => u.original.startLineNumber - l.original.endLineNumberExclusive === u.modified.startLineNumber - l.modified.endLineNumberExclusive && l.original.endLineNumberExclusive < u.original.startLineNumber && l.modified.endLineNumberExclusive < u.modified.startLineNumber)), new w0(r, [], o.quitEarly);
        }
      }
      function E8(s, e, t, i) {
        return new Dl(s, e, t).ComputeDiff(i);
      }
      let HO = class {
        constructor(e) {
          const t = [], i = [];
          for (let n = 0, o = e.length; n < o; n++) t[n] = iD(e[n], 1), i[n] = nD(e[n], 1);
          this.lines = e, this._startColumns = t, this._endColumns = i;
        }
        getElements() {
          const e = [];
          for (let t = 0, i = this.lines.length; t < i; t++) e[t] = this.lines[t].substring(this._startColumns[t] - 1, this._endColumns[t] - 1);
          return e;
        }
        getStrictElement(e) {
          return this.lines[e];
        }
        getStartLineNumber(e) {
          return e + 1;
        }
        getEndLineNumber(e) {
          return e + 1;
        }
        createCharSequence(e, t, i) {
          const n = [], o = [], r = [];
          let a = 0;
          for (let l = t; l <= i; l++) {
            const u = this.lines[l], d = e ? this._startColumns[l] : 1, f = e ? this._endColumns[l] : u.length + 1;
            for (let m = d; m < f; m++) n[a] = u.charCodeAt(m - 1), o[a] = l + 1, r[a] = m, a++;
            !e && l < i && (n[a] = 10, o[a] = l + 1, r[a] = u.length + 1, a++);
          }
          return new oY(n, o, r);
        }
      };
      class oY {
        constructor(e, t, i) {
          this._charCodes = e, this._lineNumbers = t, this._columns = i;
        }
        toString() {
          return "[" + this._charCodes.map((e, t) => (e === 10 ? "\\n" : String.fromCharCode(e)) + `-(${this._lineNumbers[t]},${this._columns[t]})`).join(", ") + "]";
        }
        _assertIndex(e, t) {
          if (e < 0 || e >= t.length) throw new Error("Illegal index");
        }
        getElements() {
          return this._charCodes;
        }
        getStartLineNumber(e) {
          return e > 0 && e === this._lineNumbers.length ? this.getEndLineNumber(e - 1) : (this._assertIndex(e, this._lineNumbers), this._lineNumbers[e]);
        }
        getEndLineNumber(e) {
          return e === -1 ? this.getStartLineNumber(e + 1) : (this._assertIndex(e, this._lineNumbers), this._charCodes[e] === 10 ? this._lineNumbers[e] + 1 : this._lineNumbers[e]);
        }
        getStartColumn(e) {
          return e > 0 && e === this._columns.length ? this.getEndColumn(e - 1) : (this._assertIndex(e, this._columns), this._columns[e]);
        }
        getEndColumn(e) {
          return e === -1 ? this.getStartColumn(e + 1) : (this._assertIndex(e, this._columns), this._charCodes[e] === 10 ? 1 : this._columns[e] + 1);
        }
      }
      class Pf {
        constructor(e, t, i, n, o, r, a, l) {
          this.originalStartLineNumber = e, this.originalStartColumn = t, this.originalEndLineNumber = i, this.originalEndColumn = n, this.modifiedStartLineNumber = o, this.modifiedStartColumn = r, this.modifiedEndLineNumber = a, this.modifiedEndColumn = l;
        }
        static createFromDiffChange(e, t, i) {
          const n = t.getStartLineNumber(e.originalStart), o = t.getStartColumn(e.originalStart), r = t.getEndLineNumber(e.originalStart + e.originalLength - 1), a = t.getEndColumn(e.originalStart + e.originalLength - 1), l = i.getStartLineNumber(e.modifiedStart), u = i.getStartColumn(e.modifiedStart), d = i.getEndLineNumber(e.modifiedStart + e.modifiedLength - 1), f = i.getEndColumn(e.modifiedStart + e.modifiedLength - 1);
          return new Pf(n, o, r, a, l, u, d, f);
        }
      }
      function rY(s) {
        if (s.length <= 1) return s;
        const e = [
          s[0]
        ];
        let t = e[0];
        for (let i = 1, n = s.length; i < n; i++) {
          const o = s[i], r = o.originalStart - (t.originalStart + t.originalLength), a = o.modifiedStart - (t.modifiedStart + t.modifiedLength);
          Math.min(r, a) < nY ? (t.originalLength = o.originalStart + o.originalLength - t.originalStart, t.modifiedLength = o.modifiedStart + o.modifiedLength - t.modifiedStart) : (e.push(o), t = o);
        }
        return e;
      }
      class Cp {
        constructor(e, t, i, n, o) {
          this.originalStartLineNumber = e, this.originalEndLineNumber = t, this.modifiedStartLineNumber = i, this.modifiedEndLineNumber = n, this.charChanges = o;
        }
        static createFromDiffResult(e, t, i, n, o, r, a) {
          let l, u, d, f, m;
          if (t.originalLength === 0 ? (l = i.getStartLineNumber(t.originalStart) - 1, u = 0) : (l = i.getStartLineNumber(t.originalStart), u = i.getEndLineNumber(t.originalStart + t.originalLength - 1)), t.modifiedLength === 0 ? (d = n.getStartLineNumber(t.modifiedStart) - 1, f = 0) : (d = n.getStartLineNumber(t.modifiedStart), f = n.getEndLineNumber(t.modifiedStart + t.modifiedLength - 1)), r && t.originalLength > 0 && t.originalLength < 20 && t.modifiedLength > 0 && t.modifiedLength < 20 && o()) {
            const _ = i.createCharSequence(e, t.originalStart, t.originalStart + t.originalLength - 1), b = n.createCharSequence(e, t.modifiedStart, t.modifiedStart + t.modifiedLength - 1);
            if (_.getElements().length > 0 && b.getElements().length > 0) {
              let v = E8(_, b, o, true).changes;
              a && (v = rY(v)), m = [];
              for (let y = 0, x = v.length; y < x; y++) m.push(Pf.createFromDiffChange(v[y], _, b));
            }
          }
          return new Cp(l, u, d, f, m);
        }
      }
      class aY {
        constructor(e, t, i) {
          this.shouldComputeCharChanges = i.shouldComputeCharChanges, this.shouldPostProcessCharChanges = i.shouldPostProcessCharChanges, this.shouldIgnoreTrimWhitespace = i.shouldIgnoreTrimWhitespace, this.shouldMakePrettyDiff = i.shouldMakePrettyDiff, this.originalLines = e, this.modifiedLines = t, this.original = new HO(e), this.modified = new HO(t), this.continueLineDiff = zO(i.maxComputationTime), this.continueCharDiff = zO(i.maxComputationTime === 0 ? 0 : Math.min(i.maxComputationTime, 5e3));
        }
        computeDiff() {
          if (this.original.lines.length === 1 && this.original.lines[0].length === 0) return this.modified.lines.length === 1 && this.modified.lines[0].length === 0 ? {
            quitEarly: false,
            changes: []
          } : {
            quitEarly: false,
            changes: [
              {
                originalStartLineNumber: 1,
                originalEndLineNumber: 1,
                modifiedStartLineNumber: 1,
                modifiedEndLineNumber: this.modified.lines.length,
                charChanges: void 0
              }
            ]
          };
          if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) return {
            quitEarly: false,
            changes: [
              {
                originalStartLineNumber: 1,
                originalEndLineNumber: this.original.lines.length,
                modifiedStartLineNumber: 1,
                modifiedEndLineNumber: 1,
                charChanges: void 0
              }
            ]
          };
          const e = E8(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff), t = e.changes, i = e.quitEarly;
          if (this.shouldIgnoreTrimWhitespace) {
            const a = [];
            for (let l = 0, u = t.length; l < u; l++) a.push(Cp.createFromDiffResult(this.shouldIgnoreTrimWhitespace, t[l], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));
            return {
              quitEarly: i,
              changes: a
            };
          }
          const n = [];
          let o = 0, r = 0;
          for (let a = -1, l = t.length; a < l; a++) {
            const u = a + 1 < l ? t[a + 1] : null, d = u ? u.originalStart : this.originalLines.length, f = u ? u.modifiedStart : this.modifiedLines.length;
            for (; o < d && r < f; ) {
              const m = this.originalLines[o], _ = this.modifiedLines[r];
              if (m !== _) {
                {
                  let b = iD(m, 1), v = iD(_, 1);
                  for (; b > 1 && v > 1; ) {
                    const y = m.charCodeAt(b - 2), x = _.charCodeAt(v - 2);
                    if (y !== x) break;
                    b--, v--;
                  }
                  (b > 1 || v > 1) && this._pushTrimWhitespaceCharChange(n, o + 1, 1, b, r + 1, 1, v);
                }
                {
                  let b = nD(m, 1), v = nD(_, 1);
                  const y = m.length + 1, x = _.length + 1;
                  for (; b < y && v < x; ) {
                    const L = m.charCodeAt(b - 1), D = m.charCodeAt(v - 1);
                    if (L !== D) break;
                    b++, v++;
                  }
                  (b < y || v < x) && this._pushTrimWhitespaceCharChange(n, o + 1, b, y, r + 1, v, x);
                }
              }
              o++, r++;
            }
            u && (n.push(Cp.createFromDiffResult(this.shouldIgnoreTrimWhitespace, u, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges)), o += u.originalLength, r += u.modifiedLength);
          }
          return {
            quitEarly: i,
            changes: n
          };
        }
        _pushTrimWhitespaceCharChange(e, t, i, n, o, r, a) {
          if (this._mergeTrimWhitespaceCharChange(e, t, i, n, o, r, a)) return;
          let l;
          this.shouldComputeCharChanges && (l = [
            new Pf(t, i, t, n, o, r, o, a)
          ]), e.push(new Cp(t, t, o, o, l));
        }
        _mergeTrimWhitespaceCharChange(e, t, i, n, o, r, a) {
          const l = e.length;
          if (l === 0) return false;
          const u = e[l - 1];
          return u.originalEndLineNumber === 0 || u.modifiedEndLineNumber === 0 ? false : u.originalEndLineNumber === t && u.modifiedEndLineNumber === o ? (this.shouldComputeCharChanges && u.charChanges && u.charChanges.push(new Pf(t, i, t, n, o, r, o, a)), true) : u.originalEndLineNumber + 1 === t && u.modifiedEndLineNumber + 1 === o ? (u.originalEndLineNumber = t, u.modifiedEndLineNumber = o, this.shouldComputeCharChanges && u.charChanges && u.charChanges.push(new Pf(t, i, t, n, o, r, o, a)), true) : false;
        }
      }
      function iD(s, e) {
        const t = qs(s);
        return t === -1 ? e : t + 1;
      }
      function nD(s, e) {
        const t = qh(s);
        return t === -1 ? e : t + 2;
      }
      function zO(s) {
        if (s === 0) return () => true;
        const e = Date.now();
        return () => Date.now() - e < s;
      }
      class Vl {
        static trivial(e, t) {
          return new Vl([
            new ji(Qe.ofLength(e.length), Qe.ofLength(t.length))
          ], false);
        }
        static trivialTimedOut(e, t) {
          return new Vl([
            new ji(Qe.ofLength(e.length), Qe.ofLength(t.length))
          ], true);
        }
        constructor(e, t) {
          this.diffs = e, this.hitTimeout = t;
        }
      }
      class ji {
        static invert(e, t) {
          const i = [];
          return q7(e, (n, o) => {
            i.push(ji.fromOffsetPairs(n ? n.getEndExclusives() : Hr.zero, o ? o.getStarts() : new Hr(t, (n ? n.seq2Range.endExclusive - n.seq1Range.endExclusive : 0) + t)));
          }), i;
        }
        static fromOffsetPairs(e, t) {
          return new ji(new Qe(e.offset1, t.offset1), new Qe(e.offset2, t.offset2));
        }
        static assertSorted(e) {
          let t;
          for (const i of e) {
            if (t && !(t.seq1Range.endExclusive <= i.seq1Range.start && t.seq2Range.endExclusive <= i.seq2Range.start)) throw new It("Sequence diffs must be sorted");
            t = i;
          }
        }
        constructor(e, t) {
          this.seq1Range = e, this.seq2Range = t;
        }
        swap() {
          return new ji(this.seq2Range, this.seq1Range);
        }
        toString() {
          return `${this.seq1Range} <-> ${this.seq2Range}`;
        }
        join(e) {
          return new ji(this.seq1Range.join(e.seq1Range), this.seq2Range.join(e.seq2Range));
        }
        delta(e) {
          return e === 0 ? this : new ji(this.seq1Range.delta(e), this.seq2Range.delta(e));
        }
        deltaStart(e) {
          return e === 0 ? this : new ji(this.seq1Range.deltaStart(e), this.seq2Range.deltaStart(e));
        }
        deltaEnd(e) {
          return e === 0 ? this : new ji(this.seq1Range.deltaEnd(e), this.seq2Range.deltaEnd(e));
        }
        intersect(e) {
          const t = this.seq1Range.intersect(e.seq1Range), i = this.seq2Range.intersect(e.seq2Range);
          if (!(!t || !i)) return new ji(t, i);
        }
        getStarts() {
          return new Hr(this.seq1Range.start, this.seq2Range.start);
        }
        getEndExclusives() {
          return new Hr(this.seq1Range.endExclusive, this.seq2Range.endExclusive);
        }
      }
      const _Hr = class _Hr {
        constructor(e, t) {
          this.offset1 = e, this.offset2 = t;
        }
        toString() {
          return `${this.offset1} <-> ${this.offset2}`;
        }
        delta(e) {
          return e === 0 ? this : new _Hr(this.offset1 + e, this.offset2 + e);
        }
        equals(e) {
          return this.offset1 === e.offset1 && this.offset2 === e.offset2;
        }
      };
      _Hr.zero = new _Hr(0, 0);
      _Hr.max = new _Hr(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);
      let Hr = _Hr;
      const _j_ = class _j_ {
        isValid() {
          return true;
        }
      };
      _j_.instance = new _j_();
      let j_ = _j_;
      class lY {
        constructor(e) {
          if (this.timeout = e, this.startTime = Date.now(), this.valid = true, e <= 0) throw new It("timeout must be positive");
        }
        isValid() {
          if (!(Date.now() - this.startTime < this.timeout) && this.valid) {
            this.valid = false;
            debugger;
          }
          return this.valid;
        }
      }
      class FL {
        constructor(e, t) {
          this.width = e, this.height = t, this.array = [], this.array = new Array(e * t);
        }
        get(e, t) {
          return this.array[e + t * this.width];
        }
        set(e, t, i) {
          this.array[e + t * this.width] = i;
        }
      }
      function sD(s) {
        return s === 32 || s === 9;
      }
      const _i_ = class _i_ {
        static getKey(e) {
          let t = this.chrKeys.get(e);
          return t === void 0 && (t = this.chrKeys.size, this.chrKeys.set(e, t)), t;
        }
        constructor(e, t, i) {
          this.range = e, this.lines = t, this.source = i, this.histogram = [];
          let n = 0;
          for (let o = e.startLineNumber - 1; o < e.endLineNumberExclusive - 1; o++) {
            const r = t[o];
            for (let l = 0; l < r.length; l++) {
              n++;
              const u = r[l], d = _i_.getKey(u);
              this.histogram[d] = (this.histogram[d] || 0) + 1;
            }
            n++;
            const a = _i_.getKey(`
`);
            this.histogram[a] = (this.histogram[a] || 0) + 1;
          }
          this.totalCount = n;
        }
        computeSimilarity(e) {
          let t = 0;
          const i = Math.max(this.histogram.length, e.histogram.length);
          for (let n = 0; n < i; n++) t += Math.abs((this.histogram[n] ?? 0) - (e.histogram[n] ?? 0));
          return 1 - t / (this.totalCount + e.totalCount);
        }
      };
      _i_.chrKeys = /* @__PURE__ */ new Map();
      let i_ = _i_;
      class cY {
        compute(e, t, i = j_.instance, n) {
          if (e.length === 0 || t.length === 0) return Vl.trivial(e, t);
          const o = new FL(e.length, t.length), r = new FL(e.length, t.length), a = new FL(e.length, t.length);
          for (let b = 0; b < e.length; b++) for (let v = 0; v < t.length; v++) {
            if (!i.isValid()) return Vl.trivialTimedOut(e, t);
            const y = b === 0 ? 0 : o.get(b - 1, v), x = v === 0 ? 0 : o.get(b, v - 1);
            let L;
            e.getElement(b) === t.getElement(v) ? (b === 0 || v === 0 ? L = 0 : L = o.get(b - 1, v - 1), b > 0 && v > 0 && r.get(b - 1, v - 1) === 3 && (L += a.get(b - 1, v - 1)), L += n ? n(b, v) : 1) : L = -1;
            const D = Math.max(y, x, L);
            if (D === L) {
              const k = b > 0 && v > 0 ? a.get(b - 1, v - 1) : 0;
              a.set(b, v, k + 1), r.set(b, v, 3);
            } else D === y ? (a.set(b, v, 0), r.set(b, v, 1)) : D === x && (a.set(b, v, 0), r.set(b, v, 2));
            o.set(b, v, D);
          }
          const l = [];
          let u = e.length, d = t.length;
          function f(b, v) {
            (b + 1 !== u || v + 1 !== d) && l.push(new ji(new Qe(b + 1, u), new Qe(v + 1, d))), u = b, d = v;
          }
          let m = e.length - 1, _ = t.length - 1;
          for (; m >= 0 && _ >= 0; ) r.get(m, _) === 3 ? (f(m, _), m--, _--) : r.get(m, _) === 1 ? m-- : _--;
          return f(-1, -1), l.reverse(), new Vl(l, false);
        }
      }
      class T8 {
        compute(e, t, i = j_.instance) {
          if (e.length === 0 || t.length === 0) return Vl.trivial(e, t);
          const n = e, o = t;
          function r(v, y) {
            for (; v < n.length && y < o.length && n.getElement(v) === o.getElement(y); ) v++, y++;
            return v;
          }
          let a = 0;
          const l = new uY();
          l.set(0, r(0, 0));
          const u = new hY();
          u.set(0, l.get(0) === 0 ? null : new UO(null, 0, 0, l.get(0)));
          let d = 0;
          e: for (; ; ) {
            if (a++, !i.isValid()) return Vl.trivialTimedOut(n, o);
            const v = -Math.min(a, o.length + a % 2), y = Math.min(a, n.length + a % 2);
            for (d = v; d <= y; d += 2) {
              const x = d === y ? -1 : l.get(d + 1), L = d === v ? -1 : l.get(d - 1) + 1, D = Math.min(Math.max(x, L), n.length), k = D - d;
              if (D > n.length || k > o.length) continue;
              const T = r(D, k);
              l.set(d, T);
              const M = D === x ? u.get(d + 1) : u.get(d - 1);
              if (u.set(d, T !== D ? new UO(M, D, k, T - D) : M), l.get(d) === n.length && l.get(d) - d === o.length) break e;
            }
          }
          let f = u.get(d);
          const m = [];
          let _ = n.length, b = o.length;
          for (; ; ) {
            const v = f ? f.x + f.length : 0, y = f ? f.y + f.length : 0;
            if ((v !== _ || y !== b) && m.push(new ji(new Qe(v, _), new Qe(y, b))), !f) break;
            _ = f.x, b = f.y, f = f.prev;
          }
          return m.reverse(), new Vl(m, false);
        }
      }
      class UO {
        constructor(e, t, i, n) {
          this.prev = e, this.x = t, this.y = i, this.length = n;
        }
      }
      class uY {
        constructor() {
          this.positiveArr = new Int32Array(10), this.negativeArr = new Int32Array(10);
        }
        get(e) {
          return e < 0 ? (e = -e - 1, this.negativeArr[e]) : this.positiveArr[e];
        }
        set(e, t) {
          if (e < 0) {
            if (e = -e - 1, e >= this.negativeArr.length) {
              const i = this.negativeArr;
              this.negativeArr = new Int32Array(i.length * 2), this.negativeArr.set(i);
            }
            this.negativeArr[e] = t;
          } else {
            if (e >= this.positiveArr.length) {
              const i = this.positiveArr;
              this.positiveArr = new Int32Array(i.length * 2), this.positiveArr.set(i);
            }
            this.positiveArr[e] = t;
          }
        }
      }
      class hY {
        constructor() {
          this.positiveArr = [], this.negativeArr = [];
        }
        get(e) {
          return e < 0 ? (e = -e - 1, this.negativeArr[e]) : this.positiveArr[e];
        }
        set(e, t) {
          e < 0 ? (e = -e - 1, this.negativeArr[e] = t) : this.positiveArr[e] = t;
        }
      }
      class mv {
        constructor(e, t, i) {
          this.lines = e, this.range = t, this.considerWhitespaceChanges = i, this.elements = [], this.firstElementOffsetByLineIdx = [], this.lineStartOffsets = [], this.trimmedWsLengthsByLineIdx = [], this.firstElementOffsetByLineIdx.push(0);
          for (let n = this.range.startLineNumber; n <= this.range.endLineNumber; n++) {
            let o = e[n - 1], r = 0;
            n === this.range.startLineNumber && this.range.startColumn > 1 && (r = this.range.startColumn - 1, o = o.substring(r)), this.lineStartOffsets.push(r);
            let a = 0;
            if (!i) {
              const u = o.trimStart();
              a = o.length - u.length, o = u.trimEnd();
            }
            this.trimmedWsLengthsByLineIdx.push(a);
            const l = n === this.range.endLineNumber ? Math.min(this.range.endColumn - 1 - r - a, o.length) : o.length;
            for (let u = 0; u < l; u++) this.elements.push(o.charCodeAt(u));
            n < this.range.endLineNumber && (this.elements.push(10), this.firstElementOffsetByLineIdx.push(this.elements.length));
          }
        }
        toString() {
          return `Slice: "${this.text}"`;
        }
        get text() {
          return this.getText(new Qe(0, this.length));
        }
        getText(e) {
          return this.elements.slice(e.start, e.endExclusive).map((t) => String.fromCharCode(t)).join("");
        }
        getElement(e) {
          return this.elements[e];
        }
        get length() {
          return this.elements.length;
        }
        getBoundaryScore(e) {
          const t = qO(e > 0 ? this.elements[e - 1] : -1), i = qO(e < this.elements.length ? this.elements[e] : -1);
          if (t === 7 && i === 8) return 0;
          if (t === 8) return 150;
          let n = 0;
          return t !== i && (n += 10, t === 0 && i === 1 && (n += 1)), n += $O(t), n += $O(i), n;
        }
        translateOffset(e, t = "right") {
          const i = t_(this.firstElementOffsetByLineIdx, (o) => o <= e), n = e - this.firstElementOffsetByLineIdx[i];
          return new X(this.range.startLineNumber + i, 1 + this.lineStartOffsets[i] + n + (n === 0 && t === "left" ? 0 : this.trimmedWsLengthsByLineIdx[i]));
        }
        translateRange(e) {
          const t = this.translateOffset(e.start, "right"), i = this.translateOffset(e.endExclusive, "left");
          return i.isBefore(t) ? z.fromPositions(i, i) : z.fromPositions(t, i);
        }
        findWordContaining(e) {
          if (e < 0 || e >= this.elements.length || !VL(this.elements[e])) return;
          let t = e;
          for (; t > 0 && VL(this.elements[t - 1]); ) t--;
          let i = e;
          for (; i < this.elements.length && VL(this.elements[i]); ) i++;
          return new Qe(t, i);
        }
        countLinesIn(e) {
          return this.translateOffset(e.endExclusive).lineNumber - this.translateOffset(e.start).lineNumber;
        }
        isStronglyEqual(e, t) {
          return this.elements[e] === this.elements[t];
        }
        extendToFullLines(e) {
          const t = lg(this.firstElementOffsetByLineIdx, (n) => n <= e.start) ?? 0, i = YG(this.firstElementOffsetByLineIdx, (n) => e.endExclusive <= n) ?? this.elements.length;
          return new Qe(t, i);
        }
      }
      function VL(s) {
        return s >= 97 && s <= 122 || s >= 65 && s <= 90 || s >= 48 && s <= 57;
      }
      const dY = {
        0: 0,
        1: 0,
        2: 0,
        3: 10,
        4: 2,
        5: 30,
        6: 3,
        7: 10,
        8: 10
      };
      function $O(s) {
        return dY[s];
      }
      function qO(s) {
        return s === 10 ? 8 : s === 13 ? 7 : sD(s) ? 6 : s >= 97 && s <= 122 ? 0 : s >= 65 && s <= 90 ? 1 : s >= 48 && s <= 57 ? 2 : s === -1 ? 3 : s === 44 || s === 59 ? 5 : 4;
      }
      function fY(s, e, t, i, n, o) {
        let { moves: r, excludedChanges: a } = mY(s, e, t, o);
        if (!o.isValid()) return [];
        const l = s.filter((d) => !a.has(d)), u = pY(l, i, n, e, t, o);
        return Nx(r, u), r = _Y(r), r = r.filter((d) => {
          const f = d.original.toOffsetRange().slice(e).map((_) => _.trim());
          return f.join(`
`).length >= 15 && gY(f, (_) => _.length >= 2) >= 2;
        }), r = bY(s, r), r;
      }
      function gY(s, e) {
        let t = 0;
        for (const i of s) e(i) && t++;
        return t;
      }
      function mY(s, e, t, i) {
        const n = [], o = s.filter((l) => l.modified.isEmpty && l.original.length >= 3).map((l) => new i_(l.original, e, l)), r = new Set(s.filter((l) => l.original.isEmpty && l.modified.length >= 3).map((l) => new i_(l.modified, t, l))), a = /* @__PURE__ */ new Set();
        for (const l of o) {
          let u = -1, d;
          for (const f of r) {
            const m = l.computeSimilarity(f);
            m > u && (u = m, d = f);
          }
          if (u > 0.9 && d && (r.delete(d), n.push(new is(l.range, d.range)), a.add(l.source), a.add(d.source)), !i.isValid()) return {
            moves: n,
            excludedChanges: a
          };
        }
        return {
          moves: n,
          excludedChanges: a
        };
      }
      function pY(s, e, t, i, n, o) {
        const r = [], a = new L8();
        for (const m of s) for (let _ = m.original.startLineNumber; _ < m.original.endLineNumberExclusive - 2; _++) {
          const b = `${e[_ - 1]}:${e[_ + 1 - 1]}:${e[_ + 2 - 1]}`;
          a.add(b, {
            range: new qe(_, _ + 3)
          });
        }
        const l = [];
        s.sort(fr((m) => m.modified.startLineNumber, Zc));
        for (const m of s) {
          let _ = [];
          for (let b = m.modified.startLineNumber; b < m.modified.endLineNumberExclusive - 2; b++) {
            const v = `${t[b - 1]}:${t[b + 1 - 1]}:${t[b + 2 - 1]}`, y = new qe(b, b + 3), x = [];
            a.forEach(v, ({ range: L }) => {
              for (const k of _) if (k.originalLineRange.endLineNumberExclusive + 1 === L.endLineNumberExclusive && k.modifiedLineRange.endLineNumberExclusive + 1 === y.endLineNumberExclusive) {
                k.originalLineRange = new qe(k.originalLineRange.startLineNumber, L.endLineNumberExclusive), k.modifiedLineRange = new qe(k.modifiedLineRange.startLineNumber, y.endLineNumberExclusive), x.push(k);
                return;
              }
              const D = {
                modifiedLineRange: y,
                originalLineRange: L
              };
              l.push(D), x.push(D);
            }), _ = x;
          }
          if (!o.isValid()) return [];
        }
        l.sort(wU(fr((m) => m.modifiedLineRange.length, Zc)));
        const u = new Mo(), d = new Mo();
        for (const m of l) {
          const _ = m.modifiedLineRange.startLineNumber - m.originalLineRange.startLineNumber, b = u.subtractFrom(m.modifiedLineRange), v = d.subtractFrom(m.originalLineRange).getWithDelta(_), y = b.getIntersection(v);
          for (const x of y.ranges) {
            if (x.length < 3) continue;
            const L = x, D = x.delta(-_);
            r.push(new is(D, L)), u.addRange(L), d.addRange(D);
          }
        }
        r.sort(fr((m) => m.original.startLineNumber, Zc));
        const f = new ow(s);
        for (let m = 0; m < r.length; m++) {
          const _ = r[m], b = f.findLastMonotonous((M) => M.original.startLineNumber <= _.original.startLineNumber), v = lg(s, (M) => M.modified.startLineNumber <= _.modified.startLineNumber), y = Math.max(_.original.startLineNumber - b.original.startLineNumber, _.modified.startLineNumber - v.modified.startLineNumber), x = f.findLastMonotonous((M) => M.original.startLineNumber < _.original.endLineNumberExclusive), L = lg(s, (M) => M.modified.startLineNumber < _.modified.endLineNumberExclusive), D = Math.max(x.original.endLineNumberExclusive - _.original.endLineNumberExclusive, L.modified.endLineNumberExclusive - _.modified.endLineNumberExclusive);
          let k;
          for (k = 0; k < y; k++) {
            const M = _.original.startLineNumber - k - 1, I = _.modified.startLineNumber - k - 1;
            if (M > i.length || I > n.length || u.contains(I) || d.contains(M) || !KO(i[M - 1], n[I - 1], o)) break;
          }
          k > 0 && (d.addRange(new qe(_.original.startLineNumber - k, _.original.startLineNumber)), u.addRange(new qe(_.modified.startLineNumber - k, _.modified.startLineNumber)));
          let T;
          for (T = 0; T < D; T++) {
            const M = _.original.endLineNumberExclusive + T, I = _.modified.endLineNumberExclusive + T;
            if (M > i.length || I > n.length || u.contains(I) || d.contains(M) || !KO(i[M - 1], n[I - 1], o)) break;
          }
          T > 0 && (d.addRange(new qe(_.original.endLineNumberExclusive, _.original.endLineNumberExclusive + T)), u.addRange(new qe(_.modified.endLineNumberExclusive, _.modified.endLineNumberExclusive + T))), (k > 0 || T > 0) && (r[m] = new is(new qe(_.original.startLineNumber - k, _.original.endLineNumberExclusive + T), new qe(_.modified.startLineNumber - k, _.modified.endLineNumberExclusive + T)));
        }
        return r;
      }
      function KO(s, e, t) {
        if (s.trim() === e.trim()) return true;
        if (s.length > 300 && e.length > 300) return false;
        const n = new T8().compute(new mv([
          s
        ], new z(1, 1, 1, s.length), false), new mv([
          e
        ], new z(1, 1, 1, e.length), false), t);
        let o = 0;
        const r = ji.invert(n.diffs, s.length);
        for (const d of r) d.seq1Range.forEach((f) => {
          sD(s.charCodeAt(f)) || o++;
        });
        function a(d) {
          let f = 0;
          for (let m = 0; m < s.length; m++) sD(d.charCodeAt(m)) || f++;
          return f;
        }
        const l = a(s.length > e.length ? s : e);
        return o / l > 0.6 && l > 10;
      }
      function _Y(s) {
        if (s.length === 0) return s;
        s.sort(fr((t) => t.original.startLineNumber, Zc));
        const e = [
          s[0]
        ];
        for (let t = 1; t < s.length; t++) {
          const i = e[e.length - 1], n = s[t], o = n.original.startLineNumber - i.original.endLineNumberExclusive, r = n.modified.startLineNumber - i.modified.endLineNumberExclusive;
          if (o >= 0 && r >= 0 && o + r <= 2) {
            e[e.length - 1] = i.join(n);
            continue;
          }
          e.push(n);
        }
        return e;
      }
      function bY(s, e) {
        const t = new ow(s);
        return e = e.filter((i) => {
          const n = t.findLastMonotonous((a) => a.original.startLineNumber < i.original.endLineNumberExclusive) || new is(new qe(1, 1), new qe(1, 1)), o = lg(s, (a) => a.modified.startLineNumber < i.modified.endLineNumberExclusive);
          return n !== o;
        }), e;
      }
      function oD(s, e, t) {
        let i = t;
        return i = jO(s, e, i), i = jO(s, e, i), i = vY(s, e, i), i;
      }
      function jO(s, e, t) {
        if (t.length === 0) return t;
        const i = [];
        i.push(t[0]);
        for (let o = 1; o < t.length; o++) {
          const r = i[i.length - 1];
          let a = t[o];
          if (a.seq1Range.isEmpty || a.seq2Range.isEmpty) {
            const l = a.seq1Range.start - r.seq1Range.endExclusive;
            let u;
            for (u = 1; u <= l && !(s.getElement(a.seq1Range.start - u) !== s.getElement(a.seq1Range.endExclusive - u) || e.getElement(a.seq2Range.start - u) !== e.getElement(a.seq2Range.endExclusive - u)); u++) ;
            if (u--, u === l) {
              i[i.length - 1] = new ji(new Qe(r.seq1Range.start, a.seq1Range.endExclusive - l), new Qe(r.seq2Range.start, a.seq2Range.endExclusive - l));
              continue;
            }
            a = a.delta(-u);
          }
          i.push(a);
        }
        const n = [];
        for (let o = 0; o < i.length - 1; o++) {
          const r = i[o + 1];
          let a = i[o];
          if (a.seq1Range.isEmpty || a.seq2Range.isEmpty) {
            const l = r.seq1Range.start - a.seq1Range.endExclusive;
            let u;
            for (u = 0; u < l && !(!s.isStronglyEqual(a.seq1Range.start + u, a.seq1Range.endExclusive + u) || !e.isStronglyEqual(a.seq2Range.start + u, a.seq2Range.endExclusive + u)); u++) ;
            if (u === l) {
              i[o + 1] = new ji(new Qe(a.seq1Range.start + l, r.seq1Range.endExclusive), new Qe(a.seq2Range.start + l, r.seq2Range.endExclusive));
              continue;
            }
            u > 0 && (a = a.delta(u));
          }
          n.push(a);
        }
        return i.length > 0 && n.push(i[i.length - 1]), n;
      }
      function vY(s, e, t) {
        if (!s.getBoundaryScore || !e.getBoundaryScore) return t;
        for (let i = 0; i < t.length; i++) {
          const n = i > 0 ? t[i - 1] : void 0, o = t[i], r = i + 1 < t.length ? t[i + 1] : void 0, a = new Qe(n ? n.seq1Range.endExclusive + 1 : 0, r ? r.seq1Range.start - 1 : s.length), l = new Qe(n ? n.seq2Range.endExclusive + 1 : 0, r ? r.seq2Range.start - 1 : e.length);
          o.seq1Range.isEmpty ? t[i] = GO(o, s, e, a, l) : o.seq2Range.isEmpty && (t[i] = GO(o.swap(), e, s, l, a).swap());
        }
        return t;
      }
      function GO(s, e, t, i, n) {
        let r = 1;
        for (; s.seq1Range.start - r >= i.start && s.seq2Range.start - r >= n.start && t.isStronglyEqual(s.seq2Range.start - r, s.seq2Range.endExclusive - r) && r < 100; ) r++;
        r--;
        let a = 0;
        for (; s.seq1Range.start + a < i.endExclusive && s.seq2Range.endExclusive + a < n.endExclusive && t.isStronglyEqual(s.seq2Range.start + a, s.seq2Range.endExclusive + a) && a < 100; ) a++;
        if (r === 0 && a === 0) return s;
        let l = 0, u = -1;
        for (let d = -r; d <= a; d++) {
          const f = s.seq2Range.start + d, m = s.seq2Range.endExclusive + d, _ = s.seq1Range.start + d, b = e.getBoundaryScore(_) + t.getBoundaryScore(f) + t.getBoundaryScore(m);
          b > u && (u = b, l = d);
        }
        return s.delta(l);
      }
      function CY(s, e, t) {
        const i = [];
        for (const n of t) {
          const o = i[i.length - 1];
          if (!o) {
            i.push(n);
            continue;
          }
          n.seq1Range.start - o.seq1Range.endExclusive <= 2 || n.seq2Range.start - o.seq2Range.endExclusive <= 2 ? i[i.length - 1] = new ji(o.seq1Range.join(n.seq1Range), o.seq2Range.join(n.seq2Range)) : i.push(n);
        }
        return i;
      }
      function wY(s, e, t) {
        const i = ji.invert(t, s.length), n = [];
        let o = new Hr(0, 0);
        function r(l, u) {
          if (l.offset1 < o.offset1 || l.offset2 < o.offset2) return;
          const d = s.findWordContaining(l.offset1), f = e.findWordContaining(l.offset2);
          if (!d || !f) return;
          let m = new ji(d, f);
          const _ = m.intersect(u);
          let b = _.seq1Range.length, v = _.seq2Range.length;
          for (; i.length > 0; ) {
            const y = i[0];
            if (!(y.seq1Range.intersects(m.seq1Range) || y.seq2Range.intersects(m.seq2Range))) break;
            const L = s.findWordContaining(y.seq1Range.start), D = e.findWordContaining(y.seq2Range.start), k = new ji(L, D), T = k.intersect(y);
            if (b += T.seq1Range.length, v += T.seq2Range.length, m = m.join(k), m.seq1Range.endExclusive >= y.seq1Range.endExclusive) i.shift();
            else break;
          }
          b + v < (m.seq1Range.length + m.seq2Range.length) * 2 / 3 && n.push(m), o = m.getEndExclusives();
        }
        for (; i.length > 0; ) {
          const l = i.shift();
          l.seq1Range.isEmpty || (r(l.getStarts(), l), r(l.getEndExclusives().delta(-1), l));
        }
        return yY(t, n);
      }
      function yY(s, e) {
        const t = [];
        for (; s.length > 0 || e.length > 0; ) {
          const i = s[0], n = e[0];
          let o;
          i && (!n || i.seq1Range.start < n.seq1Range.start) ? o = s.shift() : o = e.shift(), t.length > 0 && t[t.length - 1].seq1Range.endExclusive >= o.seq1Range.start ? t[t.length - 1] = t[t.length - 1].join(o) : t.push(o);
        }
        return t;
      }
      function SY(s, e, t) {
        let i = t;
        if (i.length === 0) return i;
        let n = 0, o;
        do {
          o = false;
          const r = [
            i[0]
          ];
          for (let a = 1; a < i.length; a++) {
            let d = function(m, _) {
              const b = new Qe(u.seq1Range.endExclusive, l.seq1Range.start);
              return s.getText(b).replace(/\s/g, "").length <= 4 && (m.seq1Range.length + m.seq2Range.length > 5 || _.seq1Range.length + _.seq2Range.length > 5);
            };
            const l = i[a], u = r[r.length - 1];
            d(u, l) ? (o = true, r[r.length - 1] = r[r.length - 1].join(l)) : r.push(l);
          }
          i = r;
        } while (n++ < 10 && o);
        return i;
      }
      function LY(s, e, t) {
        let i = t;
        if (i.length === 0) return i;
        let n = 0, o;
        do {
          o = false;
          const a = [
            i[0]
          ];
          for (let l = 1; l < i.length; l++) {
            let f = function(_, b) {
              const v = new Qe(d.seq1Range.endExclusive, u.seq1Range.start);
              if (s.countLinesIn(v) > 5 || v.length > 500) return false;
              const x = s.getText(v).trim();
              if (x.length > 20 || x.split(/\r\n|\r|\n/).length > 1) return false;
              const L = s.countLinesIn(_.seq1Range), D = _.seq1Range.length, k = e.countLinesIn(_.seq2Range), T = _.seq2Range.length, M = s.countLinesIn(b.seq1Range), I = b.seq1Range.length, R = e.countLinesIn(b.seq2Range), A = b.seq2Range.length, Y = 2 * 40 + 50;
              function U(j) {
                return Math.min(j, Y);
              }
              return Math.pow(Math.pow(U(L * 40 + D), 1.5) + Math.pow(U(k * 40 + T), 1.5), 1.5) + Math.pow(Math.pow(U(M * 40 + I), 1.5) + Math.pow(U(R * 40 + A), 1.5), 1.5) > (Y ** 1.5) ** 1.5 * 1.3;
            };
            const u = i[l], d = a[a.length - 1];
            f(d, u) ? (o = true, a[a.length - 1] = a[a.length - 1].join(u)) : a.push(u);
          }
          i = a;
        } while (n++ < 10 && o);
        const r = [];
        return pU(i, (a, l, u) => {
          let d = l;
          function f(x) {
            return x.length > 0 && x.trim().length <= 3 && l.seq1Range.length + l.seq2Range.length > 100;
          }
          const m = s.extendToFullLines(l.seq1Range), _ = s.getText(new Qe(m.start, l.seq1Range.start));
          f(_) && (d = d.deltaStart(-_.length));
          const b = s.getText(new Qe(l.seq1Range.endExclusive, m.endExclusive));
          f(b) && (d = d.deltaEnd(b.length));
          const v = ji.fromOffsetPairs(a ? a.getEndExclusives() : Hr.zero, u ? u.getStarts() : Hr.max), y = d.intersect(v);
          r.length > 0 && y.getStarts().equals(r[r.length - 1].getEndExclusives()) ? r[r.length - 1] = r[r.length - 1].join(y) : r.push(y);
        }), r;
      }
      class YO {
        constructor(e, t) {
          this.trimmedHash = e, this.lines = t;
        }
        getElement(e) {
          return this.trimmedHash[e];
        }
        get length() {
          return this.trimmedHash.length;
        }
        getBoundaryScore(e) {
          const t = e === 0 ? 0 : ZO(this.lines[e - 1]), i = e === this.lines.length ? 0 : ZO(this.lines[e]);
          return 1e3 - (t + i);
        }
        getText(e) {
          return this.lines.slice(e.start, e.endExclusive).join(`
`);
        }
        isStronglyEqual(e, t) {
          return this.lines[e] === this.lines[t];
        }
      }
      function ZO(s) {
        let e = 0;
        for (; e < s.length && (s.charCodeAt(e) === 32 || s.charCodeAt(e) === 9); ) e++;
        return e;
      }
      class N8 {
        constructor() {
          this.dynamicProgrammingDiffing = new cY(), this.myersDiffingAlgorithm = new T8();
        }
        computeDiff(e, t, i) {
          if (e.length <= 1 && Qi(e, t, (T, M) => T === M)) return new w0([], [], false);
          if (e.length === 1 && e[0].length === 0 || t.length === 1 && t[0].length === 0) return new w0([
            new go(new qe(1, e.length + 1), new qe(1, t.length + 1), [
              new ro(new z(1, 1, e.length, e[e.length - 1].length + 1), new z(1, 1, t.length, t[t.length - 1].length + 1))
            ])
          ], [], false);
          const n = i.maxComputationTimeMs === 0 ? j_.instance : new lY(i.maxComputationTimeMs), o = !i.ignoreTrimWhitespace, r = /* @__PURE__ */ new Map();
          function a(T) {
            let M = r.get(T);
            return M === void 0 && (M = r.size, r.set(T, M)), M;
          }
          const l = e.map((T) => a(T.trim())), u = t.map((T) => a(T.trim())), d = new YO(l, e), f = new YO(u, t), m = d.length + f.length < 1700 ? this.dynamicProgrammingDiffing.compute(d, f, n, (T, M) => e[T] === t[M] ? t[M].length === 0 ? 0.1 : 1 + Math.log(1 + t[M].length) : 0.99) : this.myersDiffingAlgorithm.compute(d, f, n);
          let _ = m.diffs, b = m.hitTimeout;
          _ = oD(d, f, _), _ = SY(d, f, _);
          const v = [], y = (T) => {
            if (o) for (let M = 0; M < T; M++) {
              const I = x + M, R = L + M;
              if (e[I] !== t[R]) {
                const A = this.refineDiff(e, t, new ji(new Qe(I, I + 1), new Qe(R, R + 1)), n, o);
                for (const Y of A.mappings) v.push(Y);
                A.hitTimeout && (b = true);
              }
            }
          };
          let x = 0, L = 0;
          for (const T of _) {
            Oh(() => T.seq1Range.start - x === T.seq2Range.start - L);
            const M = T.seq1Range.start - x;
            y(M), x = T.seq1Range.endExclusive, L = T.seq2Range.endExclusive;
            const I = this.refineDiff(e, t, T, n, o);
            I.hitTimeout && (b = true);
            for (const R of I.mappings) v.push(R);
          }
          y(e.length - x);
          const D = QO(v, e, t);
          let k = [];
          return i.computeMoves && (k = this.computeMoves(D, e, t, l, u, n, o)), Oh(() => {
            function T(I, R) {
              if (I.lineNumber < 1 || I.lineNumber > R.length) return false;
              const A = R[I.lineNumber - 1];
              return !(I.column < 1 || I.column > A.length + 1);
            }
            function M(I, R) {
              return !(I.startLineNumber < 1 || I.startLineNumber > R.length + 1 || I.endLineNumberExclusive < 1 || I.endLineNumberExclusive > R.length + 1);
            }
            for (const I of D) {
              if (!I.innerChanges) return false;
              for (const R of I.innerChanges) if (!(T(R.modifiedRange.getStartPosition(), t) && T(R.modifiedRange.getEndPosition(), t) && T(R.originalRange.getStartPosition(), e) && T(R.originalRange.getEndPosition(), e))) return false;
              if (!M(I.modified, t) || !M(I.original, e)) return false;
            }
            return true;
          }), new w0(D, k, b);
        }
        computeMoves(e, t, i, n, o, r, a) {
          return fY(e, t, i, n, o, r).map((d) => {
            const f = this.refineDiff(t, i, new ji(d.original.toOffsetRange(), d.modified.toOffsetRange()), r, a), m = QO(f.mappings, t, i, true);
            return new x8(d, m);
          });
        }
        refineDiff(e, t, i, n, o) {
          const a = kY(i).toRangeMapping2(e, t), l = new mv(e, a.originalRange, o), u = new mv(t, a.modifiedRange, o), d = l.length + u.length < 500 ? this.dynamicProgrammingDiffing.compute(l, u, n) : this.myersDiffingAlgorithm.compute(l, u, n);
          let f = d.diffs;
          return f = oD(l, u, f), f = wY(l, u, f), f = CY(l, u, f), f = LY(l, u, f), {
            mappings: f.map((_) => new ro(l.translateRange(_.seq1Range), u.translateRange(_.seq2Range))),
            hitTimeout: d.hitTimeout
          };
        }
      }
      function QO(s, e, t, i = false) {
        const n = [];
        for (const o of TE(s.map((r) => xY(r, e, t)), (r, a) => r.original.overlapOrTouch(a.original) || r.modified.overlapOrTouch(a.modified))) {
          const r = o[0], a = o[o.length - 1];
          n.push(new go(r.original.join(a.original), r.modified.join(a.modified), o.map((l) => l.innerChanges[0])));
        }
        return Oh(() => !i && n.length > 0 && (n[0].modified.startLineNumber !== n[0].original.startLineNumber || t.length - n[n.length - 1].modified.endLineNumberExclusive !== e.length - n[n.length - 1].original.endLineNumberExclusive) ? false : mT(n, (o, r) => r.original.startLineNumber - o.original.endLineNumberExclusive === r.modified.startLineNumber - o.modified.endLineNumberExclusive && o.original.endLineNumberExclusive < r.original.startLineNumber && o.modified.endLineNumberExclusive < r.modified.startLineNumber)), n;
      }
      function xY(s, e, t) {
        let i = 0, n = 0;
        s.modifiedRange.endColumn === 1 && s.originalRange.endColumn === 1 && s.originalRange.startLineNumber + i <= s.originalRange.endLineNumber && s.modifiedRange.startLineNumber + i <= s.modifiedRange.endLineNumber && (n = -1), s.modifiedRange.startColumn - 1 >= t[s.modifiedRange.startLineNumber - 1].length && s.originalRange.startColumn - 1 >= e[s.originalRange.startLineNumber - 1].length && s.originalRange.startLineNumber <= s.originalRange.endLineNumber + n && s.modifiedRange.startLineNumber <= s.modifiedRange.endLineNumber + n && (i = 1);
        const o = new qe(s.originalRange.startLineNumber + i, s.originalRange.endLineNumber + 1 + n), r = new qe(s.modifiedRange.startLineNumber + i, s.modifiedRange.endLineNumber + 1 + n);
        return new go(o, r, [
          s
        ]);
      }
      function kY(s) {
        return new is(new qe(s.seq1Range.start + 1, s.seq1Range.endExclusive + 1), new qe(s.seq2Range.start + 1, s.seq2Range.endExclusive + 1));
      }
      const XO = {
        getLegacy: () => new sY(),
        getDefault: () => new N8()
      };
      function eu(s, e) {
        const t = Math.pow(10, e);
        return Math.round(s * t) / t;
      }
      class yt {
        constructor(e, t, i, n = 1) {
          this._rgbaBrand = void 0, this.r = Math.min(255, Math.max(0, e)) | 0, this.g = Math.min(255, Math.max(0, t)) | 0, this.b = Math.min(255, Math.max(0, i)) | 0, this.a = eu(Math.max(Math.min(1, n), 0), 3);
        }
        static equals(e, t) {
          return e.r === t.r && e.g === t.g && e.b === t.b && e.a === t.a;
        }
      }
      class rr {
        constructor(e, t, i, n) {
          this._hslaBrand = void 0, this.h = Math.max(Math.min(360, e), 0) | 0, this.s = eu(Math.max(Math.min(1, t), 0), 3), this.l = eu(Math.max(Math.min(1, i), 0), 3), this.a = eu(Math.max(Math.min(1, n), 0), 3);
        }
        static equals(e, t) {
          return e.h === t.h && e.s === t.s && e.l === t.l && e.a === t.a;
        }
        static fromRGBA(e) {
          const t = e.r / 255, i = e.g / 255, n = e.b / 255, o = e.a, r = Math.max(t, i, n), a = Math.min(t, i, n);
          let l = 0, u = 0;
          const d = (a + r) / 2, f = r - a;
          if (f > 0) {
            switch (u = Math.min(d <= 0.5 ? f / (2 * d) : f / (2 - 2 * d), 1), r) {
              case t:
                l = (i - n) / f + (i < n ? 6 : 0);
                break;
              case i:
                l = (n - t) / f + 2;
                break;
              case n:
                l = (t - i) / f + 4;
                break;
            }
            l *= 60, l = Math.round(l);
          }
          return new rr(l, u, d, o);
        }
        static _hue2rgb(e, t, i) {
          return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? e + (t - e) * 6 * i : i < 1 / 2 ? t : i < 2 / 3 ? e + (t - e) * (2 / 3 - i) * 6 : e;
        }
        static toRGBA(e) {
          const t = e.h / 360, { s: i, l: n, a: o } = e;
          let r, a, l;
          if (i === 0) r = a = l = n;
          else {
            const u = n < 0.5 ? n * (1 + i) : n + i - n * i, d = 2 * n - u;
            r = rr._hue2rgb(d, u, t + 1 / 3), a = rr._hue2rgb(d, u, t), l = rr._hue2rgb(d, u, t - 1 / 3);
          }
          return new yt(Math.round(r * 255), Math.round(a * 255), Math.round(l * 255), o);
        }
      }
      class gf {
        constructor(e, t, i, n) {
          this._hsvaBrand = void 0, this.h = Math.max(Math.min(360, e), 0) | 0, this.s = eu(Math.max(Math.min(1, t), 0), 3), this.v = eu(Math.max(Math.min(1, i), 0), 3), this.a = eu(Math.max(Math.min(1, n), 0), 3);
        }
        static equals(e, t) {
          return e.h === t.h && e.s === t.s && e.v === t.v && e.a === t.a;
        }
        static fromRGBA(e) {
          const t = e.r / 255, i = e.g / 255, n = e.b / 255, o = Math.max(t, i, n), r = Math.min(t, i, n), a = o - r, l = o === 0 ? 0 : a / o;
          let u;
          return a === 0 ? u = 0 : o === t ? u = ((i - n) / a % 6 + 6) % 6 : o === i ? u = (n - t) / a + 2 : u = (t - i) / a + 4, new gf(Math.round(u * 60), l, o, e.a);
        }
        static toRGBA(e) {
          const { h: t, s: i, v: n, a: o } = e, r = n * i, a = r * (1 - Math.abs(t / 60 % 2 - 1)), l = n - r;
          let [u, d, f] = [
            0,
            0,
            0
          ];
          return t < 60 ? (u = r, d = a) : t < 120 ? (u = a, d = r) : t < 180 ? (d = r, f = a) : t < 240 ? (d = a, f = r) : t < 300 ? (u = a, f = r) : t <= 360 && (u = r, f = a), u = Math.round((u + l) * 255), d = Math.round((d + l) * 255), f = Math.round((f + l) * 255), new yt(u, d, f, o);
        }
      }
      const _le2 = class _le2 {
        static fromHex(e) {
          return _le2.Format.CSS.parseHex(e) || _le2.red;
        }
        static equals(e, t) {
          return !e && !t ? true : !e || !t ? false : e.equals(t);
        }
        get hsla() {
          return this._hsla ? this._hsla : rr.fromRGBA(this.rgba);
        }
        get hsva() {
          return this._hsva ? this._hsva : gf.fromRGBA(this.rgba);
        }
        constructor(e) {
          if (e) if (e instanceof yt) this.rgba = e;
          else if (e instanceof rr) this._hsla = e, this.rgba = rr.toRGBA(e);
          else if (e instanceof gf) this._hsva = e, this.rgba = gf.toRGBA(e);
          else throw new Error("Invalid color ctor argument");
          else throw new Error("Color needs a value");
        }
        equals(e) {
          return !!e && yt.equals(this.rgba, e.rgba) && rr.equals(this.hsla, e.hsla) && gf.equals(this.hsva, e.hsva);
        }
        getRelativeLuminance() {
          const e = _le2._relativeLuminanceForComponent(this.rgba.r), t = _le2._relativeLuminanceForComponent(this.rgba.g), i = _le2._relativeLuminanceForComponent(this.rgba.b), n = 0.2126 * e + 0.7152 * t + 0.0722 * i;
          return eu(n, 4);
        }
        static _relativeLuminanceForComponent(e) {
          const t = e / 255;
          return t <= 0.03928 ? t / 12.92 : Math.pow((t + 0.055) / 1.055, 2.4);
        }
        isLighter() {
          return (this.rgba.r * 299 + this.rgba.g * 587 + this.rgba.b * 114) / 1e3 >= 128;
        }
        isLighterThan(e) {
          const t = this.getRelativeLuminance(), i = e.getRelativeLuminance();
          return t > i;
        }
        isDarkerThan(e) {
          const t = this.getRelativeLuminance(), i = e.getRelativeLuminance();
          return t < i;
        }
        lighten(e) {
          return new _le2(new rr(this.hsla.h, this.hsla.s, this.hsla.l + this.hsla.l * e, this.hsla.a));
        }
        darken(e) {
          return new _le2(new rr(this.hsla.h, this.hsla.s, this.hsla.l - this.hsla.l * e, this.hsla.a));
        }
        transparent(e) {
          const { r: t, g: i, b: n, a: o } = this.rgba;
          return new _le2(new yt(t, i, n, o * e));
        }
        isTransparent() {
          return this.rgba.a === 0;
        }
        isOpaque() {
          return this.rgba.a === 1;
        }
        opposite() {
          return new _le2(new yt(255 - this.rgba.r, 255 - this.rgba.g, 255 - this.rgba.b, this.rgba.a));
        }
        makeOpaque(e) {
          if (this.isOpaque() || e.rgba.a !== 1) return this;
          const { r: t, g: i, b: n, a: o } = this.rgba;
          return new _le2(new yt(e.rgba.r - o * (e.rgba.r - t), e.rgba.g - o * (e.rgba.g - i), e.rgba.b - o * (e.rgba.b - n), 1));
        }
        toString() {
          return this._toString || (this._toString = _le2.Format.CSS.format(this)), this._toString;
        }
        static getLighterColor(e, t, i) {
          if (e.isLighterThan(t)) return e;
          i = i || 0.5;
          const n = e.getRelativeLuminance(), o = t.getRelativeLuminance();
          return i = i * (o - n) / o, e.lighten(i);
        }
        static getDarkerColor(e, t, i) {
          if (e.isDarkerThan(t)) return e;
          i = i || 0.5;
          const n = e.getRelativeLuminance(), o = t.getRelativeLuminance();
          return i = i * (n - o) / n, e.darken(i);
        }
      };
      _le2.white = new _le2(new yt(255, 255, 255, 1));
      _le2.black = new _le2(new yt(0, 0, 0, 1));
      _le2.red = new _le2(new yt(255, 0, 0, 1));
      _le2.blue = new _le2(new yt(0, 0, 255, 1));
      _le2.green = new _le2(new yt(0, 255, 0, 1));
      _le2.cyan = new _le2(new yt(0, 255, 255, 1));
      _le2.lightgrey = new _le2(new yt(211, 211, 211, 1));
      _le2.transparent = new _le2(new yt(0, 0, 0, 0));
      let le = _le2;
      (function(s) {
        (function(e) {
          (function(t) {
            function i(_) {
              return _.rgba.a === 1 ? `rgb(${_.rgba.r}, ${_.rgba.g}, ${_.rgba.b})` : s.Format.CSS.formatRGBA(_);
            }
            t.formatRGB = i;
            function n(_) {
              return `rgba(${_.rgba.r}, ${_.rgba.g}, ${_.rgba.b}, ${+_.rgba.a.toFixed(2)})`;
            }
            t.formatRGBA = n;
            function o(_) {
              return _.hsla.a === 1 ? `hsl(${_.hsla.h}, ${(_.hsla.s * 100).toFixed(2)}%, ${(_.hsla.l * 100).toFixed(2)}%)` : s.Format.CSS.formatHSLA(_);
            }
            t.formatHSL = o;
            function r(_) {
              return `hsla(${_.hsla.h}, ${(_.hsla.s * 100).toFixed(2)}%, ${(_.hsla.l * 100).toFixed(2)}%, ${_.hsla.a.toFixed(2)})`;
            }
            t.formatHSLA = r;
            function a(_) {
              const b = _.toString(16);
              return b.length !== 2 ? "0" + b : b;
            }
            function l(_) {
              return `#${a(_.rgba.r)}${a(_.rgba.g)}${a(_.rgba.b)}`;
            }
            t.formatHex = l;
            function u(_, b = false) {
              return b && _.rgba.a === 1 ? s.Format.CSS.formatHex(_) : `#${a(_.rgba.r)}${a(_.rgba.g)}${a(_.rgba.b)}${a(Math.round(_.rgba.a * 255))}`;
            }
            t.formatHexA = u;
            function d(_) {
              return _.isOpaque() ? s.Format.CSS.formatHex(_) : s.Format.CSS.formatRGBA(_);
            }
            t.format = d;
            function f(_) {
              const b = _.length;
              if (b === 0 || _.charCodeAt(0) !== 35) return null;
              if (b === 7) {
                const v = 16 * m(_.charCodeAt(1)) + m(_.charCodeAt(2)), y = 16 * m(_.charCodeAt(3)) + m(_.charCodeAt(4)), x = 16 * m(_.charCodeAt(5)) + m(_.charCodeAt(6));
                return new s(new yt(v, y, x, 1));
              }
              if (b === 9) {
                const v = 16 * m(_.charCodeAt(1)) + m(_.charCodeAt(2)), y = 16 * m(_.charCodeAt(3)) + m(_.charCodeAt(4)), x = 16 * m(_.charCodeAt(5)) + m(_.charCodeAt(6)), L = 16 * m(_.charCodeAt(7)) + m(_.charCodeAt(8));
                return new s(new yt(v, y, x, L / 255));
              }
              if (b === 4) {
                const v = m(_.charCodeAt(1)), y = m(_.charCodeAt(2)), x = m(_.charCodeAt(3));
                return new s(new yt(16 * v + v, 16 * y + y, 16 * x + x));
              }
              if (b === 5) {
                const v = m(_.charCodeAt(1)), y = m(_.charCodeAt(2)), x = m(_.charCodeAt(3)), L = m(_.charCodeAt(4));
                return new s(new yt(16 * v + v, 16 * y + y, 16 * x + x, (16 * L + L) / 255));
              }
              return null;
            }
            t.parseHex = f;
            function m(_) {
              switch (_) {
                case 48:
                  return 0;
                case 49:
                  return 1;
                case 50:
                  return 2;
                case 51:
                  return 3;
                case 52:
                  return 4;
                case 53:
                  return 5;
                case 54:
                  return 6;
                case 55:
                  return 7;
                case 56:
                  return 8;
                case 57:
                  return 9;
                case 97:
                  return 10;
                case 65:
                  return 10;
                case 98:
                  return 11;
                case 66:
                  return 11;
                case 99:
                  return 12;
                case 67:
                  return 12;
                case 100:
                  return 13;
                case 68:
                  return 13;
                case 101:
                  return 14;
                case 69:
                  return 14;
                case 102:
                  return 15;
                case 70:
                  return 15;
              }
              return 0;
            }
          })(e.CSS || (e.CSS = {}));
        })(s.Format || (s.Format = {}));
      })(le || (le = {}));
      function I8(s) {
        const e = [];
        for (const t of s) {
          const i = Number(t);
          (i || i === 0 && t.replace(/\s/g, "") !== "") && e.push(i);
        }
        return e;
      }
      function LT(s, e, t, i) {
        return {
          red: s / 255,
          blue: t / 255,
          green: e / 255,
          alpha: i
        };
      }
      function Fm(s, e) {
        const t = e.index, i = e[0].length;
        if (!t) return;
        const n = s.positionAt(t);
        return {
          startLineNumber: n.lineNumber,
          startColumn: n.column,
          endLineNumber: n.lineNumber,
          endColumn: n.column + i
        };
      }
      function DY(s, e) {
        if (!s) return;
        const t = le.Format.CSS.parseHex(e);
        if (t) return {
          range: s,
          color: LT(t.rgba.r, t.rgba.g, t.rgba.b, t.rgba.a)
        };
      }
      function JO(s, e, t) {
        if (!s || e.length !== 1) return;
        const n = e[0].values(), o = I8(n);
        return {
          range: s,
          color: LT(o[0], o[1], o[2], t ? o[3] : 1)
        };
      }
      function e5(s, e, t) {
        if (!s || e.length !== 1) return;
        const n = e[0].values(), o = I8(n), r = new le(new rr(o[0], o[1] / 100, o[2] / 100, t ? o[3] : 1));
        return {
          range: s,
          color: LT(r.rgba.r, r.rgba.g, r.rgba.b, r.rgba.a)
        };
      }
      function Vm(s, e) {
        return typeof s == "string" ? [
          ...s.matchAll(e)
        ] : s.findMatches(e);
      }
      function EY(s) {
        const e = [], i = Vm(s, /\b(rgb|rgba|hsl|hsla)(\([0-9\s,.\%]*\))|(#)([A-Fa-f0-9]{3})\b|(#)([A-Fa-f0-9]{4})\b|(#)([A-Fa-f0-9]{6})\b|(#)([A-Fa-f0-9]{8})\b/gm);
        if (i.length > 0) for (const n of i) {
          const o = n.filter((u) => u !== void 0), r = o[1], a = o[2];
          if (!a) continue;
          let l;
          if (r === "rgb") {
            const u = /^\(\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*\)$/gm;
            l = JO(Fm(s, n), Vm(a, u), false);
          } else if (r === "rgba") {
            const u = /^\(\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(0[.][0-9]+|[.][0-9]+|[01][.]|[01])\s*\)$/gm;
            l = JO(Fm(s, n), Vm(a, u), true);
          } else if (r === "hsl") {
            const u = /^\(\s*(36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*\)$/gm;
            l = e5(Fm(s, n), Vm(a, u), false);
          } else if (r === "hsla") {
            const u = /^\(\s*(36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*,\s*(0[.][0-9]+|[.][0-9]+|[01][.]|[01])\s*\)$/gm;
            l = e5(Fm(s, n), Vm(a, u), true);
          } else r === "#" && (l = DY(Fm(s, n), r + a));
          l && e.push(l);
        }
        return e;
      }
      function TY(s) {
        return !s || typeof s.getValue != "function" || typeof s.positionAt != "function" ? [] : EY(s);
      }
      const t5 = new RegExp("\\bMARK:\\s*(.*)$", "d"), NY = /^-+|-+$/g;
      function IY(s, e) {
        var _a3;
        let t = [];
        if (e.findRegionSectionHeaders && ((_a3 = e.foldingRules) == null ? void 0 : _a3.markers)) {
          const i = MY(s, e);
          t = t.concat(i);
        }
        if (e.findMarkSectionHeaders) {
          const i = AY(s);
          t = t.concat(i);
        }
        return t;
      }
      function MY(s, e) {
        const t = [], i = s.getLineCount();
        for (let n = 1; n <= i; n++) {
          const o = s.getLineContent(n), r = o.match(e.foldingRules.markers.start);
          if (r) {
            const a = {
              startLineNumber: n,
              startColumn: r[0].length + 1,
              endLineNumber: n,
              endColumn: o.length + 1
            };
            if (a.endColumn > a.startColumn) {
              const l = {
                range: a,
                ...M8(o.substring(r[0].length)),
                shouldBeInComments: false
              };
              (l.text || l.hasSeparatorLine) && t.push(l);
            }
          }
        }
        return t;
      }
      function AY(s) {
        const e = [], t = s.getLineCount();
        for (let i = 1; i <= t; i++) {
          const n = s.getLineContent(i);
          RY(n, i, e);
        }
        return e;
      }
      function RY(s, e, t) {
        t5.lastIndex = 0;
        const i = t5.exec(s);
        if (i) {
          const n = i.indices[1][0] + 1, o = i.indices[1][1] + 1, r = {
            startLineNumber: e,
            startColumn: n,
            endLineNumber: e,
            endColumn: o
          };
          if (r.endColumn > r.startColumn) {
            const a = {
              range: r,
              ...M8(i[1]),
              shouldBeInComments: true
            };
            (a.text || a.hasSeparatorLine) && t.push(a);
          }
        }
      }
      function M8(s) {
        s = s.trim();
        const e = s.startsWith("-");
        return s = s.replace(NY, ""), {
          text: s,
          hasSeparatorLine: e
        };
      }
      class OY {
        constructor(e) {
          this.values = e, this.prefixSum = new Uint32Array(e.length), this.prefixSumValidIndex = new Int32Array(1), this.prefixSumValidIndex[0] = -1;
        }
        insertValues(e, t) {
          e = Gd(e);
          const i = this.values, n = this.prefixSum, o = t.length;
          return o === 0 ? false : (this.values = new Uint32Array(i.length + o), this.values.set(i.subarray(0, e), 0), this.values.set(i.subarray(e), e + o), this.values.set(t, e), e - 1 < this.prefixSumValidIndex[0] && (this.prefixSumValidIndex[0] = e - 1), this.prefixSum = new Uint32Array(this.values.length), this.prefixSumValidIndex[0] >= 0 && this.prefixSum.set(n.subarray(0, this.prefixSumValidIndex[0] + 1)), true);
        }
        setValue(e, t) {
          return e = Gd(e), t = Gd(t), this.values[e] === t ? false : (this.values[e] = t, e - 1 < this.prefixSumValidIndex[0] && (this.prefixSumValidIndex[0] = e - 1), true);
        }
        removeValues(e, t) {
          e = Gd(e), t = Gd(t);
          const i = this.values, n = this.prefixSum;
          if (e >= i.length) return false;
          const o = i.length - e;
          return t >= o && (t = o), t === 0 ? false : (this.values = new Uint32Array(i.length - t), this.values.set(i.subarray(0, e), 0), this.values.set(i.subarray(e + t), e), this.prefixSum = new Uint32Array(this.values.length), e - 1 < this.prefixSumValidIndex[0] && (this.prefixSumValidIndex[0] = e - 1), this.prefixSumValidIndex[0] >= 0 && this.prefixSum.set(n.subarray(0, this.prefixSumValidIndex[0] + 1)), true);
        }
        getTotalSum() {
          return this.values.length === 0 ? 0 : this._getPrefixSum(this.values.length - 1);
        }
        getPrefixSum(e) {
          return e < 0 ? 0 : (e = Gd(e), this._getPrefixSum(e));
        }
        _getPrefixSum(e) {
          if (e <= this.prefixSumValidIndex[0]) return this.prefixSum[e];
          let t = this.prefixSumValidIndex[0] + 1;
          t === 0 && (this.prefixSum[0] = this.values[0], t++), e >= this.values.length && (e = this.values.length - 1);
          for (let i = t; i <= e; i++) this.prefixSum[i] = this.prefixSum[i - 1] + this.values[i];
          return this.prefixSumValidIndex[0] = Math.max(this.prefixSumValidIndex[0], e), this.prefixSum[e];
        }
        getIndexOf(e) {
          e = Math.floor(e), this.getTotalSum();
          let t = 0, i = this.values.length - 1, n = 0, o = 0, r = 0;
          for (; t <= i; ) if (n = t + (i - t) / 2 | 0, o = this.prefixSum[n], r = o - this.values[n], e < r) i = n - 1;
          else if (e >= o) t = n + 1;
          else break;
          return new A8(n, e - r);
        }
      }
      class PY {
        constructor(e) {
          this._values = e, this._isValid = false, this._validEndIndex = -1, this._prefixSum = [], this._indexBySum = [];
        }
        getTotalSum() {
          return this._ensureValid(), this._indexBySum.length;
        }
        getPrefixSum(e) {
          return this._ensureValid(), e === 0 ? 0 : this._prefixSum[e - 1];
        }
        getIndexOf(e) {
          this._ensureValid();
          const t = this._indexBySum[e], i = t > 0 ? this._prefixSum[t - 1] : 0;
          return new A8(t, e - i);
        }
        removeValues(e, t) {
          this._values.splice(e, t), this._invalidate(e);
        }
        insertValues(e, t) {
          this._values = PC(this._values, e, t), this._invalidate(e);
        }
        _invalidate(e) {
          this._isValid = false, this._validEndIndex = Math.min(this._validEndIndex, e - 1);
        }
        _ensureValid() {
          if (!this._isValid) {
            for (let e = this._validEndIndex + 1, t = this._values.length; e < t; e++) {
              const i = this._values[e], n = e > 0 ? this._prefixSum[e - 1] : 0;
              this._prefixSum[e] = n + i;
              for (let o = 0; o < i; o++) this._indexBySum[n + o] = e;
            }
            this._prefixSum.length = this._values.length, this._indexBySum.length = this._prefixSum[this._prefixSum.length - 1], this._isValid = true, this._validEndIndex = this._values.length - 1;
          }
        }
        setValue(e, t) {
          this._values[e] !== t && (this._values[e] = t, this._invalidate(e));
        }
      }
      class A8 {
        constructor(e, t) {
          this.index = e, this.remainder = t, this._prefixSumIndexOfResultBrand = void 0, this.index = e, this.remainder = t;
        }
      }
      class BY {
        constructor(e, t, i, n) {
          this._uri = e, this._lines = t, this._eol = i, this._versionId = n, this._lineStarts = null, this._cachedTextValue = null;
        }
        dispose() {
          this._lines.length = 0;
        }
        get version() {
          return this._versionId;
        }
        getText() {
          return this._cachedTextValue === null && (this._cachedTextValue = this._lines.join(this._eol)), this._cachedTextValue;
        }
        onEvents(e) {
          e.eol && e.eol !== this._eol && (this._eol = e.eol, this._lineStarts = null);
          const t = e.changes;
          for (const i of t) this._acceptDeleteRange(i.range), this._acceptInsertText(new X(i.range.startLineNumber, i.range.startColumn), i.text);
          this._versionId = e.versionId, this._cachedTextValue = null;
        }
        _ensureLineStarts() {
          if (!this._lineStarts) {
            const e = this._eol.length, t = this._lines.length, i = new Uint32Array(t);
            for (let n = 0; n < t; n++) i[n] = this._lines[n].length + e;
            this._lineStarts = new OY(i);
          }
        }
        _setLineText(e, t) {
          this._lines[e] = t, this._lineStarts && this._lineStarts.setValue(e, this._lines[e].length + this._eol.length);
        }
        _acceptDeleteRange(e) {
          if (e.startLineNumber === e.endLineNumber) {
            if (e.startColumn === e.endColumn) return;
            this._setLineText(e.startLineNumber - 1, this._lines[e.startLineNumber - 1].substring(0, e.startColumn - 1) + this._lines[e.startLineNumber - 1].substring(e.endColumn - 1));
            return;
          }
          this._setLineText(e.startLineNumber - 1, this._lines[e.startLineNumber - 1].substring(0, e.startColumn - 1) + this._lines[e.endLineNumber - 1].substring(e.endColumn - 1)), this._lines.splice(e.startLineNumber, e.endLineNumber - e.startLineNumber), this._lineStarts && this._lineStarts.removeValues(e.startLineNumber, e.endLineNumber - e.startLineNumber);
        }
        _acceptInsertText(e, t) {
          if (t.length === 0) return;
          const i = xg(t);
          if (i.length === 1) {
            this._setLineText(e.lineNumber - 1, this._lines[e.lineNumber - 1].substring(0, e.column - 1) + i[0] + this._lines[e.lineNumber - 1].substring(e.column - 1));
            return;
          }
          i[i.length - 1] += this._lines[e.lineNumber - 1].substring(e.column - 1), this._setLineText(e.lineNumber - 1, this._lines[e.lineNumber - 1].substring(0, e.column - 1) + i[0]);
          const n = new Uint32Array(i.length - 1);
          for (let o = 1; o < i.length; o++) this._lines.splice(e.lineNumber + o - 1, 0, i[o]), n[o - 1] = i[o].length + this._eol.length;
          this._lineStarts && this._lineStarts.insertValues(e.lineNumber, n);
        }
      }
      const i5 = 60 * 1e3;
      class FY extends he {
        constructor(e, t, i = false) {
          if (super(), this._syncedModels = /* @__PURE__ */ Object.create(null), this._syncedModelsLastUsedTime = /* @__PURE__ */ Object.create(null), this._proxy = e, this._modelService = t, !i) {
            const n = new eT();
            n.cancelAndSet(() => this._checkStopModelSync(), Math.round(i5 / 2)), this._register(n);
          }
        }
        dispose() {
          for (const e in this._syncedModels) On(this._syncedModels[e]);
          this._syncedModels = /* @__PURE__ */ Object.create(null), this._syncedModelsLastUsedTime = /* @__PURE__ */ Object.create(null), super.dispose();
        }
        ensureSyncedResources(e, t = false) {
          for (const i of e) {
            const n = i.toString();
            this._syncedModels[n] || this._beginModelSync(i, t), this._syncedModels[n] && (this._syncedModelsLastUsedTime[n] = (/* @__PURE__ */ new Date()).getTime());
          }
        }
        _checkStopModelSync() {
          const e = (/* @__PURE__ */ new Date()).getTime(), t = [];
          for (const i in this._syncedModelsLastUsedTime) e - this._syncedModelsLastUsedTime[i] > i5 && t.push(i);
          for (const i of t) this._stopModelSync(i);
        }
        _beginModelSync(e, t) {
          const i = this._modelService.getModel(e);
          if (!i || !t && i.isTooLargeForSyncing()) return;
          const n = e.toString();
          this._proxy.$acceptNewModel({
            url: i.uri.toString(),
            lines: i.getLinesContent(),
            EOL: i.getEOL(),
            versionId: i.getVersionId()
          });
          const o = new Me();
          o.add(i.onDidChangeContent((r) => {
            this._proxy.$acceptModelChanged(n.toString(), r);
          })), o.add(i.onWillDispose(() => {
            this._stopModelSync(n);
          })), o.add(Ze(() => {
            this._proxy.$acceptRemovedModel(n);
          })), this._syncedModels[n] = o;
        }
        _stopModelSync(e) {
          const t = this._syncedModels[e];
          delete this._syncedModels[e], delete this._syncedModelsLastUsedTime[e], On(t);
        }
      }
      class VY {
        constructor() {
          this._models = /* @__PURE__ */ Object.create(null);
        }
        getModel(e) {
          return this._models[e];
        }
        getModels() {
          const e = [];
          return Object.keys(this._models).forEach((t) => e.push(this._models[t])), e;
        }
        $acceptNewModel(e) {
          this._models[e.url] = new WY(st.parse(e.url), e.lines, e.EOL, e.versionId);
        }
        $acceptModelChanged(e, t) {
          if (!this._models[e]) return;
          this._models[e].onEvents(t);
        }
        $acceptRemovedModel(e) {
          this._models[e] && delete this._models[e];
        }
      }
      class WY extends BY {
        get uri() {
          return this._uri;
        }
        get eol() {
          return this._eol;
        }
        getValue() {
          return this.getText();
        }
        findMatches(e) {
          const t = [];
          for (let i = 0; i < this._lines.length; i++) {
            const n = this._lines[i], o = this.offsetAt(new X(i + 1, 1)), r = n.matchAll(e);
            for (const a of r) (a.index || a.index === 0) && (a.index = a.index + o), t.push(a);
          }
          return t;
        }
        getLinesContent() {
          return this._lines.slice(0);
        }
        getLineCount() {
          return this._lines.length;
        }
        getLineContent(e) {
          return this._lines[e - 1];
        }
        getWordAtPosition(e, t) {
          const i = Kp(e.column, PE(t), this._lines[e.lineNumber - 1], 0);
          return i ? new z(e.lineNumber, i.startColumn, e.lineNumber, i.endColumn) : null;
        }
        words(e) {
          const t = this._lines, i = this._wordenize.bind(this);
          let n = 0, o = "", r = 0, a = [];
          return {
            *[Symbol.iterator]() {
              for (; ; ) if (r < a.length) {
                const l = o.substring(a[r].start, a[r].end);
                r += 1, yield l;
              } else if (n < t.length) o = t[n], a = i(o, e), r = 0, n += 1;
              else break;
            }
          };
        }
        getLineWords(e, t) {
          const i = this._lines[e - 1], n = this._wordenize(i, t), o = [];
          for (const r of n) o.push({
            word: i.substring(r.start, r.end),
            startColumn: r.start + 1,
            endColumn: r.end + 1
          });
          return o;
        }
        _wordenize(e, t) {
          const i = [];
          let n;
          for (t.lastIndex = 0; (n = t.exec(e)) && n[0].length !== 0; ) i.push({
            start: n.index,
            end: n.index + n[0].length
          });
          return i;
        }
        getValueInRange(e) {
          if (e = this._validateRange(e), e.startLineNumber === e.endLineNumber) return this._lines[e.startLineNumber - 1].substring(e.startColumn - 1, e.endColumn - 1);
          const t = this._eol, i = e.startLineNumber - 1, n = e.endLineNumber - 1, o = [];
          o.push(this._lines[i].substring(e.startColumn - 1));
          for (let r = i + 1; r < n; r++) o.push(this._lines[r]);
          return o.push(this._lines[n].substring(0, e.endColumn - 1)), o.join(t);
        }
        offsetAt(e) {
          return e = this._validatePosition(e), this._ensureLineStarts(), this._lineStarts.getPrefixSum(e.lineNumber - 2) + (e.column - 1);
        }
        positionAt(e) {
          e = Math.floor(e), e = Math.max(0, e), this._ensureLineStarts();
          const t = this._lineStarts.getIndexOf(e), i = this._lines[t.index].length;
          return {
            lineNumber: 1 + t.index,
            column: 1 + Math.min(t.remainder, i)
          };
        }
        _validateRange(e) {
          const t = this._validatePosition({
            lineNumber: e.startLineNumber,
            column: e.startColumn
          }), i = this._validatePosition({
            lineNumber: e.endLineNumber,
            column: e.endColumn
          });
          return t.lineNumber !== e.startLineNumber || t.column !== e.startColumn || i.lineNumber !== e.endLineNumber || i.column !== e.endColumn ? {
            startLineNumber: t.lineNumber,
            startColumn: t.column,
            endLineNumber: i.lineNumber,
            endColumn: i.column
          } : e;
        }
        _validatePosition(e) {
          if (!X.isIPosition(e)) throw new Error("bad position");
          let { lineNumber: t, column: i } = e, n = false;
          if (t < 1) t = 1, i = 1, n = true;
          else if (t > this._lines.length) t = this._lines.length, i = this._lines[t - 1].length + 1, n = true;
          else {
            const o = this._lines[t - 1].length + 1;
            i < 1 ? (i = 1, n = true) : i > o && (i = o, n = true);
          }
          return n ? {
            lineNumber: t,
            column: i
          } : e;
        }
      }
      const _HY = class _HY {
        constructor() {
          this._workerTextModelSyncServer = new VY();
        }
        dispose() {
        }
        _getModel(e) {
          return this._workerTextModelSyncServer.getModel(e);
        }
        _getModels() {
          return this._workerTextModelSyncServer.getModels();
        }
        $acceptNewModel(e) {
          this._workerTextModelSyncServer.$acceptNewModel(e);
        }
        $acceptModelChanged(e, t) {
          this._workerTextModelSyncServer.$acceptModelChanged(e, t);
        }
        $acceptRemovedModel(e) {
          this._workerTextModelSyncServer.$acceptRemovedModel(e);
        }
        async $computeUnicodeHighlights(e, t, i) {
          const n = this._getModel(e);
          return n ? KG.computeUnicodeHighlights(n, t, i) : {
            ranges: [],
            hasMore: false,
            ambiguousCharacterCount: 0,
            invisibleCharacterCount: 0,
            nonBasicAsciiCharacterCount: 0
          };
        }
        async $findSectionHeaders(e, t) {
          const i = this._getModel(e);
          return i ? IY(i, t) : [];
        }
        async $computeDiff(e, t, i, n) {
          const o = this._getModel(e), r = this._getModel(t);
          return !o || !r ? null : y0.computeDiff(o, r, i, n);
        }
        static computeDiff(e, t, i, n) {
          const o = n === "advanced" ? XO.getDefault() : XO.getLegacy(), r = e.getLinesContent(), a = t.getLinesContent(), l = o.computeDiff(r, a, i), u = l.changes.length > 0 ? false : this._modelsAreIdentical(e, t);
          function d(f) {
            return f.map((m) => {
              var _a3;
              return [
                m.original.startLineNumber,
                m.original.endLineNumberExclusive,
                m.modified.startLineNumber,
                m.modified.endLineNumberExclusive,
                (_a3 = m.innerChanges) == null ? void 0 : _a3.map((_) => [
                  _.originalRange.startLineNumber,
                  _.originalRange.startColumn,
                  _.originalRange.endLineNumber,
                  _.originalRange.endColumn,
                  _.modifiedRange.startLineNumber,
                  _.modifiedRange.startColumn,
                  _.modifiedRange.endLineNumber,
                  _.modifiedRange.endColumn
                ])
              ];
            });
          }
          return {
            identical: u,
            quitEarly: l.hitTimeout,
            changes: d(l.changes),
            moves: l.moves.map((f) => [
              f.lineRangeMapping.original.startLineNumber,
              f.lineRangeMapping.original.endLineNumberExclusive,
              f.lineRangeMapping.modified.startLineNumber,
              f.lineRangeMapping.modified.endLineNumberExclusive,
              d(f.changes)
            ])
          };
        }
        static _modelsAreIdentical(e, t) {
          const i = e.getLineCount(), n = t.getLineCount();
          if (i !== n) return false;
          for (let o = 1; o <= i; o++) {
            const r = e.getLineContent(o), a = t.getLineContent(o);
            if (r !== a) return false;
          }
          return true;
        }
        async $computeMoreMinimalEdits(e, t, i) {
          const n = this._getModel(e);
          if (!n) return t;
          const o = [];
          let r;
          t = t.slice(0).sort((l, u) => {
            if (l.range && u.range) return z.compareRangesUsingStarts(l.range, u.range);
            const d = l.range ? 0 : 1, f = u.range ? 0 : 1;
            return d - f;
          });
          let a = 0;
          for (let l = 1; l < t.length; l++) z.getEndPosition(t[a].range).equals(z.getStartPosition(t[l].range)) ? (t[a].range = z.fromPositions(z.getStartPosition(t[a].range), z.getEndPosition(t[l].range)), t[a].text += t[l].text) : (a++, t[a] = t[l]);
          t.length = a + 1;
          for (let { range: l, text: u, eol: d } of t) {
            if (typeof d == "number" && (r = d), z.isEmpty(l) && !u) continue;
            const f = n.getValueInRange(l);
            if (u = u.replace(/\r\n|\n|\r/g, n.eol), f === u) continue;
            if (Math.max(u.length, f.length) > y0._diffLimit) {
              o.push({
                range: l,
                text: u
              });
              continue;
            }
            const m = kG(f, u, i), _ = n.offsetAt(z.lift(l).getStartPosition());
            for (const b of m) {
              const v = n.positionAt(_ + b.originalStart), y = n.positionAt(_ + b.originalStart + b.originalLength), x = {
                text: u.substr(b.modifiedStart, b.modifiedLength),
                range: {
                  startLineNumber: v.lineNumber,
                  startColumn: v.column,
                  endLineNumber: y.lineNumber,
                  endColumn: y.column
                }
              };
              n.getValueInRange(x.range) !== x.text && o.push(x);
            }
          }
          return typeof r == "number" && o.push({
            eol: r,
            text: "",
            range: {
              startLineNumber: 0,
              startColumn: 0,
              endLineNumber: 0,
              endColumn: 0
            }
          }), o;
        }
        async $computeLinks(e) {
          const t = this._getModel(e);
          return t ? IG(t) : null;
        }
        async $computeDefaultDocumentColors(e) {
          const t = this._getModel(e);
          return t ? TY(t) : null;
        }
        async $textualSuggest(e, t, i, n) {
          const o = new $h(), r = new RegExp(i, n), a = /* @__PURE__ */ new Set();
          e: for (const l of e) {
            const u = this._getModel(l);
            if (u) {
              for (const d of u.words(r)) if (!(d === t || !isNaN(Number(d))) && (a.add(d), a.size > y0._suggestionsLimit)) break e;
            }
          }
          return {
            words: Array.from(a),
            duration: o.elapsed()
          };
        }
        async $computeWordRanges(e, t, i, n) {
          const o = this._getModel(e);
          if (!o) return /* @__PURE__ */ Object.create(null);
          const r = new RegExp(i, n), a = /* @__PURE__ */ Object.create(null);
          for (let l = t.startLineNumber; l < t.endLineNumber; l++) {
            const u = o.getLineWords(l, r);
            for (const d of u) {
              if (!isNaN(Number(d.word))) continue;
              let f = a[d.word];
              f || (f = [], a[d.word] = f), f.push({
                startLineNumber: l,
                startColumn: d.startColumn,
                endLineNumber: l,
                endColumn: d.endColumn
              });
            }
          }
          return a;
        }
        async $navigateValueSet(e, t, i, n, o) {
          const r = this._getModel(e);
          if (!r) return null;
          const a = new RegExp(n, o);
          t.startColumn === t.endColumn && (t = {
            startLineNumber: t.startLineNumber,
            startColumn: t.startColumn,
            endLineNumber: t.endLineNumber,
            endColumn: t.endColumn + 1
          });
          const l = r.getValueInRange(t), u = r.getWordAtPosition({
            lineNumber: t.startLineNumber,
            column: t.startColumn
          }, a);
          if (!u) return null;
          const d = r.getValueInRange(u);
          return wT.INSTANCE.navigateValueSet(t, l, u, d, i);
        }
      };
      _HY._diffLimit = 1e5;
      _HY._suggestionsLimit = 1e4;
      let HY = _HY;
      class y0 extends HY {
        constructor(e, t) {
          super(), this._host = e, this._foreignModuleFactory = t, this._foreignModule = null;
        }
        async $ping() {
          return "pong";
        }
        $loadForeignModule(e, t, i) {
          const r = {
            host: DU(i, (a, l) => this._host.$fhr(a, l)),
            getMirrorModels: () => this._getModels()
          };
          return this._foreignModuleFactory ? (this._foreignModule = this._foreignModuleFactory(r, t), Promise.resolve(Mx(this._foreignModule))) : new Promise((a, l) => {
            const u = (d) => {
              this._foreignModule = d.create(r, t), a(Mx(this._foreignModule));
            };
            {
              const d = zC.asBrowserUri(`${e}.js`).toString(true);
              Be(() => import(`${d}`).then(async (m) => {
                await m.__tla;
                return m;
              }), []).then(u).catch(l);
            }
          });
        }
        $fmr(e, t) {
          if (!this._foreignModule || typeof this._foreignModule[e] != "function") return Promise.reject(new Error("Missing requestHandler or method: " + e));
          try {
            return Promise.resolve(this._foreignModule[e].apply(this._foreignModule, t));
          } catch (i) {
            return Promise.reject(i);
          }
        }
      }
      typeof importScripts == "function" && (globalThis.monaco = y9());
      const xT = pt("textResourceConfigurationService"), R8 = pt("textResourcePropertiesService"), jt = pt("ILanguageFeaturesService");
      var kT = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      }, Ju = function(s, e) {
        return function(t, i) {
          e(t, i, s);
        };
      };
      const n5 = 5 * 60 * 1e3;
      function eh(s, e) {
        const t = s.getModel(e);
        return !(!t || t.isTooLargeForSyncing());
      }
      let rD = class extends he {
        constructor(e, t, i, n, o, r) {
          super(), this._languageConfigurationService = o, this._modelService = t, this._workerManager = this._register(new aD(e, this._modelService)), this._logService = n, this._register(r.linkProvider.register({
            language: "*",
            hasAccessToAllModels: true
          }, {
            provideLinks: async (a, l) => {
              if (!eh(this._modelService, a.uri)) return Promise.resolve({
                links: []
              });
              const d = await (await this._workerWithResources([
                a.uri
              ])).$computeLinks(a.uri.toString());
              return d && {
                links: d
              };
            }
          })), this._register(r.completionProvider.register("*", new zY(this._workerManager, i, this._modelService, this._languageConfigurationService)));
        }
        dispose() {
          super.dispose();
        }
        canComputeUnicodeHighlights(e) {
          return eh(this._modelService, e);
        }
        async computedUnicodeHighlights(e, t, i) {
          return (await this._workerWithResources([
            e
          ])).$computeUnicodeHighlights(e.toString(), t, i);
        }
        async computeDiff(e, t, i, n) {
          const r = await (await this._workerWithResources([
            e,
            t
          ], true)).$computeDiff(e.toString(), t.toString(), i, n);
          if (!r) return null;
          return {
            identical: r.identical,
            quitEarly: r.quitEarly,
            changes: l(r.changes),
            moves: r.moves.map((u) => new x8(new is(new qe(u[0], u[1]), new qe(u[2], u[3])), l(u[4])))
          };
          function l(u) {
            return u.map((d) => {
              var _a3;
              return new go(new qe(d[0], d[1]), new qe(d[2], d[3]), (_a3 = d[4]) == null ? void 0 : _a3.map((f) => new ro(new z(f[0], f[1], f[2], f[3]), new z(f[4], f[5], f[6], f[7]))));
            });
          }
        }
        async computeMoreMinimalEdits(e, t, i = false) {
          if (OC(t)) {
            if (!eh(this._modelService, e)) return Promise.resolve(t);
            const n = $h.create(), o = this._workerWithResources([
              e
            ]).then((r) => r.$computeMoreMinimalEdits(e.toString(), t, i));
            return o.finally(() => this._logService.trace("FORMAT#computeMoreMinimalEdits", e.toString(true), n.elapsed())), Promise.race([
              o,
              Zp(1e3).then(() => t)
            ]);
          } else return Promise.resolve(void 0);
        }
        canNavigateValueSet(e) {
          return eh(this._modelService, e);
        }
        async navigateValueSet(e, t, i) {
          const n = this._modelService.getModel(e);
          if (!n) return null;
          const o = this._languageConfigurationService.getLanguageConfiguration(n.getLanguageId()).getWordDefinition(), r = o.source, a = o.flags;
          return (await this._workerWithResources([
            e
          ])).$navigateValueSet(e.toString(), t, i, r, a);
        }
        canComputeWordRanges(e) {
          return eh(this._modelService, e);
        }
        async computeWordRanges(e, t) {
          const i = this._modelService.getModel(e);
          if (!i) return Promise.resolve(null);
          const n = this._languageConfigurationService.getLanguageConfiguration(i.getLanguageId()).getWordDefinition(), o = n.source, r = n.flags;
          return (await this._workerWithResources([
            e
          ])).$computeWordRanges(e.toString(), t, o, r);
        }
        async findSectionHeaders(e, t) {
          return (await this._workerWithResources([
            e
          ])).$findSectionHeaders(e.toString(), t);
        }
        async computeDefaultDocumentColors(e) {
          return (await this._workerWithResources([
            e
          ])).$computeDefaultDocumentColors(e.toString());
        }
        async _workerWithResources(e, t = false) {
          return await (await this._workerManager.withWorker()).workerWithSyncedResources(e, t);
        }
      };
      rD = kT([
        Ju(1, _s),
        Ju(2, xT),
        Ju(3, Xr),
        Ju(4, Pa),
        Ju(5, jt)
      ], rD);
      class zY {
        constructor(e, t, i, n) {
          this.languageConfigurationService = n, this._debugDisplayName = "wordbasedCompletions", this._workerManager = e, this._configurationService = t, this._modelService = i;
        }
        async provideCompletionItems(e, t) {
          const i = this._configurationService.getValue(e.uri, t, "editor");
          if (i.wordBasedSuggestions === "off") return;
          const n = [];
          if (i.wordBasedSuggestions === "currentDocument") eh(this._modelService, e.uri) && n.push(e.uri);
          else for (const f of this._modelService.getModels()) eh(this._modelService, f.uri) && (f === e ? n.unshift(f.uri) : (i.wordBasedSuggestions === "allDocuments" || f.getLanguageId() === e.getLanguageId()) && n.push(f.uri));
          if (n.length === 0) return;
          const o = this.languageConfigurationService.getLanguageConfiguration(e.getLanguageId()).getWordDefinition(), r = e.getWordAtPosition(t), a = r ? new z(t.lineNumber, r.startColumn, t.lineNumber, r.endColumn) : z.fromPositions(t), l = a.setEndPosition(t.lineNumber, t.column), d = await (await this._workerManager.withWorker()).textualSuggest(n, r == null ? void 0 : r.word, o);
          if (d) return {
            duration: d.duration,
            suggestions: d.words.map((f) => ({
              kind: 18,
              label: f,
              insertText: f,
              range: {
                insert: l,
                replace: a
              }
            }))
          };
        }
      }
      let aD = class extends he {
        constructor(e, t) {
          super(), this._workerDescriptor = e, this._modelService = t, this._editorWorkerClient = null, this._lastWorkerUsedTime = (/* @__PURE__ */ new Date()).getTime(), this._register(new sT()).cancelAndSet(() => this._checkStopIdleWorker(), Math.round(n5 / 2), Kt), this._register(this._modelService.onModelRemoved((n) => this._checkStopEmptyWorker()));
        }
        dispose() {
          this._editorWorkerClient && (this._editorWorkerClient.dispose(), this._editorWorkerClient = null), super.dispose();
        }
        _checkStopEmptyWorker() {
          if (!this._editorWorkerClient) return;
          this._modelService.getModels().length === 0 && (this._editorWorkerClient.dispose(), this._editorWorkerClient = null);
        }
        _checkStopIdleWorker() {
          if (!this._editorWorkerClient) return;
          (/* @__PURE__ */ new Date()).getTime() - this._lastWorkerUsedTime > n5 && (this._editorWorkerClient.dispose(), this._editorWorkerClient = null);
        }
        withWorker() {
          return this._lastWorkerUsedTime = (/* @__PURE__ */ new Date()).getTime(), this._editorWorkerClient || (this._editorWorkerClient = new pv(this._workerDescriptor, false, this._modelService)), Promise.resolve(this._editorWorkerClient);
        }
      };
      aD = kT([
        Ju(1, _s)
      ], aD);
      class UY {
        constructor(e) {
          this._instance = e, this.proxy = this._instance;
        }
        dispose() {
          this._instance.dispose();
        }
        setChannel(e, t) {
          throw new Error("Not supported");
        }
      }
      let pv = class extends he {
        constructor(e, t, i) {
          super(), this._workerDescriptor = e, this._disposed = false, this._modelService = i, this._keepIdleModels = t, this._worker = null, this._modelManager = null;
        }
        fhr(e, t) {
          throw new Error("Not implemented!");
        }
        _getOrCreateWorker() {
          if (!this._worker) try {
            this._worker = this._register(Uj(this._workerDescriptor)), dv.setChannel(this._worker, this._createEditorWorkerHost());
          } catch (e) {
            Qk(e), this._worker = this._createFallbackLocalWorker();
          }
          return this._worker;
        }
        async _getProxy() {
          try {
            const e = this._getOrCreateWorker().proxy;
            return await e.$ping(), e;
          } catch (e) {
            return Qk(e), this._worker = this._createFallbackLocalWorker(), this._worker.proxy;
          }
        }
        _createFallbackLocalWorker() {
          return new UY(new y0(this._createEditorWorkerHost(), null));
        }
        _createEditorWorkerHost() {
          return {
            $fhr: (e, t) => this.fhr(e, t)
          };
        }
        _getOrCreateModelManager(e) {
          return this._modelManager || (this._modelManager = this._register(new FY(e, this._modelService, this._keepIdleModels))), this._modelManager;
        }
        async workerWithSyncedResources(e, t = false) {
          if (this._disposed) return Promise.reject(O$());
          const i = await this._getProxy();
          return this._getOrCreateModelManager(i).ensureSyncedResources(e, t), i;
        }
        async textualSuggest(e, t, i) {
          const n = await this.workerWithSyncedResources(e), o = i.source, r = i.flags;
          return n.$textualSuggest(e.map((a) => a.toString()), t, o, r);
        }
        dispose() {
          super.dispose(), this._disposed = true;
        }
      };
      pv = kT([
        Ju(2, _s)
      ], pv);
      var Fo;
      (function(s) {
        s.DARK = "dark", s.LIGHT = "light", s.HIGH_CONTRAST_DARK = "hcDark", s.HIGH_CONTRAST_LIGHT = "hcLight";
      })(Fo || (Fo = {}));
      function Bf(s) {
        return s === Fo.HIGH_CONTRAST_DARK || s === Fo.HIGH_CONTRAST_LIGHT;
      }
      function rw(s) {
        return s === Fo.DARK || s === Fo.HIGH_CONTRAST_DARK;
      }
      const vr = pt("themeService");
      function Qd(s) {
        return {
          id: s
        };
      }
      function lD(s) {
        switch (s) {
          case Fo.DARK:
            return "vs-dark";
          case Fo.HIGH_CONTRAST_DARK:
            return "hc-black";
          case Fo.HIGH_CONTRAST_LIGHT:
            return "hc-light";
          default:
            return "vs";
        }
      }
      const O8 = {
        ThemingContribution: "base.contributions.theming"
      };
      class $Y {
        constructor() {
          this.themingParticipants = [], this.themingParticipants = [], this.onThemingParticipantAddedEmitter = new G();
        }
        onColorThemeChange(e) {
          return this.themingParticipants.push(e), this.onThemingParticipantAddedEmitter.fire(e), Ze(() => {
            const t = this.themingParticipants.indexOf(e);
            this.themingParticipants.splice(t, 1);
          });
        }
        getThemingParticipants() {
          return this.themingParticipants;
        }
      }
      const P8 = new $Y();
      yn.add(O8.ThemingContribution, P8);
      function jl(s) {
        return P8.onColorThemeChange(s);
      }
      class qY extends he {
        constructor(e) {
          super(), this.themeService = e, this.theme = e.getColorTheme(), this._register(this.themeService.onDidColorThemeChange((t) => this.onThemeChange(t)));
        }
        onThemeChange(e) {
          this.theme = e, this.updateStyles();
        }
        updateStyles() {
        }
      }
      var KY = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      }, jY = function(s, e) {
        return function(t, i) {
          e(t, i, s);
        };
      };
      let cD = class extends he {
        constructor(e) {
          super(), this._themeService = e, this._onWillCreateCodeEditor = this._register(new G()), this._onCodeEditorAdd = this._register(new G()), this.onCodeEditorAdd = this._onCodeEditorAdd.event, this._onCodeEditorRemove = this._register(new G()), this.onCodeEditorRemove = this._onCodeEditorRemove.event, this._onWillCreateDiffEditor = this._register(new G()), this._onDiffEditorAdd = this._register(new G()), this.onDiffEditorAdd = this._onDiffEditorAdd.event, this._onDiffEditorRemove = this._register(new G()), this.onDiffEditorRemove = this._onDiffEditorRemove.event, this._decorationOptionProviders = /* @__PURE__ */ new Map(), this._codeEditorOpenHandlers = new Us(), this._modelProperties = /* @__PURE__ */ new Map(), this._codeEditors = /* @__PURE__ */ Object.create(null), this._diffEditors = /* @__PURE__ */ Object.create(null), this._globalStyleSheet = null;
        }
        willCreateCodeEditor() {
          this._onWillCreateCodeEditor.fire();
        }
        addCodeEditor(e) {
          this._codeEditors[e.getId()] = e, this._onCodeEditorAdd.fire(e);
        }
        removeCodeEditor(e) {
          delete this._codeEditors[e.getId()] && this._onCodeEditorRemove.fire(e);
        }
        listCodeEditors() {
          return Object.keys(this._codeEditors).map((e) => this._codeEditors[e]);
        }
        willCreateDiffEditor() {
          this._onWillCreateDiffEditor.fire();
        }
        addDiffEditor(e) {
          this._diffEditors[e.getId()] = e, this._onDiffEditorAdd.fire(e);
        }
        listDiffEditors() {
          return Object.keys(this._diffEditors).map((e) => this._diffEditors[e]);
        }
        getFocusedCodeEditor() {
          let e = null;
          const t = this.listCodeEditors();
          for (const i of t) {
            if (i.hasTextFocus()) return i;
            i.hasWidgetFocus() && (e = i);
          }
          return e;
        }
        removeDecorationType(e) {
          const t = this._decorationOptionProviders.get(e);
          t && (t.refCount--, t.refCount <= 0 && (this._decorationOptionProviders.delete(e), t.dispose(), this.listCodeEditors().forEach((i) => i.removeDecorationsByType(e))));
        }
        setModelProperty(e, t, i) {
          const n = e.toString();
          let o;
          this._modelProperties.has(n) ? o = this._modelProperties.get(n) : (o = /* @__PURE__ */ new Map(), this._modelProperties.set(n, o)), o.set(t, i);
        }
        getModelProperty(e, t) {
          const i = e.toString();
          if (this._modelProperties.has(i)) return this._modelProperties.get(i).get(t);
        }
        async openCodeEditor(e, t, i) {
          for (const n of this._codeEditorOpenHandlers) {
            const o = await n(e, t, i);
            if (o !== null) return o;
          }
          return null;
        }
        registerCodeEditorOpenHandler(e) {
          const t = this._codeEditorOpenHandlers.unshift(e);
          return Ze(t);
        }
      };
      cD = KY([
        jY(0, vr)
      ], cD);
      var GY = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      }, s5 = function(s, e) {
        return function(t, i) {
          e(t, i, s);
        };
      };
      let _v = class extends cD {
        constructor(e, t) {
          super(t), this._register(this.onCodeEditorAdd(() => this._checkContextKey())), this._register(this.onCodeEditorRemove(() => this._checkContextKey())), this._editorIsOpen = e.createKey("editorIsOpen", false), this._activeCodeEditor = null, this._register(this.registerCodeEditorOpenHandler(async (i, n, o) => n ? this.doOpenEditor(n, i) : null));
        }
        _checkContextKey() {
          let e = false;
          for (const t of this.listCodeEditors()) if (!t.isSimpleWidget) {
            e = true;
            break;
          }
          this._editorIsOpen.set(e);
        }
        setActiveCodeEditor(e) {
          this._activeCodeEditor = e;
        }
        getActiveCodeEditor() {
          return this._activeCodeEditor;
        }
        doOpenEditor(e, t) {
          if (!this.findModel(e, t.resource)) {
            if (t.resource) {
              const o = t.resource.scheme;
              if (o === it.http || o === it.https) return t8(t.resource.toString()), e;
            }
            return null;
          }
          const n = t.options ? t.options.selection : null;
          if (n) if (typeof n.endLineNumber == "number" && typeof n.endColumn == "number") e.setSelection(n), e.revealRangeInCenter(n, 1);
          else {
            const o = {
              lineNumber: n.startLineNumber,
              column: n.startColumn
            };
            e.setPosition(o), e.revealPositionInCenter(o, 1);
          }
          return e;
        }
        findModel(e, t) {
          const i = e.getModel();
          return i && i.uri.toString() !== t.toString() ? null : i;
        }
      };
      _v = GY([
        s5(0, Mt),
        s5(1, vr)
      ], _v);
      Lt(Xi, _v, 0);
      const du = pt("layoutService");
      var B8 = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      }, F8 = function(s, e) {
        return function(t, i) {
          e(t, i, s);
        };
      };
      let bv = class {
        get mainContainer() {
          var _a3;
          return ((_a3 = IE(this._codeEditorService.listCodeEditors())) == null ? void 0 : _a3.getContainerDomNode()) ?? Kt.document.body;
        }
        get activeContainer() {
          var _a3;
          return ((_a3 = this._codeEditorService.getFocusedCodeEditor() ?? this._codeEditorService.getActiveCodeEditor()) == null ? void 0 : _a3.getContainerDomNode()) ?? this.mainContainer;
        }
        get mainContainerDimension() {
          return $k(this.mainContainer);
        }
        get activeContainerDimension() {
          return $k(this.activeContainer);
        }
        get containers() {
          return NE(this._codeEditorService.listCodeEditors().map((e) => e.getContainerDomNode()));
        }
        getContainer() {
          return this.activeContainer;
        }
        whenContainerStylesLoaded() {
        }
        focus() {
          var _a3;
          (_a3 = this._codeEditorService.getFocusedCodeEditor()) == null ? void 0 : _a3.focus();
        }
        constructor(e) {
          this._codeEditorService = e, this.onDidLayoutMainContainer = be.None, this.onDidLayoutActiveContainer = be.None, this.onDidLayoutContainer = be.None, this.onDidChangeActiveContainer = be.None, this.onDidAddContainer = be.None, this.mainContainerOffset = {
            top: 0,
            quickPickTop: 0
          }, this.activeContainerOffset = {
            top: 0,
            quickPickTop: 0
          };
        }
      };
      bv = B8([
        F8(0, Xi)
      ], bv);
      let uD = class extends bv {
        get mainContainer() {
          return this._container;
        }
        constructor(e, t) {
          super(t), this._container = e;
        }
      };
      uD = B8([
        F8(1, Xi)
      ], uD);
      Lt(du, bv, 1);
      var n_;
      (function(s) {
        s[s.Ignore = 0] = "Ignore", s[s.Info = 1] = "Info", s[s.Warning = 2] = "Warning", s[s.Error = 3] = "Error";
      })(n_ || (n_ = {}));
      (function(s) {
        const e = "error", t = "warning", i = "warn", n = "info", o = "ignore";
        function r(l) {
          return l ? uf(e, l) ? s.Error : uf(t, l) || uf(i, l) ? s.Warning : uf(n, l) ? s.Info : s.Ignore : s.Ignore;
        }
        s.fromValue = r;
        function a(l) {
          switch (l) {
            case s.Error:
              return e;
            case s.Warning:
              return t;
            case s.Info:
              return n;
            default:
              return o;
          }
        }
        s.toString = a;
      })(n_ || (n_ = {}));
      const Ui = n_, V8 = pt("dialogService");
      var YY = Ui;
      const Jr = pt("notificationService");
      class ZY {
      }
      const DT = pt("undoRedoService");
      class W8 {
        constructor(e, t) {
          this.resource = e, this.elements = t;
        }
      }
      const _vv = class _vv {
        constructor() {
          this.id = _vv._ID++, this.order = 1;
        }
        nextOrder() {
          return this.id === 0 ? 0 : this.order++;
        }
      };
      _vv._ID = 0;
      _vv.None = new _vv();
      let vv = _vv;
      const _Rc = class _Rc {
        constructor() {
          this.id = _Rc._ID++, this.order = 1;
        }
        nextOrder() {
          return this.id === 0 ? 0 : this.order++;
        }
      };
      _Rc._ID = 0;
      _Rc.None = new _Rc();
      let Rc = _Rc;
      var QY = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      }, o5 = function(s, e) {
        return function(t, i) {
          e(t, i, s);
        };
      };
      function Ib(s) {
        return s.scheme === it.file ? s.fsPath : s.path;
      }
      let H8 = 0;
      class Mb {
        constructor(e, t, i, n, o, r, a) {
          this.id = ++H8, this.type = 0, this.actual = e, this.label = e.label, this.confirmBeforeUndo = e.confirmBeforeUndo || false, this.resourceLabel = t, this.strResource = i, this.resourceLabels = [
            this.resourceLabel
          ], this.strResources = [
            this.strResource
          ], this.groupId = n, this.groupOrder = o, this.sourceId = r, this.sourceOrder = a, this.isValid = true;
        }
        setValid(e) {
          this.isValid = e;
        }
        toString() {
          return `[id:${this.id}] [group:${this.groupId}] [${this.isValid ? "  VALID" : "INVALID"}] ${this.actual.constructor.name} - ${this.actual}`;
        }
      }
      class r5 {
        constructor(e, t) {
          this.resourceLabel = e, this.reason = t;
        }
      }
      class a5 {
        constructor() {
          this.elements = /* @__PURE__ */ new Map();
        }
        createMessage() {
          const e = [], t = [];
          for (const [, n] of this.elements) (n.reason === 0 ? e : t).push(n.resourceLabel);
          const i = [];
          return e.length > 0 && i.push(C({
            key: "externalRemoval",
            comment: [
              "{0} is a list of filenames"
            ]
          }, "The following files have been closed and modified on disk: {0}.", e.join(", "))), t.length > 0 && i.push(C({
            key: "noParallelUniverses",
            comment: [
              "{0} is a list of filenames"
            ]
          }, "The following files have been modified in an incompatible way: {0}.", t.join(", "))), i.join(`
`);
        }
        get size() {
          return this.elements.size;
        }
        has(e) {
          return this.elements.has(e);
        }
        set(e, t) {
          this.elements.set(e, t);
        }
        delete(e) {
          return this.elements.delete(e);
        }
      }
      class XY {
        constructor(e, t, i, n, o, r, a) {
          this.id = ++H8, this.type = 1, this.actual = e, this.label = e.label, this.confirmBeforeUndo = e.confirmBeforeUndo || false, this.resourceLabels = t, this.strResources = i, this.groupId = n, this.groupOrder = o, this.sourceId = r, this.sourceOrder = a, this.removedResources = null, this.invalidatedResources = null;
        }
        canSplit() {
          return typeof this.actual.split == "function";
        }
        removeResource(e, t, i) {
          this.removedResources || (this.removedResources = new a5()), this.removedResources.has(t) || this.removedResources.set(t, new r5(e, i));
        }
        setValid(e, t, i) {
          i ? this.invalidatedResources && (this.invalidatedResources.delete(t), this.invalidatedResources.size === 0 && (this.invalidatedResources = null)) : (this.invalidatedResources || (this.invalidatedResources = new a5()), this.invalidatedResources.has(t) || this.invalidatedResources.set(t, new r5(e, 0)));
        }
        toString() {
          return `[id:${this.id}] [group:${this.groupId}] [${this.invalidatedResources ? "INVALID" : "  VALID"}] ${this.actual.constructor.name} - ${this.actual}`;
        }
      }
      class z8 {
        constructor(e, t) {
          this.resourceLabel = e, this.strResource = t, this._past = [], this._future = [], this.locked = false, this.versionId = 1;
        }
        dispose() {
          for (const e of this._past) e.type === 1 && e.removeResource(this.resourceLabel, this.strResource, 0);
          for (const e of this._future) e.type === 1 && e.removeResource(this.resourceLabel, this.strResource, 0);
          this.versionId++;
        }
        toString() {
          const e = [];
          e.push(`* ${this.strResource}:`);
          for (let t = 0; t < this._past.length; t++) e.push(`   * [UNDO] ${this._past[t]}`);
          for (let t = this._future.length - 1; t >= 0; t--) e.push(`   * [REDO] ${this._future[t]}`);
          return e.join(`
`);
        }
        flushAllElements() {
          this._past = [], this._future = [], this.versionId++;
        }
        _setElementValidFlag(e, t) {
          e.type === 1 ? e.setValid(this.resourceLabel, this.strResource, t) : e.setValid(t);
        }
        setElementsValidFlag(e, t) {
          for (const i of this._past) t(i.actual) && this._setElementValidFlag(i, e);
          for (const i of this._future) t(i.actual) && this._setElementValidFlag(i, e);
        }
        pushElement(e) {
          for (const t of this._future) t.type === 1 && t.removeResource(this.resourceLabel, this.strResource, 1);
          this._future = [], this._past.push(e), this.versionId++;
        }
        createSnapshot(e) {
          const t = [];
          for (let i = 0, n = this._past.length; i < n; i++) t.push(this._past[i].id);
          for (let i = this._future.length - 1; i >= 0; i--) t.push(this._future[i].id);
          return new W8(e, t);
        }
        restoreSnapshot(e) {
          const t = e.elements.length;
          let i = true, n = 0, o = -1;
          for (let a = 0, l = this._past.length; a < l; a++, n++) {
            const u = this._past[a];
            i && (n >= t || u.id !== e.elements[n]) && (i = false, o = 0), !i && u.type === 1 && u.removeResource(this.resourceLabel, this.strResource, 0);
          }
          let r = -1;
          for (let a = this._future.length - 1; a >= 0; a--, n++) {
            const l = this._future[a];
            i && (n >= t || l.id !== e.elements[n]) && (i = false, r = a), !i && l.type === 1 && l.removeResource(this.resourceLabel, this.strResource, 0);
          }
          o !== -1 && (this._past = this._past.slice(0, o)), r !== -1 && (this._future = this._future.slice(r + 1)), this.versionId++;
        }
        getElements() {
          const e = [], t = [];
          for (const i of this._past) e.push(i.actual);
          for (const i of this._future) t.push(i.actual);
          return {
            past: e,
            future: t
          };
        }
        getClosestPastElement() {
          return this._past.length === 0 ? null : this._past[this._past.length - 1];
        }
        getSecondClosestPastElement() {
          return this._past.length < 2 ? null : this._past[this._past.length - 2];
        }
        getClosestFutureElement() {
          return this._future.length === 0 ? null : this._future[this._future.length - 1];
        }
        hasPastElements() {
          return this._past.length > 0;
        }
        hasFutureElements() {
          return this._future.length > 0;
        }
        splitPastWorkspaceElement(e, t) {
          for (let i = this._past.length - 1; i >= 0; i--) if (this._past[i] === e) {
            t.has(this.strResource) ? this._past[i] = t.get(this.strResource) : this._past.splice(i, 1);
            break;
          }
          this.versionId++;
        }
        splitFutureWorkspaceElement(e, t) {
          for (let i = this._future.length - 1; i >= 0; i--) if (this._future[i] === e) {
            t.has(this.strResource) ? this._future[i] = t.get(this.strResource) : this._future.splice(i, 1);
            break;
          }
          this.versionId++;
        }
        moveBackward(e) {
          this._past.pop(), this._future.push(e), this.versionId++;
        }
        moveForward(e) {
          this._future.pop(), this._past.push(e), this.versionId++;
        }
      }
      class WL {
        constructor(e) {
          this.editStacks = e, this._versionIds = [];
          for (let t = 0, i = this.editStacks.length; t < i; t++) this._versionIds[t] = this.editStacks[t].versionId;
        }
        isValid() {
          for (let e = 0, t = this.editStacks.length; e < t; e++) if (this._versionIds[e] !== this.editStacks[e].versionId) return false;
          return true;
        }
      }
      const U8 = new z8("", "");
      U8.locked = true;
      let hD = class {
        constructor(e, t) {
          this._dialogService = e, this._notificationService = t, this._editStacks = /* @__PURE__ */ new Map(), this._uriComparisonKeyComputers = [];
        }
        getUriComparisonKey(e) {
          for (const t of this._uriComparisonKeyComputers) if (t[0] === e.scheme) return t[1].getComparisonKey(e);
          return e.toString();
        }
        _print(e) {
          console.log("------------------------------------"), console.log(`AFTER ${e}: `);
          const t = [];
          for (const i of this._editStacks) t.push(i[1].toString());
          console.log(t.join(`
`));
        }
        pushElement(e, t = vv.None, i = Rc.None) {
          if (e.type === 0) {
            const n = Ib(e.resource), o = this.getUriComparisonKey(e.resource);
            this._pushElement(new Mb(e, n, o, t.id, t.nextOrder(), i.id, i.nextOrder()));
          } else {
            const n = /* @__PURE__ */ new Set(), o = [], r = [];
            for (const a of e.resources) {
              const l = Ib(a), u = this.getUriComparisonKey(a);
              n.has(u) || (n.add(u), o.push(l), r.push(u));
            }
            o.length === 1 ? this._pushElement(new Mb(e, o[0], r[0], t.id, t.nextOrder(), i.id, i.nextOrder())) : this._pushElement(new XY(e, o, r, t.id, t.nextOrder(), i.id, i.nextOrder()));
          }
        }
        _pushElement(e) {
          for (let t = 0, i = e.strResources.length; t < i; t++) {
            const n = e.resourceLabels[t], o = e.strResources[t];
            let r;
            this._editStacks.has(o) ? r = this._editStacks.get(o) : (r = new z8(n, o), this._editStacks.set(o, r)), r.pushElement(e);
          }
        }
        getLastElement(e) {
          const t = this.getUriComparisonKey(e);
          if (this._editStacks.has(t)) {
            const i = this._editStacks.get(t);
            if (i.hasFutureElements()) return null;
            const n = i.getClosestPastElement();
            return n ? n.actual : null;
          }
          return null;
        }
        _splitPastWorkspaceElement(e, t) {
          const i = e.actual.split(), n = /* @__PURE__ */ new Map();
          for (const o of i) {
            const r = Ib(o.resource), a = this.getUriComparisonKey(o.resource), l = new Mb(o, r, a, 0, 0, 0, 0);
            n.set(l.strResource, l);
          }
          for (const o of e.strResources) {
            if (t && t.has(o)) continue;
            this._editStacks.get(o).splitPastWorkspaceElement(e, n);
          }
        }
        _splitFutureWorkspaceElement(e, t) {
          const i = e.actual.split(), n = /* @__PURE__ */ new Map();
          for (const o of i) {
            const r = Ib(o.resource), a = this.getUriComparisonKey(o.resource), l = new Mb(o, r, a, 0, 0, 0, 0);
            n.set(l.strResource, l);
          }
          for (const o of e.strResources) {
            if (t && t.has(o)) continue;
            this._editStacks.get(o).splitFutureWorkspaceElement(e, n);
          }
        }
        removeElements(e) {
          const t = typeof e == "string" ? e : this.getUriComparisonKey(e);
          this._editStacks.has(t) && (this._editStacks.get(t).dispose(), this._editStacks.delete(t));
        }
        setElementsValidFlag(e, t, i) {
          const n = this.getUriComparisonKey(e);
          this._editStacks.has(n) && this._editStacks.get(n).setElementsValidFlag(t, i);
        }
        createSnapshot(e) {
          const t = this.getUriComparisonKey(e);
          return this._editStacks.has(t) ? this._editStacks.get(t).createSnapshot(e) : new W8(e, []);
        }
        restoreSnapshot(e) {
          const t = this.getUriComparisonKey(e.resource);
          if (this._editStacks.has(t)) {
            const i = this._editStacks.get(t);
            i.restoreSnapshot(e), !i.hasPastElements() && !i.hasFutureElements() && (i.dispose(), this._editStacks.delete(t));
          }
        }
        getElements(e) {
          const t = this.getUriComparisonKey(e);
          return this._editStacks.has(t) ? this._editStacks.get(t).getElements() : {
            past: [],
            future: []
          };
        }
        _findClosestUndoElementWithSource(e) {
          if (!e) return [
            null,
            null
          ];
          let t = null, i = null;
          for (const [n, o] of this._editStacks) {
            const r = o.getClosestPastElement();
            r && r.sourceId === e && (!t || r.sourceOrder > t.sourceOrder) && (t = r, i = n);
          }
          return [
            t,
            i
          ];
        }
        canUndo(e) {
          if (e instanceof Rc) {
            const [, i] = this._findClosestUndoElementWithSource(e.id);
            return !!i;
          }
          const t = this.getUriComparisonKey(e);
          return this._editStacks.has(t) ? this._editStacks.get(t).hasPastElements() : false;
        }
        _onError(e, t) {
          qt(e);
          for (const i of t.strResources) this.removeElements(i);
          this._notificationService.error(e);
        }
        _acquireLocks(e) {
          for (const t of e.editStacks) if (t.locked) throw new Error("Cannot acquire edit stack lock");
          for (const t of e.editStacks) t.locked = true;
          return () => {
            for (const t of e.editStacks) t.locked = false;
          };
        }
        _safeInvokeWithLocks(e, t, i, n, o) {
          const r = this._acquireLocks(i);
          let a;
          try {
            a = t();
          } catch (l) {
            return r(), n.dispose(), this._onError(l, e);
          }
          return a ? a.then(() => (r(), n.dispose(), o()), (l) => (r(), n.dispose(), this._onError(l, e))) : (r(), n.dispose(), o());
        }
        async _invokeWorkspacePrepare(e) {
          if (typeof e.actual.prepareUndoRedo > "u") return he.None;
          const t = e.actual.prepareUndoRedo();
          return typeof t > "u" ? he.None : t;
        }
        _invokeResourcePrepare(e, t) {
          if (e.actual.type !== 1 || typeof e.actual.prepareUndoRedo > "u") return t(he.None);
          const i = e.actual.prepareUndoRedo();
          return i ? l9(i) ? t(i) : i.then((n) => t(n)) : t(he.None);
        }
        _getAffectedEditStacks(e) {
          const t = [];
          for (const i of e.strResources) t.push(this._editStacks.get(i) || U8);
          return new WL(t);
        }
        _tryToSplitAndUndo(e, t, i, n) {
          if (t.canSplit()) return this._splitPastWorkspaceElement(t, i), this._notificationService.warn(n), new Ab(this._undo(e, 0, true));
          for (const o of t.strResources) this.removeElements(o);
          return this._notificationService.warn(n), new Ab();
        }
        _checkWorkspaceUndo(e, t, i, n) {
          if (t.removedResources) return this._tryToSplitAndUndo(e, t, t.removedResources, C({
            key: "cannotWorkspaceUndo",
            comment: [
              "{0} is a label for an operation. {1} is another message."
            ]
          }, "Could not undo '{0}' across all files. {1}", t.label, t.removedResources.createMessage()));
          if (n && t.invalidatedResources) return this._tryToSplitAndUndo(e, t, t.invalidatedResources, C({
            key: "cannotWorkspaceUndo",
            comment: [
              "{0} is a label for an operation. {1} is another message."
            ]
          }, "Could not undo '{0}' across all files. {1}", t.label, t.invalidatedResources.createMessage()));
          const o = [];
          for (const a of i.editStacks) a.getClosestPastElement() !== t && o.push(a.resourceLabel);
          if (o.length > 0) return this._tryToSplitAndUndo(e, t, null, C({
            key: "cannotWorkspaceUndoDueToChanges",
            comment: [
              "{0} is a label for an operation. {1} is a list of filenames."
            ]
          }, "Could not undo '{0}' across all files because changes were made to {1}", t.label, o.join(", ")));
          const r = [];
          for (const a of i.editStacks) a.locked && r.push(a.resourceLabel);
          return r.length > 0 ? this._tryToSplitAndUndo(e, t, null, C({
            key: "cannotWorkspaceUndoDueToInProgressUndoRedo",
            comment: [
              "{0} is a label for an operation. {1} is a list of filenames."
            ]
          }, "Could not undo '{0}' across all files because there is already an undo or redo operation running on {1}", t.label, r.join(", "))) : i.isValid() ? null : this._tryToSplitAndUndo(e, t, null, C({
            key: "cannotWorkspaceUndoDueToInMeantimeUndoRedo",
            comment: [
              "{0} is a label for an operation. {1} is a list of filenames."
            ]
          }, "Could not undo '{0}' across all files because an undo or redo operation occurred in the meantime", t.label));
        }
        _workspaceUndo(e, t, i) {
          const n = this._getAffectedEditStacks(t), o = this._checkWorkspaceUndo(e, t, n, false);
          return o ? o.returnValue : this._confirmAndExecuteWorkspaceUndo(e, t, n, i);
        }
        _isPartOfUndoGroup(e) {
          if (!e.groupId) return false;
          for (const [, t] of this._editStacks) {
            const i = t.getClosestPastElement();
            if (i) {
              if (i === e) {
                const n = t.getSecondClosestPastElement();
                if (n && n.groupId === e.groupId) return true;
              }
              if (i.groupId === e.groupId) return true;
            }
          }
          return false;
        }
        async _confirmAndExecuteWorkspaceUndo(e, t, i, n) {
          if (t.canSplit() && !this._isPartOfUndoGroup(t)) {
            let a;
            (function(d) {
              d[d.All = 0] = "All", d[d.This = 1] = "This", d[d.Cancel = 2] = "Cancel";
            })(a || (a = {}));
            const { result: l } = await this._dialogService.prompt({
              type: Ui.Info,
              message: C("confirmWorkspace", "Would you like to undo '{0}' across all files?", t.label),
              buttons: [
                {
                  label: C({
                    key: "ok",
                    comment: [
                      "{0} denotes a number that is > 1, && denotes a mnemonic"
                    ]
                  }, "&&Undo in {0} Files", i.editStacks.length),
                  run: () => a.All
                },
                {
                  label: C({
                    key: "nok",
                    comment: [
                      "&& denotes a mnemonic"
                    ]
                  }, "Undo this &&File"),
                  run: () => a.This
                }
              ],
              cancelButton: {
                run: () => a.Cancel
              }
            });
            if (l === a.Cancel) return;
            if (l === a.This) return this._splitPastWorkspaceElement(t, null), this._undo(e, 0, true);
            const u = this._checkWorkspaceUndo(e, t, i, false);
            if (u) return u.returnValue;
            n = true;
          }
          let o;
          try {
            o = await this._invokeWorkspacePrepare(t);
          } catch (a) {
            return this._onError(a, t);
          }
          const r = this._checkWorkspaceUndo(e, t, i, true);
          if (r) return o.dispose(), r.returnValue;
          for (const a of i.editStacks) a.moveBackward(t);
          return this._safeInvokeWithLocks(t, () => t.actual.undo(), i, o, () => this._continueUndoInGroup(t.groupId, n));
        }
        _resourceUndo(e, t, i) {
          if (!t.isValid) {
            e.flushAllElements();
            return;
          }
          if (e.locked) {
            const n = C({
              key: "cannotResourceUndoDueToInProgressUndoRedo",
              comment: [
                "{0} is a label for an operation."
              ]
            }, "Could not undo '{0}' because there is already an undo or redo operation running.", t.label);
            this._notificationService.warn(n);
            return;
          }
          return this._invokeResourcePrepare(t, (n) => (e.moveBackward(t), this._safeInvokeWithLocks(t, () => t.actual.undo(), new WL([
            e
          ]), n, () => this._continueUndoInGroup(t.groupId, i))));
        }
        _findClosestUndoElementInGroup(e) {
          if (!e) return [
            null,
            null
          ];
          let t = null, i = null;
          for (const [n, o] of this._editStacks) {
            const r = o.getClosestPastElement();
            r && r.groupId === e && (!t || r.groupOrder > t.groupOrder) && (t = r, i = n);
          }
          return [
            t,
            i
          ];
        }
        _continueUndoInGroup(e, t) {
          if (!e) return;
          const [, i] = this._findClosestUndoElementInGroup(e);
          if (i) return this._undo(i, 0, t);
        }
        undo(e) {
          if (e instanceof Rc) {
            const [, t] = this._findClosestUndoElementWithSource(e.id);
            return t ? this._undo(t, e.id, false) : void 0;
          }
          return typeof e == "string" ? this._undo(e, 0, false) : this._undo(this.getUriComparisonKey(e), 0, false);
        }
        _undo(e, t = 0, i) {
          if (!this._editStacks.has(e)) return;
          const n = this._editStacks.get(e), o = n.getClosestPastElement();
          if (!o) return;
          if (o.groupId) {
            const [a, l] = this._findClosestUndoElementInGroup(o.groupId);
            if (o !== a && l) return this._undo(l, t, i);
          }
          if ((o.sourceId !== t || o.confirmBeforeUndo) && !i) return this._confirmAndContinueUndo(e, t, o);
          try {
            return o.type === 1 ? this._workspaceUndo(e, o, i) : this._resourceUndo(n, o, i);
          } finally {
          }
        }
        async _confirmAndContinueUndo(e, t, i) {
          if ((await this._dialogService.confirm({
            message: C("confirmDifferentSource", "Would you like to undo '{0}'?", i.label),
            primaryButton: C({
              key: "confirmDifferentSource.yes",
              comment: [
                "&& denotes a mnemonic"
              ]
            }, "&&Yes"),
            cancelButton: C("confirmDifferentSource.no", "No")
          })).confirmed) return this._undo(e, t, true);
        }
        _findClosestRedoElementWithSource(e) {
          if (!e) return [
            null,
            null
          ];
          let t = null, i = null;
          for (const [n, o] of this._editStacks) {
            const r = o.getClosestFutureElement();
            r && r.sourceId === e && (!t || r.sourceOrder < t.sourceOrder) && (t = r, i = n);
          }
          return [
            t,
            i
          ];
        }
        canRedo(e) {
          if (e instanceof Rc) {
            const [, i] = this._findClosestRedoElementWithSource(e.id);
            return !!i;
          }
          const t = this.getUriComparisonKey(e);
          return this._editStacks.has(t) ? this._editStacks.get(t).hasFutureElements() : false;
        }
        _tryToSplitAndRedo(e, t, i, n) {
          if (t.canSplit()) return this._splitFutureWorkspaceElement(t, i), this._notificationService.warn(n), new Ab(this._redo(e));
          for (const o of t.strResources) this.removeElements(o);
          return this._notificationService.warn(n), new Ab();
        }
        _checkWorkspaceRedo(e, t, i, n) {
          if (t.removedResources) return this._tryToSplitAndRedo(e, t, t.removedResources, C({
            key: "cannotWorkspaceRedo",
            comment: [
              "{0} is a label for an operation. {1} is another message."
            ]
          }, "Could not redo '{0}' across all files. {1}", t.label, t.removedResources.createMessage()));
          if (n && t.invalidatedResources) return this._tryToSplitAndRedo(e, t, t.invalidatedResources, C({
            key: "cannotWorkspaceRedo",
            comment: [
              "{0} is a label for an operation. {1} is another message."
            ]
          }, "Could not redo '{0}' across all files. {1}", t.label, t.invalidatedResources.createMessage()));
          const o = [];
          for (const a of i.editStacks) a.getClosestFutureElement() !== t && o.push(a.resourceLabel);
          if (o.length > 0) return this._tryToSplitAndRedo(e, t, null, C({
            key: "cannotWorkspaceRedoDueToChanges",
            comment: [
              "{0} is a label for an operation. {1} is a list of filenames."
            ]
          }, "Could not redo '{0}' across all files because changes were made to {1}", t.label, o.join(", ")));
          const r = [];
          for (const a of i.editStacks) a.locked && r.push(a.resourceLabel);
          return r.length > 0 ? this._tryToSplitAndRedo(e, t, null, C({
            key: "cannotWorkspaceRedoDueToInProgressUndoRedo",
            comment: [
              "{0} is a label for an operation. {1} is a list of filenames."
            ]
          }, "Could not redo '{0}' across all files because there is already an undo or redo operation running on {1}", t.label, r.join(", "))) : i.isValid() ? null : this._tryToSplitAndRedo(e, t, null, C({
            key: "cannotWorkspaceRedoDueToInMeantimeUndoRedo",
            comment: [
              "{0} is a label for an operation. {1} is a list of filenames."
            ]
          }, "Could not redo '{0}' across all files because an undo or redo operation occurred in the meantime", t.label));
        }
        _workspaceRedo(e, t) {
          const i = this._getAffectedEditStacks(t), n = this._checkWorkspaceRedo(e, t, i, false);
          return n ? n.returnValue : this._executeWorkspaceRedo(e, t, i);
        }
        async _executeWorkspaceRedo(e, t, i) {
          let n;
          try {
            n = await this._invokeWorkspacePrepare(t);
          } catch (r) {
            return this._onError(r, t);
          }
          const o = this._checkWorkspaceRedo(e, t, i, true);
          if (o) return n.dispose(), o.returnValue;
          for (const r of i.editStacks) r.moveForward(t);
          return this._safeInvokeWithLocks(t, () => t.actual.redo(), i, n, () => this._continueRedoInGroup(t.groupId));
        }
        _resourceRedo(e, t) {
          if (!t.isValid) {
            e.flushAllElements();
            return;
          }
          if (e.locked) {
            const i = C({
              key: "cannotResourceRedoDueToInProgressUndoRedo",
              comment: [
                "{0} is a label for an operation."
              ]
            }, "Could not redo '{0}' because there is already an undo or redo operation running.", t.label);
            this._notificationService.warn(i);
            return;
          }
          return this._invokeResourcePrepare(t, (i) => (e.moveForward(t), this._safeInvokeWithLocks(t, () => t.actual.redo(), new WL([
            e
          ]), i, () => this._continueRedoInGroup(t.groupId))));
        }
        _findClosestRedoElementInGroup(e) {
          if (!e) return [
            null,
            null
          ];
          let t = null, i = null;
          for (const [n, o] of this._editStacks) {
            const r = o.getClosestFutureElement();
            r && r.groupId === e && (!t || r.groupOrder < t.groupOrder) && (t = r, i = n);
          }
          return [
            t,
            i
          ];
        }
        _continueRedoInGroup(e) {
          if (!e) return;
          const [, t] = this._findClosestRedoElementInGroup(e);
          if (t) return this._redo(t);
        }
        redo(e) {
          if (e instanceof Rc) {
            const [, t] = this._findClosestRedoElementWithSource(e.id);
            return t ? this._redo(t) : void 0;
          }
          return typeof e == "string" ? this._redo(e) : this._redo(this.getUriComparisonKey(e));
        }
        _redo(e) {
          if (!this._editStacks.has(e)) return;
          const t = this._editStacks.get(e), i = t.getClosestFutureElement();
          if (i) {
            if (i.groupId) {
              const [n, o] = this._findClosestRedoElementInGroup(i.groupId);
              if (i !== n && o) return this._redo(o);
            }
            try {
              return i.type === 1 ? this._workspaceRedo(e, i) : this._resourceRedo(t, i);
            } finally {
            }
          }
        }
      };
      hD = QY([
        o5(0, V8),
        o5(1, Jr)
      ], hD);
      class Ab {
        constructor(e) {
          this.returnValue = e;
        }
      }
      Lt(DT, hD, 1);
      function xs(s, e, t) {
        return Math.min(Math.max(s, e), t);
      }
      class $8 {
        constructor() {
          this._n = 1, this._val = 0;
        }
        update(e) {
          return this._val = this._val + (e - this._val) / this._n, this._n += 1, this._val;
        }
        get value() {
          return this._val;
        }
      }
      class JY {
        constructor(e) {
          this._n = 0, this._val = 0, this._values = [], this._index = 0, this._sum = 0, this._values = new Array(e), this._values.fill(0, 0, e);
        }
        update(e) {
          const t = this._values[this._index];
          return this._values[this._index] = e, this._index = (this._index + 1) % this._values.length, this._sum -= t, this._sum += e, this._n < this._values.length && (this._n += 1), this._val = this._sum / this._n, this._val;
        }
        get value() {
          return this._val;
        }
      }
      const q8 = pt("environmentService");
      var eZ = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      }, l5 = function(s, e) {
        return function(t, i) {
          e(t, i, s);
        };
      };
      const tZ = pt("ILanguageFeatureDebounceService");
      var Cv;
      (function(s) {
        const e = /* @__PURE__ */ new WeakMap();
        let t = 0;
        function i(n) {
          let o = e.get(n);
          return o === void 0 && (o = ++t, e.set(n, o)), o;
        }
        s.of = i;
      })(Cv || (Cv = {}));
      class iZ {
        constructor(e) {
          this._default = e;
        }
        get(e) {
          return this._default;
        }
        update(e, t) {
          return this._default;
        }
        default() {
          return this._default;
        }
      }
      class nZ {
        constructor(e, t, i, n, o, r) {
          this._logService = e, this._name = t, this._registry = i, this._default = n, this._min = o, this._max = r, this._cache = new K_(50, 0.7);
        }
        _key(e) {
          return e.id + this._registry.all(e).reduce((t, i) => UC(Cv.of(i), t), 0);
        }
        get(e) {
          const t = this._key(e), i = this._cache.get(t);
          return i ? xs(i.value, this._min, this._max) : this.default();
        }
        update(e, t) {
          const i = this._key(e);
          let n = this._cache.get(i);
          n || (n = new JY(6), this._cache.set(i, n));
          const o = xs(n.update(t), this._min, this._max);
          return tT(e.uri, "output") || this._logService.trace(`[DEBOUNCE: ${this._name}] for ${e.uri.toString()} is ${o}ms`), o;
        }
        _overall() {
          const e = new $8();
          for (const [, t] of this._cache) e.update(t.value);
          return e.value;
        }
        default() {
          const e = this._overall() | 0 || this._default;
          return xs(e, this._min, this._max);
        }
      }
      let dD = class {
        constructor(e, t) {
          this._logService = e, this._data = /* @__PURE__ */ new Map(), this._isDev = t.isExtensionDevelopment || !t.isBuilt;
        }
        for(e, t, i) {
          const n = (i == null ? void 0 : i.min) ?? 50, o = (i == null ? void 0 : i.max) ?? n ** 2, r = (i == null ? void 0 : i.key) ?? void 0, a = `${Cv.of(e)},${n}${r ? "," + r : ""}`;
          let l = this._data.get(a);
          return l || (this._isDev ? (this._logService.debug(`[DEBOUNCE: ${t}] is disabled in developed mode`), l = new iZ(n * 1.5)) : l = new nZ(this._logService, t, e, this._overallAverage() | 0 || n * 1.5, n, o), this._data.set(a, l)), l;
        }
        _overallAverage() {
          const e = new $8();
          for (const t of this._data.values()) e.update(t.default());
          return e.value;
        }
      };
      dD = eZ([
        l5(0, Xr),
        l5(1, q8)
      ], dD);
      Lt(tZ, dD, 1);
      class Pr {
        static getLanguageId(e) {
          return (e & 255) >>> 0;
        }
        static getTokenType(e) {
          return (e & 768) >>> 8;
        }
        static containsBalancedBrackets(e) {
          return (e & 1024) !== 0;
        }
        static getFontStyle(e) {
          return (e & 30720) >>> 11;
        }
        static getForeground(e) {
          return (e & 16744448) >>> 15;
        }
        static getBackground(e) {
          return (e & 4278190080) >>> 24;
        }
        static getClassNameFromMetadata(e) {
          let i = "mtk" + this.getForeground(e);
          const n = this.getFontStyle(e);
          return n & 1 && (i += " mtki"), n & 2 && (i += " mtkb"), n & 4 && (i += " mtku"), n & 8 && (i += " mtks"), i;
        }
        static getInlineStyleFromMetadata(e, t) {
          const i = this.getForeground(e), n = this.getFontStyle(e);
          let o = `color: ${t[i]};`;
          n & 1 && (o += "font-style: italic;"), n & 2 && (o += "font-weight: bold;");
          let r = "";
          return n & 4 && (r += " underline"), n & 8 && (r += " line-through"), r && (o += `text-decoration:${r};`), o;
        }
        static getPresentationFromMetadata(e) {
          const t = this.getForeground(e), i = this.getFontStyle(e);
          return {
            foreground: t,
            italic: !!(i & 1),
            bold: !!(i & 2),
            underline: !!(i & 4),
            strikethrough: !!(i & 8)
          };
        }
      }
      function cg(s) {
        let e = 0, t = 0, i = 0, n = 0;
        for (let o = 0, r = s.length; o < r; o++) {
          const a = s.charCodeAt(o);
          a === 13 ? (e === 0 && (t = o), e++, o + 1 < r && s.charCodeAt(o + 1) === 10 ? (n |= 2, o++) : n |= 3, i = o + 1) : a === 10 && (n |= 1, e === 0 && (t = o), e++, i = o + 1);
        }
        return e === 0 && (t = s.length), [
          e,
          t,
          s.length - i,
          n
        ];
      }
      var sZ = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      }, HL = function(s, e) {
        return function(t, i) {
          e(t, i, s);
        };
      };
      let fD = class {
        constructor(e, t, i, n) {
          this._legend = e, this._themeService = t, this._languageService = i, this._logService = n, this._hasWarnedOverlappingTokens = false, this._hasWarnedInvalidLengthTokens = false, this._hasWarnedInvalidEditStart = false, this._hashTable = new Tc();
        }
        getMetadata(e, t, i) {
          const n = this._languageService.languageIdCodec.encodeLanguageId(i), o = this._hashTable.get(e, t, n);
          let r;
          if (o) r = o.metadata;
          else {
            let a = this._legend.tokenTypes[e];
            const l = [];
            if (a) {
              let u = t;
              for (let f = 0; u > 0 && f < this._legend.tokenModifiers.length; f++) u & 1 && l.push(this._legend.tokenModifiers[f]), u = u >> 1;
              const d = this._themeService.getColorTheme().getTokenStyleMetadata(a, l, i);
              if (typeof d > "u") r = 2147483647;
              else {
                if (r = 0, typeof d.italic < "u") {
                  const f = (d.italic ? 1 : 0) << 11;
                  r |= f | 1;
                }
                if (typeof d.bold < "u") {
                  const f = (d.bold ? 2 : 0) << 11;
                  r |= f | 2;
                }
                if (typeof d.underline < "u") {
                  const f = (d.underline ? 4 : 0) << 11;
                  r |= f | 4;
                }
                if (typeof d.strikethrough < "u") {
                  const f = (d.strikethrough ? 8 : 0) << 11;
                  r |= f | 8;
                }
                if (d.foreground) {
                  const f = d.foreground << 15;
                  r |= f | 16;
                }
                r === 0 && (r = 2147483647);
              }
            } else r = 2147483647, a = "not-in-legend";
            this._hashTable.add(e, t, n, r);
          }
          return r;
        }
        warnOverlappingSemanticTokens(e, t) {
          this._hasWarnedOverlappingTokens || (this._hasWarnedOverlappingTokens = true, this._logService.warn(`Overlapping semantic tokens detected at lineNumber ${e}, column ${t}`));
        }
        warnInvalidLengthSemanticTokens(e, t) {
          this._hasWarnedInvalidLengthTokens || (this._hasWarnedInvalidLengthTokens = true, this._logService.warn(`Semantic token with invalid length detected at lineNumber ${e}, column ${t}`));
        }
        warnInvalidEditStart(e, t, i, n, o) {
          this._hasWarnedInvalidEditStart || (this._hasWarnedInvalidEditStart = true, this._logService.warn(`Invalid semantic tokens edit detected (previousResultId: ${e}, resultId: ${t}) at edit #${i}: The provided start offset ${n} is outside the previous data (length ${o}).`));
        }
      };
      fD = sZ([
        HL(1, vr),
        HL(2, un),
        HL(3, Xr)
      ], fD);
      class oZ {
        constructor(e, t, i, n) {
          this.tokenTypeIndex = e, this.tokenModifierSet = t, this.languageId = i, this.metadata = n, this.next = null;
        }
      }
      const _Tc = class _Tc {
        constructor() {
          this._elementsCount = 0, this._currentLengthIndex = 0, this._currentLength = _Tc._SIZES[this._currentLengthIndex], this._growCount = Math.round(this._currentLengthIndex + 1 < _Tc._SIZES.length ? 2 / 3 * this._currentLength : 0), this._elements = [], _Tc._nullOutEntries(this._elements, this._currentLength);
        }
        static _nullOutEntries(e, t) {
          for (let i = 0; i < t; i++) e[i] = null;
        }
        _hash2(e, t) {
          return (e << 5) - e + t | 0;
        }
        _hashFunc(e, t, i) {
          return this._hash2(this._hash2(e, t), i) % this._currentLength;
        }
        get(e, t, i) {
          const n = this._hashFunc(e, t, i);
          let o = this._elements[n];
          for (; o; ) {
            if (o.tokenTypeIndex === e && o.tokenModifierSet === t && o.languageId === i) return o;
            o = o.next;
          }
          return null;
        }
        add(e, t, i, n) {
          if (this._elementsCount++, this._growCount !== 0 && this._elementsCount >= this._growCount) {
            const o = this._elements;
            this._currentLengthIndex++, this._currentLength = _Tc._SIZES[this._currentLengthIndex], this._growCount = Math.round(this._currentLengthIndex + 1 < _Tc._SIZES.length ? 2 / 3 * this._currentLength : 0), this._elements = [], _Tc._nullOutEntries(this._elements, this._currentLength);
            for (const r of o) {
              let a = r;
              for (; a; ) {
                const l = a.next;
                a.next = null, this._add(a), a = l;
              }
            }
          }
          this._add(new oZ(e, t, i, n));
        }
        _add(e) {
          const t = this._hashFunc(e.tokenTypeIndex, e.tokenModifierSet, e.languageId);
          e.next = this._elements[t], this._elements[t] = e;
        }
      };
      _Tc._SIZES = [
        3,
        7,
        13,
        31,
        61,
        127,
        251,
        509,
        1021,
        2039,
        4093,
        8191,
        16381,
        32749,
        65521,
        131071,
        262139,
        524287,
        1048573,
        2097143
      ];
      let Tc = _Tc;
      const rZ = pt("semanticTokensStylingService");
      var aZ = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      }, zL = function(s, e) {
        return function(t, i) {
          e(t, i, s);
        };
      };
      let gD = class extends he {
        constructor(e, t, i) {
          super(), this._themeService = e, this._logService = t, this._languageService = i, this._caches = /* @__PURE__ */ new WeakMap(), this._register(this._themeService.onDidColorThemeChange(() => {
            this._caches = /* @__PURE__ */ new WeakMap();
          }));
        }
        getStyling(e) {
          return this._caches.has(e) || this._caches.set(e, new fD(e.getLegend(), this._themeService, this._languageService, this._logService)), this._caches.get(e);
        }
      };
      gD = aZ([
        zL(0, vr),
        zL(1, Xr),
        zL(2, un)
      ], gD);
      Lt(rZ, gD, 1);
      function Sc(s) {
        return s === 47 || s === 92;
      }
      function K8(s) {
        return s.replace(/[\\/]/g, Ii.sep);
      }
      function lZ(s) {
        return s.indexOf("/") === -1 && (s = K8(s)), /^[a-zA-Z]:(\/|$)/.test(s) && (s = "/" + s), s;
      }
      function c5(s, e = Ii.sep) {
        if (!s) return "";
        const t = s.length, i = s.charCodeAt(0);
        if (Sc(i)) {
          if (Sc(s.charCodeAt(1)) && !Sc(s.charCodeAt(2))) {
            let o = 3;
            const r = o;
            for (; o < t && !Sc(s.charCodeAt(o)); o++) ;
            if (r !== o && !Sc(s.charCodeAt(o + 1))) {
              for (o += 1; o < t; o++) if (Sc(s.charCodeAt(o))) return s.slice(0, o + 1).replace(/[\\/]/g, e);
            }
          }
          return e;
        } else if (cZ(i) && s.charCodeAt(1) === 58) return Sc(s.charCodeAt(2)) ? s.slice(0, 2) + e : s.slice(0, 2);
        let n = s.indexOf("://");
        if (n !== -1) {
          for (n += 3; n < t; n++) if (Sc(s.charCodeAt(n))) return s.slice(0, n + 1);
        }
        return "";
      }
      function mD(s, e, t, i = Jc) {
        if (s === e) return true;
        if (!s || !e || e.length > s.length) return false;
        if (t) {
          if (!KE(s, e)) return false;
          if (e.length === s.length) return true;
          let o = e.length;
          return e.charAt(e.length - 1) === i && o--, s.charAt(o) === i;
        }
        return e.charAt(e.length - 1) !== i && (e += i), s.indexOf(e) === 0;
      }
      function cZ(s) {
        return s >= 65 && s <= 90 || s >= 97 && s <= 122;
      }
      const Rb = "**", u5 = "/", S0 = "[/\\\\]", L0 = "[^/\\\\]", uZ = /\//g;
      function h5(s, e) {
        switch (s) {
          case 0:
            return "";
          case 1:
            return `${L0}*?`;
          default:
            return `(?:${S0}|${L0}+${S0}${e ? `|${S0}${L0}+` : ""})*?`;
        }
      }
      function d5(s, e) {
        if (!s) return [];
        const t = [];
        let i = false, n = false, o = "";
        for (const r of s) {
          switch (r) {
            case e:
              if (!i && !n) {
                t.push(o), o = "";
                continue;
              }
              break;
            case "{":
              i = true;
              break;
            case "}":
              i = false;
              break;
            case "[":
              n = true;
              break;
            case "]":
              n = false;
              break;
          }
          o += r;
        }
        return o && t.push(o), t;
      }
      function j8(s) {
        if (!s) return "";
        let e = "";
        const t = d5(s, u5);
        if (t.every((i) => i === Rb)) e = ".*";
        else {
          let i = false;
          t.forEach((n, o) => {
            if (n === Rb) {
              if (i) return;
              e += h5(2, o === t.length - 1);
            } else {
              let r = false, a = "", l = false, u = "";
              for (const d of n) {
                if (d !== "}" && r) {
                  a += d;
                  continue;
                }
                if (l && (d !== "]" || !u)) {
                  let f;
                  d === "-" ? f = d : (d === "^" || d === "!") && !u ? f = "^" : d === u5 ? f = "" : f = $l(d), u += f;
                  continue;
                }
                switch (d) {
                  case "{":
                    r = true;
                    continue;
                  case "[":
                    l = true;
                    continue;
                  case "}": {
                    const m = `(?:${d5(a, ",").map((_) => j8(_)).join("|")})`;
                    e += m, r = false, a = "";
                    break;
                  }
                  case "]": {
                    e += "[" + u + "]", l = false, u = "";
                    break;
                  }
                  case "?":
                    e += L0;
                    continue;
                  case "*":
                    e += h5(1);
                    continue;
                  default:
                    e += $l(d);
                }
              }
              o < t.length - 1 && (t[o + 1] !== Rb || o + 2 < t.length) && (e += S0);
            }
            i = n === Rb;
          });
        }
        return e;
      }
      const hZ = /^\*\*\/\*\.[\w\.-]+$/, dZ = /^\*\*\/([\w\.-]+)\/?$/, fZ = /^{\*\*\/\*?[\w\.-]+\/?(,\*\*\/\*?[\w\.-]+\/?)*}$/, gZ = /^{\*\*\/\*?[\w\.-]+(\/(\*\*)?)?(,\*\*\/\*?[\w\.-]+(\/(\*\*)?)?)*}$/, mZ = /^\*\*((\/[\w\.-]+)+)\/?$/, pZ = /^([\w\.-]+(\/[\w\.-]+)*)\/?$/, f5 = new K_(1e4), g5 = function() {
        return false;
      }, Da = function() {
        return null;
      };
      function ET(s, e) {
        if (!s) return Da;
        let t;
        typeof s != "string" ? t = s.pattern : t = s, t = t.trim();
        const i = `${t}_${!!e.trimForExclusions}`;
        let n = f5.get(i);
        if (n) return m5(n, s);
        let o;
        return hZ.test(t) ? n = _Z(t.substr(4), t) : (o = dZ.exec(UL(t, e))) ? n = bZ(o[1], t) : (e.trimForExclusions ? gZ : fZ).test(t) ? n = vZ(t, e) : (o = mZ.exec(UL(t, e))) ? n = p5(o[1].substr(1), t, true) : (o = pZ.exec(UL(t, e))) ? n = p5(o[1], t, false) : n = CZ(t), f5.set(i, n), m5(n, s);
      }
      function m5(s, e) {
        if (typeof e == "string") return s;
        const t = function(i, n) {
          return mD(i, e.base, !Is) ? s(WC(i.substr(e.base.length), Jc), n) : null;
        };
        return t.allBasenames = s.allBasenames, t.allPaths = s.allPaths, t.basenames = s.basenames, t.patterns = s.patterns, t;
      }
      function UL(s, e) {
        return e.trimForExclusions && s.endsWith("/**") ? s.substr(0, s.length - 2) : s;
      }
      function _Z(s, e) {
        return function(t, i) {
          return typeof t == "string" && t.endsWith(s) ? e : null;
        };
      }
      function bZ(s, e) {
        const t = `/${s}`, i = `\\${s}`, n = function(r, a) {
          return typeof r != "string" ? null : a ? a === s ? e : null : r === s || r.endsWith(t) || r.endsWith(i) ? e : null;
        }, o = [
          s
        ];
        return n.basenames = o, n.patterns = [
          e
        ], n.allBasenames = o, n;
      }
      function vZ(s, e) {
        const t = Y8(s.slice(1, -1).split(",").map((a) => ET(a, e)).filter((a) => a !== Da), s), i = t.length;
        if (!i) return Da;
        if (i === 1) return t[0];
        const n = function(a, l) {
          for (let u = 0, d = t.length; u < d; u++) if (t[u](a, l)) return s;
          return null;
        }, o = t.find((a) => !!a.allBasenames);
        o && (n.allBasenames = o.allBasenames);
        const r = t.reduce((a, l) => l.allPaths ? a.concat(l.allPaths) : a, []);
        return r.length && (n.allPaths = r), n;
      }
      function p5(s, e, t) {
        const i = Jc === Ii.sep, n = i ? s : s.replace(uZ, Jc), o = Jc + n, r = Ii.sep + s;
        let a;
        return t ? a = function(l, u) {
          return typeof l == "string" && (l === n || l.endsWith(o) || !i && (l === s || l.endsWith(r))) ? e : null;
        } : a = function(l, u) {
          return typeof l == "string" && (l === n || !i && l === s) ? e : null;
        }, a.allPaths = [
          (t ? "*/" : "./") + s
        ], a;
      }
      function CZ(s) {
        try {
          const e = new RegExp(`^${j8(s)}$`);
          return function(t) {
            return e.lastIndex = 0, typeof t == "string" && e.test(t) ? s : null;
          };
        } catch {
          return Da;
        }
      }
      function wZ(s, e, t) {
        return !s || typeof e != "string" ? false : G8(s)(e, void 0, t);
      }
      function G8(s, e = {}) {
        if (!s) return g5;
        if (typeof s == "string" || yZ(s)) {
          const t = ET(s, e);
          if (t === Da) return g5;
          const i = function(n, o) {
            return !!t(n, o);
          };
          return t.allBasenames && (i.allBasenames = t.allBasenames), t.allPaths && (i.allPaths = t.allPaths), i;
        }
        return SZ(s, e);
      }
      function yZ(s) {
        const e = s;
        return e ? typeof e.base == "string" && typeof e.pattern == "string" : false;
      }
      function SZ(s, e) {
        const t = Y8(Object.getOwnPropertyNames(s).map((a) => LZ(a, s[a], e)).filter((a) => a !== Da)), i = t.length;
        if (!i) return Da;
        if (!t.some((a) => !!a.requiresSiblings)) {
          if (i === 1) return t[0];
          const a = function(d, f) {
            let m;
            for (let _ = 0, b = t.length; _ < b; _++) {
              const v = t[_](d, f);
              if (typeof v == "string") return v;
              Fk(v) && (m || (m = []), m.push(v));
            }
            return m ? (async () => {
              for (const _ of m) {
                const b = await _;
                if (typeof b == "string") return b;
              }
              return null;
            })() : null;
          }, l = t.find((d) => !!d.allBasenames);
          l && (a.allBasenames = l.allBasenames);
          const u = t.reduce((d, f) => f.allPaths ? d.concat(f.allPaths) : d, []);
          return u.length && (a.allPaths = u), a;
        }
        const n = function(a, l, u) {
          let d, f;
          for (let m = 0, _ = t.length; m < _; m++) {
            const b = t[m];
            b.requiresSiblings && u && (l || (l = p9(a)), d || (d = l.substr(0, l.length - lq(a).length)));
            const v = b(a, l, d, u);
            if (typeof v == "string") return v;
            Fk(v) && (f || (f = []), f.push(v));
          }
          return f ? (async () => {
            for (const m of f) {
              const _ = await m;
              if (typeof _ == "string") return _;
            }
            return null;
          })() : null;
        }, o = t.find((a) => !!a.allBasenames);
        o && (n.allBasenames = o.allBasenames);
        const r = t.reduce((a, l) => l.allPaths ? a.concat(l.allPaths) : a, []);
        return r.length && (n.allPaths = r), n;
      }
      function LZ(s, e, t) {
        if (e === false) return Da;
        const i = ET(s, t);
        if (i === Da) return Da;
        if (typeof e == "boolean") return i;
        if (e) {
          const n = e.when;
          if (typeof n == "string") {
            const o = (r, a, l, u) => {
              if (!u || !i(r, a)) return null;
              const d = n.replace("$(basename)", () => l), f = u(d);
              return Fk(f) ? f.then((m) => m ? s : null) : f ? s : null;
            };
            return o.requiresSiblings = true, o;
          }
        }
        return i;
      }
      function Y8(s, e) {
        const t = s.filter((a) => !!a.basenames);
        if (t.length < 2) return s;
        const i = t.reduce((a, l) => {
          const u = l.basenames;
          return u ? a.concat(u) : a;
        }, []);
        let n;
        if (e) {
          n = [];
          for (let a = 0, l = i.length; a < l; a++) n.push(e);
        } else n = t.reduce((a, l) => {
          const u = l.patterns;
          return u ? a.concat(u) : a;
        }, []);
        const o = function(a, l) {
          if (typeof a != "string") return null;
          if (!l) {
            let d;
            for (d = a.length; d > 0; d--) {
              const f = a.charCodeAt(d - 1);
              if (f === 47 || f === 92) break;
            }
            l = a.substr(d);
          }
          const u = i.indexOf(l);
          return u !== -1 ? n[u] : null;
        };
        o.basenames = i, o.patterns = n, o.allBasenames = i;
        const r = s.filter((a) => !a.basenames);
        return r.push(o), r;
      }
      function Z8(s, e, t, i, n, o) {
        if (Array.isArray(s)) {
          let r = 0;
          for (const a of s) {
            const l = Z8(a, e, t, i, n, o);
            if (l === 10) return l;
            l > r && (r = l);
          }
          return r;
        } else {
          if (typeof s == "string") return i ? s === "*" ? 5 : s === t ? 10 : 0 : 0;
          if (s) {
            const { language: r, pattern: a, scheme: l, hasAccessToAllModels: u, notebookType: d } = s;
            if (!i && !u) return 0;
            d && n && (e = n);
            let f = 0;
            if (l) if (l === e.scheme) f = 10;
            else if (l === "*") f = 5;
            else return 0;
            if (r) if (r === t) f = 10;
            else if (r === "*") f = Math.max(f, 5);
            else return 0;
            if (d) if (d === o) f = 10;
            else if (d === "*" && o !== void 0) f = Math.max(f, 5);
            else return 0;
            if (a) {
              let m;
              if (typeof a == "string" ? m = a : m = {
                ...a,
                base: m9(a.base)
              }, m === e.fsPath || wZ(m, e.fsPath)) f = 10;
              else return 0;
            }
            return f;
          } else return 0;
        }
      }
      function Q8(s) {
        return typeof s == "string" ? false : Array.isArray(s) ? s.every(Q8) : !!s.exclusive;
      }
      class _5 {
        constructor(e, t, i, n, o) {
          this.uri = e, this.languageId = t, this.notebookUri = i, this.notebookType = n, this.recursive = o;
        }
        equals(e) {
          var _a3, _b3;
          return this.notebookType === e.notebookType && this.languageId === e.languageId && this.uri.toString() === e.uri.toString() && ((_a3 = this.notebookUri) == null ? void 0 : _a3.toString()) === ((_b3 = e.notebookUri) == null ? void 0 : _b3.toString()) && this.recursive === e.recursive;
        }
      }
      class ai {
        constructor(e) {
          this._notebookInfoResolver = e, this._clock = 0, this._entries = [], this._onDidChange = new G(), this.onDidChange = this._onDidChange.event;
        }
        register(e, t) {
          let i = {
            selector: e,
            provider: t,
            _score: -1,
            _time: this._clock++
          };
          return this._entries.push(i), this._lastCandidate = void 0, this._onDidChange.fire(this._entries.length), Ze(() => {
            if (i) {
              const n = this._entries.indexOf(i);
              n >= 0 && (this._entries.splice(n, 1), this._lastCandidate = void 0, this._onDidChange.fire(this._entries.length), i = void 0);
            }
          });
        }
        has(e) {
          return this.all(e).length > 0;
        }
        all(e) {
          if (!e) return [];
          this._updateScores(e, false);
          const t = [];
          for (const i of this._entries) i._score > 0 && t.push(i.provider);
          return t;
        }
        ordered(e, t = false) {
          const i = [];
          return this._orderedForEach(e, t, (n) => i.push(n.provider)), i;
        }
        orderedGroups(e) {
          const t = [];
          let i, n;
          return this._orderedForEach(e, false, (o) => {
            i && n === o._score ? i.push(o.provider) : (n = o._score, i = [
              o.provider
            ], t.push(i));
          }), t;
        }
        _orderedForEach(e, t, i) {
          this._updateScores(e, t);
          for (const n of this._entries) n._score > 0 && i(n);
        }
        _updateScores(e, t) {
          var _a3, _b3;
          const i = (_a3 = this._notebookInfoResolver) == null ? void 0 : _a3.call(this, e.uri), n = i ? new _5(e.uri, e.getLanguageId(), i.uri, i.type, t) : new _5(e.uri, e.getLanguageId(), void 0, void 0, t);
          if (!((_b3 = this._lastCandidate) == null ? void 0 : _b3.equals(n))) {
            this._lastCandidate = n;
            for (const o of this._entries) if (o._score = Z8(o.selector, n.uri, n.languageId, HG(e), n.notebookUri, n.notebookType), Q8(o.selector) && o._score > 0) if (t) o._score = 0;
            else {
              for (const r of this._entries) r._score = 0;
              o._score = 1e3;
              break;
            }
            this._entries.sort(ai._compareByScoreAndTime);
          }
        }
        static _compareByScoreAndTime(e, t) {
          return e._score < t._score ? 1 : e._score > t._score ? -1 : tp(e.selector) && !tp(t.selector) ? 1 : !tp(e.selector) && tp(t.selector) ? -1 : e._time < t._time ? 1 : e._time > t._time ? -1 : 0;
        }
      }
      function tp(s) {
        return typeof s == "string" ? false : Array.isArray(s) ? s.some(tp) : !!s.isBuiltin;
      }
      class xZ {
        constructor() {
          this.referenceProvider = new ai(this._score.bind(this)), this.renameProvider = new ai(this._score.bind(this)), this.newSymbolNamesProvider = new ai(this._score.bind(this)), this.codeActionProvider = new ai(this._score.bind(this)), this.definitionProvider = new ai(this._score.bind(this)), this.typeDefinitionProvider = new ai(this._score.bind(this)), this.declarationProvider = new ai(this._score.bind(this)), this.implementationProvider = new ai(this._score.bind(this)), this.documentSymbolProvider = new ai(this._score.bind(this)), this.inlayHintsProvider = new ai(this._score.bind(this)), this.colorProvider = new ai(this._score.bind(this)), this.codeLensProvider = new ai(this._score.bind(this)), this.documentFormattingEditProvider = new ai(this._score.bind(this)), this.documentRangeFormattingEditProvider = new ai(this._score.bind(this)), this.onTypeFormattingEditProvider = new ai(this._score.bind(this)), this.signatureHelpProvider = new ai(this._score.bind(this)), this.hoverProvider = new ai(this._score.bind(this)), this.documentHighlightProvider = new ai(this._score.bind(this)), this.multiDocumentHighlightProvider = new ai(this._score.bind(this)), this.selectionRangeProvider = new ai(this._score.bind(this)), this.foldingRangeProvider = new ai(this._score.bind(this)), this.linkProvider = new ai(this._score.bind(this)), this.inlineCompletionsProvider = new ai(this._score.bind(this)), this.inlineEditProvider = new ai(this._score.bind(this)), this.completionProvider = new ai(this._score.bind(this)), this.linkedEditingRangeProvider = new ai(this._score.bind(this)), this.documentRangeSemanticTokensProvider = new ai(this._score.bind(this)), this.documentSemanticTokensProvider = new ai(this._score.bind(this)), this.documentDropEditProvider = new ai(this._score.bind(this)), this.documentPasteEditProvider = new ai(this._score.bind(this));
        }
        _score(e) {
          var _a3;
          return (_a3 = this._notebookTypeResolver) == null ? void 0 : _a3.call(this, e);
        }
      }
      Lt(jt, xZ, 1);
      function TT(s) {
        return `--vscode-${s.replace(/\./g, "-")}`;
      }
      function we(s) {
        return `var(${TT(s)})`;
      }
      function kZ(s, e) {
        return `var(${TT(s)}, ${e})`;
      }
      function DZ(s) {
        return s !== null && typeof s == "object" && "light" in s && "dark" in s;
      }
      const X8 = {
        ColorContribution: "base.contributions.colors"
      }, EZ = "default";
      class TZ {
        constructor() {
          this._onDidChangeSchema = new G(), this.onDidChangeSchema = this._onDidChangeSchema.event, this.colorSchema = {
            type: "object",
            properties: {}
          }, this.colorReferenceSchema = {
            type: "string",
            enum: [],
            enumDescriptions: []
          }, this.colorsById = {};
        }
        registerColor(e, t, i, n = false, o) {
          const r = {
            id: e,
            description: i,
            defaults: t,
            needsTransparency: n,
            deprecationMessage: o
          };
          this.colorsById[e] = r;
          const a = {
            type: "string",
            format: "color-hex",
            defaultSnippets: [
              {
                body: "${1:#ff0000}"
              }
            ]
          };
          return o && (a.deprecationMessage = o), n && (a.pattern = "^#(?:(?<rgba>[0-9a-fA-f]{3}[0-9a-eA-E])|(?:[0-9a-fA-F]{6}(?:(?![fF]{2})(?:[0-9a-fA-F]{2}))))?$", a.patternErrorMessage = C("transparecyRequired", "This color must be transparent or it will obscure content")), this.colorSchema.properties[e] = {
            description: i,
            oneOf: [
              a,
              {
                type: "string",
                const: EZ,
                description: C("useDefault", "Use the default color.")
              }
            ]
          }, this.colorReferenceSchema.enum.push(e), this.colorReferenceSchema.enumDescriptions.push(i), this._onDidChangeSchema.fire(), e;
        }
        getColors() {
          return Object.keys(this.colorsById).map((e) => this.colorsById[e]);
        }
        resolveDefaultColor(e, t) {
          const i = this.colorsById[e];
          if (i == null ? void 0 : i.defaults) {
            const n = DZ(i.defaults) ? i.defaults[t.type] : i.defaults;
            return Tr(n, t);
          }
        }
        getColorSchema() {
          return this.colorSchema;
        }
        toString() {
          const e = (t, i) => {
            const n = t.indexOf(".") === -1 ? 0 : 1, o = i.indexOf(".") === -1 ? 0 : 1;
            return n !== o ? n - o : t.localeCompare(i);
          };
          return Object.keys(this.colorsById).sort(e).map((t) => `- \`${t}\`: ${this.colorsById[t].description}`).join(`
`);
        }
      }
      const aw = new TZ();
      yn.add(X8.ColorContribution, aw);
      function B(s, e, t, i, n) {
        return aw.registerColor(s, e, t, i, n);
      }
      function NZ(s, e) {
        var _a3, _b3, _c2, _d2;
        switch (s.op) {
          case 0:
            return (_a3 = Tr(s.value, e)) == null ? void 0 : _a3.darken(s.factor);
          case 1:
            return (_b3 = Tr(s.value, e)) == null ? void 0 : _b3.lighten(s.factor);
          case 2:
            return (_c2 = Tr(s.value, e)) == null ? void 0 : _c2.transparent(s.factor);
          case 3: {
            const t = Tr(s.background, e);
            return t ? (_d2 = Tr(s.value, e)) == null ? void 0 : _d2.makeOpaque(t) : Tr(s.value, e);
          }
          case 4:
            for (const t of s.values) {
              const i = Tr(t, e);
              if (i) return i;
            }
            return;
          case 6:
            return Tr(e.defines(s.if) ? s.then : s.else, e);
          case 5: {
            const t = Tr(s.value, e);
            if (!t) return;
            const i = Tr(s.background, e);
            return i ? t.isDarkerThan(i) ? le.getLighterColor(t, i, s.factor).transparent(s.transparency) : le.getDarkerColor(t, i, s.factor).transparent(s.transparency) : t.transparent(s.factor * s.transparency);
          }
          default:
            throw gT();
        }
      }
      function ed(s, e) {
        return {
          op: 0,
          value: s,
          factor: e
        };
      }
      function zr(s, e) {
        return {
          op: 1,
          value: s,
          factor: e
        };
      }
      function rt(s, e) {
        return {
          op: 2,
          value: s,
          factor: e
        };
      }
      function b5(...s) {
        return {
          op: 4,
          values: s
        };
      }
      function IZ(s, e, t) {
        return {
          op: 6,
          if: s,
          then: e,
          else: t
        };
      }
      function v5(s, e, t, i) {
        return {
          op: 5,
          value: s,
          background: e,
          factor: t,
          transparency: i
        };
      }
      function Tr(s, e) {
        if (s !== null) {
          if (typeof s == "string") return s[0] === "#" ? le.fromHex(s) : e.getColor(s);
          if (s instanceof le) return s;
          if (typeof s == "object") return NZ(s, e);
        }
      }
      const J8 = "vscode://schemas/workbench-colors", e6 = yn.as(sw.JSONContribution);
      e6.registerSchema(J8, aw.getColorSchema());
      const C5 = new ns(() => e6.notifySchemaChanged(J8), 200);
      aw.onDidChangeSchema(() => {
        C5.isScheduled() || C5.schedule();
      });
      const $t = B("foreground", {
        dark: "#CCCCCC",
        light: "#616161",
        hcDark: "#FFFFFF",
        hcLight: "#292929"
      }, C("foreground", "Overall foreground color. This color is only used if not overridden by a component."));
      B("disabledForeground", {
        dark: "#CCCCCC80",
        light: "#61616180",
        hcDark: "#A5A5A5",
        hcLight: "#7F7F7F"
      }, C("disabledForeground", "Overall foreground for disabled elements. This color is only used if not overridden by a component."));
      B("errorForeground", {
        dark: "#F48771",
        light: "#A1260D",
        hcDark: "#F48771",
        hcLight: "#B5200D"
      }, C("errorForeground", "Overall foreground color for error messages. This color is only used if not overridden by a component."));
      B("descriptionForeground", {
        light: "#717171",
        dark: rt($t, 0.7),
        hcDark: rt($t, 0.7),
        hcLight: rt($t, 0.7)
      }, C("descriptionForeground", "Foreground color for description text providing additional information, for example for a label."));
      const pD = B("icon.foreground", {
        dark: "#C5C5C5",
        light: "#424242",
        hcDark: "#FFFFFF",
        hcLight: "#292929"
      }, C("iconForeground", "The default color for icons in the workbench.")), Na = B("focusBorder", {
        dark: "#007FD4",
        light: "#0090F1",
        hcDark: "#F38518",
        hcLight: "#006BBD"
      }, C("focusBorder", "Overall border color for focused elements. This color is only used if not overridden by a component.")), Et = B("contrastBorder", {
        light: null,
        dark: null,
        hcDark: "#6FC3DF",
        hcLight: "#0F4A85"
      }, C("contrastBorder", "An extra border around elements to separate them from others for greater contrast.")), Ai = B("contrastActiveBorder", {
        light: null,
        dark: null,
        hcDark: Na,
        hcLight: Na
      }, C("activeContrastBorder", "An extra border around active elements to separate them from others for greater contrast."));
      B("selection.background", null, C("selectionBackground", "The background color of text selections in the workbench (e.g. for input fields or text areas). Note that this does not apply to selections within the editor."));
      const MZ = B("textLink.foreground", {
        light: "#006AB1",
        dark: "#3794FF",
        hcDark: "#21A6FF",
        hcLight: "#0F4A85"
      }, C("textLinkForeground", "Foreground color for links in text."));
      B("textLink.activeForeground", {
        light: "#006AB1",
        dark: "#3794FF",
        hcDark: "#21A6FF",
        hcLight: "#0F4A85"
      }, C("textLinkActiveForeground", "Foreground color for links in text when clicked on and on mouse hover."));
      B("textSeparator.foreground", {
        light: "#0000002e",
        dark: "#ffffff2e",
        hcDark: le.black,
        hcLight: "#292929"
      }, C("textSeparatorForeground", "Color for text separators."));
      B("textPreformat.foreground", {
        light: "#A31515",
        dark: "#D7BA7D",
        hcDark: "#000000",
        hcLight: "#FFFFFF"
      }, C("textPreformatForeground", "Foreground color for preformatted text segments."));
      B("textPreformat.background", {
        light: "#0000001A",
        dark: "#FFFFFF1A",
        hcDark: "#FFFFFF",
        hcLight: "#09345f"
      }, C("textPreformatBackground", "Background color for preformatted text segments."));
      B("textBlockQuote.background", {
        light: "#f2f2f2",
        dark: "#222222",
        hcDark: null,
        hcLight: "#F2F2F2"
      }, C("textBlockQuoteBackground", "Background color for block quotes in text."));
      B("textBlockQuote.border", {
        light: "#007acc80",
        dark: "#007acc80",
        hcDark: le.white,
        hcLight: "#292929"
      }, C("textBlockQuoteBorder", "Border color for block quotes in text."));
      B("textCodeBlock.background", {
        light: "#dcdcdc66",
        dark: "#0a0a0a66",
        hcDark: le.black,
        hcLight: "#F2F2F2"
      }, C("textCodeBlockBackground", "Background color for code blocks in text."));
      B("sash.hoverBorder", Na, C("sashActiveBorder", "Border color of active sashes."));
      const x0 = B("badge.background", {
        dark: "#4D4D4D",
        light: "#C4C4C4",
        hcDark: le.black,
        hcLight: "#0F4A85"
      }, C("badgeBackground", "Badge background color. Badges are small information labels, e.g. for search results count.")), AZ = B("badge.foreground", {
        dark: le.white,
        light: "#333",
        hcDark: le.white,
        hcLight: le.white
      }, C("badgeForeground", "Badge foreground color. Badges are small information labels, e.g. for search results count.")), NT = B("scrollbar.shadow", {
        dark: "#000000",
        light: "#DDDDDD",
        hcDark: null,
        hcLight: null
      }, C("scrollbarShadow", "Scrollbar shadow to indicate that the view is scrolled.")), t6 = B("scrollbarSlider.background", {
        dark: le.fromHex("#797979").transparent(0.4),
        light: le.fromHex("#646464").transparent(0.4),
        hcDark: rt(Et, 0.6),
        hcLight: rt(Et, 0.4)
      }, C("scrollbarSliderBackground", "Scrollbar slider background color.")), i6 = B("scrollbarSlider.hoverBackground", {
        dark: le.fromHex("#646464").transparent(0.7),
        light: le.fromHex("#646464").transparent(0.7),
        hcDark: rt(Et, 0.8),
        hcLight: rt(Et, 0.8)
      }, C("scrollbarSliderHoverBackground", "Scrollbar slider background color when hovering.")), n6 = B("scrollbarSlider.activeBackground", {
        dark: le.fromHex("#BFBFBF").transparent(0.4),
        light: le.fromHex("#000000").transparent(0.6),
        hcDark: Et,
        hcLight: Et
      }, C("scrollbarSliderActiveBackground", "Scrollbar slider background color when clicked on.")), RZ = B("progressBar.background", {
        dark: le.fromHex("#0E70C0"),
        light: le.fromHex("#0E70C0"),
        hcDark: Et,
        hcLight: Et
      }, C("progressBarBackground", "Background color of the progress bar that can show for long running operations.")), qr = B("editor.background", {
        light: "#ffffff",
        dark: "#1E1E1E",
        hcDark: le.black,
        hcLight: le.white
      }, C("editorBackground", "Editor background color.")), G_ = B("editor.foreground", {
        light: "#333333",
        dark: "#BBBBBB",
        hcDark: le.white,
        hcLight: $t
      }, C("editorForeground", "Editor default foreground color."));
      B("editorStickyScroll.background", qr, C("editorStickyScrollBackground", "Background color of sticky scroll in the editor"));
      B("editorStickyScrollHover.background", {
        dark: "#2A2D2E",
        light: "#F0F0F0",
        hcDark: null,
        hcLight: le.fromHex("#0F4A85").transparent(0.1)
      }, C("editorStickyScrollHoverBackground", "Background color of sticky scroll on hover in the editor"));
      B("editorStickyScroll.border", {
        dark: null,
        light: null,
        hcDark: Et,
        hcLight: Et
      }, C("editorStickyScrollBorder", "Border color of sticky scroll in the editor"));
      B("editorStickyScroll.shadow", NT, C("editorStickyScrollShadow", " Shadow color of sticky scroll in the editor"));
      const hr = B("editorWidget.background", {
        dark: "#252526",
        light: "#F3F3F3",
        hcDark: "#0C141F",
        hcLight: le.white
      }, C("editorWidgetBackground", "Background color of editor widgets, such as find/replace.")), lw = B("editorWidget.foreground", $t, C("editorWidgetForeground", "Foreground color of editor widgets, such as find/replace.")), s6 = B("editorWidget.border", {
        dark: "#454545",
        light: "#C8C8C8",
        hcDark: Et,
        hcLight: Et
      }, C("editorWidgetBorder", "Border color of editor widgets. The color is only used if the widget chooses to have a border and if the color is not overridden by a widget."));
      B("editorWidget.resizeBorder", null, C("editorWidgetResizeBorder", "Border color of the resize bar of editor widgets. The color is only used if the widget chooses to have a resize border and if the color is not overridden by a widget."));
      B("editorError.background", null, C("editorError.background", "Background color of error text in the editor. The color must not be opaque so as not to hide underlying decorations."), true);
      const IT = B("editorError.foreground", {
        dark: "#F14C4C",
        light: "#E51400",
        hcDark: "#F48771",
        hcLight: "#B5200D"
      }, C("editorError.foreground", "Foreground color of error squigglies in the editor."));
      B("editorError.border", {
        dark: null,
        light: null,
        hcDark: le.fromHex("#E47777").transparent(0.8),
        hcLight: "#B5200D"
      }, C("errorBorder", "If set, color of double underlines for errors in the editor."));
      const OZ = B("editorWarning.background", null, C("editorWarning.background", "Background color of warning text in the editor. The color must not be opaque so as not to hide underlying decorations."), true), au = B("editorWarning.foreground", {
        dark: "#CCA700",
        light: "#BF8803",
        hcDark: "#FFD370",
        hcLight: "#895503"
      }, C("editorWarning.foreground", "Foreground color of warning squigglies in the editor.")), wv = B("editorWarning.border", {
        dark: null,
        light: null,
        hcDark: le.fromHex("#FFCC00").transparent(0.8),
        hcLight: le.fromHex("#FFCC00").transparent(0.8)
      }, C("warningBorder", "If set, color of double underlines for warnings in the editor."));
      B("editorInfo.background", null, C("editorInfo.background", "Background color of info text in the editor. The color must not be opaque so as not to hide underlying decorations."), true);
      const Bh = B("editorInfo.foreground", {
        dark: "#3794FF",
        light: "#1a85ff",
        hcDark: "#3794FF",
        hcLight: "#1a85ff"
      }, C("editorInfo.foreground", "Foreground color of info squigglies in the editor.")), yv = B("editorInfo.border", {
        dark: null,
        light: null,
        hcDark: le.fromHex("#3794FF").transparent(0.8),
        hcLight: "#292929"
      }, C("infoBorder", "If set, color of double underlines for infos in the editor.")), PZ = B("editorHint.foreground", {
        dark: le.fromHex("#eeeeee").transparent(0.7),
        light: "#6c6c6c",
        hcDark: null,
        hcLight: null
      }, C("editorHint.foreground", "Foreground color of hint squigglies in the editor."));
      B("editorHint.border", {
        dark: null,
        light: null,
        hcDark: le.fromHex("#eeeeee").transparent(0.8),
        hcLight: "#292929"
      }, C("hintBorder", "If set, color of double underlines for hints in the editor."));
      B("editorLink.activeForeground", {
        dark: "#4E94CE",
        light: le.blue,
        hcDark: le.cyan,
        hcLight: "#292929"
      }, C("activeLinkForeground", "Color of active links."));
      const mf = B("editor.selectionBackground", {
        light: "#ADD6FF",
        dark: "#264F78",
        hcDark: "#f3f518",
        hcLight: "#0F4A85"
      }, C("editorSelectionBackground", "Color of the editor selection.")), BZ = B("editor.selectionForeground", {
        light: null,
        dark: null,
        hcDark: "#000000",
        hcLight: le.white
      }, C("editorSelectionForeground", "Color of the selected text for high contrast.")), o6 = B("editor.inactiveSelectionBackground", {
        light: rt(mf, 0.5),
        dark: rt(mf, 0.5),
        hcDark: rt(mf, 0.7),
        hcLight: rt(mf, 0.5)
      }, C("editorInactiveSelection", "Color of the selection in an inactive editor. The color must not be opaque so as not to hide underlying decorations."), true), r6 = B("editor.selectionHighlightBackground", {
        light: v5(mf, qr, 0.3, 0.6),
        dark: v5(mf, qr, 0.3, 0.6),
        hcDark: null,
        hcLight: null
      }, C("editorSelectionHighlight", "Color for regions with the same content as the selection. The color must not be opaque so as not to hide underlying decorations."), true);
      B("editor.selectionHighlightBorder", {
        light: null,
        dark: null,
        hcDark: Ai,
        hcLight: Ai
      }, C("editorSelectionHighlightBorder", "Border color for regions with the same content as the selection."));
      B("editor.findMatchBackground", {
        light: "#A8AC94",
        dark: "#515C6A",
        hcDark: null,
        hcLight: null
      }, C("editorFindMatch", "Color of the current search match."));
      B("editor.findMatchForeground", null, C("editorFindMatchForeground", "Text color of the current search match."));
      const zc = B("editor.findMatchHighlightBackground", {
        light: "#EA5C0055",
        dark: "#EA5C0055",
        hcDark: null,
        hcLight: null
      }, C("findMatchHighlight", "Color of the other search matches. The color must not be opaque so as not to hide underlying decorations."), true);
      B("editor.findMatchHighlightForeground", null, C("findMatchHighlightForeground", "Foreground color of the other search matches."), true);
      B("editor.findRangeHighlightBackground", {
        dark: "#3a3d4166",
        light: "#b4b4b44d",
        hcDark: null,
        hcLight: null
      }, C("findRangeHighlight", "Color of the range limiting the search. The color must not be opaque so as not to hide underlying decorations."), true);
      B("editor.findMatchBorder", {
        light: null,
        dark: null,
        hcDark: Ai,
        hcLight: Ai
      }, C("editorFindMatchBorder", "Border color of the current search match."));
      const pf = B("editor.findMatchHighlightBorder", {
        light: null,
        dark: null,
        hcDark: Ai,
        hcLight: Ai
      }, C("findMatchHighlightBorder", "Border color of the other search matches."));
      B("editor.findRangeHighlightBorder", {
        dark: null,
        light: null,
        hcDark: rt(Ai, 0.4),
        hcLight: rt(Ai, 0.4)
      }, C("findRangeHighlightBorder", "Border color of the range limiting the search. The color must not be opaque so as not to hide underlying decorations."), true);
      B("editor.hoverHighlightBackground", {
        light: "#ADD6FF26",
        dark: "#264f7840",
        hcDark: "#ADD6FF26",
        hcLight: null
      }, C("hoverHighlight", "Highlight below the word for which a hover is shown. The color must not be opaque so as not to hide underlying decorations."), true);
      const w5 = B("editorHoverWidget.background", hr, C("hoverBackground", "Background color of the editor hover."));
      B("editorHoverWidget.foreground", lw, C("hoverForeground", "Foreground color of the editor hover."));
      const FZ = B("editorHoverWidget.border", s6, C("hoverBorder", "Border color of the editor hover."));
      B("editorHoverWidget.statusBarBackground", {
        dark: zr(w5, 0.2),
        light: ed(w5, 0.05),
        hcDark: hr,
        hcLight: hr
      }, C("statusBarBackground", "Background color of the editor hover status bar."));
      const a6 = B("editorInlayHint.foreground", {
        dark: "#969696",
        light: "#969696",
        hcDark: le.white,
        hcLight: le.black
      }, C("editorInlayHintForeground", "Foreground color of inline hints")), l6 = B("editorInlayHint.background", {
        dark: rt(x0, 0.1),
        light: rt(x0, 0.1),
        hcDark: rt(le.white, 0.1),
        hcLight: rt(x0, 0.1)
      }, C("editorInlayHintBackground", "Background color of inline hints"));
      B("editorInlayHint.typeForeground", a6, C("editorInlayHintForegroundTypes", "Foreground color of inline hints for types"));
      B("editorInlayHint.typeBackground", l6, C("editorInlayHintBackgroundTypes", "Background color of inline hints for types"));
      B("editorInlayHint.parameterForeground", a6, C("editorInlayHintForegroundParameter", "Foreground color of inline hints for parameters"));
      B("editorInlayHint.parameterBackground", l6, C("editorInlayHintBackgroundParameter", "Background color of inline hints for parameters"));
      const VZ = B("editorLightBulb.foreground", {
        dark: "#FFCC00",
        light: "#DDB100",
        hcDark: "#FFCC00",
        hcLight: "#007ACC"
      }, C("editorLightBulbForeground", "The color used for the lightbulb actions icon."));
      B("editorLightBulbAutoFix.foreground", {
        dark: "#75BEFF",
        light: "#007ACC",
        hcDark: "#75BEFF",
        hcLight: "#007ACC"
      }, C("editorLightBulbAutoFixForeground", "The color used for the lightbulb auto fix actions icon."));
      B("editorLightBulbAi.foreground", VZ, C("editorLightBulbAiForeground", "The color used for the lightbulb AI icon."));
      B("editor.snippetTabstopHighlightBackground", {
        dark: new le(new yt(124, 124, 124, 0.3)),
        light: new le(new yt(10, 50, 100, 0.2)),
        hcDark: new le(new yt(124, 124, 124, 0.3)),
        hcLight: new le(new yt(10, 50, 100, 0.2))
      }, C("snippetTabstopHighlightBackground", "Highlight background color of a snippet tabstop."));
      B("editor.snippetTabstopHighlightBorder", null, C("snippetTabstopHighlightBorder", "Highlight border color of a snippet tabstop."));
      B("editor.snippetFinalTabstopHighlightBackground", null, C("snippetFinalTabstopHighlightBackground", "Highlight background color of the final tabstop of a snippet."));
      B("editor.snippetFinalTabstopHighlightBorder", {
        dark: "#525252",
        light: new le(new yt(10, 50, 100, 0.5)),
        hcDark: "#525252",
        hcLight: "#292929"
      }, C("snippetFinalTabstopHighlightBorder", "Highlight border color of the final tabstop of a snippet."));
      const _D = new le(new yt(155, 185, 85, 0.2)), bD = new le(new yt(255, 0, 0, 0.2)), WZ = B("diffEditor.insertedTextBackground", {
        dark: "#9ccc2c33",
        light: "#9ccc2c40",
        hcDark: null,
        hcLight: null
      }, C("diffEditorInserted", "Background color for text that got inserted. The color must not be opaque so as not to hide underlying decorations."), true), HZ = B("diffEditor.removedTextBackground", {
        dark: "#ff000033",
        light: "#ff000033",
        hcDark: null,
        hcLight: null
      }, C("diffEditorRemoved", "Background color for text that got removed. The color must not be opaque so as not to hide underlying decorations."), true);
      B("diffEditor.insertedLineBackground", {
        dark: _D,
        light: _D,
        hcDark: null,
        hcLight: null
      }, C("diffEditorInsertedLines", "Background color for lines that got inserted. The color must not be opaque so as not to hide underlying decorations."), true);
      B("diffEditor.removedLineBackground", {
        dark: bD,
        light: bD,
        hcDark: null,
        hcLight: null
      }, C("diffEditorRemovedLines", "Background color for lines that got removed. The color must not be opaque so as not to hide underlying decorations."), true);
      B("diffEditorGutter.insertedLineBackground", null, C("diffEditorInsertedLineGutter", "Background color for the margin where lines got inserted."));
      B("diffEditorGutter.removedLineBackground", null, C("diffEditorRemovedLineGutter", "Background color for the margin where lines got removed."));
      const zZ = B("diffEditorOverview.insertedForeground", null, C("diffEditorOverviewInserted", "Diff overview ruler foreground for inserted content.")), UZ = B("diffEditorOverview.removedForeground", null, C("diffEditorOverviewRemoved", "Diff overview ruler foreground for removed content."));
      B("diffEditor.insertedTextBorder", {
        dark: null,
        light: null,
        hcDark: "#33ff2eff",
        hcLight: "#374E06"
      }, C("diffEditorInsertedOutline", "Outline color for the text that got inserted."));
      B("diffEditor.removedTextBorder", {
        dark: null,
        light: null,
        hcDark: "#FF008F",
        hcLight: "#AD0707"
      }, C("diffEditorRemovedOutline", "Outline color for text that got removed."));
      B("diffEditor.border", {
        dark: null,
        light: null,
        hcDark: Et,
        hcLight: Et
      }, C("diffEditorBorder", "Border color between the two text editors."));
      B("diffEditor.diagonalFill", {
        dark: "#cccccc33",
        light: "#22222233",
        hcDark: null,
        hcLight: null
      }, C("diffDiagonalFill", "Color of the diff editor's diagonal fill. The diagonal fill is used in side-by-side diff views."));
      B("diffEditor.unchangedRegionBackground", "sideBar.background", C("diffEditor.unchangedRegionBackground", "The background color of unchanged blocks in the diff editor."));
      B("diffEditor.unchangedRegionForeground", "foreground", C("diffEditor.unchangedRegionForeground", "The foreground color of unchanged blocks in the diff editor."));
      B("diffEditor.unchangedCodeBackground", {
        dark: "#74747429",
        light: "#b8b8b829",
        hcDark: null,
        hcLight: null
      }, C("diffEditor.unchangedCodeBackground", "The background color of unchanged code in the diff editor."));
      const Y_ = B("widget.shadow", {
        dark: rt(le.black, 0.36),
        light: rt(le.black, 0.16),
        hcDark: null,
        hcLight: null
      }, C("widgetShadow", "Shadow color of widgets such as find/replace inside the editor.")), $Z = B("widget.border", {
        dark: null,
        light: null,
        hcDark: Et,
        hcLight: Et
      }, C("widgetBorder", "Border color of widgets such as find/replace inside the editor.")), y5 = B("toolbar.hoverBackground", {
        dark: "#5a5d5e50",
        light: "#b8b8b850",
        hcDark: null,
        hcLight: null
      }, C("toolbarHoverBackground", "Toolbar background when hovering over actions using the mouse"));
      B("toolbar.hoverOutline", {
        dark: null,
        light: null,
        hcDark: Ai,
        hcLight: Ai
      }, C("toolbarHoverOutline", "Toolbar outline when hovering over actions using the mouse"));
      B("toolbar.activeBackground", {
        dark: zr(y5, 0.1),
        light: ed(y5, 0.1),
        hcDark: null,
        hcLight: null
      }, C("toolbarActiveBackground", "Toolbar background when holding the mouse over actions"));
      const qZ = B("breadcrumb.foreground", rt($t, 0.8), C("breadcrumbsFocusForeground", "Color of focused breadcrumb items.")), KZ = B("breadcrumb.background", qr, C("breadcrumbsBackground", "Background color of breadcrumb items.")), S5 = B("breadcrumb.focusForeground", {
        light: ed($t, 0.2),
        dark: zr($t, 0.1),
        hcDark: zr($t, 0.1),
        hcLight: zr($t, 0.1)
      }, C("breadcrumbsFocusForeground", "Color of focused breadcrumb items.")), jZ = B("breadcrumb.activeSelectionForeground", {
        light: ed($t, 0.2),
        dark: zr($t, 0.1),
        hcDark: zr($t, 0.1),
        hcLight: zr($t, 0.1)
      }, C("breadcrumbsSelectedForeground", "Color of selected breadcrumb items."));
      B("breadcrumbPicker.background", hr, C("breadcrumbsSelectedBackground", "Background color of breadcrumb item picker."));
      const c6 = 0.5, L5 = le.fromHex("#40C8AE").transparent(c6), x5 = le.fromHex("#40A6FF").transparent(c6), k5 = le.fromHex("#606060").transparent(0.4), MT = 0.4, ug = 1, vD = B("merge.currentHeaderBackground", {
        dark: L5,
        light: L5,
        hcDark: null,
        hcLight: null
      }, C("mergeCurrentHeaderBackground", "Current header background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations."), true);
      B("merge.currentContentBackground", rt(vD, MT), C("mergeCurrentContentBackground", "Current content background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations."), true);
      const CD = B("merge.incomingHeaderBackground", {
        dark: x5,
        light: x5,
        hcDark: null,
        hcLight: null
      }, C("mergeIncomingHeaderBackground", "Incoming header background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations."), true);
      B("merge.incomingContentBackground", rt(CD, MT), C("mergeIncomingContentBackground", "Incoming content background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations."), true);
      const wD = B("merge.commonHeaderBackground", {
        dark: k5,
        light: k5,
        hcDark: null,
        hcLight: null
      }, C("mergeCommonHeaderBackground", "Common ancestor header background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations."), true);
      B("merge.commonContentBackground", rt(wD, MT), C("mergeCommonContentBackground", "Common ancestor content background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations."), true);
      const hg = B("merge.border", {
        dark: null,
        light: null,
        hcDark: "#C3DF6F",
        hcLight: "#007ACC"
      }, C("mergeBorder", "Border color on headers and the splitter in inline merge-conflicts."));
      B("editorOverviewRuler.currentContentForeground", {
        dark: rt(vD, ug),
        light: rt(vD, ug),
        hcDark: hg,
        hcLight: hg
      }, C("overviewRulerCurrentContentForeground", "Current overview ruler foreground for inline merge-conflicts."));
      B("editorOverviewRuler.incomingContentForeground", {
        dark: rt(CD, ug),
        light: rt(CD, ug),
        hcDark: hg,
        hcLight: hg
      }, C("overviewRulerIncomingContentForeground", "Incoming overview ruler foreground for inline merge-conflicts."));
      B("editorOverviewRuler.commonContentForeground", {
        dark: rt(wD, ug),
        light: rt(wD, ug),
        hcDark: hg,
        hcLight: hg
      }, C("overviewRulerCommonContentForeground", "Common ancestor overview ruler foreground for inline merge-conflicts."));
      B("editorOverviewRuler.findMatchForeground", {
        dark: "#d186167e",
        light: "#d186167e",
        hcDark: "#AB5A00",
        hcLight: "#AB5A00"
      }, C("overviewRulerFindMatchForeground", "Overview ruler marker color for find matches. The color must not be opaque so as not to hide underlying decorations."), true);
      B("editorOverviewRuler.selectionHighlightForeground", "#A0A0A0CC", C("overviewRulerSelectionHighlightForeground", "Overview ruler marker color for selection highlights. The color must not be opaque so as not to hide underlying decorations."), true);
      const GZ = B("problemsErrorIcon.foreground", IT, C("problemsErrorIconForeground", "The color used for the problems error icon.")), YZ = B("problemsWarningIcon.foreground", au, C("problemsWarningIconForeground", "The color used for the problems warning icon.")), ZZ = B("problemsInfoIcon.foreground", Bh, C("problemsInfoIconForeground", "The color used for the problems info icon.")), QZ = B("minimap.findMatchHighlight", {
        light: "#d18616",
        dark: "#d18616",
        hcDark: "#AB5A00",
        hcLight: "#0F4A85"
      }, C("minimapFindMatchHighlight", "Minimap marker color for find matches."), true);
      B("minimap.selectionOccurrenceHighlight", {
        light: "#c9c9c9",
        dark: "#676767",
        hcDark: "#ffffff",
        hcLight: "#0F4A85"
      }, C("minimapSelectionOccurrenceHighlight", "Minimap marker color for repeating editor selections."), true);
      const D5 = B("minimap.selectionHighlight", {
        light: "#ADD6FF",
        dark: "#264F78",
        hcDark: "#ffffff",
        hcLight: "#0F4A85"
      }, C("minimapSelectionHighlight", "Minimap marker color for the editor selection."), true), XZ = B("minimap.infoHighlight", {
        dark: Bh,
        light: Bh,
        hcDark: yv,
        hcLight: yv
      }, C("minimapInfo", "Minimap marker color for infos.")), JZ = B("minimap.warningHighlight", {
        dark: au,
        light: au,
        hcDark: wv,
        hcLight: wv
      }, C("overviewRuleWarning", "Minimap marker color for warnings.")), eQ = B("minimap.errorHighlight", {
        dark: new le(new yt(255, 18, 18, 0.7)),
        light: new le(new yt(255, 18, 18, 0.7)),
        hcDark: new le(new yt(255, 50, 50, 1)),
        hcLight: "#B5200D"
      }, C("minimapError", "Minimap marker color for errors.")), tQ = B("minimap.background", null, C("minimapBackground", "Minimap background color.")), iQ = B("minimap.foregroundOpacity", le.fromHex("#000f"), C("minimapForegroundOpacity", 'Opacity of foreground elements rendered in the minimap. For example, "#000000c0" will render the elements with 75% opacity.'));
      B("minimapSlider.background", rt(t6, 0.5), C("minimapSliderBackground", "Minimap slider background color."));
      B("minimapSlider.hoverBackground", rt(i6, 0.5), C("minimapSliderHoverBackground", "Minimap slider background color when hovering."));
      B("minimapSlider.activeBackground", rt(n6, 0.5), C("minimapSliderActiveBackground", "Minimap slider background color when clicked on."));
      B("charts.foreground", $t, C("chartsForeground", "The foreground color used in charts."));
      B("charts.lines", rt($t, 0.5), C("chartsLines", "The color used for horizontal lines in charts."));
      B("charts.red", IT, C("chartsRed", "The red color used in chart visualizations."));
      B("charts.blue", Bh, C("chartsBlue", "The blue color used in chart visualizations."));
      B("charts.yellow", au, C("chartsYellow", "The yellow color used in chart visualizations."));
      B("charts.orange", QZ, C("chartsOrange", "The orange color used in chart visualizations."));
      B("charts.green", {
        dark: "#89D185",
        light: "#388A34",
        hcDark: "#89D185",
        hcLight: "#374e06"
      }, C("chartsGreen", "The green color used in chart visualizations."));
      B("charts.purple", {
        dark: "#B180D7",
        light: "#652D90",
        hcDark: "#B180D7",
        hcLight: "#652D90"
      }, C("chartsPurple", "The purple color used in chart visualizations."));
      const nQ = B("input.background", {
        dark: "#3C3C3C",
        light: le.white,
        hcDark: le.black,
        hcLight: le.white
      }, C("inputBoxBackground", "Input box background.")), sQ = B("input.foreground", $t, C("inputBoxForeground", "Input box foreground.")), oQ = B("input.border", {
        dark: null,
        light: null,
        hcDark: Et,
        hcLight: Et
      }, C("inputBoxBorder", "Input box border.")), u6 = B("inputOption.activeBorder", {
        dark: "#007ACC",
        light: "#007ACC",
        hcDark: Et,
        hcLight: Et
      }, C("inputBoxActiveOptionBorder", "Border color of activated options in input fields.")), rQ = B("inputOption.hoverBackground", {
        dark: "#5a5d5e80",
        light: "#b8b8b850",
        hcDark: null,
        hcLight: null
      }, C("inputOption.hoverBackground", "Background color of activated options in input fields.")), h6 = B("inputOption.activeBackground", {
        dark: rt(Na, 0.4),
        light: rt(Na, 0.2),
        hcDark: le.transparent,
        hcLight: le.transparent
      }, C("inputOption.activeBackground", "Background hover color of options in input fields.")), d6 = B("inputOption.activeForeground", {
        dark: le.white,
        light: le.black,
        hcDark: $t,
        hcLight: $t
      }, C("inputOption.activeForeground", "Foreground color of activated options in input fields."));
      B("input.placeholderForeground", {
        light: rt($t, 0.5),
        dark: rt($t, 0.5),
        hcDark: rt($t, 0.7),
        hcLight: rt($t, 0.7)
      }, C("inputPlaceholderForeground", "Input box foreground color for placeholder text."));
      const aQ = B("inputValidation.infoBackground", {
        dark: "#063B49",
        light: "#D6ECF2",
        hcDark: le.black,
        hcLight: le.white
      }, C("inputValidationInfoBackground", "Input validation background color for information severity.")), lQ = B("inputValidation.infoForeground", {
        dark: null,
        light: null,
        hcDark: null,
        hcLight: $t
      }, C("inputValidationInfoForeground", "Input validation foreground color for information severity.")), cQ = B("inputValidation.infoBorder", {
        dark: "#007acc",
        light: "#007acc",
        hcDark: Et,
        hcLight: Et
      }, C("inputValidationInfoBorder", "Input validation border color for information severity.")), uQ = B("inputValidation.warningBackground", {
        dark: "#352A05",
        light: "#F6F5D2",
        hcDark: le.black,
        hcLight: le.white
      }, C("inputValidationWarningBackground", "Input validation background color for warning severity.")), hQ = B("inputValidation.warningForeground", {
        dark: null,
        light: null,
        hcDark: null,
        hcLight: $t
      }, C("inputValidationWarningForeground", "Input validation foreground color for warning severity.")), dQ = B("inputValidation.warningBorder", {
        dark: "#B89500",
        light: "#B89500",
        hcDark: Et,
        hcLight: Et
      }, C("inputValidationWarningBorder", "Input validation border color for warning severity.")), fQ = B("inputValidation.errorBackground", {
        dark: "#5A1D1D",
        light: "#F2DEDE",
        hcDark: le.black,
        hcLight: le.white
      }, C("inputValidationErrorBackground", "Input validation background color for error severity.")), gQ = B("inputValidation.errorForeground", {
        dark: null,
        light: null,
        hcDark: null,
        hcLight: $t
      }, C("inputValidationErrorForeground", "Input validation foreground color for error severity.")), mQ = B("inputValidation.errorBorder", {
        dark: "#BE1100",
        light: "#BE1100",
        hcDark: Et,
        hcLight: Et
      }, C("inputValidationErrorBorder", "Input validation border color for error severity.")), cw = B("dropdown.background", {
        dark: "#3C3C3C",
        light: le.white,
        hcDark: le.black,
        hcLight: le.white
      }, C("dropdownBackground", "Dropdown background.")), pQ = B("dropdown.listBackground", {
        dark: null,
        light: null,
        hcDark: le.black,
        hcLight: le.white
      }, C("dropdownListBackground", "Dropdown list background.")), AT = B("dropdown.foreground", {
        dark: "#F0F0F0",
        light: $t,
        hcDark: le.white,
        hcLight: $t
      }, C("dropdownForeground", "Dropdown foreground.")), RT = B("dropdown.border", {
        dark: cw,
        light: "#CECECE",
        hcDark: Et,
        hcLight: Et
      }, C("dropdownBorder", "Dropdown border.")), f6 = B("button.foreground", le.white, C("buttonForeground", "Button foreground color.")), _Q = B("button.separator", rt(f6, 0.4), C("buttonSeparator", "Button separator color.")), ip = B("button.background", {
        dark: "#0E639C",
        light: "#007ACC",
        hcDark: null,
        hcLight: "#0F4A85"
      }, C("buttonBackground", "Button background color.")), bQ = B("button.hoverBackground", {
        dark: zr(ip, 0.2),
        light: ed(ip, 0.2),
        hcDark: ip,
        hcLight: ip
      }, C("buttonHoverBackground", "Button background color when hovering.")), vQ = B("button.border", Et, C("buttonBorder", "Button border color.")), CQ = B("button.secondaryForeground", {
        dark: le.white,
        light: le.white,
        hcDark: le.white,
        hcLight: $t
      }, C("buttonSecondaryForeground", "Secondary button foreground color.")), yD = B("button.secondaryBackground", {
        dark: "#3A3D41",
        light: "#5F6A79",
        hcDark: null,
        hcLight: le.white
      }, C("buttonSecondaryBackground", "Secondary button background color.")), wQ = B("button.secondaryHoverBackground", {
        dark: zr(yD, 0.2),
        light: ed(yD, 0.2),
        hcDark: null,
        hcLight: null
      }, C("buttonSecondaryHoverBackground", "Secondary button background color when hovering.")), np = B("radio.activeForeground", d6, C("radioActiveForeground", "Foreground color of active radio option.")), yQ = B("radio.activeBackground", h6, C("radioBackground", "Background color of active radio option.")), SQ = B("radio.activeBorder", u6, C("radioActiveBorder", "Border color of the active radio option.")), LQ = B("radio.inactiveForeground", null, C("radioInactiveForeground", "Foreground color of inactive radio option.")), xQ = B("radio.inactiveBackground", null, C("radioInactiveBackground", "Background color of inactive radio option.")), kQ = B("radio.inactiveBorder", {
        light: rt(np, 0.2),
        dark: rt(np, 0.2),
        hcDark: rt(np, 0.4),
        hcLight: rt(np, 0.2)
      }, C("radioInactiveBorder", "Border color of the inactive radio option.")), DQ = B("radio.inactiveHoverBackground", rQ, C("radioHoverBackground", "Background color of inactive active radio option when hovering.")), EQ = B("checkbox.background", cw, C("checkbox.background", "Background color of checkbox widget."));
      B("checkbox.selectBackground", hr, C("checkbox.select.background", "Background color of checkbox widget when the element it's in is selected."));
      const TQ = B("checkbox.foreground", AT, C("checkbox.foreground", "Foreground color of checkbox widget.")), NQ = B("checkbox.border", RT, C("checkbox.border", "Border color of checkbox widget."));
      B("checkbox.selectBorder", pD, C("checkbox.select.border", "Border color of checkbox widget when the element it's in is selected."));
      const IQ = B("keybindingLabel.background", {
        dark: new le(new yt(128, 128, 128, 0.17)),
        light: new le(new yt(221, 221, 221, 0.4)),
        hcDark: le.transparent,
        hcLight: le.transparent
      }, C("keybindingLabelBackground", "Keybinding label background color. The keybinding label is used to represent a keyboard shortcut.")), MQ = B("keybindingLabel.foreground", {
        dark: le.fromHex("#CCCCCC"),
        light: le.fromHex("#555555"),
        hcDark: le.white,
        hcLight: $t
      }, C("keybindingLabelForeground", "Keybinding label foreground color. The keybinding label is used to represent a keyboard shortcut.")), AQ = B("keybindingLabel.border", {
        dark: new le(new yt(51, 51, 51, 0.6)),
        light: new le(new yt(204, 204, 204, 0.4)),
        hcDark: new le(new yt(111, 195, 223)),
        hcLight: Et
      }, C("keybindingLabelBorder", "Keybinding label border color. The keybinding label is used to represent a keyboard shortcut.")), RQ = B("keybindingLabel.bottomBorder", {
        dark: new le(new yt(68, 68, 68, 0.6)),
        light: new le(new yt(187, 187, 187, 0.4)),
        hcDark: new le(new yt(111, 195, 223)),
        hcLight: $t
      }, C("keybindingLabelBottomBorder", "Keybinding label border bottom color. The keybinding label is used to represent a keyboard shortcut.")), OQ = B("list.focusBackground", null, C("listFocusBackground", "List/Tree background color for the focused item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.")), PQ = B("list.focusForeground", null, C("listFocusForeground", "List/Tree foreground color for the focused item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.")), BQ = B("list.focusOutline", {
        dark: Na,
        light: Na,
        hcDark: Ai,
        hcLight: Ai
      }, C("listFocusOutline", "List/Tree outline color for the focused item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.")), FQ = B("list.focusAndSelectionOutline", null, C("listFocusAndSelectionOutline", "List/Tree outline color for the focused item when the list/tree is active and selected. An active list/tree has keyboard focus, an inactive does not.")), Fh = B("list.activeSelectionBackground", {
        dark: "#04395E",
        light: "#0060C0",
        hcDark: null,
        hcLight: le.fromHex("#0F4A85").transparent(0.1)
      }, C("listActiveSelectionBackground", "List/Tree background color for the selected item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.")), s_ = B("list.activeSelectionForeground", {
        dark: le.white,
        light: le.white,
        hcDark: null,
        hcLight: null
      }, C("listActiveSelectionForeground", "List/Tree foreground color for the selected item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.")), g6 = B("list.activeSelectionIconForeground", null, C("listActiveSelectionIconForeground", "List/Tree icon foreground color for the selected item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.")), VQ = B("list.inactiveSelectionBackground", {
        dark: "#37373D",
        light: "#E4E6F1",
        hcDark: null,
        hcLight: le.fromHex("#0F4A85").transparent(0.1)
      }, C("listInactiveSelectionBackground", "List/Tree background color for the selected item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not.")), WQ = B("list.inactiveSelectionForeground", null, C("listInactiveSelectionForeground", "List/Tree foreground color for the selected item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not.")), HQ = B("list.inactiveSelectionIconForeground", null, C("listInactiveSelectionIconForeground", "List/Tree icon foreground color for the selected item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not.")), zQ = B("list.inactiveFocusBackground", null, C("listInactiveFocusBackground", "List/Tree background color for the focused item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not.")), UQ = B("list.inactiveFocusOutline", null, C("listInactiveFocusOutline", "List/Tree outline color for the focused item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not.")), m6 = B("list.hoverBackground", {
        dark: "#2A2D2E",
        light: "#F0F0F0",
        hcDark: le.white.transparent(0.1),
        hcLight: le.fromHex("#0F4A85").transparent(0.1)
      }, C("listHoverBackground", "List/Tree background when hovering over items using the mouse.")), p6 = B("list.hoverForeground", null, C("listHoverForeground", "List/Tree foreground when hovering over items using the mouse.")), $Q = B("list.dropBackground", {
        dark: "#062F4A",
        light: "#D6EBFF",
        hcDark: null,
        hcLight: null
      }, C("listDropBackground", "List/Tree drag and drop background when moving items over other items when using the mouse.")), qQ = B("list.dropBetweenBackground", {
        dark: pD,
        light: pD,
        hcDark: null,
        hcLight: null
      }, C("listDropBetweenBackground", "List/Tree drag and drop border color when moving items between items when using the mouse.")), Ob = B("list.highlightForeground", {
        dark: "#2AAAFF",
        light: "#0066BF",
        hcDark: Na,
        hcLight: Na
      }, C("highlight", "List/Tree foreground color of the match highlights when searching inside the list/tree."));
      B("list.focusHighlightForeground", {
        dark: Ob,
        light: IZ(Fh, Ob, "#BBE7FF"),
        hcDark: Ob,
        hcLight: Ob
      }, C("listFocusHighlightForeground", "List/Tree foreground color of the match highlights on actively focused items when searching inside the list/tree."));
      B("list.invalidItemForeground", {
        dark: "#B89500",
        light: "#B89500",
        hcDark: "#B89500",
        hcLight: "#B5200D"
      }, C("invalidItemForeground", "List/Tree foreground color for invalid items, for example an unresolved root in explorer."));
      B("list.errorForeground", {
        dark: "#F88070",
        light: "#B01011",
        hcDark: null,
        hcLight: null
      }, C("listErrorForeground", "Foreground color of list items containing errors."));
      B("list.warningForeground", {
        dark: "#CCA700",
        light: "#855F00",
        hcDark: null,
        hcLight: null
      }, C("listWarningForeground", "Foreground color of list items containing warnings."));
      const KQ = B("listFilterWidget.background", {
        light: ed(hr, 0),
        dark: zr(hr, 0),
        hcDark: hr,
        hcLight: hr
      }, C("listFilterWidgetBackground", "Background color of the type filter widget in lists and trees.")), jQ = B("listFilterWidget.outline", {
        dark: le.transparent,
        light: le.transparent,
        hcDark: "#f38518",
        hcLight: "#007ACC"
      }, C("listFilterWidgetOutline", "Outline color of the type filter widget in lists and trees.")), GQ = B("listFilterWidget.noMatchesOutline", {
        dark: "#BE1100",
        light: "#BE1100",
        hcDark: Et,
        hcLight: Et
      }, C("listFilterWidgetNoMatchesOutline", "Outline color of the type filter widget in lists and trees, when there are no matches.")), YQ = B("listFilterWidget.shadow", Y_, C("listFilterWidgetShadow", "Shadow color of the type filter widget in lists and trees."));
      B("list.filterMatchBackground", {
        dark: zc,
        light: zc,
        hcDark: null,
        hcLight: null
      }, C("listFilterMatchHighlight", "Background color of the filtered match."));
      B("list.filterMatchBorder", {
        dark: pf,
        light: pf,
        hcDark: Et,
        hcLight: Ai
      }, C("listFilterMatchHighlightBorder", "Border color of the filtered match."));
      B("list.deemphasizedForeground", {
        dark: "#8C8C8C",
        light: "#8E8E90",
        hcDark: "#A7A8A9",
        hcLight: "#666666"
      }, C("listDeemphasizedForeground", "List/Tree foreground color for items that are deemphasized."));
      const _6 = B("tree.indentGuidesStroke", {
        dark: "#585858",
        light: "#a9a9a9",
        hcDark: "#a9a9a9",
        hcLight: "#a5a5a5"
      }, C("treeIndentGuidesStroke", "Tree stroke color for the indentation guides.")), ZQ = B("tree.inactiveIndentGuidesStroke", rt(_6, 0.4), C("treeInactiveIndentGuidesStroke", "Tree stroke color for the indentation guides that are not active.")), QQ = B("tree.tableColumnsBorder", {
        dark: "#CCCCCC20",
        light: "#61616120",
        hcDark: null,
        hcLight: null
      }, C("tableColumnsBorder", "Table border color between columns.")), XQ = B("tree.tableOddRowsBackground", {
        dark: rt($t, 0.04),
        light: rt($t, 0.04),
        hcDark: null,
        hcLight: null
      }, C("tableOddRowsBackgroundColor", "Background color for odd table rows."));
      B("editorActionList.background", hr, C("editorActionListBackground", "Action List background color."));
      B("editorActionList.foreground", lw, C("editorActionListForeground", "Action List foreground color."));
      B("editorActionList.focusForeground", s_, C("editorActionListFocusForeground", "Action List foreground color for the focused item."));
      B("editorActionList.focusBackground", Fh, C("editorActionListFocusBackground", "Action List background color for the focused item."));
      const JQ = B("menu.border", {
        dark: null,
        light: null,
        hcDark: Et,
        hcLight: Et
      }, C("menuBorder", "Border color of menus.")), eX = B("menu.foreground", AT, C("menuForeground", "Foreground color of menu items.")), tX = B("menu.background", cw, C("menuBackground", "Background color of menu items.")), iX = B("menu.selectionForeground", s_, C("menuSelectionForeground", "Foreground color of the selected menu item in menus.")), nX = B("menu.selectionBackground", Fh, C("menuSelectionBackground", "Background color of the selected menu item in menus.")), sX = B("menu.selectionBorder", {
        dark: null,
        light: null,
        hcDark: Ai,
        hcLight: Ai
      }, C("menuSelectionBorder", "Border color of the selected menu item in menus.")), oX = B("menu.separatorBackground", {
        dark: "#606060",
        light: "#D4D4D4",
        hcDark: Et,
        hcLight: Et
      }, C("menuSeparatorBackground", "Color of a separator menu item in menus.")), E5 = B("quickInput.background", hr, C("pickerBackground", "Quick picker background color. The quick picker widget is the container for pickers like the command palette.")), rX = B("quickInput.foreground", lw, C("pickerForeground", "Quick picker foreground color. The quick picker widget is the container for pickers like the command palette.")), aX = B("quickInputTitle.background", {
        dark: new le(new yt(255, 255, 255, 0.105)),
        light: new le(new yt(0, 0, 0, 0.06)),
        hcDark: "#000000",
        hcLight: le.white
      }, C("pickerTitleBackground", "Quick picker title background color. The quick picker widget is the container for pickers like the command palette.")), b6 = B("pickerGroup.foreground", {
        dark: "#3794FF",
        light: "#0066BF",
        hcDark: le.white,
        hcLight: "#0F4A85"
      }, C("pickerGroupForeground", "Quick picker color for grouping labels.")), lX = B("pickerGroup.border", {
        dark: "#3F3F46",
        light: "#CCCEDB",
        hcDark: le.white,
        hcLight: "#0F4A85"
      }, C("pickerGroupBorder", "Quick picker color for grouping borders.")), T5 = B("quickInput.list.focusBackground", null, "", void 0, C("quickInput.list.focusBackground deprecation", "Please use quickInputList.focusBackground instead")), SD = B("quickInputList.focusForeground", s_, C("quickInput.listFocusForeground", "Quick picker foreground color for the focused item.")), v6 = B("quickInputList.focusIconForeground", g6, C("quickInput.listFocusIconForeground", "Quick picker icon foreground color for the focused item.")), LD = B("quickInputList.focusBackground", {
        dark: b5(T5, Fh),
        light: b5(T5, Fh),
        hcDark: null,
        hcLight: null
      }, C("quickInput.listFocusBackground", "Quick picker background color for the focused item."));
      B("search.resultsInfoForeground", {
        light: $t,
        dark: rt($t, 0.65),
        hcDark: $t,
        hcLight: $t
      }, C("search.resultsInfoForeground", "Color of the text in the search viewlet's completion message."));
      B("searchEditor.findMatchBackground", {
        light: rt(zc, 0.66),
        dark: rt(zc, 0.66),
        hcDark: zc,
        hcLight: zc
      }, C("searchEditor.queryMatch", "Color of the Search Editor query matches."));
      B("searchEditor.findMatchBorder", {
        light: rt(pf, 0.66),
        dark: rt(pf, 0.66),
        hcDark: pf,
        hcLight: pf
      }, C("searchEditor.editorFindMatchBorder", "Border color of the Search Editor query matches."));
      var cX = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      }, N5 = function(s, e) {
        return function(t, i) {
          e(t, i, s);
        };
      };
      const Z_ = pt("hoverService");
      let o_ = class extends he {
        get delay() {
          return this.isInstantlyHovering() ? 0 : this._delay;
        }
        constructor(e, t, i = {}, n, o) {
          super(), this.placement = e, this.instantHover = t, this.overrideOptions = i, this.configurationService = n, this.hoverService = o, this.lastHoverHideTime = 0, this.timeLimit = 200, this.hoverDisposables = this._register(new Me()), this._delay = this.configurationService.getValue("workbench.hover.delay"), this._register(this.configurationService.onDidChangeConfiguration((r) => {
            r.affectsConfiguration("workbench.hover.delay") && (this._delay = this.configurationService.getValue("workbench.hover.delay"));
          }));
        }
        showHover(e, t) {
          const i = typeof this.overrideOptions == "function" ? this.overrideOptions(e, t) : this.overrideOptions;
          this.hoverDisposables.clear();
          const n = wn(e.target) ? [
            e.target
          ] : e.target.targetElements;
          for (const r of n) this.hoverDisposables.add(ln(r, "keydown", (a) => {
            a.equals(9) && this.hoverService.hideHover();
          }));
          const o = wn(e.content) ? void 0 : e.content.toString();
          return this.hoverService.showHover({
            ...e,
            ...i,
            persistence: {
              hideOnKeyDown: true,
              ...i.persistence
            },
            id: o,
            appearance: {
              ...e.appearance,
              compact: true,
              skipFadeInAnimation: this.isInstantlyHovering(),
              ...i.appearance
            }
          }, t);
        }
        isInstantlyHovering() {
          return this.instantHover && Date.now() - this.lastHoverHideTime < this.timeLimit;
        }
        onDidHideHover() {
          this.hoverDisposables.clear(), this.instantHover && (this.lastHoverHideTime = Date.now());
        }
      };
      o_ = cX([
        N5(3, Si),
        N5(4, Z_)
      ], o_);
      const Q_ = pt("contextViewService"), Gl = pt("contextMenuService"), Pn = pt("keybindingService");
      class uw {
        constructor() {
          this._hooks = new Me(), this._pointerMoveCallback = null, this._onStopCallback = null;
        }
        dispose() {
          this.stopMonitoring(false), this._hooks.dispose();
        }
        stopMonitoring(e, t) {
          if (!this.isMonitoring()) return;
          this._hooks.clear(), this._pointerMoveCallback = null;
          const i = this._onStopCallback;
          this._onStopCallback = null, e && i && i(t);
        }
        isMonitoring() {
          return !!this._pointerMoveCallback;
        }
        startMonitoring(e, t, i, n, o) {
          this.isMonitoring() && this.stopMonitoring(false), this._pointerMoveCallback = n, this._onStopCallback = o;
          let r = e;
          try {
            e.setPointerCapture(t), this._hooks.add(Ze(() => {
              try {
                e.releasePointerCapture(t);
              } catch {
              }
            }));
          } catch {
            r = Oe(e);
          }
          this._hooks.add(re(r, Ce.POINTER_MOVE, (a) => {
            if (a.buttons !== i) {
              this.stopMonitoring(true);
              return;
            }
            a.preventDefault(), this._pointerMoveCallback(a);
          })), this._hooks.add(re(r, Ce.POINTER_UP, (a) => this.stopMonitoring(true)));
        }
      }
      function Li(s, e, t) {
        let i = null, n = null;
        if (typeof t.value == "function" ? (i = "value", n = t.value, n.length !== 0 && console.warn("Memoize should only be used in functions with zero parameters")) : typeof t.get == "function" && (i = "get", n = t.get), !n) throw new Error("not supported");
        const o = `$memoize$${e}`;
        t[i] = function(...r) {
          return this.hasOwnProperty(o) || Object.defineProperty(this, o, {
            configurable: false,
            enumerable: false,
            writable: false,
            value: n.apply(this, r)
          }), this[o];
        };
      }
      var uX = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      }, Qt;
      (function(s) {
        s.Tap = "-monaco-gesturetap", s.Change = "-monaco-gesturechange", s.Start = "-monaco-gesturestart", s.End = "-monaco-gesturesend", s.Contextmenu = "-monaco-gesturecontextmenu";
      })(Qt || (Qt = {}));
      const _ui = class _ui extends he {
        constructor() {
          super(), this.dispatched = false, this.targets = new Us(), this.ignoreTargets = new Us(), this.activeTouches = {}, this.handle = null, this._lastSetTapCountTime = 0, this._register(be.runAndSubscribe($C, ({ window: e, disposables: t }) => {
            t.add(re(e.document, "touchstart", (i) => this.onTouchStart(i), {
              passive: false
            })), t.add(re(e.document, "touchend", (i) => this.onTouchEnd(e, i))), t.add(re(e.document, "touchmove", (i) => this.onTouchMove(i), {
              passive: false
            }));
          }, {
            window: Kt,
            disposables: this._store
          }));
        }
        static addTarget(e) {
          if (!_ui.isTouchDevice()) return he.None;
          _ui.INSTANCE || (_ui.INSTANCE = new _ui());
          const t = _ui.INSTANCE.targets.push(e);
          return Ze(t);
        }
        static ignoreTarget(e) {
          if (!_ui.isTouchDevice()) return he.None;
          _ui.INSTANCE || (_ui.INSTANCE = new _ui());
          const t = _ui.INSTANCE.ignoreTargets.push(e);
          return Ze(t);
        }
        static isTouchDevice() {
          return "ontouchstart" in Kt || navigator.maxTouchPoints > 0;
        }
        dispose() {
          this.handle && (this.handle.dispose(), this.handle = null), super.dispose();
        }
        onTouchStart(e) {
          const t = Date.now();
          this.handle && (this.handle.dispose(), this.handle = null);
          for (let i = 0, n = e.targetTouches.length; i < n; i++) {
            const o = e.targetTouches.item(i);
            this.activeTouches[o.identifier] = {
              id: o.identifier,
              initialTarget: o.target,
              initialTimeStamp: t,
              initialPageX: o.pageX,
              initialPageY: o.pageY,
              rollingTimestamps: [
                t
              ],
              rollingPageX: [
                o.pageX
              ],
              rollingPageY: [
                o.pageY
              ]
            };
            const r = this.newGestureEvent(Qt.Start, o.target);
            r.pageX = o.pageX, r.pageY = o.pageY, this.dispatchEvent(r);
          }
          this.dispatched && (e.preventDefault(), e.stopPropagation(), this.dispatched = false);
        }
        onTouchEnd(e, t) {
          const i = Date.now(), n = Object.keys(this.activeTouches).length;
          for (let o = 0, r = t.changedTouches.length; o < r; o++) {
            const a = t.changedTouches.item(o);
            if (!this.activeTouches.hasOwnProperty(String(a.identifier))) {
              console.warn("move of an UNKNOWN touch", a);
              continue;
            }
            const l = this.activeTouches[a.identifier], u = Date.now() - l.initialTimeStamp;
            if (u < _ui.HOLD_DELAY && Math.abs(l.initialPageX - ko(l.rollingPageX)) < 30 && Math.abs(l.initialPageY - ko(l.rollingPageY)) < 30) {
              const d = this.newGestureEvent(Qt.Tap, l.initialTarget);
              d.pageX = ko(l.rollingPageX), d.pageY = ko(l.rollingPageY), this.dispatchEvent(d);
            } else if (u >= _ui.HOLD_DELAY && Math.abs(l.initialPageX - ko(l.rollingPageX)) < 30 && Math.abs(l.initialPageY - ko(l.rollingPageY)) < 30) {
              const d = this.newGestureEvent(Qt.Contextmenu, l.initialTarget);
              d.pageX = ko(l.rollingPageX), d.pageY = ko(l.rollingPageY), this.dispatchEvent(d);
            } else if (n === 1) {
              const d = ko(l.rollingPageX), f = ko(l.rollingPageY), m = ko(l.rollingTimestamps) - l.rollingTimestamps[0], _ = d - l.rollingPageX[0], b = f - l.rollingPageY[0], v = [
                ...this.targets
              ].filter((y) => l.initialTarget instanceof Node && y.contains(l.initialTarget));
              this.inertia(e, v, i, Math.abs(_) / m, _ > 0 ? 1 : -1, d, Math.abs(b) / m, b > 0 ? 1 : -1, f);
            }
            this.dispatchEvent(this.newGestureEvent(Qt.End, l.initialTarget)), delete this.activeTouches[a.identifier];
          }
          this.dispatched && (t.preventDefault(), t.stopPropagation(), this.dispatched = false);
        }
        newGestureEvent(e, t) {
          const i = document.createEvent("CustomEvent");
          return i.initEvent(e, false, true), i.initialTarget = t, i.tapCount = 0, i;
        }
        dispatchEvent(e) {
          if (e.type === Qt.Tap) {
            const t = (/* @__PURE__ */ new Date()).getTime();
            let i = 0;
            t - this._lastSetTapCountTime > _ui.CLEAR_TAP_COUNT_TIME ? i = 1 : i = 2, this._lastSetTapCountTime = t, e.tapCount = i;
          } else (e.type === Qt.Change || e.type === Qt.Contextmenu) && (this._lastSetTapCountTime = 0);
          if (e.initialTarget instanceof Node) {
            for (const i of this.ignoreTargets) if (i.contains(e.initialTarget)) return;
            const t = [];
            for (const i of this.targets) if (i.contains(e.initialTarget)) {
              let n = 0, o = e.initialTarget;
              for (; o && o !== i; ) n++, o = o.parentElement;
              t.push([
                n,
                i
              ]);
            }
            t.sort((i, n) => i[0] - n[0]);
            for (const [i, n] of t) n.dispatchEvent(e), this.dispatched = true;
          }
        }
        inertia(e, t, i, n, o, r, a, l, u) {
          this.handle = Gs(e, () => {
            const d = Date.now(), f = d - i;
            let m = 0, _ = 0, b = true;
            n += _ui.SCROLL_FRICTION * f, a += _ui.SCROLL_FRICTION * f, n > 0 && (b = false, m = o * n * f), a > 0 && (b = false, _ = l * a * f);
            const v = this.newGestureEvent(Qt.Change);
            v.translationX = m, v.translationY = _, t.forEach((y) => y.dispatchEvent(v)), b || this.inertia(e, t, d, n, o, r + m, a, l, u + _);
          });
        }
        onTouchMove(e) {
          const t = Date.now();
          for (let i = 0, n = e.changedTouches.length; i < n; i++) {
            const o = e.changedTouches.item(i);
            if (!this.activeTouches.hasOwnProperty(String(o.identifier))) {
              console.warn("end of an UNKNOWN touch", o);
              continue;
            }
            const r = this.activeTouches[o.identifier], a = this.newGestureEvent(Qt.Change, r.initialTarget);
            a.translationX = o.pageX - ko(r.rollingPageX), a.translationY = o.pageY - ko(r.rollingPageY), a.pageX = o.pageX, a.pageY = o.pageY, this.dispatchEvent(a), r.rollingPageX.length > 3 && (r.rollingPageX.shift(), r.rollingPageY.shift(), r.rollingTimestamps.shift()), r.rollingPageX.push(o.pageX), r.rollingPageY.push(o.pageY), r.rollingTimestamps.push(t);
          }
          this.dispatched && (e.preventDefault(), e.stopPropagation(), this.dispatched = false);
        }
      };
      _ui.SCROLL_FRICTION = -5e-3;
      _ui.HOLD_DELAY = 700;
      _ui.CLEAR_TAP_COUNT_TIME = 400;
      let ui = _ui;
      uX([
        Li
      ], ui, "isTouchDevice", null);
      let Yl = class extends he {
        onclick(e, t) {
          this._register(re(e, Ce.CLICK, (i) => t(new Vr(Oe(e), i))));
        }
        onmousedown(e, t) {
          this._register(re(e, Ce.MOUSE_DOWN, (i) => t(new Vr(Oe(e), i))));
        }
        onmouseover(e, t) {
          this._register(re(e, Ce.MOUSE_OVER, (i) => t(new Vr(Oe(e), i))));
        }
        onmouseleave(e, t) {
          this._register(re(e, Ce.MOUSE_LEAVE, (i) => t(new Vr(Oe(e), i))));
        }
        onkeydown(e, t) {
          this._register(re(e, Ce.KEY_DOWN, (i) => t(new si(i))));
        }
        onkeyup(e, t) {
          this._register(re(e, Ce.KEY_UP, (i) => t(new si(i))));
        }
        oninput(e, t) {
          this._register(re(e, Ce.INPUT, t));
        }
        onblur(e, t) {
          this._register(re(e, Ce.BLUR, t));
        }
        onfocus(e, t) {
          this._register(re(e, Ce.FOCUS, t));
        }
        ignoreGesture(e) {
          return ui.ignoreTarget(e);
        }
      };
      const dg = 11;
      class hX extends Yl {
        constructor(e) {
          super(), this._onActivate = e.onActivate, this.bgDomNode = document.createElement("div"), this.bgDomNode.className = "arrow-background", this.bgDomNode.style.position = "absolute", this.bgDomNode.style.width = e.bgWidth + "px", this.bgDomNode.style.height = e.bgHeight + "px", typeof e.top < "u" && (this.bgDomNode.style.top = "0px"), typeof e.left < "u" && (this.bgDomNode.style.left = "0px"), typeof e.bottom < "u" && (this.bgDomNode.style.bottom = "0px"), typeof e.right < "u" && (this.bgDomNode.style.right = "0px"), this.domNode = document.createElement("div"), this.domNode.className = e.className, this.domNode.classList.add(...wt.asClassNameArray(e.icon)), this.domNode.style.position = "absolute", this.domNode.style.width = dg + "px", this.domNode.style.height = dg + "px", typeof e.top < "u" && (this.domNode.style.top = e.top + "px"), typeof e.left < "u" && (this.domNode.style.left = e.left + "px"), typeof e.bottom < "u" && (this.domNode.style.bottom = e.bottom + "px"), typeof e.right < "u" && (this.domNode.style.right = e.right + "px"), this._pointerMoveMonitor = this._register(new uw()), this._register(ln(this.bgDomNode, Ce.POINTER_DOWN, (t) => this._arrowPointerDown(t))), this._register(ln(this.domNode, Ce.POINTER_DOWN, (t) => this._arrowPointerDown(t))), this._pointerdownRepeatTimer = this._register(new sT()), this._pointerdownScheduleRepeatTimer = this._register(new Kh());
        }
        _arrowPointerDown(e) {
          if (!e.target || !(e.target instanceof Element)) return;
          const t = () => {
            this._pointerdownRepeatTimer.cancelAndSet(() => this._onActivate(), 1e3 / 24, Oe(e));
          };
          this._onActivate(), this._pointerdownRepeatTimer.cancel(), this._pointerdownScheduleRepeatTimer.cancelAndSet(t, 200), this._pointerMoveMonitor.startMonitoring(e.target, e.pointerId, e.buttons, (i) => {
          }, () => {
            this._pointerdownRepeatTimer.cancel(), this._pointerdownScheduleRepeatTimer.cancel();
          }), e.preventDefault();
        }
      }
      class dX extends he {
        constructor(e, t, i) {
          super(), this._visibility = e, this._visibleClassName = t, this._invisibleClassName = i, this._domNode = null, this._isVisible = false, this._isNeeded = false, this._rawShouldBeVisible = false, this._shouldBeVisible = false, this._revealTimer = this._register(new Kh());
        }
        setVisibility(e) {
          this._visibility !== e && (this._visibility = e, this._updateShouldBeVisible());
        }
        setShouldBeVisible(e) {
          this._rawShouldBeVisible = e, this._updateShouldBeVisible();
        }
        _applyVisibilitySetting() {
          return this._visibility === 2 ? false : this._visibility === 3 ? true : this._rawShouldBeVisible;
        }
        _updateShouldBeVisible() {
          const e = this._applyVisibilitySetting();
          this._shouldBeVisible !== e && (this._shouldBeVisible = e, this.ensureVisibility());
        }
        setIsNeeded(e) {
          this._isNeeded !== e && (this._isNeeded = e, this.ensureVisibility());
        }
        setDomNode(e) {
          this._domNode = e, this._domNode.setClassName(this._invisibleClassName), this.setShouldBeVisible(false);
        }
        ensureVisibility() {
          if (!this._isNeeded) {
            this._hide(false);
            return;
          }
          this._shouldBeVisible ? this._reveal() : this._hide(true);
        }
        _reveal() {
          this._isVisible || (this._isVisible = true, this._revealTimer.setIfNotSet(() => {
            var _a3;
            (_a3 = this._domNode) == null ? void 0 : _a3.setClassName(this._visibleClassName);
          }, 0));
        }
        _hide(e) {
          var _a3;
          this._revealTimer.cancel(), this._isVisible && (this._isVisible = false, (_a3 = this._domNode) == null ? void 0 : _a3.setClassName(this._invisibleClassName + (e ? " fade" : "")));
        }
      }
      const fX = 140;
      class C6 extends Yl {
        constructor(e) {
          super(), this._lazyRender = e.lazyRender, this._host = e.host, this._scrollable = e.scrollable, this._scrollByPage = e.scrollByPage, this._scrollbarState = e.scrollbarState, this._visibilityController = this._register(new dX(e.visibility, "visible scrollbar " + e.extraScrollbarClassName, "invisible scrollbar " + e.extraScrollbarClassName)), this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded()), this._pointerMoveMonitor = this._register(new uw()), this._shouldRender = true, this.domNode = St(document.createElement("div")), this.domNode.setAttribute("role", "presentation"), this.domNode.setAttribute("aria-hidden", "true"), this._visibilityController.setDomNode(this.domNode), this.domNode.setPosition("absolute"), this._register(re(this.domNode.domNode, Ce.POINTER_DOWN, (t) => this._domNodePointerDown(t)));
        }
        _createArrow(e) {
          const t = this._register(new hX(e));
          this.domNode.domNode.appendChild(t.bgDomNode), this.domNode.domNode.appendChild(t.domNode);
        }
        _createSlider(e, t, i, n) {
          this.slider = St(document.createElement("div")), this.slider.setClassName("slider"), this.slider.setPosition("absolute"), this.slider.setTop(e), this.slider.setLeft(t), typeof i == "number" && this.slider.setWidth(i), typeof n == "number" && this.slider.setHeight(n), this.slider.setLayerHinting(true), this.slider.setContain("strict"), this.domNode.domNode.appendChild(this.slider.domNode), this._register(re(this.slider.domNode, Ce.POINTER_DOWN, (o) => {
            o.button === 0 && (o.preventDefault(), this._sliderPointerDown(o));
          })), this.onclick(this.slider.domNode, (o) => {
            o.leftButton && o.stopPropagation();
          });
        }
        _onElementSize(e) {
          return this._scrollbarState.setVisibleSize(e) && (this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded()), this._shouldRender = true, this._lazyRender || this.render()), this._shouldRender;
        }
        _onElementScrollSize(e) {
          return this._scrollbarState.setScrollSize(e) && (this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded()), this._shouldRender = true, this._lazyRender || this.render()), this._shouldRender;
        }
        _onElementScrollPosition(e) {
          return this._scrollbarState.setScrollPosition(e) && (this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded()), this._shouldRender = true, this._lazyRender || this.render()), this._shouldRender;
        }
        beginReveal() {
          this._visibilityController.setShouldBeVisible(true);
        }
        beginHide() {
          this._visibilityController.setShouldBeVisible(false);
        }
        render() {
          this._shouldRender && (this._shouldRender = false, this._renderDomNode(this._scrollbarState.getRectangleLargeSize(), this._scrollbarState.getRectangleSmallSize()), this._updateSlider(this._scrollbarState.getSliderSize(), this._scrollbarState.getArrowSize() + this._scrollbarState.getSliderPosition()));
        }
        _domNodePointerDown(e) {
          e.target === this.domNode.domNode && this._onPointerDown(e);
        }
        delegatePointerDown(e) {
          const t = this.domNode.domNode.getClientRects()[0].top, i = t + this._scrollbarState.getSliderPosition(), n = t + this._scrollbarState.getSliderPosition() + this._scrollbarState.getSliderSize(), o = this._sliderPointerPosition(e);
          i <= o && o <= n ? e.button === 0 && (e.preventDefault(), this._sliderPointerDown(e)) : this._onPointerDown(e);
        }
        _onPointerDown(e) {
          let t, i;
          if (e.target === this.domNode.domNode && typeof e.offsetX == "number" && typeof e.offsetY == "number") t = e.offsetX, i = e.offsetY;
          else {
            const o = Bo(this.domNode.domNode);
            t = e.pageX - o.left, i = e.pageY - o.top;
          }
          const n = this._pointerDownRelativePosition(t, i);
          this._setDesiredScrollPositionNow(this._scrollByPage ? this._scrollbarState.getDesiredScrollPositionFromOffsetPaged(n) : this._scrollbarState.getDesiredScrollPositionFromOffset(n)), e.button === 0 && (e.preventDefault(), this._sliderPointerDown(e));
        }
        _sliderPointerDown(e) {
          if (!e.target || !(e.target instanceof Element)) return;
          const t = this._sliderPointerPosition(e), i = this._sliderOrthogonalPointerPosition(e), n = this._scrollbarState.clone();
          this.slider.toggleClassName("active", true), this._pointerMoveMonitor.startMonitoring(e.target, e.pointerId, e.buttons, (o) => {
            const r = this._sliderOrthogonalPointerPosition(o), a = Math.abs(r - i);
            if (Ks && a > fX) {
              this._setDesiredScrollPositionNow(n.getScrollPosition());
              return;
            }
            const u = this._sliderPointerPosition(o) - t;
            this._setDesiredScrollPositionNow(n.getDesiredScrollPositionFromDelta(u));
          }, () => {
            this.slider.toggleClassName("active", false), this._host.onDragEnd();
          }), this._host.onDragStart();
        }
        _setDesiredScrollPositionNow(e) {
          const t = {};
          this.writeScrollPosition(t, e), this._scrollable.setScrollPositionNow(t);
        }
        updateScrollbarSize(e) {
          this._updateScrollbarSize(e), this._scrollbarState.setScrollbarSize(e), this._shouldRender = true, this._lazyRender || this.render();
        }
        isNeeded() {
          return this._scrollbarState.isNeeded();
        }
      }
      const gX = 20;
      class fg {
        constructor(e, t, i, n, o, r) {
          this._scrollbarSize = Math.round(t), this._oppositeScrollbarSize = Math.round(i), this._arrowSize = Math.round(e), this._visibleSize = n, this._scrollSize = o, this._scrollPosition = r, this._computedAvailableSize = 0, this._computedIsNeeded = false, this._computedSliderSize = 0, this._computedSliderRatio = 0, this._computedSliderPosition = 0, this._refreshComputedValues();
        }
        clone() {
          return new fg(this._arrowSize, this._scrollbarSize, this._oppositeScrollbarSize, this._visibleSize, this._scrollSize, this._scrollPosition);
        }
        setVisibleSize(e) {
          const t = Math.round(e);
          return this._visibleSize !== t ? (this._visibleSize = t, this._refreshComputedValues(), true) : false;
        }
        setScrollSize(e) {
          const t = Math.round(e);
          return this._scrollSize !== t ? (this._scrollSize = t, this._refreshComputedValues(), true) : false;
        }
        setScrollPosition(e) {
          const t = Math.round(e);
          return this._scrollPosition !== t ? (this._scrollPosition = t, this._refreshComputedValues(), true) : false;
        }
        setScrollbarSize(e) {
          this._scrollbarSize = Math.round(e);
        }
        setOppositeScrollbarSize(e) {
          this._oppositeScrollbarSize = Math.round(e);
        }
        static _computeValues(e, t, i, n, o) {
          const r = Math.max(0, i - e), a = Math.max(0, r - 2 * t), l = n > 0 && n > i;
          if (!l) return {
            computedAvailableSize: Math.round(r),
            computedIsNeeded: l,
            computedSliderSize: Math.round(a),
            computedSliderRatio: 0,
            computedSliderPosition: 0
          };
          const u = Math.round(Math.max(gX, Math.floor(i * a / n))), d = (a - u) / (n - i), f = o * d;
          return {
            computedAvailableSize: Math.round(r),
            computedIsNeeded: l,
            computedSliderSize: Math.round(u),
            computedSliderRatio: d,
            computedSliderPosition: Math.round(f)
          };
        }
        _refreshComputedValues() {
          const e = fg._computeValues(this._oppositeScrollbarSize, this._arrowSize, this._visibleSize, this._scrollSize, this._scrollPosition);
          this._computedAvailableSize = e.computedAvailableSize, this._computedIsNeeded = e.computedIsNeeded, this._computedSliderSize = e.computedSliderSize, this._computedSliderRatio = e.computedSliderRatio, this._computedSliderPosition = e.computedSliderPosition;
        }
        getArrowSize() {
          return this._arrowSize;
        }
        getScrollPosition() {
          return this._scrollPosition;
        }
        getRectangleLargeSize() {
          return this._computedAvailableSize;
        }
        getRectangleSmallSize() {
          return this._scrollbarSize;
        }
        isNeeded() {
          return this._computedIsNeeded;
        }
        getSliderSize() {
          return this._computedSliderSize;
        }
        getSliderPosition() {
          return this._computedSliderPosition;
        }
        getDesiredScrollPositionFromOffset(e) {
          if (!this._computedIsNeeded) return 0;
          const t = e - this._arrowSize - this._computedSliderSize / 2;
          return Math.round(t / this._computedSliderRatio);
        }
        getDesiredScrollPositionFromOffsetPaged(e) {
          if (!this._computedIsNeeded) return 0;
          const t = e - this._arrowSize;
          let i = this._scrollPosition;
          return t < this._computedSliderPosition ? i -= this._visibleSize : i += this._visibleSize, i;
        }
        getDesiredScrollPositionFromDelta(e) {
          if (!this._computedIsNeeded) return 0;
          const t = this._computedSliderPosition + e;
          return Math.round(t / this._computedSliderRatio);
        }
      }
      class mX extends C6 {
        constructor(e, t, i) {
          const n = e.getScrollDimensions(), o = e.getCurrentScrollPosition();
          if (super({
            lazyRender: t.lazyRender,
            host: i,
            scrollbarState: new fg(t.horizontalHasArrows ? t.arrowSize : 0, t.horizontal === 2 ? 0 : t.horizontalScrollbarSize, t.vertical === 2 ? 0 : t.verticalScrollbarSize, n.width, n.scrollWidth, o.scrollLeft),
            visibility: t.horizontal,
            extraScrollbarClassName: "horizontal",
            scrollable: e,
            scrollByPage: t.scrollByPage
          }), t.horizontalHasArrows) {
            const r = (t.arrowSize - dg) / 2, a = (t.horizontalScrollbarSize - dg) / 2;
            this._createArrow({
              className: "scra",
              icon: Te.scrollbarButtonLeft,
              top: a,
              left: r,
              bottom: void 0,
              right: void 0,
              bgWidth: t.arrowSize,
              bgHeight: t.horizontalScrollbarSize,
              onActivate: () => this._host.onMouseWheel(new Ah(null, 1, 0))
            }), this._createArrow({
              className: "scra",
              icon: Te.scrollbarButtonRight,
              top: a,
              left: void 0,
              bottom: void 0,
              right: r,
              bgWidth: t.arrowSize,
              bgHeight: t.horizontalScrollbarSize,
              onActivate: () => this._host.onMouseWheel(new Ah(null, -1, 0))
            });
          }
          this._createSlider(Math.floor((t.horizontalScrollbarSize - t.horizontalSliderSize) / 2), 0, void 0, t.horizontalSliderSize);
        }
        _updateSlider(e, t) {
          this.slider.setWidth(e), this.slider.setLeft(t);
        }
        _renderDomNode(e, t) {
          this.domNode.setWidth(e), this.domNode.setHeight(t), this.domNode.setLeft(0), this.domNode.setBottom(0);
        }
        onDidScroll(e) {
          return this._shouldRender = this._onElementScrollSize(e.scrollWidth) || this._shouldRender, this._shouldRender = this._onElementScrollPosition(e.scrollLeft) || this._shouldRender, this._shouldRender = this._onElementSize(e.width) || this._shouldRender, this._shouldRender;
        }
        _pointerDownRelativePosition(e, t) {
          return e;
        }
        _sliderPointerPosition(e) {
          return e.pageX;
        }
        _sliderOrthogonalPointerPosition(e) {
          return e.pageY;
        }
        _updateScrollbarSize(e) {
          this.slider.setHeight(e);
        }
        writeScrollPosition(e, t) {
          e.scrollLeft = t;
        }
        updateOptions(e) {
          this.updateScrollbarSize(e.horizontal === 2 ? 0 : e.horizontalScrollbarSize), this._scrollbarState.setOppositeScrollbarSize(e.vertical === 2 ? 0 : e.verticalScrollbarSize), this._visibilityController.setVisibility(e.horizontal), this._scrollByPage = e.scrollByPage;
        }
      }
      class pX extends C6 {
        constructor(e, t, i) {
          const n = e.getScrollDimensions(), o = e.getCurrentScrollPosition();
          if (super({
            lazyRender: t.lazyRender,
            host: i,
            scrollbarState: new fg(t.verticalHasArrows ? t.arrowSize : 0, t.vertical === 2 ? 0 : t.verticalScrollbarSize, 0, n.height, n.scrollHeight, o.scrollTop),
            visibility: t.vertical,
            extraScrollbarClassName: "vertical",
            scrollable: e,
            scrollByPage: t.scrollByPage
          }), t.verticalHasArrows) {
            const r = (t.arrowSize - dg) / 2, a = (t.verticalScrollbarSize - dg) / 2;
            this._createArrow({
              className: "scra",
              icon: Te.scrollbarButtonUp,
              top: r,
              left: a,
              bottom: void 0,
              right: void 0,
              bgWidth: t.verticalScrollbarSize,
              bgHeight: t.arrowSize,
              onActivate: () => this._host.onMouseWheel(new Ah(null, 0, 1))
            }), this._createArrow({
              className: "scra",
              icon: Te.scrollbarButtonDown,
              top: void 0,
              left: a,
              bottom: r,
              right: void 0,
              bgWidth: t.verticalScrollbarSize,
              bgHeight: t.arrowSize,
              onActivate: () => this._host.onMouseWheel(new Ah(null, 0, -1))
            });
          }
          this._createSlider(0, Math.floor((t.verticalScrollbarSize - t.verticalSliderSize) / 2), t.verticalSliderSize, void 0);
        }
        _updateSlider(e, t) {
          this.slider.setHeight(e), this.slider.setTop(t);
        }
        _renderDomNode(e, t) {
          this.domNode.setWidth(t), this.domNode.setHeight(e), this.domNode.setRight(0), this.domNode.setTop(0);
        }
        onDidScroll(e) {
          return this._shouldRender = this._onElementScrollSize(e.scrollHeight) || this._shouldRender, this._shouldRender = this._onElementScrollPosition(e.scrollTop) || this._shouldRender, this._shouldRender = this._onElementSize(e.height) || this._shouldRender, this._shouldRender;
        }
        _pointerDownRelativePosition(e, t) {
          return t;
        }
        _sliderPointerPosition(e) {
          return e.pageY;
        }
        _sliderOrthogonalPointerPosition(e) {
          return e.pageX;
        }
        _updateScrollbarSize(e) {
          this.slider.setWidth(e);
        }
        writeScrollPosition(e, t) {
          e.scrollTop = t;
        }
        updateOptions(e) {
          this.updateScrollbarSize(e.vertical === 2 ? 0 : e.verticalScrollbarSize), this._scrollbarState.setOppositeScrollbarSize(0), this._visibilityController.setVisibility(e.vertical), this._scrollByPage = e.scrollByPage;
        }
      }
      class Sv {
        constructor(e, t, i, n, o, r, a) {
          this._forceIntegerValues = e, this._scrollStateBrand = void 0, this._forceIntegerValues && (t = t | 0, i = i | 0, n = n | 0, o = o | 0, r = r | 0, a = a | 0), this.rawScrollLeft = n, this.rawScrollTop = a, t < 0 && (t = 0), n + t > i && (n = i - t), n < 0 && (n = 0), o < 0 && (o = 0), a + o > r && (a = r - o), a < 0 && (a = 0), this.width = t, this.scrollWidth = i, this.scrollLeft = n, this.height = o, this.scrollHeight = r, this.scrollTop = a;
        }
        equals(e) {
          return this.rawScrollLeft === e.rawScrollLeft && this.rawScrollTop === e.rawScrollTop && this.width === e.width && this.scrollWidth === e.scrollWidth && this.scrollLeft === e.scrollLeft && this.height === e.height && this.scrollHeight === e.scrollHeight && this.scrollTop === e.scrollTop;
        }
        withScrollDimensions(e, t) {
          return new Sv(this._forceIntegerValues, typeof e.width < "u" ? e.width : this.width, typeof e.scrollWidth < "u" ? e.scrollWidth : this.scrollWidth, t ? this.rawScrollLeft : this.scrollLeft, typeof e.height < "u" ? e.height : this.height, typeof e.scrollHeight < "u" ? e.scrollHeight : this.scrollHeight, t ? this.rawScrollTop : this.scrollTop);
        }
        withScrollPosition(e) {
          return new Sv(this._forceIntegerValues, this.width, this.scrollWidth, typeof e.scrollLeft < "u" ? e.scrollLeft : this.rawScrollLeft, this.height, this.scrollHeight, typeof e.scrollTop < "u" ? e.scrollTop : this.rawScrollTop);
        }
        createScrollEvent(e, t) {
          const i = this.width !== e.width, n = this.scrollWidth !== e.scrollWidth, o = this.scrollLeft !== e.scrollLeft, r = this.height !== e.height, a = this.scrollHeight !== e.scrollHeight, l = this.scrollTop !== e.scrollTop;
          return {
            inSmoothScrolling: t,
            oldWidth: e.width,
            oldScrollWidth: e.scrollWidth,
            oldScrollLeft: e.scrollLeft,
            width: this.width,
            scrollWidth: this.scrollWidth,
            scrollLeft: this.scrollLeft,
            oldHeight: e.height,
            oldScrollHeight: e.scrollHeight,
            oldScrollTop: e.scrollTop,
            height: this.height,
            scrollHeight: this.scrollHeight,
            scrollTop: this.scrollTop,
            widthChanged: i,
            scrollWidthChanged: n,
            scrollLeftChanged: o,
            heightChanged: r,
            scrollHeightChanged: a,
            scrollTopChanged: l
          };
        }
      }
      class Dg extends he {
        constructor(e) {
          super(), this._scrollableBrand = void 0, this._onScroll = this._register(new G()), this.onScroll = this._onScroll.event, this._smoothScrollDuration = e.smoothScrollDuration, this._scheduleAtNextAnimationFrame = e.scheduleAtNextAnimationFrame, this._state = new Sv(e.forceIntegerValues, 0, 0, 0, 0, 0, 0), this._smoothScrolling = null;
        }
        dispose() {
          this._smoothScrolling && (this._smoothScrolling.dispose(), this._smoothScrolling = null), super.dispose();
        }
        setSmoothScrollDuration(e) {
          this._smoothScrollDuration = e;
        }
        validateScrollPosition(e) {
          return this._state.withScrollPosition(e);
        }
        getScrollDimensions() {
          return this._state;
        }
        setScrollDimensions(e, t) {
          var _a3;
          const i = this._state.withScrollDimensions(e, t);
          this._setState(i, !!this._smoothScrolling), (_a3 = this._smoothScrolling) == null ? void 0 : _a3.acceptScrollDimensions(this._state);
        }
        getFutureScrollPosition() {
          return this._smoothScrolling ? this._smoothScrolling.to : this._state;
        }
        getCurrentScrollPosition() {
          return this._state;
        }
        setScrollPositionNow(e) {
          const t = this._state.withScrollPosition(e);
          this._smoothScrolling && (this._smoothScrolling.dispose(), this._smoothScrolling = null), this._setState(t, false);
        }
        setScrollPositionSmooth(e, t) {
          if (this._smoothScrollDuration === 0) return this.setScrollPositionNow(e);
          if (this._smoothScrolling) {
            e = {
              scrollLeft: typeof e.scrollLeft > "u" ? this._smoothScrolling.to.scrollLeft : e.scrollLeft,
              scrollTop: typeof e.scrollTop > "u" ? this._smoothScrolling.to.scrollTop : e.scrollTop
            };
            const i = this._state.withScrollPosition(e);
            if (this._smoothScrolling.to.scrollLeft === i.scrollLeft && this._smoothScrolling.to.scrollTop === i.scrollTop) return;
            let n;
            t ? n = new r_(this._smoothScrolling.from, i, this._smoothScrolling.startTime, this._smoothScrolling.duration) : n = this._smoothScrolling.combine(this._state, i, this._smoothScrollDuration), this._smoothScrolling.dispose(), this._smoothScrolling = n;
          } else {
            const i = this._state.withScrollPosition(e);
            this._smoothScrolling = r_.start(this._state, i, this._smoothScrollDuration);
          }
          this._smoothScrolling.animationFrameDisposable = this._scheduleAtNextAnimationFrame(() => {
            this._smoothScrolling && (this._smoothScrolling.animationFrameDisposable = null, this._performSmoothScrolling());
          });
        }
        hasPendingScrollAnimation() {
          return !!this._smoothScrolling;
        }
        _performSmoothScrolling() {
          if (!this._smoothScrolling) return;
          const e = this._smoothScrolling.tick(), t = this._state.withScrollPosition(e);
          if (this._setState(t, true), !!this._smoothScrolling) {
            if (e.isDone) {
              this._smoothScrolling.dispose(), this._smoothScrolling = null;
              return;
            }
            this._smoothScrolling.animationFrameDisposable = this._scheduleAtNextAnimationFrame(() => {
              this._smoothScrolling && (this._smoothScrolling.animationFrameDisposable = null, this._performSmoothScrolling());
            });
          }
        }
        _setState(e, t) {
          const i = this._state;
          i.equals(e) || (this._state = e, this._onScroll.fire(this._state.createScrollEvent(i, t)));
        }
      }
      class I5 {
        constructor(e, t, i) {
          this.scrollLeft = e, this.scrollTop = t, this.isDone = i;
        }
      }
      function $L(s, e) {
        const t = e - s;
        return function(i) {
          return s + t * vX(i);
        };
      }
      function _X(s, e, t) {
        return function(i) {
          return i < t ? s(i / t) : e((i - t) / (1 - t));
        };
      }
      class r_ {
        constructor(e, t, i, n) {
          this.from = e, this.to = t, this.duration = n, this.startTime = i, this.animationFrameDisposable = null, this._initAnimations();
        }
        _initAnimations() {
          this.scrollLeft = this._initAnimation(this.from.scrollLeft, this.to.scrollLeft, this.to.width), this.scrollTop = this._initAnimation(this.from.scrollTop, this.to.scrollTop, this.to.height);
        }
        _initAnimation(e, t, i) {
          if (Math.abs(e - t) > 2.5 * i) {
            let o, r;
            return e < t ? (o = e + 0.75 * i, r = t - 0.75 * i) : (o = e - 0.75 * i, r = t + 0.75 * i), _X($L(e, o), $L(r, t), 0.33);
          }
          return $L(e, t);
        }
        dispose() {
          this.animationFrameDisposable !== null && (this.animationFrameDisposable.dispose(), this.animationFrameDisposable = null);
        }
        acceptScrollDimensions(e) {
          this.to = e.withScrollPosition(this.to), this._initAnimations();
        }
        tick() {
          return this._tick(Date.now());
        }
        _tick(e) {
          const t = (e - this.startTime) / this.duration;
          if (t < 1) {
            const i = this.scrollLeft(t), n = this.scrollTop(t);
            return new I5(i, n, false);
          }
          return new I5(this.to.scrollLeft, this.to.scrollTop, true);
        }
        combine(e, t, i) {
          return r_.start(e, t, i);
        }
        static start(e, t, i) {
          i = i + 10;
          const n = Date.now() - 10;
          return new r_(e, t, n, i);
        }
      }
      function bX(s) {
        return Math.pow(s, 3);
      }
      function vX(s) {
        return 1 - bX(1 - s);
      }
      const CX = 500, M5 = 50;
      class wX {
        constructor(e, t, i) {
          this.timestamp = e, this.deltaX = t, this.deltaY = i, this.score = 0;
        }
      }
      const _hw = class _hw {
        constructor() {
          this._capacity = 5, this._memory = [], this._front = -1, this._rear = -1;
        }
        isPhysicalMouseWheel() {
          if (this._front === -1 && this._rear === -1) return false;
          let e = 1, t = 0, i = 1, n = this._rear;
          do {
            const o = n === this._front ? e : Math.pow(2, -i);
            if (e -= o, t += this._memory[n].score * o, n === this._front) break;
            n = (this._capacity + n - 1) % this._capacity, i++;
          } while (true);
          return t <= 0.5;
        }
        acceptStandardWheelEvent(e) {
          if (V_) {
            const t = Oe(e.browserEvent), i = Wq(t);
            this.accept(Date.now(), e.deltaX * i, e.deltaY * i);
          } else this.accept(Date.now(), e.deltaX, e.deltaY);
        }
        accept(e, t, i) {
          let n = null;
          const o = new wX(e, t, i);
          this._front === -1 && this._rear === -1 ? (this._memory[0] = o, this._front = 0, this._rear = 0) : (n = this._memory[this._rear], this._rear = (this._rear + 1) % this._capacity, this._rear === this._front && (this._front = (this._front + 1) % this._capacity), this._memory[this._rear] = o), o.score = this._computeScore(o, n);
        }
        _computeScore(e, t) {
          if (Math.abs(e.deltaX) > 0 && Math.abs(e.deltaY) > 0) return 1;
          let i = 0.5;
          if ((!this._isAlmostInt(e.deltaX) || !this._isAlmostInt(e.deltaY)) && (i += 0.25), t) {
            const n = Math.abs(e.deltaX), o = Math.abs(e.deltaY), r = Math.abs(t.deltaX), a = Math.abs(t.deltaY), l = Math.max(Math.min(n, r), 1), u = Math.max(Math.min(o, a), 1), d = Math.max(n, r), f = Math.max(o, a);
            d % l === 0 && f % u === 0 && (i -= 0.5);
          }
          return Math.min(Math.max(i, 0), 1);
        }
        _isAlmostInt(e) {
          return Math.abs(Math.round(e) - e) < 0.01;
        }
      };
      _hw.INSTANCE = new _hw();
      let hw = _hw;
      class OT extends Yl {
        get options() {
          return this._options;
        }
        constructor(e, t, i) {
          super(), this._onScroll = this._register(new G()), this.onScroll = this._onScroll.event, this._onWillScroll = this._register(new G()), e.style.overflow = "hidden", this._options = SX(t), this._scrollable = i, this._register(this._scrollable.onScroll((o) => {
            this._onWillScroll.fire(o), this._onDidScroll(o), this._onScroll.fire(o);
          }));
          const n = {
            onMouseWheel: (o) => this._onMouseWheel(o),
            onDragStart: () => this._onDragStart(),
            onDragEnd: () => this._onDragEnd()
          };
          this._verticalScrollbar = this._register(new pX(this._scrollable, this._options, n)), this._horizontalScrollbar = this._register(new mX(this._scrollable, this._options, n)), this._domNode = document.createElement("div"), this._domNode.className = "monaco-scrollable-element " + this._options.className, this._domNode.setAttribute("role", "presentation"), this._domNode.style.position = "relative", this._domNode.style.overflow = "hidden", this._domNode.appendChild(e), this._domNode.appendChild(this._horizontalScrollbar.domNode.domNode), this._domNode.appendChild(this._verticalScrollbar.domNode.domNode), this._options.useShadows ? (this._leftShadowDomNode = St(document.createElement("div")), this._leftShadowDomNode.setClassName("shadow"), this._domNode.appendChild(this._leftShadowDomNode.domNode), this._topShadowDomNode = St(document.createElement("div")), this._topShadowDomNode.setClassName("shadow"), this._domNode.appendChild(this._topShadowDomNode.domNode), this._topLeftShadowDomNode = St(document.createElement("div")), this._topLeftShadowDomNode.setClassName("shadow"), this._domNode.appendChild(this._topLeftShadowDomNode.domNode)) : (this._leftShadowDomNode = null, this._topShadowDomNode = null, this._topLeftShadowDomNode = null), this._listenOnDomNode = this._options.listenOnDomNode || this._domNode, this._mouseWheelToDispose = [], this._setListeningToMouseWheel(this._options.handleMouseWheel), this.onmouseover(this._listenOnDomNode, (o) => this._onMouseOver(o)), this.onmouseleave(this._listenOnDomNode, (o) => this._onMouseLeave(o)), this._hideTimeout = this._register(new Kh()), this._isDragging = false, this._mouseIsOver = false, this._shouldRender = true, this._revealOnScroll = true;
        }
        dispose() {
          this._mouseWheelToDispose = On(this._mouseWheelToDispose), super.dispose();
        }
        getDomNode() {
          return this._domNode;
        }
        getOverviewRulerLayoutInfo() {
          return {
            parent: this._domNode,
            insertBefore: this._verticalScrollbar.domNode.domNode
          };
        }
        delegateVerticalScrollbarPointerDown(e) {
          this._verticalScrollbar.delegatePointerDown(e);
        }
        getScrollDimensions() {
          return this._scrollable.getScrollDimensions();
        }
        setScrollDimensions(e) {
          this._scrollable.setScrollDimensions(e, false);
        }
        updateClassName(e) {
          this._options.className = e, _t && (this._options.className += " mac"), this._domNode.className = "monaco-scrollable-element " + this._options.className;
        }
        updateOptions(e) {
          typeof e.handleMouseWheel < "u" && (this._options.handleMouseWheel = e.handleMouseWheel, this._setListeningToMouseWheel(this._options.handleMouseWheel)), typeof e.mouseWheelScrollSensitivity < "u" && (this._options.mouseWheelScrollSensitivity = e.mouseWheelScrollSensitivity), typeof e.fastScrollSensitivity < "u" && (this._options.fastScrollSensitivity = e.fastScrollSensitivity), typeof e.scrollPredominantAxis < "u" && (this._options.scrollPredominantAxis = e.scrollPredominantAxis), typeof e.horizontal < "u" && (this._options.horizontal = e.horizontal), typeof e.vertical < "u" && (this._options.vertical = e.vertical), typeof e.horizontalScrollbarSize < "u" && (this._options.horizontalScrollbarSize = e.horizontalScrollbarSize), typeof e.verticalScrollbarSize < "u" && (this._options.verticalScrollbarSize = e.verticalScrollbarSize), typeof e.scrollByPage < "u" && (this._options.scrollByPage = e.scrollByPage), this._horizontalScrollbar.updateOptions(this._options), this._verticalScrollbar.updateOptions(this._options), this._options.lazyRender || this._render();
        }
        delegateScrollFromMouseWheelEvent(e) {
          this._onMouseWheel(new Ah(e));
        }
        _setListeningToMouseWheel(e) {
          if (this._mouseWheelToDispose.length > 0 !== e && (this._mouseWheelToDispose = On(this._mouseWheelToDispose), e)) {
            const i = (n) => {
              this._onMouseWheel(new Ah(n));
            };
            this._mouseWheelToDispose.push(re(this._listenOnDomNode, Ce.MOUSE_WHEEL, i, {
              passive: false
            }));
          }
        }
        _onMouseWheel(e) {
          var _a3;
          if ((_a3 = e.browserEvent) == null ? void 0 : _a3.defaultPrevented) return;
          const t = hw.INSTANCE;
          t.acceptStandardWheelEvent(e);
          let i = false;
          if (e.deltaY || e.deltaX) {
            let o = e.deltaY * this._options.mouseWheelScrollSensitivity, r = e.deltaX * this._options.mouseWheelScrollSensitivity;
            this._options.scrollPredominantAxis && (this._options.scrollYToX && r + o === 0 ? r = o = 0 : Math.abs(o) >= Math.abs(r) ? r = 0 : o = 0), this._options.flipAxes && ([o, r] = [
              r,
              o
            ]);
            const a = !_t && e.browserEvent && e.browserEvent.shiftKey;
            (this._options.scrollYToX || a) && !r && (r = o, o = 0), e.browserEvent && e.browserEvent.altKey && (r = r * this._options.fastScrollSensitivity, o = o * this._options.fastScrollSensitivity);
            const l = this._scrollable.getFutureScrollPosition();
            let u = {};
            if (o) {
              const d = M5 * o, f = l.scrollTop - (d < 0 ? Math.floor(d) : Math.ceil(d));
              this._verticalScrollbar.writeScrollPosition(u, f);
            }
            if (r) {
              const d = M5 * r, f = l.scrollLeft - (d < 0 ? Math.floor(d) : Math.ceil(d));
              this._horizontalScrollbar.writeScrollPosition(u, f);
            }
            u = this._scrollable.validateScrollPosition(u), (l.scrollLeft !== u.scrollLeft || l.scrollTop !== u.scrollTop) && (this._options.mouseWheelSmoothScroll && t.isPhysicalMouseWheel() ? this._scrollable.setScrollPositionSmooth(u) : this._scrollable.setScrollPositionNow(u), i = true);
          }
          let n = i;
          !n && this._options.alwaysConsumeMouseWheel && (n = true), !n && this._options.consumeMouseWheelIfScrollbarIsNeeded && (this._verticalScrollbar.isNeeded() || this._horizontalScrollbar.isNeeded()) && (n = true), n && (e.preventDefault(), e.stopPropagation());
        }
        _onDidScroll(e) {
          this._shouldRender = this._horizontalScrollbar.onDidScroll(e) || this._shouldRender, this._shouldRender = this._verticalScrollbar.onDidScroll(e) || this._shouldRender, this._options.useShadows && (this._shouldRender = true), this._revealOnScroll && this._reveal(), this._options.lazyRender || this._render();
        }
        renderNow() {
          if (!this._options.lazyRender) throw new Error("Please use `lazyRender` together with `renderNow`!");
          this._render();
        }
        _render() {
          if (this._shouldRender && (this._shouldRender = false, this._horizontalScrollbar.render(), this._verticalScrollbar.render(), this._options.useShadows)) {
            const e = this._scrollable.getCurrentScrollPosition(), t = e.scrollTop > 0, i = e.scrollLeft > 0, n = i ? " left" : "", o = t ? " top" : "", r = i || t ? " top-left-corner" : "";
            this._leftShadowDomNode.setClassName(`shadow${n}`), this._topShadowDomNode.setClassName(`shadow${o}`), this._topLeftShadowDomNode.setClassName(`shadow${r}${o}${n}`);
          }
        }
        _onDragStart() {
          this._isDragging = true, this._reveal();
        }
        _onDragEnd() {
          this._isDragging = false, this._hide();
        }
        _onMouseLeave(e) {
          this._mouseIsOver = false, this._hide();
        }
        _onMouseOver(e) {
          this._mouseIsOver = true, this._reveal();
        }
        _reveal() {
          this._verticalScrollbar.beginReveal(), this._horizontalScrollbar.beginReveal(), this._scheduleHide();
        }
        _hide() {
          !this._mouseIsOver && !this._isDragging && (this._verticalScrollbar.beginHide(), this._horizontalScrollbar.beginHide());
        }
        _scheduleHide() {
          !this._mouseIsOver && !this._isDragging && this._hideTimeout.cancelAndSet(() => this._hide(), CX);
        }
      }
      class yX extends OT {
        constructor(e, t) {
          t = t || {}, t.mouseWheelSmoothScroll = false;
          const i = new Dg({
            forceIntegerValues: true,
            smoothScrollDuration: 0,
            scheduleAtNextAnimationFrame: (n) => Gs(Oe(e), n)
          });
          super(e, t, i), this._register(i);
        }
        setScrollPosition(e) {
          this._scrollable.setScrollPositionNow(e);
        }
      }
      class dw extends OT {
        constructor(e, t, i) {
          super(e, t, i);
        }
        setScrollPosition(e) {
          e.reuseAnimation ? this._scrollable.setScrollPositionSmooth(e, e.reuseAnimation) : this._scrollable.setScrollPositionNow(e);
        }
        getScrollPosition() {
          return this._scrollable.getCurrentScrollPosition();
        }
      }
      class PT extends OT {
        constructor(e, t) {
          t = t || {}, t.mouseWheelSmoothScroll = false;
          const i = new Dg({
            forceIntegerValues: false,
            smoothScrollDuration: 0,
            scheduleAtNextAnimationFrame: (n) => Gs(Oe(e), n)
          });
          super(e, t, i), this._register(i), this._element = e, this._register(this.onScroll((n) => {
            n.scrollTopChanged && (this._element.scrollTop = n.scrollTop), n.scrollLeftChanged && (this._element.scrollLeft = n.scrollLeft);
          })), this.scanDomNode();
        }
        setScrollPosition(e) {
          this._scrollable.setScrollPositionNow(e);
        }
        getScrollPosition() {
          return this._scrollable.getCurrentScrollPosition();
        }
        scanDomNode() {
          this.setScrollDimensions({
            width: this._element.clientWidth,
            scrollWidth: this._element.scrollWidth,
            height: this._element.clientHeight,
            scrollHeight: this._element.scrollHeight
          }), this.setScrollPosition({
            scrollLeft: this._element.scrollLeft,
            scrollTop: this._element.scrollTop
          });
        }
      }
      function SX(s) {
        const e = {
          lazyRender: typeof s.lazyRender < "u" ? s.lazyRender : false,
          className: typeof s.className < "u" ? s.className : "",
          useShadows: typeof s.useShadows < "u" ? s.useShadows : true,
          handleMouseWheel: typeof s.handleMouseWheel < "u" ? s.handleMouseWheel : true,
          flipAxes: typeof s.flipAxes < "u" ? s.flipAxes : false,
          consumeMouseWheelIfScrollbarIsNeeded: typeof s.consumeMouseWheelIfScrollbarIsNeeded < "u" ? s.consumeMouseWheelIfScrollbarIsNeeded : false,
          alwaysConsumeMouseWheel: typeof s.alwaysConsumeMouseWheel < "u" ? s.alwaysConsumeMouseWheel : false,
          scrollYToX: typeof s.scrollYToX < "u" ? s.scrollYToX : false,
          mouseWheelScrollSensitivity: typeof s.mouseWheelScrollSensitivity < "u" ? s.mouseWheelScrollSensitivity : 1,
          fastScrollSensitivity: typeof s.fastScrollSensitivity < "u" ? s.fastScrollSensitivity : 5,
          scrollPredominantAxis: typeof s.scrollPredominantAxis < "u" ? s.scrollPredominantAxis : true,
          mouseWheelSmoothScroll: typeof s.mouseWheelSmoothScroll < "u" ? s.mouseWheelSmoothScroll : true,
          arrowSize: typeof s.arrowSize < "u" ? s.arrowSize : 11,
          listenOnDomNode: typeof s.listenOnDomNode < "u" ? s.listenOnDomNode : null,
          horizontal: typeof s.horizontal < "u" ? s.horizontal : 1,
          horizontalScrollbarSize: typeof s.horizontalScrollbarSize < "u" ? s.horizontalScrollbarSize : 10,
          horizontalSliderSize: typeof s.horizontalSliderSize < "u" ? s.horizontalSliderSize : 0,
          horizontalHasArrows: typeof s.horizontalHasArrows < "u" ? s.horizontalHasArrows : false,
          vertical: typeof s.vertical < "u" ? s.vertical : 1,
          verticalScrollbarSize: typeof s.verticalScrollbarSize < "u" ? s.verticalScrollbarSize : 10,
          verticalHasArrows: typeof s.verticalHasArrows < "u" ? s.verticalHasArrows : false,
          verticalSliderSize: typeof s.verticalSliderSize < "u" ? s.verticalSliderSize : 0,
          scrollByPage: typeof s.scrollByPage < "u" ? s.scrollByPage : false
        };
        return e.horizontalSliderSize = typeof s.horizontalSliderSize < "u" ? s.horizontalSliderSize : e.horizontalScrollbarSize, e.verticalSliderSize = typeof s.verticalSliderSize < "u" ? s.verticalSliderSize : e.verticalScrollbarSize, _t && (e.className += " mac"), e;
      }
      const Pb = He;
      let LX = class extends he {
        constructor() {
          super(), this.containerDomNode = document.createElement("div"), this.containerDomNode.className = "monaco-hover", this.containerDomNode.tabIndex = 0, this.containerDomNode.setAttribute("role", "tooltip"), this.contentsDomNode = document.createElement("div"), this.contentsDomNode.className = "monaco-hover-content", this.scrollbar = this._register(new PT(this.contentsDomNode, {
            consumeMouseWheelIfScrollbarIsNeeded: true
          })), this.containerDomNode.appendChild(this.scrollbar.getDomNode());
        }
        onContentsChanged() {
          this.scrollbar.scanDomNode();
        }
      };
      class BT extends he {
        static render(e, t, i) {
          return new BT(e, t, i);
        }
        constructor(e, t, i) {
          super(), this.actionLabel = t.label, this.actionKeybindingLabel = i, this.actionContainer = Ne(e, Pb("div.action-container")), this.actionContainer.setAttribute("tabindex", "0"), this.action = Ne(this.actionContainer, Pb("a.action")), this.action.setAttribute("role", "button"), t.iconClass && Ne(this.action, Pb(`span.icon.${t.iconClass}`));
          const n = Ne(this.action, Pb("span"));
          n.textContent = i ? `${t.label} (${i})` : t.label, this._store.add(new kX(this.actionContainer, t.run)), this._store.add(new DX(this.actionContainer, t.run, [
            3,
            10
          ])), this.setEnabled(true);
        }
        setEnabled(e) {
          e ? (this.actionContainer.classList.remove("disabled"), this.actionContainer.removeAttribute("aria-disabled")) : (this.actionContainer.classList.add("disabled"), this.actionContainer.setAttribute("aria-disabled", "true"));
        }
      }
      function xX(s, e) {
        return s && e ? C("acessibleViewHint", "Inspect this in the accessible view with {0}.", e) : s ? C("acessibleViewHintNoKbOpen", "Inspect this in the accessible view via the command Open Accessible View which is currently not triggerable via keybinding.") : "";
      }
      class kX extends he {
        constructor(e, t) {
          super(), this._register(re(e, Ce.CLICK, (i) => {
            i.stopPropagation(), i.preventDefault(), t(e);
          }));
        }
      }
      class DX extends he {
        constructor(e, t, i) {
          super(), this._register(re(e, Ce.KEY_DOWN, (n) => {
            const o = new si(n);
            i.some((r) => o.equals(r)) && (n.stopPropagation(), n.preventDefault(), t(e));
          }));
        }
      }
      const X_ = pt("openerService");
      function EX(s) {
        let e;
        const t = /^L?(\d+)(?:,(\d+))?(-L?(\d+)(?:,(\d+))?)?/.exec(s.fragment);
        return t && (e = {
          startLineNumber: parseInt(t[1]),
          startColumn: t[2] ? parseInt(t[2]) : 1,
          endLineNumber: t[4] ? parseInt(t[4]) : void 0,
          endColumn: t[4] ? t[5] ? parseInt(t[5]) : 1 : void 0
        }, s = s.with({
          fragment: ""
        })), {
          selection: e,
          uri: s
        };
      }
      class ot {
        get event() {
          return this.emitter.event;
        }
        constructor(e, t, i) {
          const n = (o) => this.emitter.fire(o);
          this.emitter = new G({
            onWillAddFirstListener: () => e.addEventListener(t, n, i),
            onDidRemoveLastListener: () => e.removeEventListener(t, n, i)
          });
        }
        dispose() {
          this.emitter.dispose();
        }
      }
      function TX(s, e = {}) {
        const t = FT(e);
        return t.textContent = s, t;
      }
      function NX(s, e = {}) {
        const t = FT(e);
        return w6(t, MX(s, !!e.renderCodeSegments), e.actionHandler, e.renderCodeSegments), t;
      }
      function FT(s) {
        const e = s.inline ? "span" : "div", t = document.createElement(e);
        return s.className && (t.className = s.className), t;
      }
      class IX {
        constructor(e) {
          this.source = e, this.index = 0;
        }
        eos() {
          return this.index >= this.source.length;
        }
        next() {
          const e = this.peek();
          return this.advance(), e;
        }
        peek() {
          return this.source[this.index];
        }
        advance() {
          this.index++;
        }
      }
      function w6(s, e, t, i) {
        let n;
        if (e.type === 2) n = document.createTextNode(e.content || "");
        else if (e.type === 3) n = document.createElement("b");
        else if (e.type === 4) n = document.createElement("i");
        else if (e.type === 7 && i) n = document.createElement("code");
        else if (e.type === 5 && t) {
          const o = document.createElement("a");
          t.disposables.add(ln(o, "click", (r) => {
            t.callback(String(e.index), r);
          })), n = o;
        } else e.type === 8 ? n = document.createElement("br") : e.type === 1 && (n = s);
        n && s !== n && s.appendChild(n), n && Array.isArray(e.children) && e.children.forEach((o) => {
          w6(n, o, t, i);
        });
      }
      function MX(s, e) {
        const t = {
          type: 1,
          children: []
        };
        let i = 0, n = t;
        const o = [], r = new IX(s);
        for (; !r.eos(); ) {
          let a = r.next();
          const l = a === "\\" && xD(r.peek(), e) !== 0;
          if (l && (a = r.next()), !l && AX(a, e) && a === r.peek()) {
            r.advance(), n.type === 2 && (n = o.pop());
            const u = xD(a, e);
            if (n.type === u || n.type === 5 && u === 6) n = o.pop();
            else {
              const d = {
                type: u,
                children: []
              };
              u === 5 && (d.index = i, i++), n.children.push(d), o.push(n), n = d;
            }
          } else if (a === `
`) n.type === 2 && (n = o.pop()), n.children.push({
            type: 8
          });
          else if (n.type !== 2) {
            const u = {
              type: 2,
              content: a
            };
            n.children.push(u), o.push(n), n = u;
          } else n.content += a;
        }
        return n.type === 2 && (n = o.pop()), t;
      }
      function AX(s, e) {
        return xD(s, e) !== 0;
      }
      function xD(s, e) {
        switch (s) {
          case "*":
            return 3;
          case "_":
            return 4;
          case "[":
            return 5;
          case "]":
            return 6;
          case "`":
            return e ? 7 : 0;
          default:
            return 0;
        }
      }
      const RX = new RegExp(`(\\\\)?\\$\\((${wt.iconNameExpression}(?:${wt.iconModifierExpression})?)\\)`, "g");
      function wh(s) {
        const e = new Array();
        let t, i = 0, n = 0;
        for (; (t = RX.exec(s)) !== null; ) {
          n = t.index || 0, i < n && e.push(s.substring(i, n)), i = (t.index || 0) + t[0].length;
          const [, o, r] = t;
          e.push(o ? `$(${r})` : Lv({
            id: r
          }));
        }
        return i < s.length && e.push(s.substring(i)), e;
      }
      function Lv(s) {
        const e = He("span");
        return e.classList.add(...wt.asClassNameArray(s)), e;
      }
      function y6(...s) {
        return function(e, t) {
          for (let i = 0, n = s.length; i < n; i++) {
            const o = s[i](e, t);
            if (o) return o;
          }
          return null;
        };
      }
      S6.bind(void 0, false);
      const xv = S6.bind(void 0, true);
      function S6(s, e, t) {
        if (!t || t.length < e.length) return null;
        let i;
        return s ? i = KE(t, e) : i = t.indexOf(e) === 0, i ? e.length > 0 ? [
          {
            start: 0,
            end: e.length
          }
        ] : [] : null;
      }
      function OX(s, e) {
        const t = e.toLowerCase().indexOf(s.toLowerCase());
        return t === -1 ? null : [
          {
            start: t,
            end: t + s.length
          }
        ];
      }
      function PX(s, e) {
        return kD(s.toLowerCase(), e.toLowerCase(), 0, 0);
      }
      function kD(s, e, t, i) {
        if (t === s.length) return [];
        if (i === e.length) return null;
        if (s[t] === e[i]) {
          let n = null;
          return (n = kD(s, e, t + 1, i + 1)) ? x6({
            start: i,
            end: i + 1
          }, n) : null;
        }
        return kD(s, e, t, i + 1);
      }
      function VT(s) {
        return 97 <= s && s <= 122;
      }
      function fw(s) {
        return 65 <= s && s <= 90;
      }
      function WT(s) {
        return 48 <= s && s <= 57;
      }
      function BX(s) {
        return s === 32 || s === 9 || s === 10 || s === 13;
      }
      const FX = /* @__PURE__ */ new Set();
      "()[]{}<>`'\"-/;:,.?!".split("").forEach((s) => FX.add(s.charCodeAt(0)));
      function L6(s) {
        return VT(s) || fw(s) || WT(s);
      }
      function x6(s, e) {
        return e.length === 0 ? e = [
          s
        ] : s.end === e[0].start ? e[0].start = s.start : e.unshift(s), e;
      }
      function k6(s, e) {
        for (let t = e; t < s.length; t++) {
          const i = s.charCodeAt(t);
          if (fw(i) || WT(i) || t > 0 && !L6(s.charCodeAt(t - 1))) return t;
        }
        return s.length;
      }
      function DD(s, e, t, i) {
        if (t === s.length) return [];
        if (i === e.length) return null;
        if (s[t] !== e[i].toLowerCase()) return null;
        {
          let n = null, o = i + 1;
          for (n = DD(s, e, t + 1, i + 1); !n && (o = k6(e, o)) < e.length; ) n = DD(s, e, t + 1, o), o++;
          return n === null ? null : x6({
            start: i,
            end: i + 1
          }, n);
        }
      }
      function VX(s) {
        let e = 0, t = 0, i = 0, n = 0, o = 0;
        for (let d = 0; d < s.length; d++) o = s.charCodeAt(d), fw(o) && e++, VT(o) && t++, L6(o) && i++, WT(o) && n++;
        const r = e / s.length, a = t / s.length, l = i / s.length, u = n / s.length;
        return {
          upperPercent: r,
          lowerPercent: a,
          alphaPercent: l,
          numericPercent: u
        };
      }
      function WX(s) {
        const { upperPercent: e, lowerPercent: t } = s;
        return t === 0 && e > 0.6;
      }
      function HX(s) {
        const { upperPercent: e, lowerPercent: t, alphaPercent: i, numericPercent: n } = s;
        return t > 0.2 && e < 0.8 && i > 0.6 && n < 0.2;
      }
      function zX(s) {
        let e = 0, t = 0, i = 0, n = 0;
        for (let o = 0; o < s.length; o++) i = s.charCodeAt(o), fw(i) && e++, VT(i) && t++, BX(i) && n++;
        return (e === 0 || t === 0) && n === 0 ? s.length <= 30 : e <= 5;
      }
      function D6(s, e) {
        if (!e || (e = e.trim(), e.length === 0) || !zX(s)) return null;
        e.length > 60 && (e = e.substring(0, 60));
        const t = VX(e);
        if (!HX(t)) {
          if (!WX(t)) return null;
          e = e.toLowerCase();
        }
        let i = null, n = 0;
        for (s = s.toLowerCase(); n < e.length && (i = DD(s, e, 0, n)) === null; ) n = k6(e, n + 1);
        return i;
      }
      const UX = y6(xv, D6, OX), $X = y6(xv, D6, PX), A5 = new K_(1e4);
      function R5(s, e, t = false) {
        if (typeof s != "string" || typeof e != "string") return null;
        let i = A5.get(s);
        i || (i = new RegExp(Tq(s), "i"), A5.set(s, i));
        const n = i.exec(e);
        return n ? [
          {
            start: n.index,
            end: n.index + n[0].length
          }
        ] : t ? $X(s, e) : UX(s, e);
      }
      function qX(s, e) {
        const t = N6(s, s.toLowerCase(), 0, e, e.toLowerCase(), 0, {
          firstMatchCanBeWeak: true,
          boostFullMatch: true
        });
        return t ? KX(t) : null;
      }
      function KX(s) {
        if (typeof s > "u") return [];
        const e = [], t = s[1];
        for (let i = s.length - 1; i > 1; i--) {
          const n = s[i] + t, o = e[e.length - 1];
          o && o.end === n ? o.end = n + 1 : e.push({
            start: n,
            end: n + 1
          });
        }
        return e;
      }
      const Uc = 128;
      function HT() {
        const s = [], e = [];
        for (let t = 0; t <= Uc; t++) e[t] = 0;
        for (let t = 0; t <= Uc; t++) s.push(e.slice(0));
        return s;
      }
      function E6(s) {
        const e = [];
        for (let t = 0; t <= s; t++) e[t] = 0;
        return e;
      }
      const T6 = E6(2 * Uc), ED = E6(2 * Uc), al = HT(), Bu = HT(), Bb = HT();
      function Fb(s, e) {
        if (e < 0 || e >= s.length) return false;
        const t = s.codePointAt(e);
        switch (t) {
          case 95:
          case 45:
          case 46:
          case 32:
          case 47:
          case 92:
          case 39:
          case 34:
          case 58:
          case 36:
          case 60:
          case 62:
          case 40:
          case 41:
          case 91:
          case 93:
          case 123:
          case 125:
            return true;
          case void 0:
            return false;
          default:
            return !!QE(t);
        }
      }
      function O5(s, e) {
        if (e < 0 || e >= s.length) return false;
        switch (s.charCodeAt(e)) {
          case 32:
          case 9:
            return true;
          default:
            return false;
        }
      }
      function k0(s, e, t) {
        return e[s] !== t[s];
      }
      function jX(s, e, t, i, n, o, r = false) {
        for (; e < t && n < o; ) s[e] === i[n] && (r && (T6[e] = n), e += 1), n += 1;
        return e === t;
      }
      var Ff;
      (function(s) {
        s.Default = [
          -100,
          0
        ];
        function e(t) {
          return !t || t.length === 2 && t[0] === -100 && t[1] === 0;
        }
        s.isDefault = e;
      })(Ff || (Ff = {}));
      const _GX = class _GX {
        constructor(e, t) {
          this.firstMatchCanBeWeak = e, this.boostFullMatch = t;
        }
      };
      _GX.default = {
        boostFullMatch: true,
        firstMatchCanBeWeak: false
      };
      let GX = _GX;
      function N6(s, e, t, i, n, o, r = GX.default) {
        const a = s.length > Uc ? Uc : s.length, l = i.length > Uc ? Uc : i.length;
        if (t >= a || o >= l || a - t > l - o || !jX(e, t, a, n, o, l, true)) return;
        YX(a, l, t, o, e, n);
        let u = 1, d = 1, f = t, m = o;
        const _ = [
          false
        ];
        for (u = 1, f = t; f < a; u++, f++) {
          const L = T6[f], D = ED[f], k = f + 1 < a ? ED[f + 1] : l;
          for (d = L - o + 1, m = L; m < k; d++, m++) {
            let T = Number.MIN_SAFE_INTEGER, M = false;
            m <= D && (T = ZX(s, e, f, t, i, n, m, l, o, al[u - 1][d - 1] === 0, _));
            let I = 0;
            T !== Number.MAX_SAFE_INTEGER && (M = true, I = T + Bu[u - 1][d - 1]);
            const R = m > L, A = R ? Bu[u][d - 1] + (al[u][d - 1] > 0 ? -5 : 0) : 0, Y = m > L + 1 && al[u][d - 1] > 0, U = Y ? Bu[u][d - 2] + (al[u][d - 2] > 0 ? -5 : 0) : 0;
            if (Y && (!R || U >= A) && (!M || U >= I)) Bu[u][d] = U, Bb[u][d] = 3, al[u][d] = 0;
            else if (R && (!M || A >= I)) Bu[u][d] = A, Bb[u][d] = 2, al[u][d] = 0;
            else if (M) Bu[u][d] = I, Bb[u][d] = 1, al[u][d] = al[u - 1][d - 1] + 1;
            else throw new Error("not possible");
          }
        }
        if (!_[0] && !r.firstMatchCanBeWeak) return;
        u--, d--;
        const b = [
          Bu[u][d],
          o
        ];
        let v = 0, y = 0;
        for (; u >= 1; ) {
          let L = d;
          do {
            const D = Bb[u][L];
            if (D === 3) L = L - 2;
            else if (D === 2) L = L - 1;
            else break;
          } while (L >= 1);
          v > 1 && e[t + u - 1] === n[o + d - 1] && !k0(L + o - 1, i, n) && v + 1 > al[u][L] && (L = d), L === d ? v++ : v = 1, y || (y = L), u--, d = L - 1, b.push(d);
        }
        l - o === a && r.boostFullMatch && (b[0] += 2);
        const x = y - a;
        return b[0] -= x, b;
      }
      function YX(s, e, t, i, n, o) {
        let r = s - 1, a = e - 1;
        for (; r >= t && a >= i; ) n[r] === o[a] && (ED[r] = a, r--), a--;
      }
      function ZX(s, e, t, i, n, o, r, a, l, u, d) {
        if (e[t] !== o[r]) return Number.MIN_SAFE_INTEGER;
        let f = 1, m = false;
        return r === t - i ? f = s[t] === n[r] ? 7 : 5 : k0(r, n, o) && (r === 0 || !k0(r - 1, n, o)) ? (f = s[t] === n[r] ? 7 : 5, m = true) : Fb(o, r) && (r === 0 || !Fb(o, r - 1)) ? f = 5 : (Fb(o, r - 1) || O5(o, r - 1)) && (f = 5, m = true), f > 1 && t === i && (d[0] = true), m || (m = k0(r, n, o) || Fb(o, r - 1) || O5(o, r - 1)), t === i ? r > l && (f -= m ? 3 : 5) : u ? f += m ? 2 : 0 : f += m ? 0 : 1, r + 1 === a && (f -= m ? 3 : 5), f;
      }
      const QX = "$(", zT = new RegExp(`\\$\\(${wt.iconNameExpression}(?:${wt.iconModifierExpression})?\\)`, "g"), XX = new RegExp(`(\\\\)?${zT.source}`, "g");
      function JX(s) {
        return s.replace(XX, (e, t) => t ? e : `\\${e}`);
      }
      const eJ = new RegExp(`\\\\${zT.source}`, "g");
      function tJ(s) {
        return s.replace(eJ, (e) => `\\${e}`);
      }
      const iJ = new RegExp(`(\\s)?(\\\\)?${zT.source}(\\s)?`, "g");
      function I6(s) {
        return s.indexOf(QX) === -1 ? s : s.replace(iJ, (e, t, i, n) => i ? e : t || n || "");
      }
      function nJ(s) {
        return s ? s.replace(/\$\((.*?)\)/g, (e, t) => ` ${t} `).trim() : "";
      }
      const qL = new RegExp(`\\$\\(${wt.iconNameCharacter}+\\)`, "g");
      function sp(s) {
        qL.lastIndex = 0;
        let e = "";
        const t = [];
        let i = 0;
        for (; ; ) {
          const n = qL.lastIndex, o = qL.exec(s), r = s.substring(n, o == null ? void 0 : o.index);
          if (r.length > 0) {
            e += r;
            for (let a = 0; a < r.length; a++) t.push(i);
          }
          if (!o) break;
          i += o[0].length;
        }
        return {
          text: e,
          iconOffsets: t
        };
      }
      function KL(s, e, t = false) {
        const { text: i, iconOffsets: n } = e;
        if (!n || n.length === 0) return R5(s, i, t);
        const o = WC(i, " "), r = i.length - o.length, a = R5(s, o, t);
        if (a) for (const l of a) {
          const u = n[l.start + r] + r;
          l.start += u, l.end += u;
        }
        return a;
      }
      function ll(s) {
        return J0(s, true);
      }
      class sJ {
        constructor(e) {
          this._ignorePathCasing = e;
        }
        compare(e, t, i = false) {
          return e === t ? 0 : Rk(this.getComparisonKey(e, i), this.getComparisonKey(t, i));
        }
        isEqual(e, t, i = false) {
          return e === t ? true : !e || !t ? false : this.getComparisonKey(e, i) === this.getComparisonKey(t, i);
        }
        getComparisonKey(e, t = false) {
          return e.with({
            path: this._ignorePathCasing(e) ? e.path.toLowerCase() : void 0,
            fragment: t ? null : void 0
          }).toString();
        }
        isEqualOrParent(e, t, i = false) {
          if (e.scheme === t.scheme) {
            if (e.scheme === it.file) return mD(ll(e), ll(t), this._ignorePathCasing(e)) && e.query === t.query && (i || e.fragment === t.fragment);
            if (B5(e.authority, t.authority)) return mD(e.path, t.path, this._ignorePathCasing(e), "/") && e.query === t.query && (i || e.fragment === t.fragment);
          }
          return false;
        }
        joinPath(e, ...t) {
          return st.joinPath(e, ...t);
        }
        basenameOrAuthority(e) {
          return UT(e) || e.authority;
        }
        basename(e) {
          return Ii.basename(e.path);
        }
        extname(e) {
          return Ii.extname(e.path);
        }
        dirname(e) {
          if (e.path.length === 0) return e;
          let t;
          return e.scheme === it.file ? t = st.file(aq(ll(e))).path : (t = Ii.dirname(e.path), e.authority && t.length && t.charCodeAt(0) !== 47 && (console.error(`dirname("${e.toString})) resulted in a relative path`), t = "/")), e.with({
            path: t
          });
        }
        normalizePath(e) {
          if (!e.path.length) return e;
          let t;
          return e.scheme === it.file ? t = st.file(m9(ll(e))).path : t = Ii.normalize(e.path), e.with({
            path: t
          });
        }
        relativePath(e, t) {
          if (e.scheme !== t.scheme || !B5(e.authority, t.authority)) return;
          if (e.scheme === it.file) {
            const o = rq(ll(e), ll(t));
            return Ks ? K8(o) : o;
          }
          let i = e.path || "/";
          const n = t.path || "/";
          if (this._ignorePathCasing(e)) {
            let o = 0;
            for (const r = Math.min(i.length, n.length); o < r && !(i.charCodeAt(o) !== n.charCodeAt(o) && i.charAt(o).toLowerCase() !== n.charAt(o).toLowerCase()); o++) ;
            i = n.substr(0, o) + i.substr(o);
          }
          return Ii.relative(i, n);
        }
        resolvePath(e, t) {
          if (e.scheme === it.file) {
            const i = st.file(oq(ll(e), t));
            return e.with({
              authority: i.authority,
              path: i.path
            });
          }
          return t = lZ(t), e.with({
            path: Ii.resolve(e.path, t)
          });
        }
        isAbsolutePath(e) {
          return !!e.path && e.path[0] === "/";
        }
        isEqualAuthority(e, t) {
          return e === t || e !== void 0 && t !== void 0 && uf(e, t);
        }
        hasTrailingPathSeparator(e, t = Jc) {
          if (e.scheme === it.file) {
            const i = ll(e);
            return i.length > c5(i).length && i[i.length - 1] === t;
          } else {
            const i = e.path;
            return i.length > 1 && i.charCodeAt(i.length - 1) === 47 && !/^[a-zA-Z]:(\/$|\\$)/.test(e.fsPath);
          }
        }
        removeTrailingPathSeparator(e, t = Jc) {
          return F5(e, t) ? e.with({
            path: e.path.substr(0, e.path.length - 1)
          }) : e;
        }
        addTrailingPathSeparator(e, t = Jc) {
          let i = false;
          if (e.scheme === it.file) {
            const n = ll(e);
            i = n !== void 0 && n.length === c5(n).length && n[n.length - 1] === t;
          } else {
            t = "/";
            const n = e.path;
            i = n.length === 1 && n.charCodeAt(n.length - 1) === 47;
          }
          return !i && !F5(e, t) ? e.with({
            path: e.path + "/"
          }) : e;
        }
      }
      const li = new sJ(() => false), oJ = li.isEqual.bind(li);
      li.isEqualOrParent.bind(li);
      li.getComparisonKey.bind(li);
      li.basenameOrAuthority.bind(li);
      const UT = li.basename.bind(li);
      li.extname.bind(li);
      const rJ = li.dirname.bind(li);
      li.joinPath.bind(li);
      const aJ = li.normalizePath.bind(li);
      li.relativePath.bind(li);
      const P5 = li.resolvePath.bind(li);
      li.isAbsolutePath.bind(li);
      const B5 = li.isEqualAuthority.bind(li), F5 = li.hasTrailingPathSeparator.bind(li);
      li.removeTrailingPathSeparator.bind(li);
      li.addTrailingPathSeparator.bind(li);
      var kv;
      (function(s) {
        s.META_DATA_LABEL = "label", s.META_DATA_DESCRIPTION = "description", s.META_DATA_SIZE = "size", s.META_DATA_MIME = "mime";
        function e(t) {
          const i = /* @__PURE__ */ new Map();
          t.path.substring(t.path.indexOf(";") + 1, t.path.lastIndexOf(";")).split(";").forEach((r) => {
            const [a, l] = r.split(":");
            a && l && i.set(a, l);
          });
          const o = t.path.substring(0, t.path.indexOf(";"));
          return o && i.set(s.META_DATA_MIME, o), i;
        }
        s.parseMetaData = e;
      })(kv || (kv = {}));
      class M6 {
        constructor(e = "", t = false) {
          if (this.value = e, typeof this.value != "string") throw FC("value");
          typeof t == "boolean" ? (this.isTrusted = t, this.supportThemeIcons = false, this.supportHtml = false) : (this.isTrusted = t.isTrusted ?? void 0, this.supportThemeIcons = t.supportThemeIcons ?? false, this.supportHtml = t.supportHtml ?? false);
        }
        appendText(e, t = 0) {
          return this.value += cJ(this.supportThemeIcons ? JX(e) : e).replace(/([ \t]+)/g, (i, n) => "&nbsp;".repeat(n.length)).replace(/\>/gm, "\\>").replace(/\n/g, t === 1 ? `\\
` : `

`), this;
        }
        appendMarkdown(e) {
          return this.value += e, this;
        }
        appendCodeblock(e, t) {
          return this.value += `
${uJ(t, e)}
`, this;
        }
        appendLink(e, t, i) {
          return this.value += "[", this.value += this._escape(t, "]"), this.value += "](", this.value += this._escape(String(e), ")"), i && (this.value += ` "${this._escape(this._escape(i, '"'), ")")}"`), this.value += ")", this;
        }
        _escape(e, t) {
          const i = new RegExp($l(t), "g");
          return e.replace(i, (n, o) => e.charAt(o - 1) !== "\\" ? `\\${n}` : n);
        }
      }
      function Vf(s) {
        return s instanceof M6 ? true : s && typeof s == "object" ? typeof s.value == "string" && (typeof s.isTrusted == "boolean" || typeof s.isTrusted == "object" || s.isTrusted === void 0) && (typeof s.supportThemeIcons == "boolean" || s.supportThemeIcons === void 0) : false;
      }
      function lJ(s, e) {
        return s === e ? true : !s || !e ? false : s.value === e.value && s.isTrusted === e.isTrusted && s.supportThemeIcons === e.supportThemeIcons && s.supportHtml === e.supportHtml && (s.baseUri === e.baseUri || !!s.baseUri && !!e.baseUri && oJ(st.from(s.baseUri), st.from(e.baseUri)));
      }
      function cJ(s) {
        return s.replace(/[\\`*_{}[\]()#+\-!~]/g, "\\$&");
      }
      function uJ(s, e) {
        var _a3;
        const t = ((_a3 = s.match(/^`+/gm)) == null ? void 0 : _a3.reduce((n, o) => n.length > o.length ? n : o).length) ?? 0, i = t >= 3 ? t + 1 : 3;
        return [
          `${"`".repeat(i)}${e}`,
          s,
          `${"`".repeat(i)}`
        ].join(`
`);
      }
      function Vb(s) {
        return s.replace(/"/g, "&quot;");
      }
      function jL(s) {
        return s && s.replace(/\\([\\`*_{}[\]()#+\-.!~])/g, "$1");
      }
      function hJ(s) {
        const e = [], t = s.split("|").map((n) => n.trim());
        s = t[0];
        const i = t[1];
        if (i) {
          const n = /height=(\d+)/.exec(i), o = /width=(\d+)/.exec(i), r = n ? n[1] : "", a = o ? o[1] : "", l = isFinite(parseInt(a)), u = isFinite(parseInt(r));
          l && e.push(`width="${a}"`), u && e.push(`height="${r}"`);
        }
        return {
          href: s,
          dimensions: e
        };
      }
      class A6 {
        constructor(e) {
          this._prefix = e, this._lastId = 0;
        }
        nextId() {
          return this._prefix + ++this._lastId;
        }
      }
      const V5 = new A6("id#");
      let Kn = {};
      (function() {
        function s(e, t) {
          t(Kn);
        }
        s.amd = true, function(e, t) {
          typeof s == "function" && s.amd ? s([
            "exports"
          ], t) : typeof exports == "object" && typeof module < "u" ? t(exports) : (e = typeof globalThis < "u" ? globalThis : e || self, t(e.marked = {}));
        }(this, function(e) {
          function t() {
            return {
              async: false,
              breaks: false,
              extensions: null,
              gfm: true,
              hooks: null,
              pedantic: false,
              renderer: null,
              silent: false,
              tokenizer: null,
              walkTokens: null
            };
          }
          e.defaults = t();
          function i(nt) {
            e.defaults = nt;
          }
          const n = /[&<>"']/, o = new RegExp(n.source, "g"), r = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/, a = new RegExp(r.source, "g"), l = {
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
            '"': "&quot;",
            "'": "&#39;"
          }, u = (nt) => l[nt];
          function d(nt, P) {
            if (P) {
              if (n.test(nt)) return nt.replace(o, u);
            } else if (r.test(nt)) return nt.replace(a, u);
            return nt;
          }
          const f = /(^|[^\[])\^/g;
          function m(nt, P) {
            let F = typeof nt == "string" ? nt : nt.source;
            P = P || "";
            const V = {
              replace: ($, Z) => {
                let ce = typeof Z == "string" ? Z : Z.source;
                return ce = ce.replace(f, "$1"), F = F.replace($, ce), V;
              },
              getRegex: () => new RegExp(F, P)
            };
            return V;
          }
          function _(nt) {
            try {
              nt = encodeURI(nt).replace(/%25/g, "%");
            } catch {
              return null;
            }
            return nt;
          }
          const b = {
            exec: () => null
          };
          function v(nt, P) {
            const F = nt.replace(/\|/g, (Z, ce, _e2) => {
              let Re = false, Fe = ce;
              for (; --Fe >= 0 && _e2[Fe] === "\\"; ) Re = !Re;
              return Re ? "|" : " |";
            }), V = F.split(/ \|/);
            let $ = 0;
            if (V[0].trim() || V.shift(), V.length > 0 && !V[V.length - 1].trim() && V.pop(), P) if (V.length > P) V.splice(P);
            else for (; V.length < P; ) V.push("");
            for (; $ < V.length; $++) V[$] = V[$].trim().replace(/\\\|/g, "|");
            return V;
          }
          function y(nt, P, F) {
            const V = nt.length;
            if (V === 0) return "";
            let $ = 0;
            for (; $ < V && nt.charAt(V - $ - 1) === P; ) $++;
            return nt.slice(0, V - $);
          }
          function x(nt, P) {
            if (nt.indexOf(P[1]) === -1) return -1;
            let F = 0;
            for (let V = 0; V < nt.length; V++) if (nt[V] === "\\") V++;
            else if (nt[V] === P[0]) F++;
            else if (nt[V] === P[1] && (F--, F < 0)) return V;
            return -1;
          }
          function L(nt, P, F, V) {
            const $ = P.href, Z = P.title ? d(P.title) : null, ce = nt[1].replace(/\\([\[\]])/g, "$1");
            if (nt[0].charAt(0) !== "!") {
              V.state.inLink = true;
              const _e2 = {
                type: "link",
                raw: F,
                href: $,
                title: Z,
                text: ce,
                tokens: V.inlineTokens(ce)
              };
              return V.state.inLink = false, _e2;
            }
            return {
              type: "image",
              raw: F,
              href: $,
              title: Z,
              text: d(ce)
            };
          }
          function D(nt, P) {
            const F = nt.match(/^(\s+)(?:```)/);
            if (F === null) return P;
            const V = F[1];
            return P.split(`
`).map(($) => {
              const Z = $.match(/^\s+/);
              if (Z === null) return $;
              const [ce] = Z;
              return ce.length >= V.length ? $.slice(V.length) : $;
            }).join(`
`);
          }
          class k {
            constructor(P) {
              __publicField(this, "options");
              __publicField(this, "rules");
              __publicField(this, "lexer");
              this.options = P || e.defaults;
            }
            space(P) {
              const F = this.rules.block.newline.exec(P);
              if (F && F[0].length > 0) return {
                type: "space",
                raw: F[0]
              };
            }
            code(P) {
              const F = this.rules.block.code.exec(P);
              if (F) {
                const V = F[0].replace(/^ {1,4}/gm, "");
                return {
                  type: "code",
                  raw: F[0],
                  codeBlockStyle: "indented",
                  text: this.options.pedantic ? V : y(V, `
`)
                };
              }
            }
            fences(P) {
              const F = this.rules.block.fences.exec(P);
              if (F) {
                const V = F[0], $ = D(V, F[3] || "");
                return {
                  type: "code",
                  raw: V,
                  lang: F[2] ? F[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : F[2],
                  text: $
                };
              }
            }
            heading(P) {
              const F = this.rules.block.heading.exec(P);
              if (F) {
                let V = F[2].trim();
                if (/#$/.test(V)) {
                  const $ = y(V, "#");
                  (this.options.pedantic || !$ || / $/.test($)) && (V = $.trim());
                }
                return {
                  type: "heading",
                  raw: F[0],
                  depth: F[1].length,
                  text: V,
                  tokens: this.lexer.inline(V)
                };
              }
            }
            hr(P) {
              const F = this.rules.block.hr.exec(P);
              if (F) return {
                type: "hr",
                raw: y(F[0], `
`)
              };
            }
            blockquote(P) {
              const F = this.rules.block.blockquote.exec(P);
              if (F) {
                let V = y(F[0], `
`).split(`
`), $ = "", Z = "";
                const ce = [];
                for (; V.length > 0; ) {
                  let _e2 = false;
                  const Re = [];
                  let Fe;
                  for (Fe = 0; Fe < V.length; Fe++) if (/^ {0,3}>/.test(V[Fe])) Re.push(V[Fe]), _e2 = true;
                  else if (!_e2) Re.push(V[Fe]);
                  else break;
                  V = V.slice(Fe);
                  const tt = Re.join(`
`), xt = tt.replace(/\n {0,3}((?:=+|-+) *)(?=\n|$)/g, `
    $1`).replace(/^ {0,3}>[ \t]?/gm, "");
                  $ = $ ? `${$}
${tt}` : tt, Z = Z ? `${Z}
${xt}` : xt;
                  const At = this.lexer.state.top;
                  if (this.lexer.state.top = true, this.lexer.blockTokens(xt, ce, true), this.lexer.state.top = At, V.length === 0) break;
                  const fi = ce[ce.length - 1];
                  if ((fi == null ? void 0 : fi.type) === "code") break;
                  if ((fi == null ? void 0 : fi.type) === "blockquote") {
                    const Gt = fi, fn = Gt.raw + `
` + V.join(`
`), xn = this.blockquote(fn);
                    ce[ce.length - 1] = xn, $ = $.substring(0, $.length - Gt.raw.length) + xn.raw, Z = Z.substring(0, Z.length - Gt.text.length) + xn.text;
                    break;
                  } else if ((fi == null ? void 0 : fi.type) === "list") {
                    const Gt = fi, fn = Gt.raw + `
` + V.join(`
`), xn = this.list(fn);
                    ce[ce.length - 1] = xn, $ = $.substring(0, $.length - fi.raw.length) + xn.raw, Z = Z.substring(0, Z.length - Gt.raw.length) + xn.raw, V = fn.substring(ce[ce.length - 1].raw.length).split(`
`);
                    continue;
                  }
                }
                return {
                  type: "blockquote",
                  raw: $,
                  tokens: ce,
                  text: Z
                };
              }
            }
            list(P) {
              let F = this.rules.block.list.exec(P);
              if (F) {
                let V = F[1].trim();
                const $ = V.length > 1, Z = {
                  type: "list",
                  raw: "",
                  ordered: $,
                  start: $ ? +V.slice(0, -1) : "",
                  loose: false,
                  items: []
                };
                V = $ ? `\\d{1,9}\\${V.slice(-1)}` : `\\${V}`, this.options.pedantic && (V = $ ? V : "[*+-]");
                const ce = new RegExp(`^( {0,3}${V})((?:[	 ][^\\n]*)?(?:\\n|$))`);
                let _e2 = false;
                for (; P; ) {
                  let Re = false, Fe = "", tt = "";
                  if (!(F = ce.exec(P)) || this.rules.block.hr.test(P)) break;
                  Fe = F[0], P = P.substring(Fe.length);
                  let xt = F[2].split(`
`, 1)[0].replace(/^\t+/, (Hi) => " ".repeat(3 * Hi.length)), At = P.split(`
`, 1)[0], fi = !xt.trim(), Gt = 0;
                  if (this.options.pedantic ? (Gt = 2, tt = xt.trimStart()) : fi ? Gt = F[1].length + 1 : (Gt = F[2].search(/[^ ]/), Gt = Gt > 4 ? 1 : Gt, tt = xt.slice(Gt), Gt += F[1].length), fi && /^ *$/.test(At) && (Fe += At + `
`, P = P.substring(At.length + 1), Re = true), !Re) {
                    const Hi = new RegExp(`^ {0,${Math.min(3, Gt - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`), je = new RegExp(`^ {0,${Math.min(3, Gt - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`), ie = new RegExp(`^ {0,${Math.min(3, Gt - 1)}}(?:\`\`\`|~~~)`), De = new RegExp(`^ {0,${Math.min(3, Gt - 1)}}#`);
                    for (; P; ) {
                      const ze = P.split(`
`, 1)[0];
                      if (At = ze, this.options.pedantic && (At = At.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ")), ie.test(At) || De.test(At) || Hi.test(At) || je.test(P)) break;
                      if (At.search(/[^ ]/) >= Gt || !At.trim()) tt += `
` + At.slice(Gt);
                      else {
                        if (fi || xt.search(/[^ ]/) >= 4 || ie.test(xt) || De.test(xt) || je.test(xt)) break;
                        tt += `
` + At;
                      }
                      !fi && !At.trim() && (fi = true), Fe += ze + `
`, P = P.substring(ze.length + 1), xt = At.slice(Gt);
                    }
                  }
                  Z.loose || (_e2 ? Z.loose = true : /\n *\n *$/.test(Fe) && (_e2 = true));
                  let fn = null, xn;
                  this.options.gfm && (fn = /^\[[ xX]\] /.exec(tt), fn && (xn = fn[0] !== "[ ] ", tt = tt.replace(/^\[[ xX]\] +/, ""))), Z.items.push({
                    type: "list_item",
                    raw: Fe,
                    task: !!fn,
                    checked: xn,
                    loose: false,
                    text: tt,
                    tokens: []
                  }), Z.raw += Fe;
                }
                Z.items[Z.items.length - 1].raw = Z.items[Z.items.length - 1].raw.trimEnd(), Z.items[Z.items.length - 1].text = Z.items[Z.items.length - 1].text.trimEnd(), Z.raw = Z.raw.trimEnd();
                for (let Re = 0; Re < Z.items.length; Re++) if (this.lexer.state.top = false, Z.items[Re].tokens = this.lexer.blockTokens(Z.items[Re].text, []), !Z.loose) {
                  const Fe = Z.items[Re].tokens.filter((xt) => xt.type === "space"), tt = Fe.length > 0 && Fe.some((xt) => /\n.*\n/.test(xt.raw));
                  Z.loose = tt;
                }
                if (Z.loose) for (let Re = 0; Re < Z.items.length; Re++) Z.items[Re].loose = true;
                return Z;
              }
            }
            html(P) {
              const F = this.rules.block.html.exec(P);
              if (F) return {
                type: "html",
                block: true,
                raw: F[0],
                pre: F[1] === "pre" || F[1] === "script" || F[1] === "style",
                text: F[0]
              };
            }
            def(P) {
              const F = this.rules.block.def.exec(P);
              if (F) {
                const V = F[1].toLowerCase().replace(/\s+/g, " "), $ = F[2] ? F[2].replace(/^<(.*)>$/, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "", Z = F[3] ? F[3].substring(1, F[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : F[3];
                return {
                  type: "def",
                  tag: V,
                  raw: F[0],
                  href: $,
                  title: Z
                };
              }
            }
            table(P) {
              const F = this.rules.block.table.exec(P);
              if (!F || !/[:|]/.test(F[2])) return;
              const V = v(F[1]), $ = F[2].replace(/^\||\| *$/g, "").split("|"), Z = F[3] && F[3].trim() ? F[3].replace(/\n[ \t]*$/, "").split(`
`) : [], ce = {
                type: "table",
                raw: F[0],
                header: [],
                align: [],
                rows: []
              };
              if (V.length === $.length) {
                for (const _e2 of $) /^ *-+: *$/.test(_e2) ? ce.align.push("right") : /^ *:-+: *$/.test(_e2) ? ce.align.push("center") : /^ *:-+ *$/.test(_e2) ? ce.align.push("left") : ce.align.push(null);
                for (let _e2 = 0; _e2 < V.length; _e2++) ce.header.push({
                  text: V[_e2],
                  tokens: this.lexer.inline(V[_e2]),
                  header: true,
                  align: ce.align[_e2]
                });
                for (const _e2 of Z) ce.rows.push(v(_e2, ce.header.length).map((Re, Fe) => ({
                  text: Re,
                  tokens: this.lexer.inline(Re),
                  header: false,
                  align: ce.align[Fe]
                })));
                return ce;
              }
            }
            lheading(P) {
              const F = this.rules.block.lheading.exec(P);
              if (F) return {
                type: "heading",
                raw: F[0],
                depth: F[2].charAt(0) === "=" ? 1 : 2,
                text: F[1],
                tokens: this.lexer.inline(F[1])
              };
            }
            paragraph(P) {
              const F = this.rules.block.paragraph.exec(P);
              if (F) {
                const V = F[1].charAt(F[1].length - 1) === `
` ? F[1].slice(0, -1) : F[1];
                return {
                  type: "paragraph",
                  raw: F[0],
                  text: V,
                  tokens: this.lexer.inline(V)
                };
              }
            }
            text(P) {
              const F = this.rules.block.text.exec(P);
              if (F) return {
                type: "text",
                raw: F[0],
                text: F[0],
                tokens: this.lexer.inline(F[0])
              };
            }
            escape(P) {
              const F = this.rules.inline.escape.exec(P);
              if (F) return {
                type: "escape",
                raw: F[0],
                text: d(F[1])
              };
            }
            tag(P) {
              const F = this.rules.inline.tag.exec(P);
              if (F) return !this.lexer.state.inLink && /^<a /i.test(F[0]) ? this.lexer.state.inLink = true : this.lexer.state.inLink && /^<\/a>/i.test(F[0]) && (this.lexer.state.inLink = false), !this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(F[0]) ? this.lexer.state.inRawBlock = true : this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(F[0]) && (this.lexer.state.inRawBlock = false), {
                type: "html",
                raw: F[0],
                inLink: this.lexer.state.inLink,
                inRawBlock: this.lexer.state.inRawBlock,
                block: false,
                text: F[0]
              };
            }
            link(P) {
              const F = this.rules.inline.link.exec(P);
              if (F) {
                const V = F[2].trim();
                if (!this.options.pedantic && /^</.test(V)) {
                  if (!/>$/.test(V)) return;
                  const ce = y(V.slice(0, -1), "\\");
                  if ((V.length - ce.length) % 2 === 0) return;
                } else {
                  const ce = x(F[2], "()");
                  if (ce > -1) {
                    const Re = (F[0].indexOf("!") === 0 ? 5 : 4) + F[1].length + ce;
                    F[2] = F[2].substring(0, ce), F[0] = F[0].substring(0, Re).trim(), F[3] = "";
                  }
                }
                let $ = F[2], Z = "";
                if (this.options.pedantic) {
                  const ce = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec($);
                  ce && ($ = ce[1], Z = ce[3]);
                } else Z = F[3] ? F[3].slice(1, -1) : "";
                return $ = $.trim(), /^</.test($) && (this.options.pedantic && !/>$/.test(V) ? $ = $.slice(1) : $ = $.slice(1, -1)), L(F, {
                  href: $ && $.replace(this.rules.inline.anyPunctuation, "$1"),
                  title: Z && Z.replace(this.rules.inline.anyPunctuation, "$1")
                }, F[0], this.lexer);
              }
            }
            reflink(P, F) {
              let V;
              if ((V = this.rules.inline.reflink.exec(P)) || (V = this.rules.inline.nolink.exec(P))) {
                const $ = (V[2] || V[1]).replace(/\s+/g, " "), Z = F[$.toLowerCase()];
                if (!Z) {
                  const ce = V[0].charAt(0);
                  return {
                    type: "text",
                    raw: ce,
                    text: ce
                  };
                }
                return L(V, Z, V[0], this.lexer);
              }
            }
            emStrong(P, F, V = "") {
              let $ = this.rules.inline.emStrongLDelim.exec(P);
              if (!$ || $[3] && V.match(/[\p{L}\p{N}]/u)) return;
              if (!($[1] || $[2] || "") || !V || this.rules.inline.punctuation.exec(V)) {
                const ce = [
                  ...$[0]
                ].length - 1;
                let _e2, Re, Fe = ce, tt = 0;
                const xt = $[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
                for (xt.lastIndex = 0, F = F.slice(-1 * P.length + ce); ($ = xt.exec(F)) != null; ) {
                  if (_e2 = $[1] || $[2] || $[3] || $[4] || $[5] || $[6], !_e2) continue;
                  if (Re = [
                    ..._e2
                  ].length, $[3] || $[4]) {
                    Fe += Re;
                    continue;
                  } else if (($[5] || $[6]) && ce % 3 && !((ce + Re) % 3)) {
                    tt += Re;
                    continue;
                  }
                  if (Fe -= Re, Fe > 0) continue;
                  Re = Math.min(Re, Re + Fe + tt);
                  const At = [
                    ...$[0]
                  ][0].length, fi = P.slice(0, ce + $.index + At + Re);
                  if (Math.min(ce, Re) % 2) {
                    const fn = fi.slice(1, -1);
                    return {
                      type: "em",
                      raw: fi,
                      text: fn,
                      tokens: this.lexer.inlineTokens(fn)
                    };
                  }
                  const Gt = fi.slice(2, -2);
                  return {
                    type: "strong",
                    raw: fi,
                    text: Gt,
                    tokens: this.lexer.inlineTokens(Gt)
                  };
                }
              }
            }
            codespan(P) {
              const F = this.rules.inline.code.exec(P);
              if (F) {
                let V = F[2].replace(/\n/g, " ");
                const $ = /[^ ]/.test(V), Z = /^ /.test(V) && / $/.test(V);
                return $ && Z && (V = V.substring(1, V.length - 1)), V = d(V, true), {
                  type: "codespan",
                  raw: F[0],
                  text: V
                };
              }
            }
            br(P) {
              const F = this.rules.inline.br.exec(P);
              if (F) return {
                type: "br",
                raw: F[0]
              };
            }
            del(P) {
              const F = this.rules.inline.del.exec(P);
              if (F) return {
                type: "del",
                raw: F[0],
                text: F[2],
                tokens: this.lexer.inlineTokens(F[2])
              };
            }
            autolink(P) {
              const F = this.rules.inline.autolink.exec(P);
              if (F) {
                let V, $;
                return F[2] === "@" ? (V = d(F[1]), $ = "mailto:" + V) : (V = d(F[1]), $ = V), {
                  type: "link",
                  raw: F[0],
                  text: V,
                  href: $,
                  tokens: [
                    {
                      type: "text",
                      raw: V,
                      text: V
                    }
                  ]
                };
              }
            }
            url(P) {
              var _a3;
              let F;
              if (F = this.rules.inline.url.exec(P)) {
                let V, $;
                if (F[2] === "@") V = d(F[0]), $ = "mailto:" + V;
                else {
                  let Z;
                  do
                    Z = F[0], F[0] = ((_a3 = this.rules.inline._backpedal.exec(F[0])) == null ? void 0 : _a3[0]) ?? "";
                  while (Z !== F[0]);
                  V = d(F[0]), F[1] === "www." ? $ = "http://" + F[0] : $ = F[0];
                }
                return {
                  type: "link",
                  raw: F[0],
                  text: V,
                  href: $,
                  tokens: [
                    {
                      type: "text",
                      raw: V,
                      text: V
                    }
                  ]
                };
              }
            }
            inlineText(P) {
              const F = this.rules.inline.text.exec(P);
              if (F) {
                let V;
                return this.lexer.state.inRawBlock ? V = F[0] : V = d(F[0]), {
                  type: "text",
                  raw: F[0],
                  text: V
                };
              }
            }
          }
          const T = /^(?: *(?:\n|$))+/, M = /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/, I = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/, R = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/, A = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/, Y = /(?:[*+-]|\d{1,9}[.)])/, U = m(/^(?!bull |blockCode|fences|blockquote|heading|html)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html))+?)\n {0,3}(=+|-+) *(?:\n+|$)/).replace(/bull/g, Y).replace(/blockCode/g, / {4}/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).getRegex(), j = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/, ee = /^[^\n]+/, K = /(?!\s*\])(?:\\.|[^\[\]\\])+/, te = m(/^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/).replace("label", K).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex(), H = m(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, Y).getRegex(), se = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul", de = /<!--(?:-?>|[\s\S]*?(?:-->|$))/, fe = m("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))", "i").replace("comment", de).replace("tag", se).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(), W = m(j).replace("hr", R).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", se).getRegex(), xe = {
            blockquote: m(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", W).getRegex(),
            code: M,
            def: te,
            fences: I,
            heading: A,
            hr: R,
            html: fe,
            lheading: U,
            list: H,
            newline: T,
            paragraph: W,
            table: b,
            text: ee
          }, ye = m("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr", R).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", se).getRegex(), Ae = {
            ...xe,
            table: ye,
            paragraph: m(j).replace("hr", R).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", ye).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", se).getRegex()
          }, Ve = {
            ...xe,
            html: m(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", de).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
            def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
            heading: /^(#{1,6})(.*)(?:\n+|$)/,
            fences: b,
            lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
            paragraph: m(j).replace("hr", R).replace("heading", ` *#{1,6} *[^
]`).replace("lheading", U).replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex()
          }, We = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/, xi = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/, ct = /^( {2,}|\\)\n(?!\s*$)/, hn = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/, qo = "\\p{P}\\p{S}", Wa = m(/^((?![*_])[\spunctuation])/, "u").replace(/punctuation/g, qo).getRegex(), Ko = /\[[^[\]]*?\]\([^\(\)]*?\)|`[^`]*?`|<[^<>]*?>/g, Ha = m(/^(?:\*+(?:((?!\*)[punct])|[^\s*]))|^_+(?:((?!_)[punct])|([^\s_]))/, "u").replace(/punct/g, qo).getRegex(), _o2 = m("^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)[punct](\\*+)(?=[\\s]|$)|[^punct\\s](\\*+)(?!\\*)(?=[punct\\s]|$)|(?!\\*)[punct\\s](\\*+)(?=[^punct\\s])|[\\s](\\*+)(?!\\*)(?=[punct])|(?!\\*)[punct](\\*+)(?!\\*)(?=[punct])|[^punct\\s](\\*+)(?=[^punct\\s])", "gu").replace(/punct/g, qo).getRegex(), pu = m("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)[punct](_+)(?=[\\s]|$)|[^punct\\s](_+)(?!_)(?=[punct\\s]|$)|(?!_)[punct\\s](_+)(?=[^punct\\s])|[\\s](_+)(?!_)(?=[punct])|(?!_)[punct](_+)(?!_)(?=[punct])", "gu").replace(/punct/g, qo).getRegex(), _u = m(/\\([punct])/, "gu").replace(/punct/g, qo).getRegex(), Bn = m(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex(), Xl = m(de).replace("(?:-->|$)", "-->").getRegex(), za = m("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment", Xl).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex(), na = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/, Ua = m(/^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/).replace("label", na).replace("href", /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex(), rd = m(/^!?\[(label)\]\[(ref)\]/).replace("label", na).replace("ref", K).getRegex(), $a = m(/^!?\[(ref)\](?:\[\])?/).replace("ref", K).getRegex(), qa = m("reflink|nolink(?!\\()", "g").replace("reflink", rd).replace("nolink", $a).getRegex(), jo = {
            _backpedal: b,
            anyPunctuation: _u,
            autolink: Bn,
            blockSkip: Ko,
            br: ct,
            code: xi,
            del: b,
            emStrongLDelim: Ha,
            emStrongRDelimAst: _o2,
            emStrongRDelimUnd: pu,
            escape: We,
            link: Ua,
            nolink: $a,
            punctuation: Wa,
            reflink: rd,
            reflinkSearch: qa,
            tag: za,
            text: hn,
            url: b
          }, Qs = {
            ...jo,
            link: m(/^!?\[(label)\]\((.*?)\)/).replace("label", na).getRegex(),
            reflink: m(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", na).getRegex()
          }, Sn = {
            ...jo,
            escape: m(We).replace("])", "~|])").getRegex(),
            url: m(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, "i").replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),
            _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
            del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
            text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
          }, bo = {
            ...Sn,
            br: m(ct).replace("{2,}", "*").getRegex(),
            text: m(Sn.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
          }, dn = {
            normal: xe,
            gfm: Ae,
            pedantic: Ve
          }, yr = {
            normal: jo,
            gfm: Sn,
            breaks: bo,
            pedantic: Qs
          };
          class vs {
            constructor(P) {
              __publicField(this, "tokens");
              __publicField(this, "options");
              __publicField(this, "state");
              __publicField(this, "tokenizer");
              __publicField(this, "inlineQueue");
              this.tokens = [], this.tokens.links = /* @__PURE__ */ Object.create(null), this.options = P || e.defaults, this.options.tokenizer = this.options.tokenizer || new k(), this.tokenizer = this.options.tokenizer, this.tokenizer.options = this.options, this.tokenizer.lexer = this, this.inlineQueue = [], this.state = {
                inLink: false,
                inRawBlock: false,
                top: true
              };
              const F = {
                block: dn.normal,
                inline: yr.normal
              };
              this.options.pedantic ? (F.block = dn.pedantic, F.inline = yr.pedantic) : this.options.gfm && (F.block = dn.gfm, this.options.breaks ? F.inline = yr.breaks : F.inline = yr.gfm), this.tokenizer.rules = F;
            }
            static get rules() {
              return {
                block: dn,
                inline: yr
              };
            }
            static lex(P, F) {
              return new vs(F).lex(P);
            }
            static lexInline(P, F) {
              return new vs(F).inlineTokens(P);
            }
            lex(P) {
              P = P.replace(/\r\n|\r/g, `
`), this.blockTokens(P, this.tokens);
              for (let F = 0; F < this.inlineQueue.length; F++) {
                const V = this.inlineQueue[F];
                this.inlineTokens(V.src, V.tokens);
              }
              return this.inlineQueue = [], this.tokens;
            }
            blockTokens(P, F = [], V = false) {
              this.options.pedantic ? P = P.replace(/\t/g, "    ").replace(/^ +$/gm, "") : P = P.replace(/^( *)(\t+)/gm, (_e2, Re, Fe) => Re + "    ".repeat(Fe.length));
              let $, Z, ce;
              for (; P; ) if (!(this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((_e2) => ($ = _e2.call({
                lexer: this
              }, P, F)) ? (P = P.substring($.raw.length), F.push($), true) : false))) {
                if ($ = this.tokenizer.space(P)) {
                  P = P.substring($.raw.length), $.raw.length === 1 && F.length > 0 ? F[F.length - 1].raw += `
` : F.push($);
                  continue;
                }
                if ($ = this.tokenizer.code(P)) {
                  P = P.substring($.raw.length), Z = F[F.length - 1], Z && (Z.type === "paragraph" || Z.type === "text") ? (Z.raw += `
` + $.raw, Z.text += `
` + $.text, this.inlineQueue[this.inlineQueue.length - 1].src = Z.text) : F.push($);
                  continue;
                }
                if ($ = this.tokenizer.fences(P)) {
                  P = P.substring($.raw.length), F.push($);
                  continue;
                }
                if ($ = this.tokenizer.heading(P)) {
                  P = P.substring($.raw.length), F.push($);
                  continue;
                }
                if ($ = this.tokenizer.hr(P)) {
                  P = P.substring($.raw.length), F.push($);
                  continue;
                }
                if ($ = this.tokenizer.blockquote(P)) {
                  P = P.substring($.raw.length), F.push($);
                  continue;
                }
                if ($ = this.tokenizer.list(P)) {
                  P = P.substring($.raw.length), F.push($);
                  continue;
                }
                if ($ = this.tokenizer.html(P)) {
                  P = P.substring($.raw.length), F.push($);
                  continue;
                }
                if ($ = this.tokenizer.def(P)) {
                  P = P.substring($.raw.length), Z = F[F.length - 1], Z && (Z.type === "paragraph" || Z.type === "text") ? (Z.raw += `
` + $.raw, Z.text += `
` + $.raw, this.inlineQueue[this.inlineQueue.length - 1].src = Z.text) : this.tokens.links[$.tag] || (this.tokens.links[$.tag] = {
                    href: $.href,
                    title: $.title
                  });
                  continue;
                }
                if ($ = this.tokenizer.table(P)) {
                  P = P.substring($.raw.length), F.push($);
                  continue;
                }
                if ($ = this.tokenizer.lheading(P)) {
                  P = P.substring($.raw.length), F.push($);
                  continue;
                }
                if (ce = P, this.options.extensions && this.options.extensions.startBlock) {
                  let _e2 = 1 / 0;
                  const Re = P.slice(1);
                  let Fe;
                  this.options.extensions.startBlock.forEach((tt) => {
                    Fe = tt.call({
                      lexer: this
                    }, Re), typeof Fe == "number" && Fe >= 0 && (_e2 = Math.min(_e2, Fe));
                  }), _e2 < 1 / 0 && _e2 >= 0 && (ce = P.substring(0, _e2 + 1));
                }
                if (this.state.top && ($ = this.tokenizer.paragraph(ce))) {
                  Z = F[F.length - 1], V && (Z == null ? void 0 : Z.type) === "paragraph" ? (Z.raw += `
` + $.raw, Z.text += `
` + $.text, this.inlineQueue.pop(), this.inlineQueue[this.inlineQueue.length - 1].src = Z.text) : F.push($), V = ce.length !== P.length, P = P.substring($.raw.length);
                  continue;
                }
                if ($ = this.tokenizer.text(P)) {
                  P = P.substring($.raw.length), Z = F[F.length - 1], Z && Z.type === "text" ? (Z.raw += `
` + $.raw, Z.text += `
` + $.text, this.inlineQueue.pop(), this.inlineQueue[this.inlineQueue.length - 1].src = Z.text) : F.push($);
                  continue;
                }
                if (P) {
                  const _e2 = "Infinite loop on byte: " + P.charCodeAt(0);
                  if (this.options.silent) {
                    console.error(_e2);
                    break;
                  } else throw new Error(_e2);
                }
              }
              return this.state.top = true, F;
            }
            inline(P, F = []) {
              return this.inlineQueue.push({
                src: P,
                tokens: F
              }), F;
            }
            inlineTokens(P, F = []) {
              let V, $, Z, ce = P, _e2, Re, Fe;
              if (this.tokens.links) {
                const tt = Object.keys(this.tokens.links);
                if (tt.length > 0) for (; (_e2 = this.tokenizer.rules.inline.reflinkSearch.exec(ce)) != null; ) tt.includes(_e2[0].slice(_e2[0].lastIndexOf("[") + 1, -1)) && (ce = ce.slice(0, _e2.index) + "[" + "a".repeat(_e2[0].length - 2) + "]" + ce.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));
              }
              for (; (_e2 = this.tokenizer.rules.inline.blockSkip.exec(ce)) != null; ) ce = ce.slice(0, _e2.index) + "[" + "a".repeat(_e2[0].length - 2) + "]" + ce.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
              for (; (_e2 = this.tokenizer.rules.inline.anyPunctuation.exec(ce)) != null; ) ce = ce.slice(0, _e2.index) + "++" + ce.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
              for (; P; ) if (Re || (Fe = ""), Re = false, !(this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((tt) => (V = tt.call({
                lexer: this
              }, P, F)) ? (P = P.substring(V.raw.length), F.push(V), true) : false))) {
                if (V = this.tokenizer.escape(P)) {
                  P = P.substring(V.raw.length), F.push(V);
                  continue;
                }
                if (V = this.tokenizer.tag(P)) {
                  P = P.substring(V.raw.length), $ = F[F.length - 1], $ && V.type === "text" && $.type === "text" ? ($.raw += V.raw, $.text += V.text) : F.push(V);
                  continue;
                }
                if (V = this.tokenizer.link(P)) {
                  P = P.substring(V.raw.length), F.push(V);
                  continue;
                }
                if (V = this.tokenizer.reflink(P, this.tokens.links)) {
                  P = P.substring(V.raw.length), $ = F[F.length - 1], $ && V.type === "text" && $.type === "text" ? ($.raw += V.raw, $.text += V.text) : F.push(V);
                  continue;
                }
                if (V = this.tokenizer.emStrong(P, ce, Fe)) {
                  P = P.substring(V.raw.length), F.push(V);
                  continue;
                }
                if (V = this.tokenizer.codespan(P)) {
                  P = P.substring(V.raw.length), F.push(V);
                  continue;
                }
                if (V = this.tokenizer.br(P)) {
                  P = P.substring(V.raw.length), F.push(V);
                  continue;
                }
                if (V = this.tokenizer.del(P)) {
                  P = P.substring(V.raw.length), F.push(V);
                  continue;
                }
                if (V = this.tokenizer.autolink(P)) {
                  P = P.substring(V.raw.length), F.push(V);
                  continue;
                }
                if (!this.state.inLink && (V = this.tokenizer.url(P))) {
                  P = P.substring(V.raw.length), F.push(V);
                  continue;
                }
                if (Z = P, this.options.extensions && this.options.extensions.startInline) {
                  let tt = 1 / 0;
                  const xt = P.slice(1);
                  let At;
                  this.options.extensions.startInline.forEach((fi) => {
                    At = fi.call({
                      lexer: this
                    }, xt), typeof At == "number" && At >= 0 && (tt = Math.min(tt, At));
                  }), tt < 1 / 0 && tt >= 0 && (Z = P.substring(0, tt + 1));
                }
                if (V = this.tokenizer.inlineText(Z)) {
                  P = P.substring(V.raw.length), V.raw.slice(-1) !== "_" && (Fe = V.raw.slice(-1)), Re = true, $ = F[F.length - 1], $ && $.type === "text" ? ($.raw += V.raw, $.text += V.text) : F.push(V);
                  continue;
                }
                if (P) {
                  const tt = "Infinite loop on byte: " + P.charCodeAt(0);
                  if (this.options.silent) {
                    console.error(tt);
                    break;
                  } else throw new Error(tt);
                }
              }
              return F;
            }
          }
          class Go {
            constructor(P) {
              __publicField(this, "options");
              __publicField(this, "parser");
              this.options = P || e.defaults;
            }
            space(P) {
              return "";
            }
            code({ text: P, lang: F, escaped: V }) {
              var _a3;
              const $ = (_a3 = (F || "").match(/^\S*/)) == null ? void 0 : _a3[0], Z = P.replace(/\n$/, "") + `
`;
              return $ ? '<pre><code class="language-' + d($) + '">' + (V ? Z : d(Z, true)) + `</code></pre>
` : "<pre><code>" + (V ? Z : d(Z, true)) + `</code></pre>
`;
            }
            blockquote({ tokens: P }) {
              return `<blockquote>
${this.parser.parse(P)}</blockquote>
`;
            }
            html({ text: P }) {
              return P;
            }
            heading({ tokens: P, depth: F }) {
              return `<h${F}>${this.parser.parseInline(P)}</h${F}>
`;
            }
            hr(P) {
              return `<hr>
`;
            }
            list(P) {
              const F = P.ordered, V = P.start;
              let $ = "";
              for (let _e2 = 0; _e2 < P.items.length; _e2++) {
                const Re = P.items[_e2];
                $ += this.listitem(Re);
              }
              const Z = F ? "ol" : "ul", ce = F && V !== 1 ? ' start="' + V + '"' : "";
              return "<" + Z + ce + `>
` + $ + "</" + Z + `>
`;
            }
            listitem(P) {
              let F = "";
              if (P.task) {
                const V = this.checkbox({
                  checked: !!P.checked
                });
                P.loose ? P.tokens.length > 0 && P.tokens[0].type === "paragraph" ? (P.tokens[0].text = V + " " + P.tokens[0].text, P.tokens[0].tokens && P.tokens[0].tokens.length > 0 && P.tokens[0].tokens[0].type === "text" && (P.tokens[0].tokens[0].text = V + " " + P.tokens[0].tokens[0].text)) : P.tokens.unshift({
                  type: "text",
                  raw: V + " ",
                  text: V + " "
                }) : F += V + " ";
              }
              return F += this.parser.parse(P.tokens, !!P.loose), `<li>${F}</li>
`;
            }
            checkbox({ checked: P }) {
              return "<input " + (P ? 'checked="" ' : "") + 'disabled="" type="checkbox">';
            }
            paragraph({ tokens: P }) {
              return `<p>${this.parser.parseInline(P)}</p>
`;
            }
            table(P) {
              let F = "", V = "";
              for (let Z = 0; Z < P.header.length; Z++) V += this.tablecell(P.header[Z]);
              F += this.tablerow({
                text: V
              });
              let $ = "";
              for (let Z = 0; Z < P.rows.length; Z++) {
                const ce = P.rows[Z];
                V = "";
                for (let _e2 = 0; _e2 < ce.length; _e2++) V += this.tablecell(ce[_e2]);
                $ += this.tablerow({
                  text: V
                });
              }
              return $ && ($ = `<tbody>${$}</tbody>`), `<table>
<thead>
` + F + `</thead>
` + $ + `</table>
`;
            }
            tablerow({ text: P }) {
              return `<tr>
${P}</tr>
`;
            }
            tablecell(P) {
              const F = this.parser.parseInline(P.tokens), V = P.header ? "th" : "td";
              return (P.align ? `<${V} align="${P.align}">` : `<${V}>`) + F + `</${V}>
`;
            }
            strong({ tokens: P }) {
              return `<strong>${this.parser.parseInline(P)}</strong>`;
            }
            em({ tokens: P }) {
              return `<em>${this.parser.parseInline(P)}</em>`;
            }
            codespan({ text: P }) {
              return `<code>${P}</code>`;
            }
            br(P) {
              return "<br>";
            }
            del({ tokens: P }) {
              return `<del>${this.parser.parseInline(P)}</del>`;
            }
            link({ href: P, title: F, tokens: V }) {
              const $ = this.parser.parseInline(V), Z = _(P);
              if (Z === null) return $;
              P = Z;
              let ce = '<a href="' + P + '"';
              return F && (ce += ' title="' + F + '"'), ce += ">" + $ + "</a>", ce;
            }
            image({ href: P, title: F, text: V }) {
              const $ = _(P);
              if ($ === null) return V;
              P = $;
              let Z = `<img src="${P}" alt="${V}"`;
              return F && (Z += ` title="${F}"`), Z += ">", Z;
            }
            text(P) {
              return "tokens" in P && P.tokens ? this.parser.parseInline(P.tokens) : P.text;
            }
          }
          class Xs {
            strong({ text: P }) {
              return P;
            }
            em({ text: P }) {
              return P;
            }
            codespan({ text: P }) {
              return P;
            }
            del({ text: P }) {
              return P;
            }
            html({ text: P }) {
              return P;
            }
            text({ text: P }) {
              return P;
            }
            link({ text: P }) {
              return "" + P;
            }
            image({ text: P }) {
              return "" + P;
            }
            br() {
              return "";
            }
          }
          class Ri {
            constructor(P) {
              __publicField(this, "options");
              __publicField(this, "renderer");
              __publicField(this, "textRenderer");
              this.options = P || e.defaults, this.options.renderer = this.options.renderer || new Go(), this.renderer = this.options.renderer, this.renderer.options = this.options, this.renderer.parser = this, this.textRenderer = new Xs();
            }
            static parse(P, F) {
              return new Ri(F).parse(P);
            }
            static parseInline(P, F) {
              return new Ri(F).parseInline(P);
            }
            parse(P, F = true) {
              let V = "";
              for (let $ = 0; $ < P.length; $++) {
                const Z = P[$];
                if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[Z.type]) {
                  const _e2 = Z, Re = this.options.extensions.renderers[_e2.type].call({
                    parser: this
                  }, _e2);
                  if (Re !== false || ![
                    "space",
                    "hr",
                    "heading",
                    "code",
                    "table",
                    "blockquote",
                    "list",
                    "html",
                    "paragraph",
                    "text"
                  ].includes(_e2.type)) {
                    V += Re || "";
                    continue;
                  }
                }
                const ce = Z;
                switch (ce.type) {
                  case "space": {
                    V += this.renderer.space(ce);
                    continue;
                  }
                  case "hr": {
                    V += this.renderer.hr(ce);
                    continue;
                  }
                  case "heading": {
                    V += this.renderer.heading(ce);
                    continue;
                  }
                  case "code": {
                    V += this.renderer.code(ce);
                    continue;
                  }
                  case "table": {
                    V += this.renderer.table(ce);
                    continue;
                  }
                  case "blockquote": {
                    V += this.renderer.blockquote(ce);
                    continue;
                  }
                  case "list": {
                    V += this.renderer.list(ce);
                    continue;
                  }
                  case "html": {
                    V += this.renderer.html(ce);
                    continue;
                  }
                  case "paragraph": {
                    V += this.renderer.paragraph(ce);
                    continue;
                  }
                  case "text": {
                    let _e2 = ce, Re = this.renderer.text(_e2);
                    for (; $ + 1 < P.length && P[$ + 1].type === "text"; ) _e2 = P[++$], Re += `
` + this.renderer.text(_e2);
                    F ? V += this.renderer.paragraph({
                      type: "paragraph",
                      raw: Re,
                      text: Re,
                      tokens: [
                        {
                          type: "text",
                          raw: Re,
                          text: Re
                        }
                      ]
                    }) : V += Re;
                    continue;
                  }
                  default: {
                    const _e2 = 'Token with "' + ce.type + '" type was not found.';
                    if (this.options.silent) return console.error(_e2), "";
                    throw new Error(_e2);
                  }
                }
              }
              return V;
            }
            parseInline(P, F) {
              F = F || this.renderer;
              let V = "";
              for (let $ = 0; $ < P.length; $++) {
                const Z = P[$];
                if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[Z.type]) {
                  const _e2 = this.options.extensions.renderers[Z.type].call({
                    parser: this
                  }, Z);
                  if (_e2 !== false || ![
                    "escape",
                    "html",
                    "link",
                    "image",
                    "strong",
                    "em",
                    "codespan",
                    "br",
                    "del",
                    "text"
                  ].includes(Z.type)) {
                    V += _e2 || "";
                    continue;
                  }
                }
                const ce = Z;
                switch (ce.type) {
                  case "escape": {
                    V += F.text(ce);
                    break;
                  }
                  case "html": {
                    V += F.html(ce);
                    break;
                  }
                  case "link": {
                    V += F.link(ce);
                    break;
                  }
                  case "image": {
                    V += F.image(ce);
                    break;
                  }
                  case "strong": {
                    V += F.strong(ce);
                    break;
                  }
                  case "em": {
                    V += F.em(ce);
                    break;
                  }
                  case "codespan": {
                    V += F.codespan(ce);
                    break;
                  }
                  case "br": {
                    V += F.br(ce);
                    break;
                  }
                  case "del": {
                    V += F.del(ce);
                    break;
                  }
                  case "text": {
                    V += F.text(ce);
                    break;
                  }
                  default: {
                    const _e2 = 'Token with "' + ce.type + '" type was not found.';
                    if (this.options.silent) return console.error(_e2), "";
                    throw new Error(_e2);
                  }
                }
              }
              return V;
            }
          }
          class Ln {
            constructor(P) {
              __publicField(this, "options");
              this.options = P || e.defaults;
            }
            preprocess(P) {
              return P;
            }
            postprocess(P) {
              return P;
            }
            processAllTokens(P) {
              return P;
            }
          }
          __publicField(Ln, "passThroughHooks", /* @__PURE__ */ new Set([
            "preprocess",
            "postprocess",
            "processAllTokens"
          ]));
          class Sr {
            constructor(...P) {
              __publicField(this, "defaults", t());
              __publicField(this, "options", this.setOptions);
              __publicField(this, "parse", this.parseMarkdown(vs.lex, Ri.parse));
              __publicField(this, "parseInline", this.parseMarkdown(vs.lexInline, Ri.parseInline));
              __publicField(this, "Parser", Ri);
              __publicField(this, "Renderer", Go);
              __publicField(this, "TextRenderer", Xs);
              __publicField(this, "Lexer", vs);
              __publicField(this, "Tokenizer", k);
              __publicField(this, "Hooks", Ln);
              this.use(...P);
            }
            walkTokens(P, F) {
              var _a3, _b3;
              let V = [];
              for (const $ of P) switch (V = V.concat(F.call(this, $)), $.type) {
                case "table": {
                  const Z = $;
                  for (const ce of Z.header) V = V.concat(this.walkTokens(ce.tokens, F));
                  for (const ce of Z.rows) for (const _e2 of ce) V = V.concat(this.walkTokens(_e2.tokens, F));
                  break;
                }
                case "list": {
                  const Z = $;
                  V = V.concat(this.walkTokens(Z.items, F));
                  break;
                }
                default: {
                  const Z = $;
                  ((_b3 = (_a3 = this.defaults.extensions) == null ? void 0 : _a3.childTokens) == null ? void 0 : _b3[Z.type]) ? this.defaults.extensions.childTokens[Z.type].forEach((ce) => {
                    const _e2 = Z[ce].flat(1 / 0);
                    V = V.concat(this.walkTokens(_e2, F));
                  }) : Z.tokens && (V = V.concat(this.walkTokens(Z.tokens, F)));
                }
              }
              return V;
            }
            use(...P) {
              const F = this.defaults.extensions || {
                renderers: {},
                childTokens: {}
              };
              return P.forEach((V) => {
                const $ = {
                  ...V
                };
                if ($.async = this.defaults.async || $.async || false, V.extensions && (V.extensions.forEach((Z) => {
                  if (!Z.name) throw new Error("extension name required");
                  if ("renderer" in Z) {
                    const ce = F.renderers[Z.name];
                    ce ? F.renderers[Z.name] = function(..._e2) {
                      let Re = Z.renderer.apply(this, _e2);
                      return Re === false && (Re = ce.apply(this, _e2)), Re;
                    } : F.renderers[Z.name] = Z.renderer;
                  }
                  if ("tokenizer" in Z) {
                    if (!Z.level || Z.level !== "block" && Z.level !== "inline") throw new Error("extension level must be 'block' or 'inline'");
                    const ce = F[Z.level];
                    ce ? ce.unshift(Z.tokenizer) : F[Z.level] = [
                      Z.tokenizer
                    ], Z.start && (Z.level === "block" ? F.startBlock ? F.startBlock.push(Z.start) : F.startBlock = [
                      Z.start
                    ] : Z.level === "inline" && (F.startInline ? F.startInline.push(Z.start) : F.startInline = [
                      Z.start
                    ]));
                  }
                  "childTokens" in Z && Z.childTokens && (F.childTokens[Z.name] = Z.childTokens);
                }), $.extensions = F), V.renderer) {
                  const Z = this.defaults.renderer || new Go(this.defaults);
                  for (const ce in V.renderer) {
                    if (!(ce in Z)) throw new Error(`renderer '${ce}' does not exist`);
                    if ([
                      "options",
                      "parser"
                    ].includes(ce)) continue;
                    const _e2 = ce, Re = V.renderer[_e2], Fe = Z[_e2];
                    Z[_e2] = (...tt) => {
                      let xt = Re.apply(Z, tt);
                      return xt === false && (xt = Fe.apply(Z, tt)), xt || "";
                    };
                  }
                  $.renderer = Z;
                }
                if (V.tokenizer) {
                  const Z = this.defaults.tokenizer || new k(this.defaults);
                  for (const ce in V.tokenizer) {
                    if (!(ce in Z)) throw new Error(`tokenizer '${ce}' does not exist`);
                    if ([
                      "options",
                      "rules",
                      "lexer"
                    ].includes(ce)) continue;
                    const _e2 = ce, Re = V.tokenizer[_e2], Fe = Z[_e2];
                    Z[_e2] = (...tt) => {
                      let xt = Re.apply(Z, tt);
                      return xt === false && (xt = Fe.apply(Z, tt)), xt;
                    };
                  }
                  $.tokenizer = Z;
                }
                if (V.hooks) {
                  const Z = this.defaults.hooks || new Ln();
                  for (const ce in V.hooks) {
                    if (!(ce in Z)) throw new Error(`hook '${ce}' does not exist`);
                    if (ce === "options") continue;
                    const _e2 = ce, Re = V.hooks[_e2], Fe = Z[_e2];
                    Ln.passThroughHooks.has(ce) ? Z[_e2] = (tt) => {
                      if (this.defaults.async) return Promise.resolve(Re.call(Z, tt)).then((At) => Fe.call(Z, At));
                      const xt = Re.call(Z, tt);
                      return Fe.call(Z, xt);
                    } : Z[_e2] = (...tt) => {
                      let xt = Re.apply(Z, tt);
                      return xt === false && (xt = Fe.apply(Z, tt)), xt;
                    };
                  }
                  $.hooks = Z;
                }
                if (V.walkTokens) {
                  const Z = this.defaults.walkTokens, ce = V.walkTokens;
                  $.walkTokens = function(_e2) {
                    let Re = [];
                    return Re.push(ce.call(this, _e2)), Z && (Re = Re.concat(Z.call(this, _e2))), Re;
                  };
                }
                this.defaults = {
                  ...this.defaults,
                  ...$
                };
              }), this;
            }
            setOptions(P) {
              return this.defaults = {
                ...this.defaults,
                ...P
              }, this;
            }
            lexer(P, F) {
              return vs.lex(P, F ?? this.defaults);
            }
            parser(P, F) {
              return Ri.parse(P, F ?? this.defaults);
            }
            parseMarkdown(P, F) {
              return ($, Z) => {
                const ce = {
                  ...Z
                }, _e2 = {
                  ...this.defaults,
                  ...ce
                }, Re = this.onError(!!_e2.silent, !!_e2.async);
                if (this.defaults.async === true && ce.async === false) return Re(new Error("marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise."));
                if (typeof $ > "u" || $ === null) return Re(new Error("marked(): input parameter is undefined or null"));
                if (typeof $ != "string") return Re(new Error("marked(): input parameter is of type " + Object.prototype.toString.call($) + ", string expected"));
                if (_e2.hooks && (_e2.hooks.options = _e2), _e2.async) return Promise.resolve(_e2.hooks ? _e2.hooks.preprocess($) : $).then((Fe) => P(Fe, _e2)).then((Fe) => _e2.hooks ? _e2.hooks.processAllTokens(Fe) : Fe).then((Fe) => _e2.walkTokens ? Promise.all(this.walkTokens(Fe, _e2.walkTokens)).then(() => Fe) : Fe).then((Fe) => F(Fe, _e2)).then((Fe) => _e2.hooks ? _e2.hooks.postprocess(Fe) : Fe).catch(Re);
                try {
                  _e2.hooks && ($ = _e2.hooks.preprocess($));
                  let Fe = P($, _e2);
                  _e2.hooks && (Fe = _e2.hooks.processAllTokens(Fe)), _e2.walkTokens && this.walkTokens(Fe, _e2.walkTokens);
                  let tt = F(Fe, _e2);
                  return _e2.hooks && (tt = _e2.hooks.postprocess(tt)), tt;
                } catch (Fe) {
                  return Re(Fe);
                }
              };
            }
            onError(P, F) {
              return (V) => {
                if (V.message += `
Please report this to https://github.com/markedjs/marked.`, P) {
                  const $ = "<p>An error occurred:</p><pre>" + d(V.message + "", true) + "</pre>";
                  return F ? Promise.resolve($) : $;
                }
                if (F) return Promise.reject(V);
                throw V;
              };
            }
          }
          const os = new Sr();
          function ei(nt, P) {
            return os.parse(nt, P);
          }
          ei.options = ei.setOptions = function(nt) {
            return os.setOptions(nt), ei.defaults = os.defaults, i(ei.defaults), ei;
          }, ei.getDefaults = t, ei.defaults = e.defaults, ei.use = function(...nt) {
            return os.use(...nt), ei.defaults = os.defaults, i(ei.defaults), ei;
          }, ei.walkTokens = function(nt, P) {
            return os.walkTokens(nt, P);
          }, ei.parseInline = os.parseInline, ei.Parser = Ri, ei.parser = Ri.parse, ei.Renderer = Go, ei.TextRenderer = Xs, ei.Lexer = vs, ei.lexer = vs.lex, ei.Tokenizer = k, ei.Hooks = Ln, ei.parse = ei;
          const sa = ei.options, ad = ei.setOptions, bu = ei.use, Oi = ei.walkTokens, oa = ei.parseInline, ld = ei, vu = Ri.parse, Ka = vs.lex;
          e.Hooks = Ln, e.Lexer = vs, e.Marked = Sr, e.Parser = Ri, e.Renderer = Go, e.TextRenderer = Xs, e.Tokenizer = k, e.getDefaults = t, e.lexer = Ka, e.marked = ei, e.options = sa, e.parse = ld, e.parseInline = oa, e.parser = vu, e.setOptions = ad, e.use = bu, e.walkTokens = Oi;
        });
      })();
      Kn.Hooks || exports.Hooks;
      Kn.Lexer || exports.Lexer;
      Kn.Marked || exports.Marked;
      Kn.Parser || exports.Parser;
      var R6 = Kn.Renderer || exports.Renderer;
      Kn.TextRenderer || exports.TextRenderer;
      Kn.Tokenizer || exports.Tokenizer;
      var dJ = Kn.defaults || exports.defaults;
      Kn.getDefaults || exports.getDefaults;
      var gw = Kn.lexer || exports.lexer;
      Kn.marked || exports.marked;
      Kn.options || exports.options;
      var O6 = Kn.parse || exports.parse;
      Kn.parseInline || exports.parseInline;
      var fJ = Kn.parser || exports.parser;
      Kn.setOptions || exports.setOptions;
      Kn.use || exports.use;
      Kn.walkTokens || exports.walkTokens;
      function gJ(s) {
        return JSON.stringify(s, mJ);
      }
      function TD(s) {
        let e = JSON.parse(s);
        return e = ND(e), e;
      }
      function mJ(s, e) {
        return e instanceof RegExp ? {
          $mid: 2,
          source: e.source,
          flags: e.flags
        } : e;
      }
      function ND(s, e = 0) {
        if (!s || e > 200) return s;
        if (typeof s == "object") {
          switch (s.$mid) {
            case 1:
              return st.revive(s);
            case 2:
              return new RegExp(s.source, s.flags);
            case 17:
              return new Date(s.source);
          }
          if (s instanceof vT || s instanceof Uint8Array) return s;
          if (Array.isArray(s)) for (let t = 0; t < s.length; ++t) s[t] = ND(s[t], e + 1);
          else for (const t in s) Object.hasOwnProperty.call(s, t) && (s[t] = ND(s[t], e + 1));
        }
        return s;
      }
      const GL = Object.freeze({
        image: ({ href: s, title: e, text: t }) => {
          let i = [], n = [];
          return s && ({ href: s, dimensions: i } = hJ(s), n.push(`src="${Vb(s)}"`)), t && n.push(`alt="${Vb(t)}"`), e && n.push(`title="${Vb(e)}"`), i.length && (n = n.concat(i)), "<img " + n.join(" ") + ">";
        },
        paragraph({ tokens: s }) {
          return `<p>${this.parser.parseInline(s)}</p>`;
        },
        link({ href: s, title: e, tokens: t }) {
          let i = this.parser.parseInline(t);
          return typeof s != "string" ? "" : (s === i && (i = jL(i)), e = typeof e == "string" ? Vb(jL(e)) : "", s = jL(s), s = s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;"), `<a href="${s}" title="${e || s}" draggable="false">${i}</a>`);
        }
      });
      function $T(s, e = {}, t = {}) {
        const i = new Me();
        let n = false;
        const o = FT(e), r = function(v) {
          let y;
          try {
            y = TD(decodeURIComponent(v));
          } catch {
          }
          return y ? (y = Z7(y, (x) => {
            if (s.uris && s.uris[x]) return st.revive(s.uris[x]);
          }), encodeURIComponent(JSON.stringify(y))) : v;
        }, a = function(v, y) {
          const x = s.uris && s.uris[v];
          let L = st.revive(x);
          return y ? v.startsWith(it.data + ":") ? v : (L || (L = st.parse(v)), zC.uriToBrowserUri(L).toString(true)) : !L || st.parse(v).toString() === L.toString() ? v : (L.query && (L = L.with({
            query: r(L.query)
          })), L.toString());
        }, l = new R6();
        l.image = GL.image, l.link = GL.link, l.paragraph = GL.paragraph;
        const u = [], d = [];
        if (e.codeBlockRendererSync ? l.code = ({ text: v, lang: y }) => {
          const x = V5.nextId(), L = e.codeBlockRendererSync(W5(y), v);
          return d.push([
            x,
            L
          ]), `<div class="code" data-code="${x}">${mp(v)}</div>`;
        } : e.codeBlockRenderer && (l.code = ({ text: v, lang: y }) => {
          const x = V5.nextId(), L = e.codeBlockRenderer(W5(y), v);
          return u.push(L.then((D) => [
            x,
            D
          ])), `<div class="code" data-code="${x}">${mp(v)}</div>`;
        }), e.actionHandler) {
          const v = function(L) {
            let D = L.target;
            if (!(D.tagName !== "A" && (D = D.parentElement, !D || D.tagName !== "A"))) try {
              let k = D.dataset.href;
              k && (s.baseUri && (k = YL(st.from(s.baseUri), k)), e.actionHandler.callback(k, L));
            } catch (k) {
              qt(k);
            } finally {
              L.preventDefault();
            }
          }, y = e.actionHandler.disposables.add(new ot(o, "click")), x = e.actionHandler.disposables.add(new ot(o, "auxclick"));
          e.actionHandler.disposables.add(be.any(y.event, x.event)((L) => {
            const D = new Vr(Oe(o), L);
            !D.leftButton && !D.middleButton || v(D);
          })), e.actionHandler.disposables.add(re(o, "keydown", (L) => {
            const D = new si(L);
            !D.equals(10) && !D.equals(3) || v(D);
          }));
        }
        s.supportHtml || (l.html = ({ text: v }) => {
          var _a3;
          return ((_a3 = e.sanitizerOptions) == null ? void 0 : _a3.replaceWithPlaintext) ? mp(v) : (s.isTrusted ? v.match(/^(<span[^>]+>)|(<\/\s*span>)$/) : void 0) ? v : "";
        }), t.renderer = l;
        let f = s.value ?? "";
        f.length > 1e5 && (f = `${f.substr(0, 1e5)}\u2026`), s.supportThemeIcons && (f = tJ(f));
        let m;
        if (e.fillInIncompleteTokens) {
          const v = {
            ...dJ,
            ...t
          }, y = gw(f, v), x = EJ(y);
          m = fJ(x, v);
        } else m = O6(f, {
          ...t,
          async: false
        });
        s.supportThemeIcons && (m = wh(m).map((y) => typeof y == "string" ? y : y.outerHTML).join(""));
        const b = new DOMParser().parseFromString(ID({
          isTrusted: s.isTrusted,
          ...e.sanitizerOptions
        }, m), "text/html");
        if (b.body.querySelectorAll("img, audio, video, source").forEach((v) => {
          const y = v.getAttribute("src");
          if (y) {
            let x = y;
            try {
              s.baseUri && (x = YL(st.from(s.baseUri), x));
            } catch {
            }
            if (v.setAttribute("src", a(x, true)), e.remoteImageIsAllowed) {
              const L = st.parse(x);
              L.scheme !== it.file && L.scheme !== it.data && !e.remoteImageIsAllowed(L) && v.replaceWith(He("", void 0, v.outerHTML));
            }
          }
        }), b.body.querySelectorAll("a").forEach((v) => {
          const y = v.getAttribute("href");
          if (v.setAttribute("href", ""), !y || /^data:|javascript:/i.test(y) || /^command:/i.test(y) && !s.isTrusted || /^command:(\/\/\/)?_workbench\.downloadResource/i.test(y)) v.replaceWith(...v.childNodes);
          else {
            let x = a(y, false);
            s.baseUri && (x = YL(st.from(s.baseUri), y)), v.dataset.href = x;
          }
        }), o.innerHTML = ID({
          isTrusted: s.isTrusted,
          ...e.sanitizerOptions
        }, b.body.innerHTML), u.length > 0) Promise.all(u).then((v) => {
          var _a3;
          if (n) return;
          const y = new Map(v), x = o.querySelectorAll("div[data-code]");
          for (const L of x) {
            const D = y.get(L.dataset.code ?? "");
            D && gs(L, D);
          }
          (_a3 = e.asyncRenderCallback) == null ? void 0 : _a3.call(e);
        });
        else if (d.length > 0) {
          const v = new Map(d), y = o.querySelectorAll("div[data-code]");
          for (const x of y) {
            const L = v.get(x.dataset.code ?? "");
            L && gs(x, L);
          }
        }
        if (e.asyncRenderCallback) for (const v of o.getElementsByTagName("img")) {
          const y = i.add(re(v, "load", () => {
            y.dispose(), e.asyncRenderCallback();
          }));
        }
        return {
          element: o,
          dispose: () => {
            n = true, i.dispose();
          }
        };
      }
      function W5(s) {
        if (!s) return "";
        const e = s.split(/[\s+|:|,|\{|\?]/, 1);
        return e.length ? e[0] : s;
      }
      function YL(s, e) {
        return /^\w[\w\d+.-]*:/.test(e) ? e : s.path.endsWith("/") ? P5(s, e).toString() : P5(rJ(s), e).toString();
      }
      const pJ = [
        "area",
        "base",
        "br",
        "col",
        "command",
        "embed",
        "hr",
        "img",
        "input",
        "keygen",
        "link",
        "meta",
        "param",
        "source",
        "track",
        "wbr"
      ];
      function ID(s, e) {
        const { config: t, allowedSchemes: i } = bJ(s), n = new Me();
        n.add(H5("uponSanitizeAttribute", (o, r) => {
          var _a3;
          if (r.attrName === "style" || r.attrName === "class") {
            if (o.tagName === "SPAN") {
              if (r.attrName === "style") {
                r.keepAttr = /^(color\:(#[0-9a-fA-F]+|var\(--vscode(-[a-zA-Z]+)+\));)?(background-color\:(#[0-9a-fA-F]+|var\(--vscode(-[a-zA-Z]+)+\));)?(border-radius:[0-9]+px;)?$/.test(r.attrValue);
                return;
              } else if (r.attrName === "class") {
                r.keepAttr = /^codicon codicon-[a-z\-]+( codicon-modifier-[a-z\-]+)?$/.test(r.attrValue);
                return;
              }
            }
            r.keepAttr = false;
            return;
          } else if (o.tagName === "INPUT" && ((_a3 = o.attributes.getNamedItem("type")) == null ? void 0 : _a3.value) === "checkbox") {
            if (r.attrName === "type" && r.attrValue === "checkbox" || r.attrName === "disabled" || r.attrName === "checked") {
              r.keepAttr = true;
              return;
            }
            r.keepAttr = false;
          }
        })), n.add(H5("uponSanitizeElement", (o, r) => {
          var _a3;
          if (r.tagName === "input" && (((_a3 = o.attributes.getNamedItem("type")) == null ? void 0 : _a3.value) === "checkbox" ? o.setAttribute("disabled", "") : s.replaceWithPlaintext || o.remove()), s.replaceWithPlaintext && !r.allowedTags[r.tagName] && r.tagName !== "body" && o.parentElement) {
            let a, l;
            if (r.tagName === "#comment") a = `<!--${o.textContent}-->`;
            else {
              const m = pJ.includes(r.tagName), _ = o.attributes.length ? " " + Array.from(o.attributes).map((b) => `${b.name}="${b.value}"`).join(" ") : "";
              a = `<${r.tagName}${_}>`, m || (l = `</${r.tagName}>`);
            }
            const u = document.createDocumentFragment(), d = o.parentElement.ownerDocument.createTextNode(a);
            u.appendChild(d);
            const f = l ? o.parentElement.ownerDocument.createTextNode(l) : void 0;
            for (; o.firstChild; ) u.appendChild(o.firstChild);
            f && u.appendChild(f), o.nodeType === Node.COMMENT_NODE ? o.parentElement.insertBefore(u, o) : o.parentElement.replaceChild(u, o);
          }
        })), n.add(jK(i));
        try {
          return z9(e, {
            ...t,
            RETURN_TRUSTED_TYPE: true
          });
        } finally {
          n.dispose();
        }
      }
      const _J = [
        "align",
        "autoplay",
        "alt",
        "checked",
        "class",
        "colspan",
        "controls",
        "data-code",
        "data-href",
        "disabled",
        "draggable",
        "height",
        "href",
        "loop",
        "muted",
        "playsinline",
        "poster",
        "rowspan",
        "src",
        "style",
        "target",
        "title",
        "type",
        "width",
        "start"
      ];
      function bJ(s) {
        const e = [
          it.http,
          it.https,
          it.mailto,
          it.data,
          it.file,
          it.vscodeFileResource,
          it.vscodeRemote,
          it.vscodeRemoteResource
        ];
        return s.isTrusted && e.push(it.command), {
          config: {
            ALLOWED_TAGS: s.allowedTags ?? [
              ...GK
            ],
            ALLOWED_ATTR: _J,
            ALLOW_UNKNOWN_PROTOCOLS: true
          },
          allowedSchemes: e
        };
      }
      function vJ(s) {
        return typeof s == "string" ? s : CJ(s);
      }
      function CJ(s, e) {
        let t = s.value ?? "";
        t.length > 1e5 && (t = `${t.substr(0, 1e5)}\u2026`);
        const i = O6(t, {
          async: false,
          renderer: SJ.value
        }).replace(/&(#\d+|[a-zA-Z]+);/g, (n) => wJ.get(n) ?? n);
        return ID({
          isTrusted: false
        }, i).toString();
      }
      const wJ = /* @__PURE__ */ new Map([
        [
          "&quot;",
          '"'
        ],
        [
          "&nbsp;",
          " "
        ],
        [
          "&amp;",
          "&"
        ],
        [
          "&#39;",
          "'"
        ],
        [
          "&lt;",
          "<"
        ],
        [
          "&gt;",
          ">"
        ]
      ]);
      function yJ() {
        const s = new R6();
        return s.code = ({ text: e }) => e, s.blockquote = ({ text: e }) => e + `
`, s.html = (e) => "", s.heading = function({ tokens: e }) {
          return this.parser.parseInline(e) + `
`;
        }, s.hr = () => "", s.list = function({ items: e }) {
          return e.map((t) => this.listitem(t)).join(`
`) + `
`;
        }, s.listitem = ({ text: e }) => e + `
`, s.paragraph = function({ tokens: e }) {
          return this.parser.parseInline(e) + `
`;
        }, s.table = function({ header: e, rows: t }) {
          return e.map((i) => this.tablecell(i)).join(" ") + `
` + t.map((i) => i.map((n) => this.tablecell(n)).join(" ")).join(`
`) + `
`;
        }, s.tablerow = ({ text: e }) => e, s.tablecell = function({ tokens: e }) {
          return this.parser.parseInline(e);
        }, s.strong = ({ text: e }) => e, s.em = ({ text: e }) => e, s.codespan = ({ text: e }) => e, s.br = (e) => `
`, s.del = ({ text: e }) => e, s.image = (e) => "", s.text = ({ text: e }) => e, s.link = ({ text: e }) => e, s;
      }
      const SJ = new iu((s) => yJ());
      function Dv(s) {
        let e = "";
        return s.forEach((t) => {
          e += t.raw;
        }), e;
      }
      function P6(s) {
        var _a3, _b3;
        if (s.tokens) for (let e = s.tokens.length - 1; e >= 0; e--) {
          const t = s.tokens[e];
          if (t.type === "text") {
            const i = t.raw.split(`
`), n = i[i.length - 1];
            if (n.includes("`")) return NJ(s);
            if (n.includes("**")) return PJ(s);
            if (n.match(/\*\w/)) return IJ(s);
            if (n.match(/(^|\s)__\w/)) return BJ(s);
            if (n.match(/(^|\s)_\w/)) return MJ(s);
            if (LJ(n) || xJ(n) && s.tokens.slice(0, e).some((o) => o.type === "text" && o.raw.match(/\[[^\]]*$/))) {
              const o = s.tokens.slice(e + 1);
              return ((_a3 = o[0]) == null ? void 0 : _a3.type) === "link" && ((_b3 = o[1]) == null ? void 0 : _b3.type) === "text" && o[1].raw.match(/^ *"[^"]*$/) || n.match(/^[^"]* +"[^"]*$/) ? RJ(s) : AJ(s);
            } else if (n.match(/(^|\s)\[\w*/)) return OJ(s);
          }
        }
      }
      function LJ(s) {
        return !!s.match(/(^|\s)\[.*\]\(\w*/);
      }
      function xJ(s) {
        return !!s.match(/^[^\[]*\]\([^\)]*$/);
      }
      function kJ(s) {
        var _a3;
        const e = s.items[s.items.length - 1], t = e.tokens ? e.tokens[e.tokens.length - 1] : void 0;
        let i;
        if ((t == null ? void 0 : t.type) === "text" && !("inRawBlock" in e) && (i = P6(t)), !i || i.type !== "paragraph") return;
        const n = Dv(s.items.slice(0, -1)), o = (_a3 = e.raw.match(/^(\s*(-|\d+\.|\*) +)/)) == null ? void 0 : _a3[0];
        if (!o) return;
        const r = o + Dv(e.tokens.slice(0, -1)) + i.raw, a = gw(n + r)[0];
        if (a.type === "list") return a;
      }
      const DJ = 3;
      function EJ(s) {
        for (let e = 0; e < DJ; e++) {
          const t = TJ(s);
          if (t) s = t;
          else break;
        }
        return s;
      }
      function TJ(s) {
        let e, t;
        for (e = 0; e < s.length; e++) {
          const i = s[e];
          if (i.type === "paragraph" && i.raw.match(/(\n|^)\|/)) {
            t = FJ(s.slice(e));
            break;
          }
          if (e === s.length - 1 && i.type === "list") {
            const n = kJ(i);
            if (n) {
              t = [
                n
              ];
              break;
            }
          }
          if (e === s.length - 1 && i.type === "paragraph") {
            const n = P6(i);
            if (n) {
              t = [
                n
              ];
              break;
            }
          }
        }
        if (t) {
          const i = [
            ...s.slice(0, e),
            ...t
          ];
          return i.links = s.links, i;
        }
        return null;
      }
      function NJ(s) {
        return fu(s, "`");
      }
      function IJ(s) {
        return fu(s, "*");
      }
      function MJ(s) {
        return fu(s, "_");
      }
      function AJ(s) {
        return fu(s, ")");
      }
      function RJ(s) {
        return fu(s, '")');
      }
      function OJ(s) {
        return fu(s, "](https://microsoft.com)");
      }
      function PJ(s) {
        return fu(s, "**");
      }
      function BJ(s) {
        return fu(s, "__");
      }
      function fu(s, e) {
        const t = Dv(Array.isArray(s) ? s : [
          s
        ]);
        return gw(t + e)[0];
      }
      function FJ(s) {
        const e = Dv(s), t = e.split(`
`);
        let i, n = false;
        for (let o = 0; o < t.length; o++) {
          const r = t[o].trim();
          if (typeof i > "u" && r.match(/^\s*\|/)) {
            const a = r.match(/(\|[^\|]+)(?=\||$)/g);
            a && (i = a.length);
          } else if (typeof i == "number") if (r.match(/^\s*\|/)) {
            if (o !== t.length - 1) return;
            n = true;
          } else return;
        }
        if (typeof i == "number" && i > 0) {
          const o = n ? t.slice(0, -1).join(`
`) : e, r = !!o.match(/\|\s*$/), a = o + (r ? "" : "|") + `
|${" --- |".repeat(i)}`;
          return gw(a);
        }
      }
      function H5(s, e) {
        return U9(s, e), Ze(() => $9(s));
      }
      const _Fi = class _Fi {
        static createEmpty(e, t) {
          const i = _Fi.defaultTokenMetadata, n = new Uint32Array(2);
          return n[0] = e.length, n[1] = i, new _Fi(n, e, t);
        }
        static createFromTextAndMetadata(e, t) {
          let i = 0, n = "";
          const o = new Array();
          for (const { text: r, metadata: a } of e) o.push(i + r.length, a), i += r.length, n += r;
          return new _Fi(new Uint32Array(o), n, t);
        }
        constructor(e, t, i) {
          this._lineTokensBrand = void 0, this._tokens = e, this._tokensCount = this._tokens.length >>> 1, this._text = t, this.languageIdCodec = i;
        }
        equals(e) {
          return e instanceof _Fi ? this.slicedEquals(e, 0, this._tokensCount) : false;
        }
        slicedEquals(e, t, i) {
          if (this._text !== e._text || this._tokensCount !== e._tokensCount) return false;
          const n = t << 1, o = n + (i << 1);
          for (let r = n; r < o; r++) if (this._tokens[r] !== e._tokens[r]) return false;
          return true;
        }
        getLineContent() {
          return this._text;
        }
        getCount() {
          return this._tokensCount;
        }
        getStartOffset(e) {
          return e > 0 ? this._tokens[e - 1 << 1] : 0;
        }
        getMetadata(e) {
          return this._tokens[(e << 1) + 1];
        }
        getLanguageId(e) {
          const t = this._tokens[(e << 1) + 1], i = Pr.getLanguageId(t);
          return this.languageIdCodec.decodeLanguageId(i);
        }
        getStandardTokenType(e) {
          const t = this._tokens[(e << 1) + 1];
          return Pr.getTokenType(t);
        }
        getForeground(e) {
          const t = this._tokens[(e << 1) + 1];
          return Pr.getForeground(t);
        }
        getClassName(e) {
          const t = this._tokens[(e << 1) + 1];
          return Pr.getClassNameFromMetadata(t);
        }
        getInlineStyle(e, t) {
          const i = this._tokens[(e << 1) + 1];
          return Pr.getInlineStyleFromMetadata(i, t);
        }
        getPresentation(e) {
          const t = this._tokens[(e << 1) + 1];
          return Pr.getPresentationFromMetadata(t);
        }
        getEndOffset(e) {
          return this._tokens[e << 1];
        }
        findTokenIndexAtOffset(e) {
          return _Fi.findIndexInTokensArray(this._tokens, e);
        }
        inflate() {
          return this;
        }
        sliceAndInflate(e, t, i) {
          return new qT(this, e, t, i);
        }
        static convertToEndOffset(e, t) {
          const n = (e.length >>> 1) - 1;
          for (let o = 0; o < n; o++) e[o << 1] = e[o + 1 << 1];
          e[n << 1] = t;
        }
        static findIndexInTokensArray(e, t) {
          if (e.length <= 2) return 0;
          let i = 0, n = (e.length >>> 1) - 1;
          for (; i < n; ) {
            const o = i + Math.floor((n - i) / 2), r = e[o << 1];
            if (r === t) return o + 1;
            r < t ? i = o + 1 : r > t && (n = o);
          }
          return i;
        }
        withInserted(e) {
          if (e.length === 0) return this;
          let t = 0, i = 0, n = "";
          const o = new Array();
          let r = 0;
          for (; ; ) {
            const a = t < this._tokensCount ? this._tokens[t << 1] : -1, l = i < e.length ? e[i] : null;
            if (a !== -1 && (l === null || a <= l.offset)) {
              n += this._text.substring(r, a);
              const u = this._tokens[(t << 1) + 1];
              o.push(n.length, u), t++, r = a;
            } else if (l) {
              if (l.offset > r) {
                n += this._text.substring(r, l.offset);
                const u = this._tokens[(t << 1) + 1];
                o.push(n.length, u), r = l.offset;
              }
              n += l.text, o.push(n.length, l.tokenMetadata), i++;
            } else break;
          }
          return new _Fi(new Uint32Array(o), n, this.languageIdCodec);
        }
        getTokenText(e) {
          const t = this.getStartOffset(e), i = this.getEndOffset(e);
          return this._text.substring(t, i);
        }
        forEach(e) {
          const t = this.getCount();
          for (let i = 0; i < t; i++) e(i);
        }
      };
      _Fi.defaultTokenMetadata = (32768 | 2 << 24) >>> 0;
      let Fi = _Fi;
      class qT {
        constructor(e, t, i, n) {
          this._source = e, this._startOffset = t, this._endOffset = i, this._deltaOffset = n, this._firstTokenIndex = e.findTokenIndexAtOffset(t), this.languageIdCodec = e.languageIdCodec, this._tokensCount = 0;
          for (let o = this._firstTokenIndex, r = e.getCount(); o < r && !(e.getStartOffset(o) >= i); o++) this._tokensCount++;
        }
        getMetadata(e) {
          return this._source.getMetadata(this._firstTokenIndex + e);
        }
        getLanguageId(e) {
          return this._source.getLanguageId(this._firstTokenIndex + e);
        }
        getLineContent() {
          return this._source.getLineContent().substring(this._startOffset, this._endOffset);
        }
        equals(e) {
          return e instanceof qT ? this._startOffset === e._startOffset && this._endOffset === e._endOffset && this._deltaOffset === e._deltaOffset && this._source.slicedEquals(e._source, this._firstTokenIndex, this._tokensCount) : false;
        }
        getCount() {
          return this._tokensCount;
        }
        getStandardTokenType(e) {
          return this._source.getStandardTokenType(this._firstTokenIndex + e);
        }
        getForeground(e) {
          return this._source.getForeground(this._firstTokenIndex + e);
        }
        getEndOffset(e) {
          const t = this._source.getEndOffset(this._firstTokenIndex + e);
          return Math.min(this._endOffset, t) - this._startOffset + this._deltaOffset;
        }
        getClassName(e) {
          return this._source.getClassName(this._firstTokenIndex + e);
        }
        getInlineStyle(e, t) {
          return this._source.getInlineStyle(this._firstTokenIndex + e, t);
        }
        getPresentation(e) {
          return this._source.getPresentation(this._firstTokenIndex + e);
        }
        findTokenIndexAtOffset(e) {
          return this._source.findTokenIndexAtOffset(e + this._startOffset - this._deltaOffset) - this._firstTokenIndex;
        }
        getTokenText(e) {
          const t = this._firstTokenIndex + e, i = this._source.getStartOffset(t), n = this._source.getEndOffset(t);
          let o = this._source.getTokenText(t);
          return i < this._startOffset && (o = o.substring(this._startOffset - i)), n > this._endOffset && (o = o.substring(0, o.length - (n - this._endOffset))), o;
        }
        forEach(e) {
          for (let t = 0; t < this.getCount(); t++) e(t);
        }
      }
      const a_ = new class {
        clone() {
          return this;
        }
        equals(s) {
          return this === s;
        }
      }();
      function B6(s, e) {
        return new $E([
          new Gp(0, "", s)
        ], e);
      }
      function KT(s, e) {
        const t = new Uint32Array(2);
        return t[0] = 0, t[1] = (s << 0 | 0 | 0 | 32768 | 2 << 24) >>> 0, new VC(t, e === null ? a_ : e);
      }
      const z5 = {
        getInitialState: () => a_,
        tokenizeEncoded: (s, e, t) => KT(0, t)
      };
      async function VJ(s, e, t) {
        if (!t) return U5(e, s.languageIdCodec, z5);
        const i = await Bi.getOrCreate(t);
        return U5(e, s.languageIdCodec, i || z5);
      }
      function WJ(s, e, t, i, n, o, r) {
        let a = "<div>", l = i, u = 0, d = true;
        for (let f = 0, m = e.getCount(); f < m; f++) {
          const _ = e.getEndOffset(f);
          if (_ <= i) continue;
          let b = "";
          for (; l < _ && l < n; l++) {
            const v = s.charCodeAt(l);
            switch (v) {
              case 9: {
                let y = o - (l + u) % o;
                for (u += y - 1; y > 0; ) r && d ? (b += "&#160;", d = false) : (b += " ", d = true), y--;
                break;
              }
              case 60:
                b += "&lt;", d = false;
                break;
              case 62:
                b += "&gt;", d = false;
                break;
              case 38:
                b += "&amp;", d = false;
                break;
              case 0:
                b += "&#00;", d = false;
                break;
              case 65279:
              case 8232:
              case 8233:
              case 133:
                b += "\uFFFD", d = false;
                break;
              case 13:
                b += "&#8203", d = false;
                break;
              case 32:
                r && d ? (b += "&#160;", d = false) : (b += " ", d = true);
                break;
              default:
                b += String.fromCharCode(v), d = false;
            }
          }
          if (a += `<span style="${e.getInlineStyle(f, t)}">${b}</span>`, _ > n || l >= n) break;
        }
        return a += "</div>", a;
      }
      function U5(s, e, t) {
        let i = '<div class="monaco-tokenized-source">';
        const n = xg(s);
        let o = t.getInitialState();
        for (let r = 0, a = n.length; r < a; r++) {
          const l = n[r];
          r > 0 && (i += "<br/>");
          const u = t.tokenizeEncoded(l, true, o);
          Fi.convertToEndOffset(u.tokens, l.length);
          const f = new Fi(u.tokens, l, e).inflate();
          let m = 0;
          for (let _ = 0, b = f.getCount(); _ < b; _++) {
            const v = f.getClassName(_), y = f.getEndOffset(_);
            i += `<span class="${v}">${mp(l.substring(m, y))}</span>`, m = y;
          }
          o = u.endState;
        }
        return i += "</div>", i;
      }
      var HJ = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      }, $5 = function(s, e) {
        return function(t, i) {
          e(t, i, s);
        };
      }, MD;
      let AD = (_g2 = class {
        constructor(e, t, i) {
          this._options = e, this._languageService = t, this._openerService = i, this._onDidRenderAsync = new G(), this.onDidRenderAsync = this._onDidRenderAsync.event;
        }
        dispose() {
          this._onDidRenderAsync.dispose();
        }
        render(e, t, i) {
          if (!e) return {
            element: document.createElement("span"),
            dispose: () => {
            }
          };
          const n = new Me(), o = n.add($T(e, {
            ...this._getRenderOptions(e, n),
            ...t
          }, i));
          return o.element.classList.add("rendered-markdown"), {
            element: o.element,
            dispose: () => n.dispose()
          };
        }
        _getRenderOptions(e, t) {
          return {
            codeBlockRenderer: async (i, n) => {
              var _a3, _b3;
              let o;
              i ? o = this._languageService.getLanguageIdByLanguageName(i) : this._options.editor && (o = (_a3 = this._options.editor.getModel()) == null ? void 0 : _a3.getLanguageId()), o || (o = gr);
              const r = await VJ(this._languageService, n, o), a = document.createElement("span");
              if (a.innerHTML = ((_b3 = MD._ttpTokenizer) == null ? void 0 : _b3.createHTML(r)) ?? r, this._options.editor) {
                const l = this._options.editor.getOption(50);
                Un(a, l);
              } else this._options.codeBlockFontFamily && (a.style.fontFamily = this._options.codeBlockFontFamily);
              return this._options.codeBlockFontSize !== void 0 && (a.style.fontSize = this._options.codeBlockFontSize), a;
            },
            asyncRenderCallback: () => this._onDidRenderAsync.fire(),
            actionHandler: {
              callback: (i) => F6(this._openerService, i, e.isTrusted),
              disposables: t
            }
          };
        }
      }, MD = _g2, _g2._ttpTokenizer = Xh("tokenizeToString", {
        createHTML(e) {
          return e;
        }
      }), _g2);
      AD = MD = HJ([
        $5(1, un),
        $5(2, X_)
      ], AD);
      async function F6(s, e, t) {
        try {
          return await s.open(e, {
            fromUserGesture: true,
            allowContributedOpeners: true,
            allowCommands: zJ(t)
          });
        } catch (i) {
          return qt(i), false;
        }
      }
      function zJ(s) {
        return s === true ? true : s && Array.isArray(s.enabledCommands) ? s.enabledCommands : false;
      }
      const ea = pt("accessibilityService"), UJ = new Ie("accessibilityModeEnabled", false), q5 = 2e4;
      let th, D0, RD, E0, OD;
      function $J(s) {
        th = document.createElement("div"), th.className = "monaco-aria-container";
        const e = () => {
          const i = document.createElement("div");
          return i.className = "monaco-alert", i.setAttribute("role", "alert"), i.setAttribute("aria-atomic", "true"), th.appendChild(i), i;
        };
        D0 = e(), RD = e();
        const t = () => {
          const i = document.createElement("div");
          return i.className = "monaco-status", i.setAttribute("aria-live", "polite"), i.setAttribute("aria-atomic", "true"), th.appendChild(i), i;
        };
        E0 = t(), OD = t(), s.appendChild(th);
      }
      function l_(s) {
        th && (D0.textContent !== s ? ($r(RD), Tv(D0, s)) : ($r(D0), Tv(RD, s)));
      }
      function Ev(s) {
        th && (E0.textContent !== s ? ($r(OD), Tv(E0, s)) : ($r(E0), Tv(OD, s)));
      }
      function Tv(s, e) {
        $r(s), e.length > q5 && (e = e.substr(0, q5)), s.textContent = e, s.style.visibility = "hidden", s.style.visibility = "visible";
      }
      var qJ = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      }, Wm = function(s, e) {
        return function(t, i) {
          e(t, i, s);
        };
      };
      const da = He;
      let PD = class extends Yl {
        get _targetWindow() {
          return Oe(this._target.targetElements[0]);
        }
        get _targetDocumentElement() {
          return Oe(this._target.targetElements[0]).document.documentElement;
        }
        get isDisposed() {
          return this._isDisposed;
        }
        get isMouseIn() {
          return this._lockMouseTracker.isMouseIn;
        }
        get domNode() {
          return this._hover.containerDomNode;
        }
        get onDispose() {
          return this._onDispose.event;
        }
        get onRequestLayout() {
          return this._onRequestLayout.event;
        }
        get anchor() {
          return this._hoverPosition === 2 ? 0 : 1;
        }
        get x() {
          return this._x;
        }
        get y() {
          return this._y;
        }
        get isLocked() {
          return this._isLocked;
        }
        set isLocked(e) {
          this._isLocked !== e && (this._isLocked = e, this._hoverContainer.classList.toggle("locked", this._isLocked));
        }
        constructor(e, t, i, n, o, r) {
          var _a3, _b3, _c2, _d2, _e2, _f3, _g3;
          super(), this._keybindingService = t, this._configurationService = i, this._openerService = n, this._instantiationService = o, this._accessibilityService = r, this._messageListeners = new Me(), this._isDisposed = false, this._forcePosition = false, this._x = 0, this._y = 0, this._isLocked = false, this._enableFocusTraps = false, this._addedFocusTrap = false, this._onDispose = this._register(new G()), this._onRequestLayout = this._register(new G()), this._linkHandler = e.linkHandler || ((m) => F6(this._openerService, m, Vf(e.content) ? e.content.isTrusted : void 0)), this._target = "targetElements" in e.target ? e.target : new KJ(e.target), this._hoverPointer = ((_a3 = e.appearance) == null ? void 0 : _a3.showPointer) ? da("div.workbench-hover-pointer") : void 0, this._hover = this._register(new LX()), this._hover.containerDomNode.classList.add("workbench-hover", "fadeIn"), ((_b3 = e.appearance) == null ? void 0 : _b3.compact) && this._hover.containerDomNode.classList.add("workbench-hover", "compact"), ((_c2 = e.appearance) == null ? void 0 : _c2.skipFadeInAnimation) && this._hover.containerDomNode.classList.add("skip-fade-in"), e.additionalClasses && this._hover.containerDomNode.classList.add(...e.additionalClasses), ((_d2 = e.position) == null ? void 0 : _d2.forcePosition) && (this._forcePosition = true), e.trapFocus && (this._enableFocusTraps = true), this._hoverPosition = ((_e2 = e.position) == null ? void 0 : _e2.hoverPosition) ?? 3, this.onmousedown(this._hover.containerDomNode, (m) => m.stopPropagation()), this.onkeydown(this._hover.containerDomNode, (m) => {
            m.equals(9) && this.dispose();
          }), this._register(re(this._targetWindow, "blur", () => this.dispose()));
          const a = da("div.hover-row.markdown-hover"), l = da("div.hover-contents");
          if (typeof e.content == "string") l.textContent = e.content, l.style.whiteSpace = "pre-wrap";
          else if (wn(e.content)) l.appendChild(e.content), l.classList.add("html-hover-contents");
          else {
            const m = e.content, _ = this._instantiationService.createInstance(AD, {
              codeBlockFontFamily: this._configurationService.getValue("editor").fontFamily || fo.fontFamily
            }), { element: b } = _.render(m, {
              actionHandler: {
                callback: (v) => this._linkHandler(v),
                disposables: this._messageListeners
              },
              asyncRenderCallback: () => {
                l.classList.add("code-hover-contents"), this.layout(), this._onRequestLayout.fire();
              }
            });
            l.appendChild(b);
          }
          if (a.appendChild(l), this._hover.contentsDomNode.appendChild(a), e.actions && e.actions.length > 0) {
            const m = da("div.hover-row.status-bar"), _ = da("div.actions");
            e.actions.forEach((b) => {
              const v = this._keybindingService.lookupKeybinding(b.commandId), y = v ? v.getLabel() : null;
              BT.render(_, {
                label: b.label,
                commandId: b.commandId,
                run: (x) => {
                  b.run(x), this.dispose();
                },
                iconClass: b.iconClass
              }, y);
            }), m.appendChild(_), this._hover.containerDomNode.appendChild(m);
          }
          this._hoverContainer = da("div.workbench-hover-container"), this._hoverPointer && this._hoverContainer.appendChild(this._hoverPointer), this._hoverContainer.appendChild(this._hover.containerDomNode);
          let u;
          if (e.actions && e.actions.length > 0 ? u = false : ((_f3 = e.persistence) == null ? void 0 : _f3.hideOnHover) === void 0 ? u = typeof e.content == "string" || Vf(e.content) && !e.content.value.includes("](") && !e.content.value.includes("</a>") : u = e.persistence.hideOnHover, (_g3 = e.appearance) == null ? void 0 : _g3.showHoverHint) {
            const m = da("div.hover-row.status-bar"), _ = da("div.info");
            _.textContent = C("hoverhint", "Hold {0} key to mouse over", _t ? "Option" : "Alt"), m.appendChild(_), this._hover.containerDomNode.appendChild(m);
          }
          const d = [
            ...this._target.targetElements
          ];
          u || d.push(this._hoverContainer);
          const f = this._register(new K5(d));
          if (this._register(f.onMouseOut(() => {
            this._isLocked || this.dispose();
          })), u) {
            const m = [
              ...this._target.targetElements,
              this._hoverContainer
            ];
            this._lockMouseTracker = this._register(new K5(m)), this._register(this._lockMouseTracker.onMouseOut(() => {
              this._isLocked || this.dispose();
            }));
          } else this._lockMouseTracker = f;
        }
        addFocusTrap() {
          if (!this._enableFocusTraps || this._addedFocusTrap) return;
          this._addedFocusTrap = true;
          const e = this._hover.containerDomNode, t = this.findLastFocusableChild(this._hover.containerDomNode);
          if (t) {
            const i = uT(this._hoverContainer, da("div")), n = Ne(this._hoverContainer, da("div"));
            i.tabIndex = 0, n.tabIndex = 0, this._register(re(n, "focus", (o) => {
              e.focus(), o.preventDefault();
            })), this._register(re(i, "focus", (o) => {
              t.focus(), o.preventDefault();
            }));
          }
        }
        findLastFocusableChild(e) {
          if (e.hasChildNodes()) for (let t = 0; t < e.childNodes.length; t++) {
            const i = e.childNodes.item(e.childNodes.length - t - 1);
            if (i.nodeType === i.ELEMENT_NODE) {
              const o = i;
              if (typeof o.tabIndex == "number" && o.tabIndex >= 0) return o;
            }
            const n = this.findLastFocusableChild(i);
            if (n) return n;
          }
        }
        render(e) {
          var _a3;
          e.appendChild(this._hoverContainer);
          const i = this._hoverContainer.contains(this._hoverContainer.ownerDocument.activeElement) && xX(this._configurationService.getValue("accessibility.verbosity.hover") === true && this._accessibilityService.isScreenReaderOptimized(), (_a3 = this._keybindingService.lookupKeybinding("editor.action.accessibleView")) == null ? void 0 : _a3.getAriaLabel());
          i && Ev(i), this.layout(), this.addFocusTrap();
        }
        layout() {
          this._hover.containerDomNode.classList.remove("right-aligned"), this._hover.contentsDomNode.style.maxHeight = "";
          const e = (d) => {
            const f = Y9(d), m = d.getBoundingClientRect();
            return {
              top: m.top * f,
              bottom: m.bottom * f,
              right: m.right * f,
              left: m.left * f
            };
          }, t = this._target.targetElements.map((d) => e(d)), { top: i, right: n, bottom: o, left: r } = t[0], a = n - r, l = o - i, u = {
            top: i,
            right: n,
            bottom: o,
            left: r,
            width: a,
            height: l,
            center: {
              x: r + a / 2,
              y: i + l / 2
            }
          };
          if (this.adjustHorizontalHoverPosition(u), this.adjustVerticalHoverPosition(u), this.adjustHoverMaxHeight(u), this._hoverContainer.style.padding = "", this._hoverContainer.style.margin = "", this._hoverPointer) {
            switch (this._hoverPosition) {
              case 1:
                u.left += 3, u.right += 3, this._hoverContainer.style.paddingLeft = "3px", this._hoverContainer.style.marginLeft = "-3px";
                break;
              case 0:
                u.left -= 3, u.right -= 3, this._hoverContainer.style.paddingRight = "3px", this._hoverContainer.style.marginRight = "-3px";
                break;
              case 2:
                u.top += 3, u.bottom += 3, this._hoverContainer.style.paddingTop = "3px", this._hoverContainer.style.marginTop = "-3px";
                break;
              case 3:
                u.top -= 3, u.bottom -= 3, this._hoverContainer.style.paddingBottom = "3px", this._hoverContainer.style.marginBottom = "-3px";
                break;
            }
            u.center.x = u.left + a / 2, u.center.y = u.top + l / 2;
          }
          this.computeXCordinate(u), this.computeYCordinate(u), this._hoverPointer && (this._hoverPointer.classList.remove("top"), this._hoverPointer.classList.remove("left"), this._hoverPointer.classList.remove("right"), this._hoverPointer.classList.remove("bottom"), this.setHoverPointerPosition(u)), this._hover.onContentsChanged();
        }
        computeXCordinate(e) {
          const t = this._hover.containerDomNode.clientWidth + 2;
          this._target.x !== void 0 ? this._x = this._target.x : this._hoverPosition === 1 ? this._x = e.right : this._hoverPosition === 0 ? this._x = e.left - t : (this._hoverPointer ? this._x = e.center.x - this._hover.containerDomNode.clientWidth / 2 : this._x = e.left, this._x + t >= this._targetDocumentElement.clientWidth && (this._hover.containerDomNode.classList.add("right-aligned"), this._x = Math.max(this._targetDocumentElement.clientWidth - t - 2, this._targetDocumentElement.clientLeft))), this._x < this._targetDocumentElement.clientLeft && (this._x = e.left + 2);
        }
        computeYCordinate(e) {
          this._target.y !== void 0 ? this._y = this._target.y : this._hoverPosition === 3 ? this._y = e.top : this._hoverPosition === 2 ? this._y = e.bottom - 2 : this._hoverPointer ? this._y = e.center.y + this._hover.containerDomNode.clientHeight / 2 : this._y = e.bottom, this._y > this._targetWindow.innerHeight && (this._y = e.bottom);
        }
        adjustHorizontalHoverPosition(e) {
          if (this._target.x !== void 0) return;
          const t = this._hoverPointer ? 3 : 0;
          if (this._forcePosition) {
            const i = t + 2;
            this._hoverPosition === 1 ? this._hover.containerDomNode.style.maxWidth = `${this._targetDocumentElement.clientWidth - e.right - i}px` : this._hoverPosition === 0 && (this._hover.containerDomNode.style.maxWidth = `${e.left - i}px`);
            return;
          }
          this._hoverPosition === 1 ? this._targetDocumentElement.clientWidth - e.right < this._hover.containerDomNode.clientWidth + t && (e.left >= this._hover.containerDomNode.clientWidth + t ? this._hoverPosition = 0 : this._hoverPosition = 2) : this._hoverPosition === 0 && (e.left < this._hover.containerDomNode.clientWidth + t && (this._targetDocumentElement.clientWidth - e.right >= this._hover.containerDomNode.clientWidth + t ? this._hoverPosition = 1 : this._hoverPosition = 2), e.left - this._hover.containerDomNode.clientWidth - t <= this._targetDocumentElement.clientLeft && (this._hoverPosition = 1));
        }
        adjustVerticalHoverPosition(e) {
          if (this._target.y !== void 0 || this._forcePosition) return;
          const t = this._hoverPointer ? 3 : 0;
          this._hoverPosition === 3 ? e.top - this._hover.containerDomNode.clientHeight - t < 0 && (this._hoverPosition = 2) : this._hoverPosition === 2 && e.bottom + this._hover.containerDomNode.clientHeight + t > this._targetWindow.innerHeight && (this._hoverPosition = 3);
        }
        adjustHoverMaxHeight(e) {
          let t = this._targetWindow.innerHeight / 2;
          if (this._forcePosition) {
            const i = (this._hoverPointer ? 3 : 0) + 2;
            this._hoverPosition === 3 ? t = Math.min(t, e.top - i) : this._hoverPosition === 2 && (t = Math.min(t, this._targetWindow.innerHeight - e.bottom - i));
          }
          if (this._hover.containerDomNode.style.maxHeight = `${t}px`, this._hover.contentsDomNode.clientHeight < this._hover.contentsDomNode.scrollHeight) {
            const i = `${this._hover.scrollbar.options.verticalScrollbarSize}px`;
            this._hover.contentsDomNode.style.paddingRight !== i && (this._hover.contentsDomNode.style.paddingRight = i);
          }
        }
        setHoverPointerPosition(e) {
          if (this._hoverPointer) switch (this._hoverPosition) {
            case 0:
            case 1: {
              this._hoverPointer.classList.add(this._hoverPosition === 0 ? "right" : "left");
              const t = this._hover.containerDomNode.clientHeight;
              t > e.height ? this._hoverPointer.style.top = `${e.center.y - (this._y - t) - 3}px` : this._hoverPointer.style.top = `${Math.round(t / 2) - 3}px`;
              break;
            }
            case 3:
            case 2: {
              this._hoverPointer.classList.add(this._hoverPosition === 3 ? "bottom" : "top");
              const t = this._hover.containerDomNode.clientWidth;
              let i = Math.round(t / 2) - 3;
              const n = this._x + i;
              (n < e.left || n > e.right) && (i = e.center.x - this._x - 3), this._hoverPointer.style.left = `${i}px`;
              break;
            }
          }
        }
        focus() {
          this._hover.containerDomNode.focus();
        }
        dispose() {
          this._isDisposed || (this._onDispose.fire(), this._hoverContainer.remove(), this._messageListeners.dispose(), this._target.dispose(), super.dispose()), this._isDisposed = true;
        }
      };
      PD = qJ([
        Wm(1, Pn),
        Wm(2, Si),
        Wm(3, X_),
        Wm(4, Ft),
        Wm(5, ea)
      ], PD);
      class K5 extends Yl {
        get onMouseOut() {
          return this._onMouseOut.event;
        }
        get isMouseIn() {
          return this._isMouseIn;
        }
        constructor(e) {
          super(), this._elements = e, this._isMouseIn = true, this._onMouseOut = this._register(new G()), this._elements.forEach((t) => this.onmouseover(t, () => this._onTargetMouseOver(t))), this._elements.forEach((t) => this.onmouseleave(t, () => this._onTargetMouseLeave(t)));
        }
        _onTargetMouseOver(e) {
          this._isMouseIn = true, this._clearEvaluateMouseStateTimeout(e);
        }
        _onTargetMouseLeave(e) {
          this._isMouseIn = false, this._evaluateMouseState(e);
        }
        _evaluateMouseState(e) {
          this._clearEvaluateMouseStateTimeout(e), this._mouseTimeout = Oe(e).setTimeout(() => this._fireIfMouseOutside(), 0);
        }
        _clearEvaluateMouseStateTimeout(e) {
          this._mouseTimeout && (Oe(e).clearTimeout(this._mouseTimeout), this._mouseTimeout = void 0);
        }
        _fireIfMouseOutside() {
          this._isMouseIn || this._onMouseOut.fire();
        }
      }
      class KJ {
        constructor(e) {
          this._element = e, this.targetElements = [
            this._element
          ];
        }
        dispose() {
        }
      }
      var Hn;
      (function(s) {
        function e(o, r) {
          if (o.start >= r.end || r.start >= o.end) return {
            start: 0,
            end: 0
          };
          const a = Math.max(o.start, r.start), l = Math.min(o.end, r.end);
          return l - a <= 0 ? {
            start: 0,
            end: 0
          } : {
            start: a,
            end: l
          };
        }
        s.intersect = e;
        function t(o) {
          return o.end - o.start <= 0;
        }
        s.isEmpty = t;
        function i(o, r) {
          return !t(e(o, r));
        }
        s.intersects = i;
        function n(o, r) {
          const a = [], l = {
            start: o.start,
            end: Math.min(r.start, o.end)
          }, u = {
            start: Math.max(r.end, o.start),
            end: o.end
          };
          return t(l) || a.push(l), t(u) || a.push(u), a;
        }
        s.relativeComplement = n;
      })(Hn || (Hn = {}));
      function jJ(s) {
        const e = s;
        return !!e && typeof e.x == "number" && typeof e.y == "number";
      }
      var $c;
      (function(s) {
        s[s.AVOID = 0] = "AVOID", s[s.ALIGN = 1] = "ALIGN";
      })($c || ($c = {}));
      function _f(s, e, t) {
        const i = t.mode === $c.ALIGN ? t.offset : t.offset + t.size, n = t.mode === $c.ALIGN ? t.offset + t.size : t.offset;
        return t.position === 0 ? e <= s - i ? i : e <= n ? n - e : Math.max(s - e, 0) : e <= n ? n - e : e <= s - i ? i : 0;
      }
      const _Nv = class _Nv extends he {
        constructor(e, t) {
          super(), this.container = null, this.useFixedPosition = false, this.useShadowDOM = false, this.delegate = null, this.toDisposeOnClean = he.None, this.toDisposeOnSetContainer = he.None, this.shadowRoot = null, this.shadowRootHostElement = null, this.view = He(".context-view"), lO(this.view), this.setContainer(e, t), this._register(Ze(() => this.setContainer(null, 1)));
        }
        setContainer(e, t) {
          var _a3;
          this.useFixedPosition = t !== 1;
          const i = this.useShadowDOM;
          if (this.useShadowDOM = t === 3, !(e === this.container && i === this.useShadowDOM) && (this.container && (this.toDisposeOnSetContainer.dispose(), this.view.remove(), this.shadowRoot && (this.shadowRoot = null, (_a3 = this.shadowRootHostElement) == null ? void 0 : _a3.remove(), this.shadowRootHostElement = null), this.container = null), e)) {
            if (this.container = e, this.useShadowDOM) {
              this.shadowRootHostElement = He(".shadow-root-host"), this.container.appendChild(this.shadowRootHostElement), this.shadowRoot = this.shadowRootHostElement.attachShadow({
                mode: "open"
              });
              const o = document.createElement("style");
              o.textContent = GJ, this.shadowRoot.appendChild(o), this.shadowRoot.appendChild(this.view), this.shadowRoot.appendChild(He("slot"));
            } else this.container.appendChild(this.view);
            const n = new Me();
            _Nv.BUBBLE_UP_EVENTS.forEach((o) => {
              n.add(ln(this.container, o, (r) => {
                this.onDOMEvent(r, false);
              }));
            }), _Nv.BUBBLE_DOWN_EVENTS.forEach((o) => {
              n.add(ln(this.container, o, (r) => {
                this.onDOMEvent(r, true);
              }, true));
            }), this.toDisposeOnSetContainer = n;
          }
        }
        show(e) {
          var _a3, _b3;
          this.isVisible() && this.hide(), $r(this.view), this.view.className = "context-view monaco-component", this.view.style.top = "0px", this.view.style.left = "0px", this.view.style.zIndex = `${2575 + (e.layer ?? 0)}`, this.view.style.position = this.useFixedPosition ? "fixed" : "absolute", e8(this.view), this.toDisposeOnClean = e.render(this.view) || he.None, this.delegate = e, this.doLayout(), (_b3 = (_a3 = this.delegate).focus) == null ? void 0 : _b3.call(_a3);
        }
        getViewElement() {
          return this.view;
        }
        layout() {
          var _a3, _b3;
          if (this.isVisible()) {
            if (this.delegate.canRelayout === false && !(Ih && I9.pointerEvents)) {
              this.hide();
              return;
            }
            (_b3 = (_a3 = this.delegate) == null ? void 0 : _a3.layout) == null ? void 0 : _b3.call(_a3), this.doLayout();
          }
        }
        doLayout() {
          if (!this.isVisible()) return;
          const e = this.delegate.getAnchor();
          let t;
          if (wn(e)) {
            const m = Bo(e), _ = Y9(e);
            t = {
              top: m.top * _,
              left: m.left * _,
              width: m.width * _,
              height: m.height * _
            };
          } else jJ(e) ? t = {
            top: e.y,
            left: e.x,
            width: e.width || 1,
            height: e.height || 2
          } : t = {
            top: e.posy,
            left: e.posx,
            width: 2,
            height: 2
          };
          const i = rT(this.view), n = qk(this.view), o = this.delegate.anchorPosition || 0, r = this.delegate.anchorAlignment || 0, a = this.delegate.anchorAxisAlignment || 0;
          let l, u;
          const d = Jm();
          if (a === 0) {
            const m = {
              offset: t.top - d.pageYOffset,
              size: t.height,
              position: o === 0 ? 0 : 1
            }, _ = {
              offset: t.left,
              size: t.width,
              position: r === 0 ? 0 : 1,
              mode: $c.ALIGN
            };
            l = _f(d.innerHeight, n, m) + d.pageYOffset, Hn.intersects({
              start: l,
              end: l + n
            }, {
              start: m.offset,
              end: m.offset + m.size
            }) && (_.mode = $c.AVOID), u = _f(d.innerWidth, i, _);
          } else {
            const m = {
              offset: t.left,
              size: t.width,
              position: r === 0 ? 0 : 1
            }, _ = {
              offset: t.top,
              size: t.height,
              position: o === 0 ? 0 : 1,
              mode: $c.ALIGN
            };
            u = _f(d.innerWidth, i, m), Hn.intersects({
              start: u,
              end: u + i
            }, {
              start: m.offset,
              end: m.offset + m.size
            }) && (_.mode = $c.AVOID), l = _f(d.innerHeight, n, _) + d.pageYOffset;
          }
          this.view.classList.remove("top", "bottom", "left", "right"), this.view.classList.add(o === 0 ? "bottom" : "top"), this.view.classList.add(r === 0 ? "left" : "right"), this.view.classList.toggle("fixed", this.useFixedPosition);
          const f = Bo(this.container);
          this.view.style.top = `${l - (this.useFixedPosition ? Bo(this.view).top : f.top)}px`, this.view.style.left = `${u - (this.useFixedPosition ? Bo(this.view).left : f.left)}px`, this.view.style.width = "initial";
        }
        hide(e) {
          const t = this.delegate;
          this.delegate = null, (t == null ? void 0 : t.onHide) && t.onHide(e), this.toDisposeOnClean.dispose(), lO(this.view);
        }
        isVisible() {
          return !!this.delegate;
        }
        onDOMEvent(e, t) {
          this.delegate && (this.delegate.onDOMEvent ? this.delegate.onDOMEvent(e, Oe(e).document.activeElement) : t && !an(e.target, this.container) && this.hide());
        }
        dispose() {
          this.hide(), super.dispose();
        }
      };
      _Nv.BUBBLE_UP_EVENTS = [
        "click",
        "keydown",
        "focus",
        "blur"
      ];
      _Nv.BUBBLE_DOWN_EVENTS = [
        "click"
      ];
      let Nv = _Nv;
      const GJ = `
	:host {
		all: initial; /* 1st rule so subsequent properties are reset. */
	}

	.codicon[class*='codicon-'] {
		font: normal normal normal 16px/1 codicon;
		display: inline-block;
		text-decoration: none;
		text-rendering: auto;
		text-align: center;
		-webkit-font-smoothing: antialiased;
		-moz-osx-font-smoothing: grayscale;
		user-select: none;
		-webkit-user-select: none;
		-ms-user-select: none;
	}

	:host {
		font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "HelveticaNeue-Light", system-ui, "Ubuntu", "Droid Sans", sans-serif;
	}

	:host-context(.mac) { font-family: -apple-system, BlinkMacSystemFont, sans-serif; }
	:host-context(.mac:lang(zh-Hans)) { font-family: -apple-system, BlinkMacSystemFont, "PingFang SC", "Hiragino Sans GB", sans-serif; }
	:host-context(.mac:lang(zh-Hant)) { font-family: -apple-system, BlinkMacSystemFont, "PingFang TC", sans-serif; }
	:host-context(.mac:lang(ja)) { font-family: -apple-system, BlinkMacSystemFont, "Hiragino Kaku Gothic Pro", sans-serif; }
	:host-context(.mac:lang(ko)) { font-family: -apple-system, BlinkMacSystemFont, "Nanum Gothic", "Apple SD Gothic Neo", "AppleGothic", sans-serif; }

	:host-context(.windows) { font-family: "Segoe WPC", "Segoe UI", sans-serif; }
	:host-context(.windows:lang(zh-Hans)) { font-family: "Segoe WPC", "Segoe UI", "Microsoft YaHei", sans-serif; }
	:host-context(.windows:lang(zh-Hant)) { font-family: "Segoe WPC", "Segoe UI", "Microsoft Jhenghei", sans-serif; }
	:host-context(.windows:lang(ja)) { font-family: "Segoe WPC", "Segoe UI", "Yu Gothic UI", "Meiryo UI", sans-serif; }
	:host-context(.windows:lang(ko)) { font-family: "Segoe WPC", "Segoe UI", "Malgun Gothic", "Dotom", sans-serif; }

	:host-context(.linux) { font-family: system-ui, "Ubuntu", "Droid Sans", sans-serif; }
	:host-context(.linux:lang(zh-Hans)) { font-family: system-ui, "Ubuntu", "Droid Sans", "Source Han Sans SC", "Source Han Sans CN", "Source Han Sans", sans-serif; }
	:host-context(.linux:lang(zh-Hant)) { font-family: system-ui, "Ubuntu", "Droid Sans", "Source Han Sans TC", "Source Han Sans TW", "Source Han Sans", sans-serif; }
	:host-context(.linux:lang(ja)) { font-family: system-ui, "Ubuntu", "Droid Sans", "Source Han Sans J", "Source Han Sans JP", "Source Han Sans", sans-serif; }
	:host-context(.linux:lang(ko)) { font-family: system-ui, "Ubuntu", "Droid Sans", "Source Han Sans K", "Source Han Sans JR", "Source Han Sans", "UnDotum", "FBaekmuk Gulim", sans-serif; }
`;
      var YJ = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      }, ZJ = function(s, e) {
        return function(t, i) {
          e(t, i, s);
        };
      };
      let Iv = class extends he {
        constructor(e) {
          super(), this.layoutService = e, this.contextView = this._register(new Nv(this.layoutService.mainContainer, 1)), this.layout(), this._register(e.onDidLayoutContainer(() => this.layout()));
        }
        showContextView(e, t, i) {
          let n;
          t ? t === this.layoutService.getContainer(Oe(t)) ? n = 1 : i ? n = 3 : n = 2 : n = 1, this.contextView.setContainer(t ?? this.layoutService.activeContainer, n), this.contextView.show(e);
          const o = {
            close: () => {
              this.openContextView === o && this.hideContextView();
            }
          };
          return this.openContextView = o, o;
        }
        layout() {
          this.contextView.layout();
        }
        hideContextView(e) {
          this.contextView.hide(e), this.openContextView = void 0;
        }
      };
      Iv = YJ([
        ZJ(0, du)
      ], Iv);
      class QJ extends Iv {
        getContextViewElement() {
          return this.contextView.getViewElement();
        }
      }
      class XJ {
        constructor(e, t, i) {
          this.hoverDelegate = e, this.target = t, this.fadeInAnimation = i;
        }
        async update(e, t, i) {
          if (this._cancellationTokenSource && (this._cancellationTokenSource.dispose(true), this._cancellationTokenSource = void 0), this.isDisposed) return;
          let n;
          if (e === void 0 || ho(e) || wn(e)) n = e;
          else if (!$0(e.markdown)) n = e.markdown ?? e.markdownNotSupportedFallback;
          else {
            this._hoverWidget || this.show(C("iconLabel.loading", "Loading..."), t, i), this._cancellationTokenSource = new Lg();
            const o = this._cancellationTokenSource.token;
            if (n = await e.markdown(o), n === void 0 && (n = e.markdownNotSupportedFallback), this.isDisposed || o.isCancellationRequested) return;
          }
          this.show(n, t, i);
        }
        show(e, t, i) {
          var _a3;
          const n = this._hoverWidget;
          if (this.hasContent(e)) {
            const o = {
              content: e,
              target: this.target,
              actions: i == null ? void 0 : i.actions,
              linkHandler: i == null ? void 0 : i.linkHandler,
              trapFocus: i == null ? void 0 : i.trapFocus,
              appearance: {
                showPointer: this.hoverDelegate.placement === "element",
                skipFadeInAnimation: !this.fadeInAnimation || !!n,
                showHoverHint: (_a3 = i == null ? void 0 : i.appearance) == null ? void 0 : _a3.showHoverHint
              },
              position: {
                hoverPosition: 2
              }
            };
            this._hoverWidget = this.hoverDelegate.showHover(o, t);
          }
          n == null ? void 0 : n.dispose();
        }
        hasContent(e) {
          return e ? Vf(e) ? !!e.value : true : false;
        }
        get isDisposed() {
          var _a3;
          return (_a3 = this._hoverWidget) == null ? void 0 : _a3.isDisposed;
        }
        dispose() {
          var _a3, _b3;
          (_a3 = this._hoverWidget) == null ? void 0 : _a3.dispose(), (_b3 = this._cancellationTokenSource) == null ? void 0 : _b3.dispose(true), this._cancellationTokenSource = void 0;
        }
      }
      var JJ = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      }, Hm = function(s, e) {
        return function(t, i) {
          e(t, i, s);
        };
      };
      let BD = class extends he {
        constructor(e, t, i, n, o) {
          super(), this._instantiationService = e, this._keybindingService = i, this._layoutService = n, this._accessibilityService = o, this._managedHovers = /* @__PURE__ */ new Map(), t.onDidShowContextMenu(() => this.hideHover()), this._contextViewHandler = this._register(new Iv(this._layoutService));
        }
        showHover(e, t, i) {
          var _a3, _b3, _c2, _d2;
          if (j5(this._currentHoverOptions) === j5(e) || this._currentHover && ((_b3 = (_a3 = this._currentHoverOptions) == null ? void 0 : _a3.persistence) == null ? void 0 : _b3.sticky)) return;
          this._currentHoverOptions = e, this._lastHoverOptions = e;
          const n = e.trapFocus || this._accessibilityService.isScreenReaderOptimized(), o = ss();
          i || (n && o ? o.classList.contains("monaco-hover") || (this._lastFocusedElementBeforeOpen = o) : this._lastFocusedElementBeforeOpen = void 0);
          const r = new Me(), a = this._instantiationService.createInstance(PD, e);
          if (((_c2 = e.persistence) == null ? void 0 : _c2.sticky) && (a.isLocked = true), a.onDispose(() => {
            var _a4, _b4;
            ((_a4 = this._currentHover) == null ? void 0 : _a4.domNode) && Q9(this._currentHover.domNode) && ((_b4 = this._lastFocusedElementBeforeOpen) == null ? void 0 : _b4.focus()), this._currentHoverOptions === e && (this._currentHoverOptions = void 0), r.dispose();
          }, void 0, r), !e.container) {
            const l = wn(e.target) ? e.target : e.target.targetElements[0];
            e.container = this._layoutService.getContainer(Oe(l));
          }
          if (this._contextViewHandler.showContextView(new eee(a, t), e.container), a.onRequestLayout(() => this._contextViewHandler.layout(), void 0, r), (_d2 = e.persistence) == null ? void 0 : _d2.sticky) r.add(re(Oe(e.container).document, Ce.MOUSE_DOWN, (l) => {
            an(l.target, a.domNode) || this.doHideHover();
          }));
          else {
            if ("targetElements" in e.target) for (const u of e.target.targetElements) r.add(re(u, Ce.CLICK, () => this.hideHover()));
            else r.add(re(e.target, Ce.CLICK, () => this.hideHover()));
            const l = ss();
            if (l) {
              const u = Oe(l).document;
              r.add(re(l, Ce.KEY_DOWN, (d) => {
                var _a4;
                return this._keyDown(d, a, !!((_a4 = e.persistence) == null ? void 0 : _a4.hideOnKeyDown));
              })), r.add(re(u, Ce.KEY_DOWN, (d) => {
                var _a4;
                return this._keyDown(d, a, !!((_a4 = e.persistence) == null ? void 0 : _a4.hideOnKeyDown));
              })), r.add(re(l, Ce.KEY_UP, (d) => this._keyUp(d, a))), r.add(re(u, Ce.KEY_UP, (d) => this._keyUp(d, a)));
            }
          }
          if ("IntersectionObserver" in Kt) {
            const l = new IntersectionObserver((d) => this._intersectionChange(d, a), {
              threshold: 0
            }), u = "targetElements" in e.target ? e.target.targetElements[0] : e.target;
            l.observe(u), r.add(Ze(() => l.disconnect()));
          }
          return this._currentHover = a, a;
        }
        hideHover() {
          var _a3;
          ((_a3 = this._currentHover) == null ? void 0 : _a3.isLocked) || !this._currentHoverOptions || this.doHideHover();
        }
        doHideHover() {
          this._currentHover = void 0, this._currentHoverOptions = void 0, this._contextViewHandler.hideContextView();
        }
        _intersectionChange(e, t) {
          e[e.length - 1].isIntersecting || t.dispose();
        }
        showAndFocusLastHover() {
          this._lastHoverOptions && this.showHover(this._lastHoverOptions, true, true);
        }
        _keyDown(e, t, i) {
          var _a3, _b3;
          if (e.key === "Alt") {
            t.isLocked = true;
            return;
          }
          const n = new si(e);
          this._keybindingService.resolveKeyboardEvent(n).getSingleModifierDispatchChords().some((r) => !!r) || this._keybindingService.softDispatch(n, n.target).kind !== 0 || i && (!((_a3 = this._currentHoverOptions) == null ? void 0 : _a3.trapFocus) || e.key !== "Tab") && (this.hideHover(), (_b3 = this._lastFocusedElementBeforeOpen) == null ? void 0 : _b3.focus());
        }
        _keyUp(e, t) {
          var _a3;
          e.key === "Alt" && (t.isLocked = false, t.isMouseIn || (this.hideHover(), (_a3 = this._lastFocusedElementBeforeOpen) == null ? void 0 : _a3.focus()));
        }
        setupManagedHover(e, t, i, n) {
          t.setAttribute("custom-hover", "true"), t.title !== "" && (console.warn("HTML element already has a title attribute, which will conflict with the custom hover. Please remove the title attribute."), console.trace("Stack trace:", t.title), t.title = "");
          let o, r;
          const a = (D, k) => {
            var _a3;
            const T = r !== void 0;
            D && (r == null ? void 0 : r.dispose(), r = void 0), k && (o == null ? void 0 : o.dispose(), o = void 0), T && ((_a3 = e.onDidHideHover) == null ? void 0 : _a3.call(e), r = void 0);
          }, l = (D, k, T, M) => new Kh(async () => {
            (!r || r.isDisposed) && (r = new XJ(e, T || t, D > 0), await r.update(typeof i == "function" ? i() : i, k, {
              ...n,
              trapFocus: M
            }));
          }, D);
          let u = false;
          const d = re(t, Ce.MOUSE_DOWN, () => {
            u = true, a(true, true);
          }, true), f = re(t, Ce.MOUSE_UP, () => {
            u = false;
          }, true), m = re(t, Ce.MOUSE_LEAVE, (D) => {
            u = false, a(false, D.fromElement === t);
          }, true), _ = (D) => {
            if (o) return;
            const k = new Me(), T = {
              targetElements: [
                t
              ],
              dispose: () => {
              }
            };
            if (e.placement === void 0 || e.placement === "mouse") {
              const M = (I) => {
                T.x = I.x + 10, wn(I.target) && G5(I.target, t) !== t && a(true, true);
              };
              k.add(re(t, Ce.MOUSE_MOVE, M, true));
            }
            o = k, !(wn(D.target) && G5(D.target, t) !== t) && k.add(l(e.delay, false, T));
          }, b = re(t, Ce.MOUSE_OVER, _, true), v = () => {
            if (u || o) return;
            const D = {
              targetElements: [
                t
              ],
              dispose: () => {
              }
            }, k = new Me(), T = () => a(true, true);
            k.add(re(t, Ce.BLUR, T, true)), k.add(l(e.delay, false, D)), o = k;
          };
          let y;
          const x = t.tagName.toLowerCase();
          x !== "input" && x !== "textarea" && (y = re(t, Ce.FOCUS, v, true));
          const L = {
            show: (D) => {
              a(false, true), l(0, D, void 0, D);
            },
            hide: () => {
              a(true, true);
            },
            update: async (D, k) => {
              i = D, await (r == null ? void 0 : r.update(i, void 0, k));
            },
            dispose: () => {
              this._managedHovers.delete(t), b.dispose(), m.dispose(), d.dispose(), f.dispose(), y == null ? void 0 : y.dispose(), a(true, true);
            }
          };
          return this._managedHovers.set(t, L), L;
        }
        showManagedHover(e) {
          const t = this._managedHovers.get(e);
          t && t.show(true);
        }
        dispose() {
          this._managedHovers.forEach((e) => e.dispose()), super.dispose();
        }
      };
      BD = JJ([
        Hm(0, Ft),
        Hm(1, Gl),
        Hm(2, Pn),
        Hm(3, du),
        Hm(4, ea)
      ], BD);
      function j5(s) {
        if (s !== void 0) return (s == null ? void 0 : s.id) ?? s;
      }
      class eee {
        get anchorPosition() {
          return this._hover.anchor;
        }
        constructor(e, t = false) {
          this._hover = e, this._focus = t, this.layer = 1;
        }
        render(e) {
          return this._hover.render(e), this._focus && this._hover.focus(), this._hover;
        }
        getAnchor() {
          return {
            x: this._hover.x,
            y: this._hover.y
          };
        }
        layout() {
          this._hover.layout();
        }
      }
      function G5(s, e) {
        for (e = e ?? Oe(s).document.body; !s.hasAttribute("custom-hover") && s !== e; ) s = s.parentElement;
        return s;
      }
      Lt(Z_, BD, 1);
      jl((s, e) => {
        const t = s.getColor(FZ);
        t && (e.addRule(`.monaco-workbench .workbench-hover .hover-row:not(:first-child):not(:empty) { border-top: 1px solid ${t.transparent(0.5)}; }`), e.addRule(`.monaco-workbench .workbench-hover hr { border-top: 1px solid ${t.transparent(0.5)}; }`));
      });
      const tee = pt("IWorkspaceEditService");
      class jT {
        constructor(e) {
          this.metadata = e;
        }
        static convert(e) {
          return e.edits.map((t) => {
            if (yh.is(t)) return yh.lift(t);
            if (Wf.is(t)) return Wf.lift(t);
            throw new Error("Unsupported edit");
          });
        }
      }
      class yh extends jT {
        static is(e) {
          return e instanceof yh ? true : Es(e) && st.isUri(e.resource) && Es(e.textEdit);
        }
        static lift(e) {
          return e instanceof yh ? e : new yh(e.resource, e.textEdit, e.versionId, e.metadata);
        }
        constructor(e, t, i = void 0, n) {
          super(n), this.resource = e, this.textEdit = t, this.versionId = i;
        }
      }
      class Wf extends jT {
        static is(e) {
          return e instanceof Wf ? true : Es(e) && (!!e.newResource || !!e.oldResource);
        }
        static lift(e) {
          return e instanceof Wf ? e : new Wf(e.oldResource, e.newResource, e.options, e.metadata);
        }
        constructor(e, t, i = {}, n) {
          super(n), this.oldResource = e, this.newResource = t, this.options = i;
        }
      }
      const Tn = {
        enableSplitViewResizing: true,
        renderSideBySide: true,
        renderMarginRevertIcon: true,
        renderGutterMenu: true,
        maxComputationTime: 5e3,
        maxFileSize: 50,
        ignoreTrimWhitespace: true,
        renderIndicators: true,
        originalEditable: false,
        diffCodeLens: false,
        renderOverviewRuler: true,
        diffWordWrap: "inherit",
        diffAlgorithm: "advanced",
        accessibilityVerbose: false,
        experimental: {
          showMoves: false,
          showEmptyDecorations: true,
          useTrueInlineView: false
        },
        hideUnchangedRegions: {
          enabled: false,
          contextLineCount: 3,
          minimumLineCount: 3,
          revealLineCount: 20
        },
        isInEmbeddedEditor: false,
        onlyShowAccessibleDiffViewer: false,
        renderSideBySideInlineBreakpoint: 900,
        useInlineViewWhenSpaceIsLimited: true,
        compactMode: false
      }, iee = Object.freeze({
        id: "editor",
        order: 5,
        type: "object",
        title: C("editorConfigurationTitle", "Editor"),
        scope: 5
      }), Mv = {
        ...iee,
        properties: {
          "editor.tabSize": {
            type: "number",
            default: zn.tabSize,
            minimum: 1,
            markdownDescription: C("tabSize", "The number of spaces a tab is equal to. This setting is overridden based on the file contents when {0} is on.", "`#editor.detectIndentation#`")
          },
          "editor.indentSize": {
            anyOf: [
              {
                type: "string",
                enum: [
                  "tabSize"
                ]
              },
              {
                type: "number",
                minimum: 1
              }
            ],
            default: "tabSize",
            markdownDescription: C("indentSize", 'The number of spaces used for indentation or `"tabSize"` to use the value from `#editor.tabSize#`. This setting is overridden based on the file contents when `#editor.detectIndentation#` is on.')
          },
          "editor.insertSpaces": {
            type: "boolean",
            default: zn.insertSpaces,
            markdownDescription: C("insertSpaces", "Insert spaces when pressing `Tab`. This setting is overridden based on the file contents when {0} is on.", "`#editor.detectIndentation#`")
          },
          "editor.detectIndentation": {
            type: "boolean",
            default: zn.detectIndentation,
            markdownDescription: C("detectIndentation", "Controls whether {0} and {1} will be automatically detected when a file is opened based on the file contents.", "`#editor.tabSize#`", "`#editor.insertSpaces#`")
          },
          "editor.trimAutoWhitespace": {
            type: "boolean",
            default: zn.trimAutoWhitespace,
            description: C("trimAutoWhitespace", "Remove trailing auto inserted whitespace.")
          },
          "editor.largeFileOptimizations": {
            type: "boolean",
            default: zn.largeFileOptimizations,
            description: C("largeFileOptimizations", "Special handling for large files to disable certain memory intensive features.")
          },
          "editor.wordBasedSuggestions": {
            enum: [
              "off",
              "currentDocument",
              "matchingDocuments",
              "allDocuments"
            ],
            default: "matchingDocuments",
            enumDescriptions: [
              C("wordBasedSuggestions.off", "Turn off Word Based Suggestions."),
              C("wordBasedSuggestions.currentDocument", "Only suggest words from the active document."),
              C("wordBasedSuggestions.matchingDocuments", "Suggest words from all open documents of the same language."),
              C("wordBasedSuggestions.allDocuments", "Suggest words from all open documents.")
            ],
            description: C("wordBasedSuggestions", "Controls whether completions should be computed based on words in the document and from which documents they are computed.")
          },
          "editor.semanticHighlighting.enabled": {
            enum: [
              true,
              false,
              "configuredByTheme"
            ],
            enumDescriptions: [
              C("semanticHighlighting.true", "Semantic highlighting enabled for all color themes."),
              C("semanticHighlighting.false", "Semantic highlighting disabled for all color themes."),
              C("semanticHighlighting.configuredByTheme", "Semantic highlighting is configured by the current color theme's `semanticHighlighting` setting.")
            ],
            default: "configuredByTheme",
            description: C("semanticHighlighting.enabled", "Controls whether the semanticHighlighting is shown for the languages that support it.")
          },
          "editor.stablePeek": {
            type: "boolean",
            default: false,
            markdownDescription: C("stablePeek", "Keep peek editors open even when double-clicking their content or when hitting `Escape`.")
          },
          "editor.maxTokenizationLineLength": {
            type: "integer",
            default: 2e4,
            description: C("maxTokenizationLineLength", "Lines above this length will not be tokenized for performance reasons")
          },
          "editor.experimental.asyncTokenization": {
            type: "boolean",
            default: true,
            description: C("editor.experimental.asyncTokenization", "Controls whether the tokenization should happen asynchronously on a web worker."),
            tags: [
              "experimental"
            ]
          },
          "editor.experimental.asyncTokenizationLogging": {
            type: "boolean",
            default: false,
            description: C("editor.experimental.asyncTokenizationLogging", "Controls whether async tokenization should be logged. For debugging only.")
          },
          "editor.experimental.asyncTokenizationVerification": {
            type: "boolean",
            default: false,
            description: C("editor.experimental.asyncTokenizationVerification", "Controls whether async tokenization should be verified against legacy background tokenization. Might slow down tokenization. For debugging only."),
            tags: [
              "experimental"
            ]
          },
          "editor.experimental.treeSitterTelemetry": {
            type: "boolean",
            default: false,
            markdownDescription: C("editor.experimental.treeSitterTelemetry", "Controls whether tree sitter parsing should be turned on and telemetry collected. Setting `editor.experimental.preferTreeSitter` for specific languages will take precedence."),
            tags: [
              "experimental"
            ]
          },
          "editor.language.brackets": {
            type: [
              "array",
              "null"
            ],
            default: null,
            description: C("schema.brackets", "Defines the bracket symbols that increase or decrease the indentation."),
            items: {
              type: "array",
              items: [
                {
                  type: "string",
                  description: C("schema.openBracket", "The opening bracket character or string sequence.")
                },
                {
                  type: "string",
                  description: C("schema.closeBracket", "The closing bracket character or string sequence.")
                }
              ]
            }
          },
          "editor.language.colorizedBracketPairs": {
            type: [
              "array",
              "null"
            ],
            default: null,
            description: C("schema.colorizedBracketPairs", "Defines the bracket pairs that are colorized by their nesting level if bracket pair colorization is enabled."),
            items: {
              type: "array",
              items: [
                {
                  type: "string",
                  description: C("schema.openBracket", "The opening bracket character or string sequence.")
                },
                {
                  type: "string",
                  description: C("schema.closeBracket", "The closing bracket character or string sequence.")
                }
              ]
            }
          },
          "diffEditor.maxComputationTime": {
            type: "number",
            default: Tn.maxComputationTime,
            description: C("maxComputationTime", "Timeout in milliseconds after which diff computation is cancelled. Use 0 for no timeout.")
          },
          "diffEditor.maxFileSize": {
            type: "number",
            default: Tn.maxFileSize,
            description: C("maxFileSize", "Maximum file size in MB for which to compute diffs. Use 0 for no limit.")
          },
          "diffEditor.renderSideBySide": {
            type: "boolean",
            default: Tn.renderSideBySide,
            description: C("sideBySide", "Controls whether the diff editor shows the diff side by side or inline.")
          },
          "diffEditor.renderSideBySideInlineBreakpoint": {
            type: "number",
            default: Tn.renderSideBySideInlineBreakpoint,
            description: C("renderSideBySideInlineBreakpoint", "If the diff editor width is smaller than this value, the inline view is used.")
          },
          "diffEditor.useInlineViewWhenSpaceIsLimited": {
            type: "boolean",
            default: Tn.useInlineViewWhenSpaceIsLimited,
            description: C("useInlineViewWhenSpaceIsLimited", "If enabled and the editor width is too small, the inline view is used.")
          },
          "diffEditor.renderMarginRevertIcon": {
            type: "boolean",
            default: Tn.renderMarginRevertIcon,
            description: C("renderMarginRevertIcon", "When enabled, the diff editor shows arrows in its glyph margin to revert changes.")
          },
          "diffEditor.renderGutterMenu": {
            type: "boolean",
            default: Tn.renderGutterMenu,
            description: C("renderGutterMenu", "When enabled, the diff editor shows a special gutter for revert and stage actions.")
          },
          "diffEditor.ignoreTrimWhitespace": {
            type: "boolean",
            default: Tn.ignoreTrimWhitespace,
            description: C("ignoreTrimWhitespace", "When enabled, the diff editor ignores changes in leading or trailing whitespace.")
          },
          "diffEditor.renderIndicators": {
            type: "boolean",
            default: Tn.renderIndicators,
            description: C("renderIndicators", "Controls whether the diff editor shows +/- indicators for added/removed changes.")
          },
          "diffEditor.codeLens": {
            type: "boolean",
            default: Tn.diffCodeLens,
            description: C("codeLens", "Controls whether the editor shows CodeLens.")
          },
          "diffEditor.wordWrap": {
            type: "string",
            enum: [
              "off",
              "on",
              "inherit"
            ],
            default: Tn.diffWordWrap,
            markdownEnumDescriptions: [
              C("wordWrap.off", "Lines will never wrap."),
              C("wordWrap.on", "Lines will wrap at the viewport width."),
              C("wordWrap.inherit", "Lines will wrap according to the {0} setting.", "`#editor.wordWrap#`")
            ]
          },
          "diffEditor.diffAlgorithm": {
            type: "string",
            enum: [
              "legacy",
              "advanced"
            ],
            default: Tn.diffAlgorithm,
            markdownEnumDescriptions: [
              C("diffAlgorithm.legacy", "Uses the legacy diffing algorithm."),
              C("diffAlgorithm.advanced", "Uses the advanced diffing algorithm.")
            ],
            tags: [
              "experimental"
            ]
          },
          "diffEditor.hideUnchangedRegions.enabled": {
            type: "boolean",
            default: Tn.hideUnchangedRegions.enabled,
            markdownDescription: C("hideUnchangedRegions.enabled", "Controls whether the diff editor shows unchanged regions.")
          },
          "diffEditor.hideUnchangedRegions.revealLineCount": {
            type: "integer",
            default: Tn.hideUnchangedRegions.revealLineCount,
            markdownDescription: C("hideUnchangedRegions.revealLineCount", "Controls how many lines are used for unchanged regions."),
            minimum: 1
          },
          "diffEditor.hideUnchangedRegions.minimumLineCount": {
            type: "integer",
            default: Tn.hideUnchangedRegions.minimumLineCount,
            markdownDescription: C("hideUnchangedRegions.minimumLineCount", "Controls how many lines are used as a minimum for unchanged regions."),
            minimum: 1
          },
          "diffEditor.hideUnchangedRegions.contextLineCount": {
            type: "integer",
            default: Tn.hideUnchangedRegions.contextLineCount,
            markdownDescription: C("hideUnchangedRegions.contextLineCount", "Controls how many lines are used as context when comparing unchanged regions."),
            minimum: 1
          },
          "diffEditor.experimental.showMoves": {
            type: "boolean",
            default: Tn.experimental.showMoves,
            markdownDescription: C("showMoves", "Controls whether the diff editor should show detected code moves.")
          },
          "diffEditor.experimental.showEmptyDecorations": {
            type: "boolean",
            default: Tn.experimental.showEmptyDecorations,
            description: C("showEmptyDecorations", "Controls whether the diff editor shows empty decorations to see where characters got inserted or deleted.")
          },
          "diffEditor.experimental.useTrueInlineView": {
            type: "boolean",
            default: Tn.experimental.useTrueInlineView,
            description: C("useTrueInlineView", "If enabled and the editor uses the inline view, word changes are rendered inline.")
          }
        }
      };
      function nee(s) {
        return typeof s.type < "u" || typeof s.anyOf < "u";
      }
      for (const s of lf) {
        const e = s.schema;
        if (typeof e < "u") if (nee(e)) Mv.properties[`editor.${s.name}`] = e;
        else for (const t in e) Object.hasOwnProperty.call(e, t) && (Mv.properties[t] = e[t]);
      }
      let Wb = null;
      function V6() {
        return Wb === null && (Wb = /* @__PURE__ */ Object.create(null), Object.keys(Mv.properties).forEach((s) => {
          Wb[s] = true;
        })), Wb;
      }
      function see(s) {
        return V6()[`editor.${s}`] || false;
      }
      function oee(s) {
        return V6()[`diffEditor.${s}`] || false;
      }
      const ree = yn.as(Jh.Configuration);
      ree.registerConfiguration(Mv);
      class aee {
        static insert(e, t) {
          return {
            range: new z(e.lineNumber, e.column, e.lineNumber, e.column),
            text: t,
            forceMoveMarkers: true
          };
        }
        static delete(e) {
          return {
            range: e,
            text: null
          };
        }
        static replace(e, t) {
          return {
            range: e,
            text: t
          };
        }
        static replaceMove(e, t) {
          return {
            range: e,
            text: t,
            forceMoveMarkers: true
          };
        }
      }
      function Hb(s) {
        return Object.isFrozen(s) ? s : xU(s);
      }
      class Cn {
        static createEmptyModel(e) {
          return new Cn({}, [], [], void 0, e);
        }
        constructor(e, t, i, n, o) {
          this._contents = e, this._keys = t, this._overrides = i, this.raw = n, this.logService = o, this.overrideConfigurations = /* @__PURE__ */ new Map();
        }
        get rawConfiguration() {
          var _a3;
          if (!this._rawConfiguration) if ((_a3 = this.raw) == null ? void 0 : _a3.length) {
            const e = this.raw.map((t) => {
              if (t instanceof Cn) return t;
              const i = new lee("", this.logService);
              return i.parseRaw(t), i.configurationModel;
            });
            this._rawConfiguration = e.reduce((t, i) => i === t ? i : t.merge(i), e[0]);
          } else this._rawConfiguration = this;
          return this._rawConfiguration;
        }
        get contents() {
          return this._contents;
        }
        get overrides() {
          return this._overrides;
        }
        get keys() {
          return this._keys;
        }
        isEmpty() {
          return this._keys.length === 0 && Object.keys(this._contents).length === 0 && this._overrides.length === 0;
        }
        getValue(e) {
          return e ? yO(this.contents, e) : this.contents;
        }
        inspect(e, t) {
          const i = this;
          return {
            get value() {
              return Hb(i.rawConfiguration.getValue(e));
            },
            get override() {
              return t ? Hb(i.rawConfiguration.getOverrideValue(e, t)) : void 0;
            },
            get merged() {
              return Hb(t ? i.rawConfiguration.override(t).getValue(e) : i.rawConfiguration.getValue(e));
            },
            get overrides() {
              const n = [];
              for (const { contents: o, identifiers: r, keys: a } of i.rawConfiguration.overrides) {
                const l = new Cn(o, a, [], void 0, i.logService).getValue(e);
                l !== void 0 && n.push({
                  identifiers: r,
                  value: l
                });
              }
              return n.length ? Hb(n) : void 0;
            }
          };
        }
        getOverrideValue(e, t) {
          const i = this.getContentsForOverrideIdentifer(t);
          return i ? e ? yO(i, e) : i : void 0;
        }
        override(e) {
          let t = this.overrideConfigurations.get(e);
          return t || (t = this.createOverrideConfigurationModel(e), this.overrideConfigurations.set(e, t)), t;
        }
        merge(...e) {
          var _a3, _b3;
          const t = Dc(this.contents), i = Dc(this.overrides), n = [
            ...this.keys
          ], o = ((_a3 = this.raw) == null ? void 0 : _a3.length) ? [
            ...this.raw
          ] : [
            this
          ];
          for (const r of e) if (o.push(...((_b3 = r.raw) == null ? void 0 : _b3.length) ? r.raw : [
            r
          ]), !r.isEmpty()) {
            this.mergeContents(t, r.contents);
            for (const a of r.overrides) {
              const [l] = i.filter((u) => Qi(u.identifiers, a.identifiers));
              l ? (this.mergeContents(l.contents, a.contents), l.keys.push(...a.keys), l.keys = Nh(l.keys)) : i.push(Dc(a));
            }
            for (const a of r.keys) n.indexOf(a) === -1 && n.push(a);
          }
          return new Cn(t, n, i, o.every((r) => r instanceof Cn) ? void 0 : o, this.logService);
        }
        createOverrideConfigurationModel(e) {
          const t = this.getContentsForOverrideIdentifer(e);
          if (!t || typeof t != "object" || !Object.keys(t).length) return this;
          const i = {};
          for (const n of Nh([
            ...Object.keys(this.contents),
            ...Object.keys(t)
          ])) {
            let o = this.contents[n];
            const r = t[n];
            r && (typeof o == "object" && typeof r == "object" ? (o = Dc(o), this.mergeContents(o, r)) : o = r), i[n] = o;
          }
          return new Cn(i, this.keys, this.overrides, void 0, this.logService);
        }
        mergeContents(e, t) {
          for (const i of Object.keys(t)) {
            if (i in e && Es(e[i]) && Es(t[i])) {
              this.mergeContents(e[i], t[i]);
              continue;
            }
            e[i] = Dc(t[i]);
          }
        }
        getContentsForOverrideIdentifer(e) {
          let t = null, i = null;
          const n = (o) => {
            o && (i ? this.mergeContents(i, o) : i = Dc(o));
          };
          for (const o of this.overrides) o.identifiers.length === 1 && o.identifiers[0] === e ? t = o.contents : o.identifiers.includes(e) && n(o.contents);
          return n(t), i;
        }
        toJSON() {
          return {
            contents: this.contents,
            overrides: this.overrides,
            keys: this.keys
          };
        }
        setValue(e, t) {
          this.updateValue(e, t, false);
        }
        removeValue(e) {
          const t = this.keys.indexOf(e);
          t !== -1 && (this.keys.splice(t, 1), rG(this.contents, e), ou.test(e) && this.overrides.splice(this.overrides.findIndex((i) => Qi(i.identifiers, cv(e))), 1));
        }
        updateValue(e, t, i) {
          if (_8(this.contents, e, t, (n) => this.logService.error(n)), i = i || this.keys.indexOf(e) === -1, i && this.keys.push(e), ou.test(e)) {
            const n = cv(e), o = {
              identifiers: n,
              keys: Object.keys(this.contents[e]),
              contents: Xk(this.contents[e], (a) => this.logService.error(a))
            }, r = this.overrides.findIndex((a) => Qi(a.identifiers, n));
            r !== -1 ? this.overrides[r] = o : this.overrides.push(o);
          }
        }
      }
      class lee {
        constructor(e, t) {
          this._name = e, this.logService = t, this._raw = null, this._configurationModel = null, this._restrictedConfigurations = [];
        }
        get configurationModel() {
          return this._configurationModel || Cn.createEmptyModel(this.logService);
        }
        parseRaw(e, t) {
          this._raw = e;
          const { contents: i, keys: n, overrides: o, restricted: r, hasExcludedProperties: a } = this.doParseRaw(e, t);
          this._configurationModel = new Cn(i, n, o, a ? [
            e
          ] : void 0, this.logService), this._restrictedConfigurations = r || [];
        }
        doParseRaw(e, t) {
          const i = yn.as(Jh.Configuration).getConfigurationProperties(), n = this.filter(e, i, true, t);
          e = n.raw;
          const o = Xk(e, (l) => this.logService.error(`Conflict in settings file ${this._name}: ${l}`)), r = Object.keys(e), a = this.toOverrides(e, (l) => this.logService.error(`Conflict in settings file ${this._name}: ${l}`));
          return {
            contents: o,
            keys: r,
            overrides: a,
            restricted: n.restricted,
            hasExcludedProperties: n.hasExcludedProperties
          };
        }
        filter(e, t, i, n) {
          var _a3, _b3, _c2;
          let o = false;
          if (!(n == null ? void 0 : n.scopes) && !(n == null ? void 0 : n.skipRestricted) && !((_a3 = n == null ? void 0 : n.exclude) == null ? void 0 : _a3.length)) return {
            raw: e,
            restricted: [],
            hasExcludedProperties: o
          };
          const r = {}, a = [];
          for (const l in e) if (ou.test(l) && i) {
            const u = this.filter(e[l], t, false, n);
            r[l] = u.raw, o = o || u.hasExcludedProperties, a.push(...u.restricted);
          } else {
            const u = t[l], d = u ? typeof u.scope < "u" ? u.scope : 3 : void 0;
            (u == null ? void 0 : u.restricted) && a.push(l), !((_b3 = n.exclude) == null ? void 0 : _b3.includes(l)) && (((_c2 = n.include) == null ? void 0 : _c2.includes(l)) || (d === void 0 || n.scopes === void 0 || n.scopes.includes(d)) && !(n.skipRestricted && (u == null ? void 0 : u.restricted))) ? r[l] = e[l] : o = true;
          }
          return {
            raw: r,
            restricted: a,
            hasExcludedProperties: o
          };
        }
        toOverrides(e, t) {
          const i = [];
          for (const n of Object.keys(e)) if (ou.test(n)) {
            const o = {};
            for (const r in e[n]) o[r] = e[n][r];
            i.push({
              identifiers: cv(n),
              keys: Object.keys(o),
              contents: Xk(o, t)
            });
          }
          return i;
        }
      }
      class cee {
        constructor(e, t, i, n, o, r, a, l, u, d, f, m, _) {
          this.key = e, this.overrides = t, this._value = i, this.overrideIdentifiers = n, this.defaultConfiguration = o, this.policyConfiguration = r, this.applicationConfiguration = a, this.userConfiguration = l, this.localUserConfiguration = u, this.remoteUserConfiguration = d, this.workspaceConfiguration = f, this.folderConfigurationModel = m, this.memoryConfigurationModel = _;
        }
        toInspectValue(e) {
          return (e == null ? void 0 : e.value) !== void 0 || (e == null ? void 0 : e.override) !== void 0 || (e == null ? void 0 : e.overrides) !== void 0 ? e : void 0;
        }
        get userInspectValue() {
          return this._userInspectValue || (this._userInspectValue = this.userConfiguration.inspect(this.key, this.overrides.overrideIdentifier)), this._userInspectValue;
        }
        get user() {
          return this.toInspectValue(this.userInspectValue);
        }
      }
      class mw {
        constructor(e, t, i, n, o, r, a, l, u, d) {
          this._defaultConfiguration = e, this._policyConfiguration = t, this._applicationConfiguration = i, this._localUserConfiguration = n, this._remoteUserConfiguration = o, this._workspaceConfiguration = r, this._folderConfigurations = a, this._memoryConfiguration = l, this._memoryConfigurationByResource = u, this.logService = d, this._workspaceConsolidatedConfiguration = null, this._foldersConsolidatedConfigurations = new fs(), this._userConfiguration = null;
        }
        getValue(e, t, i) {
          return this.getConsolidatedConfigurationModel(e, t, i).getValue(e);
        }
        updateValue(e, t, i = {}) {
          let n;
          i.resource ? (n = this._memoryConfigurationByResource.get(i.resource), n || (n = Cn.createEmptyModel(this.logService), this._memoryConfigurationByResource.set(i.resource, n))) : n = this._memoryConfiguration, t === void 0 ? n.removeValue(e) : n.setValue(e, t), i.resource || (this._workspaceConsolidatedConfiguration = null);
        }
        inspect(e, t, i) {
          const n = this.getConsolidatedConfigurationModel(e, t, i), o = this.getFolderConfigurationModelForResource(t.resource, i), r = t.resource ? this._memoryConfigurationByResource.get(t.resource) || this._memoryConfiguration : this._memoryConfiguration, a = /* @__PURE__ */ new Set();
          for (const l of n.overrides) for (const u of l.identifiers) n.getOverrideValue(e, u) !== void 0 && a.add(u);
          return new cee(e, t, n.getValue(e), a.size ? [
            ...a
          ] : void 0, this._defaultConfiguration, this._policyConfiguration.isEmpty() ? void 0 : this._policyConfiguration, this.applicationConfiguration.isEmpty() ? void 0 : this.applicationConfiguration, this.userConfiguration, this.localUserConfiguration, this.remoteUserConfiguration, i ? this._workspaceConfiguration : void 0, o || void 0, r);
        }
        get applicationConfiguration() {
          return this._applicationConfiguration;
        }
        get userConfiguration() {
          return this._userConfiguration || (this._userConfiguration = this._remoteUserConfiguration.isEmpty() ? this._localUserConfiguration : this._localUserConfiguration.merge(this._remoteUserConfiguration)), this._userConfiguration;
        }
        get localUserConfiguration() {
          return this._localUserConfiguration;
        }
        get remoteUserConfiguration() {
          return this._remoteUserConfiguration;
        }
        getConsolidatedConfigurationModel(e, t, i) {
          let n = this.getConsolidatedConfigurationModelForResource(t, i);
          return t.overrideIdentifier && (n = n.override(t.overrideIdentifier)), !this._policyConfiguration.isEmpty() && this._policyConfiguration.getValue(e) !== void 0 && (n = n.merge(this._policyConfiguration)), n;
        }
        getConsolidatedConfigurationModelForResource({ resource: e }, t) {
          let i = this.getWorkspaceConsolidatedConfiguration();
          if (t && e) {
            const n = t.getFolder(e);
            n && (i = this.getFolderConsolidatedConfiguration(n.uri) || i);
            const o = this._memoryConfigurationByResource.get(e);
            o && (i = i.merge(o));
          }
          return i;
        }
        getWorkspaceConsolidatedConfiguration() {
          return this._workspaceConsolidatedConfiguration || (this._workspaceConsolidatedConfiguration = this._defaultConfiguration.merge(this.applicationConfiguration, this.userConfiguration, this._workspaceConfiguration, this._memoryConfiguration)), this._workspaceConsolidatedConfiguration;
        }
        getFolderConsolidatedConfiguration(e) {
          let t = this._foldersConsolidatedConfigurations.get(e);
          if (!t) {
            const i = this.getWorkspaceConsolidatedConfiguration(), n = this._folderConfigurations.get(e);
            n ? (t = i.merge(n), this._foldersConsolidatedConfigurations.set(e, t)) : t = i;
          }
          return t;
        }
        getFolderConfigurationModelForResource(e, t) {
          if (t && e) {
            const i = t.getFolder(e);
            if (i) return this._folderConfigurations.get(i.uri);
          }
        }
        toData() {
          return {
            defaults: {
              contents: this._defaultConfiguration.contents,
              overrides: this._defaultConfiguration.overrides,
              keys: this._defaultConfiguration.keys
            },
            policy: {
              contents: this._policyConfiguration.contents,
              overrides: this._policyConfiguration.overrides,
              keys: this._policyConfiguration.keys
            },
            application: {
              contents: this.applicationConfiguration.contents,
              overrides: this.applicationConfiguration.overrides,
              keys: this.applicationConfiguration.keys
            },
            user: {
              contents: this.userConfiguration.contents,
              overrides: this.userConfiguration.overrides,
              keys: this.userConfiguration.keys
            },
            workspace: {
              contents: this._workspaceConfiguration.contents,
              overrides: this._workspaceConfiguration.overrides,
              keys: this._workspaceConfiguration.keys
            },
            folders: [
              ...this._folderConfigurations.keys()
            ].reduce((e, t) => {
              const { contents: i, overrides: n, keys: o } = this._folderConfigurations.get(t);
              return e.push([
                t,
                {
                  contents: i,
                  overrides: n,
                  keys: o
                }
              ]), e;
            }, [])
          };
        }
        static parse(e, t) {
          const i = this.parseConfigurationModel(e.defaults, t), n = this.parseConfigurationModel(e.policy, t), o = this.parseConfigurationModel(e.application, t), r = this.parseConfigurationModel(e.user, t), a = this.parseConfigurationModel(e.workspace, t), l = e.folders.reduce((u, d) => (u.set(st.revive(d[0]), this.parseConfigurationModel(d[1], t)), u), new fs());
          return new mw(i, n, o, r, Cn.createEmptyModel(t), a, l, Cn.createEmptyModel(t), new fs(), t);
        }
        static parseConfigurationModel(e, t) {
          return new Cn(e.contents, e.keys, e.overrides, void 0, t);
        }
      }
      class uee {
        constructor(e, t, i, n, o) {
          this.change = e, this.previous = t, this.currentConfiguraiton = i, this.currentWorkspace = n, this.logService = o, this._marker = `
`, this._markerCode1 = this._marker.charCodeAt(0), this._markerCode2 = 46, this.affectedKeys = /* @__PURE__ */ new Set(), this._previousConfiguration = void 0;
          for (const r of e.keys) this.affectedKeys.add(r);
          for (const [, r] of e.overrides) for (const a of r) this.affectedKeys.add(a);
          this._affectsConfigStr = this._marker;
          for (const r of this.affectedKeys) this._affectsConfigStr += r + this._marker;
        }
        get previousConfiguration() {
          return !this._previousConfiguration && this.previous && (this._previousConfiguration = mw.parse(this.previous.data, this.logService)), this._previousConfiguration;
        }
        affectsConfiguration(e, t) {
          var _a3;
          const i = this._marker + e, n = this._affectsConfigStr.indexOf(i);
          if (n < 0) return false;
          const o = n + i.length;
          if (o >= this._affectsConfigStr.length) return false;
          const r = this._affectsConfigStr.charCodeAt(o);
          if (r !== this._markerCode1 && r !== this._markerCode2) return false;
          if (t) {
            const a = this.previousConfiguration ? this.previousConfiguration.getValue(e, t, (_a3 = this.previous) == null ? void 0 : _a3.workspace) : void 0, l = this.currentConfiguraiton.getValue(e, t, this.currentWorkspace);
            return !$s(a, l);
          }
          return true;
        }
      }
      class hee {
        constructor() {
          this._onDidChange = new G(), this.onDidChange = this._onDidChange.event, this._enabled = true;
        }
        get enabled() {
          return this._enabled;
        }
        enable() {
          this._enabled = true, this._onDidChange.fire();
        }
        disable() {
          this._enabled = false, this._onDidChange.fire();
        }
      }
      const wp = new hee(), Av = {
        kind: 0
      }, dee = {
        kind: 1
      };
      function fee(s, e, t) {
        return {
          kind: 2,
          commandId: s,
          commandArgs: e,
          isBubble: t
        };
      }
      class yp {
        constructor(e, t, i) {
          var _a3;
          this._log = i, this._defaultKeybindings = e, this._defaultBoundCommands = /* @__PURE__ */ new Map();
          for (const n of e) {
            const o = n.command;
            o && o.charAt(0) !== "-" && this._defaultBoundCommands.set(o, true);
          }
          this._map = /* @__PURE__ */ new Map(), this._lookupMap = /* @__PURE__ */ new Map(), this._keybindings = yp.handleRemovals([].concat(e).concat(t));
          for (let n = 0, o = this._keybindings.length; n < o; n++) {
            const r = this._keybindings[n];
            if (r.chords.length === 0) continue;
            const a = (_a3 = r.when) == null ? void 0 : _a3.substituteConstants();
            a && a.type === 0 || this._addKeyPress(r.chords[0], r);
          }
        }
        static _isTargetedForRemoval(e, t, i) {
          if (t) {
            for (let n = 0; n < t.length; n++) if (t[n] !== e.chords[n]) return false;
          }
          return !(i && i.type !== 1 && (!e.when || !vj(i, e.when)));
        }
        static handleRemovals(e) {
          const t = /* @__PURE__ */ new Map();
          for (let n = 0, o = e.length; n < o; n++) {
            const r = e[n];
            if (r.command && r.command.charAt(0) === "-") {
              const a = r.command.substring(1);
              t.has(a) ? t.get(a).push(r) : t.set(a, [
                r
              ]);
            }
          }
          if (t.size === 0) return e;
          const i = [];
          for (let n = 0, o = e.length; n < o; n++) {
            const r = e[n];
            if (!r.command || r.command.length === 0) {
              i.push(r);
              continue;
            }
            if (r.command.charAt(0) === "-") continue;
            const a = t.get(r.command);
            if (!a || !r.isDefault) {
              i.push(r);
              continue;
            }
            let l = false;
            for (const u of a) {
              const d = u.when;
              if (this._isTargetedForRemoval(r, u.chords, d)) {
                l = true;
                break;
              }
            }
            if (!l) {
              i.push(r);
              continue;
            }
          }
          return i;
        }
        _addKeyPress(e, t) {
          const i = this._map.get(e);
          if (typeof i > "u") {
            this._map.set(e, [
              t
            ]), this._addToLookupMap(t);
            return;
          }
          for (let n = i.length - 1; n >= 0; n--) {
            const o = i[n];
            if (o.command === t.command) continue;
            let r = true;
            for (let a = 1; a < o.chords.length && a < t.chords.length; a++) if (o.chords[a] !== t.chords[a]) {
              r = false;
              break;
            }
            r && yp.whenIsEntirelyIncluded(o.when, t.when) && this._removeFromLookupMap(o);
          }
          i.push(t), this._addToLookupMap(t);
        }
        _addToLookupMap(e) {
          if (!e.command) return;
          let t = this._lookupMap.get(e.command);
          typeof t > "u" ? (t = [
            e
          ], this._lookupMap.set(e.command, t)) : t.push(e);
        }
        _removeFromLookupMap(e) {
          if (!e.command) return;
          const t = this._lookupMap.get(e.command);
          if (!(typeof t > "u")) {
            for (let i = 0, n = t.length; i < n; i++) if (t[i] === e) {
              t.splice(i, 1);
              return;
            }
          }
        }
        static whenIsEntirelyIncluded(e, t) {
          return !t || t.type === 1 ? true : !e || e.type === 1 ? false : Zk(e, t);
        }
        getKeybindings() {
          return this._keybindings;
        }
        lookupPrimaryKeybinding(e, t) {
          const i = this._lookupMap.get(e);
          if (typeof i > "u" || i.length === 0) return null;
          if (i.length === 1) return i[0];
          for (let n = i.length - 1; n >= 0; n--) {
            const o = i[n];
            if (t.contextMatchesRules(o.when)) return o;
          }
          return i[i.length - 1];
        }
        resolve(e, t, i) {
          const n = [
            ...t,
            i
          ];
          this._log(`| Resolving ${n}`);
          const o = this._map.get(n[0]);
          if (o === void 0) return this._log("\\ No keybinding entries."), Av;
          let r = null;
          if (n.length < 2) r = o;
          else {
            r = [];
            for (let l = 0, u = o.length; l < u; l++) {
              const d = o[l];
              if (n.length > d.chords.length) continue;
              let f = true;
              for (let m = 1; m < n.length; m++) if (d.chords[m] !== n[m]) {
                f = false;
                break;
              }
              f && r.push(d);
            }
          }
          const a = this._findCommand(e, r);
          return a ? n.length < a.chords.length ? (this._log(`\\ From ${r.length} keybinding entries, awaiting ${a.chords.length - n.length} more chord(s), when: ${Y5(a.when)}, source: ${Z5(a)}.`), dee) : (this._log(`\\ From ${r.length} keybinding entries, matched ${a.command}, when: ${Y5(a.when)}, source: ${Z5(a)}.`), fee(a.command, a.commandArgs, a.bubble)) : (this._log(`\\ From ${r.length} keybinding entries, no when clauses matched the context.`), Av);
        }
        _findCommand(e, t) {
          for (let i = t.length - 1; i >= 0; i--) {
            const n = t[i];
            if (yp._contextMatchesRules(e, n.when)) return n;
          }
          return null;
        }
        static _contextMatchesRules(e, t) {
          return t ? t.evaluate(e) : true;
        }
      }
      function Y5(s) {
        return s ? `${s.serialize()}` : "no when condition";
      }
      function Z5(s) {
        return s.extensionId ? s.isBuiltinExtension ? `built-in extension ${s.extensionId}` : `user extension ${s.extensionId}` : s.isDefault ? "built-in" : "user";
      }
      const gee = /^(cursor|delete|undo|redo|tab|editor\.action\.clipboard)/;
      class mee extends he {
        get onDidUpdateKeybindings() {
          return this._onDidUpdateKeybindings ? this._onDidUpdateKeybindings.event : be.None;
        }
        get inChordMode() {
          return this._currentChords.length > 0;
        }
        constructor(e, t, i, n, o) {
          super(), this._contextKeyService = e, this._commandService = t, this._telemetryService = i, this._notificationService = n, this._logService = o, this._onDidUpdateKeybindings = this._register(new G()), this._currentChords = [], this._currentChordChecker = new eT(), this._currentChordStatusMessage = null, this._ignoreSingleModifiers = bf.EMPTY, this._currentSingleModifier = null, this._currentSingleModifierClearTimeout = new Kh(), this._currentlyDispatchingCommandId = null, this._logging = false;
        }
        dispose() {
          super.dispose();
        }
        _log(e) {
          this._logging && this._logService.info(`[KeybindingService]: ${e}`);
        }
        getKeybindings() {
          return this._getResolver().getKeybindings();
        }
        lookupKeybinding(e, t) {
          const i = this._getResolver().lookupPrimaryKeybinding(e, t || this._contextKeyService);
          if (i) return i.resolvedKeybinding;
        }
        dispatchEvent(e, t) {
          return this._dispatch(e, t);
        }
        softDispatch(e, t) {
          this._log("/ Soft dispatching keyboard event");
          const i = this.resolveKeyboardEvent(e);
          if (i.hasMultipleChords()) return console.warn("keyboard event should not be mapped to multiple chords"), Av;
          const [n] = i.getDispatchChords();
          if (n === null) return this._log("\\ Keyboard event cannot be dispatched"), Av;
          const o = this._contextKeyService.getContext(t), r = this._currentChords.map(({ keypress: a }) => a);
          return this._getResolver().resolve(o, r, n);
        }
        _scheduleLeaveChordMode() {
          const e = Date.now();
          this._currentChordChecker.cancelAndSet(() => {
            if (!this._documentHasFocus()) {
              this._leaveChordMode();
              return;
            }
            Date.now() - e > 5e3 && this._leaveChordMode();
          }, 500);
        }
        _expectAnotherChord(e, t) {
          switch (this._currentChords.push({
            keypress: e,
            label: t
          }), this._currentChords.length) {
            case 0:
              throw FE("impossible");
            case 1:
              this._currentChordStatusMessage = this._notificationService.status(C("first.chord", "({0}) was pressed. Waiting for second key of chord...", t));
              break;
            default: {
              const i = this._currentChords.map(({ label: n }) => n).join(", ");
              this._currentChordStatusMessage = this._notificationService.status(C("next.chord", "({0}) was pressed. Waiting for next key of chord...", i));
            }
          }
          this._scheduleLeaveChordMode(), wp.enabled && wp.disable();
        }
        _leaveChordMode() {
          this._currentChordStatusMessage && (this._currentChordStatusMessage.dispose(), this._currentChordStatusMessage = null), this._currentChordChecker.cancel(), this._currentChords = [], wp.enable();
        }
        _dispatch(e, t) {
          return this._doDispatch(this.resolveKeyboardEvent(e), t, false);
        }
        _singleModifierDispatch(e, t) {
          const i = this.resolveKeyboardEvent(e), [n] = i.getSingleModifierDispatchChords();
          if (n) return this._ignoreSingleModifiers.has(n) ? (this._log(`+ Ignoring single modifier ${n} due to it being pressed together with other keys.`), this._ignoreSingleModifiers = bf.EMPTY, this._currentSingleModifierClearTimeout.cancel(), this._currentSingleModifier = null, false) : (this._ignoreSingleModifiers = bf.EMPTY, this._currentSingleModifier === null ? (this._log(`+ Storing single modifier for possible chord ${n}.`), this._currentSingleModifier = n, this._currentSingleModifierClearTimeout.cancelAndSet(() => {
            this._log("+ Clearing single modifier due to 300ms elapsed."), this._currentSingleModifier = null;
          }, 300), false) : n === this._currentSingleModifier ? (this._log(`/ Dispatching single modifier chord ${n} ${n}`), this._currentSingleModifierClearTimeout.cancel(), this._currentSingleModifier = null, this._doDispatch(i, t, true)) : (this._log(`+ Clearing single modifier due to modifier mismatch: ${this._currentSingleModifier} ${n}`), this._currentSingleModifierClearTimeout.cancel(), this._currentSingleModifier = null, false));
          const [o] = i.getChords();
          return this._ignoreSingleModifiers = new bf(o), this._currentSingleModifier !== null && this._log("+ Clearing single modifier due to other key up."), this._currentSingleModifierClearTimeout.cancel(), this._currentSingleModifier = null, false;
        }
        _doDispatch(e, t, i = false) {
          let n = false;
          if (e.hasMultipleChords()) return console.warn("Unexpected keyboard event mapped to multiple chords"), false;
          let o = null, r = null;
          if (i) {
            const [d] = e.getSingleModifierDispatchChords();
            o = d, r = d ? [
              d
            ] : [];
          } else [o] = e.getDispatchChords(), r = this._currentChords.map(({ keypress: d }) => d);
          if (o === null) return this._log("\\ Keyboard event cannot be dispatched in keydown phase."), n;
          const a = this._contextKeyService.getContext(t), l = e.getLabel(), u = this._getResolver().resolve(a, r, o);
          switch (u.kind) {
            case 0: {
              if (this._logService.trace("KeybindingService#dispatch", l, "[ No matching keybinding ]"), this.inChordMode) {
                const d = this._currentChords.map(({ label: f }) => f).join(", ");
                this._log(`+ Leaving multi-chord mode: Nothing bound to "${d}, ${l}".`), this._notificationService.status(C("missing.chord", "The key combination ({0}, {1}) is not a command.", d, l), {
                  hideAfter: 10 * 1e3
                }), this._leaveChordMode(), n = true;
              }
              return n;
            }
            case 1:
              return this._logService.trace("KeybindingService#dispatch", l, "[ Several keybindings match - more chords needed ]"), n = true, this._expectAnotherChord(o, l), this._log(this._currentChords.length === 1 ? "+ Entering multi-chord mode..." : "+ Continuing multi-chord mode..."), n;
            case 2: {
              if (this._logService.trace("KeybindingService#dispatch", l, `[ Will dispatch command ${u.commandId} ]`), u.commandId === null || u.commandId === "") {
                if (this.inChordMode) {
                  const d = this._currentChords.map(({ label: f }) => f).join(", ");
                  this._log(`+ Leaving chord mode: Nothing bound to "${d}, ${l}".`), this._notificationService.status(C("missing.chord", "The key combination ({0}, {1}) is not a command.", d, l), {
                    hideAfter: 10 * 1e3
                  }), this._leaveChordMode(), n = true;
                }
              } else {
                this.inChordMode && this._leaveChordMode(), u.isBubble || (n = true), this._log(`+ Invoking command ${u.commandId}.`), this._currentlyDispatchingCommandId = u.commandId;
                try {
                  typeof u.commandArgs > "u" ? this._commandService.executeCommand(u.commandId).then(void 0, (d) => this._notificationService.warn(d)) : this._commandService.executeCommand(u.commandId, u.commandArgs).then(void 0, (d) => this._notificationService.warn(d));
                } finally {
                  this._currentlyDispatchingCommandId = null;
                }
                gee.test(u.commandId) || this._telemetryService.publicLog2("workbenchActionExecuted", {
                  id: u.commandId,
                  from: "keybinding",
                  detail: e.getUserSettingsLabel() ?? void 0
                });
              }
              return n;
            }
          }
        }
        mightProducePrintableCharacter(e) {
          return e.ctrlKey || e.metaKey ? false : e.keyCode >= 31 && e.keyCode <= 56 || e.keyCode >= 21 && e.keyCode <= 30;
        }
      }
      const _bf = class _bf {
        constructor(e) {
          this._ctrlKey = e ? e.ctrlKey : false, this._shiftKey = e ? e.shiftKey : false, this._altKey = e ? e.altKey : false, this._metaKey = e ? e.metaKey : false;
        }
        has(e) {
          switch (e) {
            case "ctrl":
              return this._ctrlKey;
            case "shift":
              return this._shiftKey;
            case "alt":
              return this._altKey;
            case "meta":
              return this._metaKey;
          }
        }
      };
      _bf.EMPTY = new _bf(null);
      let bf = _bf;
      class Q5 {
        constructor(e, t, i, n, o, r, a) {
          this._resolvedKeybindingItemBrand = void 0, this.resolvedKeybinding = e, this.chords = e ? FD(e.getDispatchChords()) : [], e && this.chords.length === 0 && (this.chords = FD(e.getSingleModifierDispatchChords())), this.bubble = t ? t.charCodeAt(0) === 94 : false, this.command = this.bubble ? t.substr(1) : t, this.commandArgs = i, this.when = n, this.isDefault = o, this.extensionId = r, this.isBuiltinExtension = a;
        }
      }
      function FD(s) {
        const e = [];
        for (let t = 0, i = s.length; t < i; t++) {
          const n = s[t];
          if (!n) return [];
          e.push(n);
        }
        return e;
      }
      class pw {
        constructor(e, t, i = t) {
          this.modifierLabels = [
            null
          ], this.modifierLabels[2] = e, this.modifierLabels[1] = t, this.modifierLabels[3] = i;
        }
        toLabel(e, t, i) {
          if (t.length === 0) return null;
          const n = [];
          for (let o = 0, r = t.length; o < r; o++) {
            const a = t[o], l = i(a);
            if (l === null) return null;
            n[o] = vee(a, l, this.modifierLabels[e]);
          }
          return n.join(" ");
        }
      }
      const GT = new pw({
        ctrlKey: "\u2303",
        shiftKey: "\u21E7",
        altKey: "\u2325",
        metaKey: "\u2318",
        separator: ""
      }, {
        ctrlKey: C({
          key: "ctrlKey",
          comment: [
            "This is the short form for the Control key on the keyboard"
          ]
        }, "Ctrl"),
        shiftKey: C({
          key: "shiftKey",
          comment: [
            "This is the short form for the Shift key on the keyboard"
          ]
        }, "Shift"),
        altKey: C({
          key: "altKey",
          comment: [
            "This is the short form for the Alt key on the keyboard"
          ]
        }, "Alt"),
        metaKey: C({
          key: "windowsKey",
          comment: [
            "This is the short form for the Windows key on the keyboard"
          ]
        }, "Windows"),
        separator: "+"
      }, {
        ctrlKey: C({
          key: "ctrlKey",
          comment: [
            "This is the short form for the Control key on the keyboard"
          ]
        }, "Ctrl"),
        shiftKey: C({
          key: "shiftKey",
          comment: [
            "This is the short form for the Shift key on the keyboard"
          ]
        }, "Shift"),
        altKey: C({
          key: "altKey",
          comment: [
            "This is the short form for the Alt key on the keyboard"
          ]
        }, "Alt"),
        metaKey: C({
          key: "superKey",
          comment: [
            "This is the short form for the Super key on the keyboard"
          ]
        }, "Super"),
        separator: "+"
      }), pee = new pw({
        ctrlKey: C({
          key: "ctrlKey.long",
          comment: [
            "This is the long form for the Control key on the keyboard"
          ]
        }, "Control"),
        shiftKey: C({
          key: "shiftKey.long",
          comment: [
            "This is the long form for the Shift key on the keyboard"
          ]
        }, "Shift"),
        altKey: C({
          key: "optKey.long",
          comment: [
            "This is the long form for the Alt/Option key on the keyboard"
          ]
        }, "Option"),
        metaKey: C({
          key: "cmdKey.long",
          comment: [
            "This is the long form for the Command key on the keyboard"
          ]
        }, "Command"),
        separator: "+"
      }, {
        ctrlKey: C({
          key: "ctrlKey.long",
          comment: [
            "This is the long form for the Control key on the keyboard"
          ]
        }, "Control"),
        shiftKey: C({
          key: "shiftKey.long",
          comment: [
            "This is the long form for the Shift key on the keyboard"
          ]
        }, "Shift"),
        altKey: C({
          key: "altKey.long",
          comment: [
            "This is the long form for the Alt key on the keyboard"
          ]
        }, "Alt"),
        metaKey: C({
          key: "windowsKey.long",
          comment: [
            "This is the long form for the Windows key on the keyboard"
          ]
        }, "Windows"),
        separator: "+"
      }, {
        ctrlKey: C({
          key: "ctrlKey.long",
          comment: [
            "This is the long form for the Control key on the keyboard"
          ]
        }, "Control"),
        shiftKey: C({
          key: "shiftKey.long",
          comment: [
            "This is the long form for the Shift key on the keyboard"
          ]
        }, "Shift"),
        altKey: C({
          key: "altKey.long",
          comment: [
            "This is the long form for the Alt key on the keyboard"
          ]
        }, "Alt"),
        metaKey: C({
          key: "superKey.long",
          comment: [
            "This is the long form for the Super key on the keyboard"
          ]
        }, "Super"),
        separator: "+"
      }), _ee = new pw({
        ctrlKey: "Ctrl",
        shiftKey: "Shift",
        altKey: "Alt",
        metaKey: "Cmd",
        separator: "+"
      }, {
        ctrlKey: "Ctrl",
        shiftKey: "Shift",
        altKey: "Alt",
        metaKey: "Super",
        separator: "+"
      }), bee = new pw({
        ctrlKey: "ctrl",
        shiftKey: "shift",
        altKey: "alt",
        metaKey: "cmd",
        separator: "+"
      }, {
        ctrlKey: "ctrl",
        shiftKey: "shift",
        altKey: "alt",
        metaKey: "win",
        separator: "+"
      }, {
        ctrlKey: "ctrl",
        shiftKey: "shift",
        altKey: "alt",
        metaKey: "meta",
        separator: "+"
      });
      function vee(s, e, t) {
        if (e === null) return "";
        const i = [];
        return s.ctrlKey && i.push(t.ctrlKey), s.shiftKey && i.push(t.shiftKey), s.altKey && i.push(t.altKey), s.metaKey && i.push(t.metaKey), e !== "" && i.push(e), i.join(t.separator);
      }
      class Cee extends zq {
        constructor(e, t) {
          if (super(), t.length === 0) throw FC("chords");
          this._os = e, this._chords = t;
        }
        getLabel() {
          return GT.toLabel(this._os, this._chords, (e) => this._getLabel(e));
        }
        getAriaLabel() {
          return pee.toLabel(this._os, this._chords, (e) => this._getAriaLabel(e));
        }
        getElectronAccelerator() {
          return this._chords.length > 1 || this._chords[0].isDuplicateModifierCase() ? null : _ee.toLabel(this._os, this._chords, (e) => this._getElectronAccelerator(e));
        }
        getUserSettingsLabel() {
          return bee.toLabel(this._os, this._chords, (e) => this._getUserSettingsLabel(e));
        }
        hasMultipleChords() {
          return this._chords.length > 1;
        }
        getChords() {
          return this._chords.map((e) => this._getChord(e));
        }
        _getChord(e) {
          return new Hq(e.ctrlKey, e.shiftKey, e.altKey, e.metaKey, this._getLabel(e), this._getAriaLabel(e));
        }
        getDispatchChords() {
          return this._chords.map((e) => this._getChordDispatch(e));
        }
        getSingleModifierDispatchChords() {
          return this._chords.map((e) => this._getSingleModifierChordDispatch(e));
        }
      }
      class c_ extends Cee {
        constructor(e, t) {
          super(t, e);
        }
        _keyCodeToUILabel(e) {
          if (this._os === 2) switch (e) {
            case 15:
              return "\u2190";
            case 16:
              return "\u2191";
            case 17:
              return "\u2192";
            case 18:
              return "\u2193";
          }
          return Ll.toString(e);
        }
        _getLabel(e) {
          return e.isDuplicateModifierCase() ? "" : this._keyCodeToUILabel(e.keyCode);
        }
        _getAriaLabel(e) {
          return e.isDuplicateModifierCase() ? "" : Ll.toString(e.keyCode);
        }
        _getElectronAccelerator(e) {
          return Ll.toElectronAccelerator(e.keyCode);
        }
        _getUserSettingsLabel(e) {
          if (e.isDuplicateModifierCase()) return "";
          const t = Ll.toUserSettingsUS(e.keyCode);
          return t && t.toLowerCase();
        }
        _getChordDispatch(e) {
          return c_.getDispatchStr(e);
        }
        static getDispatchStr(e) {
          if (e.isModifierKey()) return null;
          let t = "";
          return e.ctrlKey && (t += "ctrl+"), e.shiftKey && (t += "shift+"), e.altKey && (t += "alt+"), e.metaKey && (t += "meta+"), t += Ll.toString(e.keyCode), t;
        }
        _getSingleModifierChordDispatch(e) {
          return e.keyCode === 5 && !e.shiftKey && !e.altKey && !e.metaKey ? "ctrl" : e.keyCode === 4 && !e.ctrlKey && !e.altKey && !e.metaKey ? "shift" : e.keyCode === 6 && !e.ctrlKey && !e.shiftKey && !e.metaKey ? "alt" : e.keyCode === 57 && !e.ctrlKey && !e.shiftKey && !e.altKey ? "meta" : null;
        }
        static _scanCodeToKeyCode(e) {
          const t = UE[e];
          if (t !== -1) return t;
          switch (e) {
            case 10:
              return 31;
            case 11:
              return 32;
            case 12:
              return 33;
            case 13:
              return 34;
            case 14:
              return 35;
            case 15:
              return 36;
            case 16:
              return 37;
            case 17:
              return 38;
            case 18:
              return 39;
            case 19:
              return 40;
            case 20:
              return 41;
            case 21:
              return 42;
            case 22:
              return 43;
            case 23:
              return 44;
            case 24:
              return 45;
            case 25:
              return 46;
            case 26:
              return 47;
            case 27:
              return 48;
            case 28:
              return 49;
            case 29:
              return 50;
            case 30:
              return 51;
            case 31:
              return 52;
            case 32:
              return 53;
            case 33:
              return 54;
            case 34:
              return 55;
            case 35:
              return 56;
            case 36:
              return 22;
            case 37:
              return 23;
            case 38:
              return 24;
            case 39:
              return 25;
            case 40:
              return 26;
            case 41:
              return 27;
            case 42:
              return 28;
            case 43:
              return 29;
            case 44:
              return 30;
            case 45:
              return 21;
            case 51:
              return 88;
            case 52:
              return 86;
            case 53:
              return 92;
            case 54:
              return 94;
            case 55:
              return 93;
            case 56:
              return 0;
            case 57:
              return 85;
            case 58:
              return 95;
            case 59:
              return 91;
            case 60:
              return 87;
            case 61:
              return 89;
            case 62:
              return 90;
            case 106:
              return 97;
          }
          return 0;
        }
        static _toKeyCodeChord(e) {
          if (!e) return null;
          if (e instanceof Mh) return e;
          const t = this._scanCodeToKeyCode(e.scanCode);
          return t === 0 ? null : new Mh(e.ctrlKey, e.shiftKey, e.altKey, e.metaKey, t);
        }
        static resolveKeybinding(e, t) {
          const i = FD(e.chords.map((n) => this._toKeyCodeChord(n)));
          return i.length > 0 ? [
            new c_(i, t)
          ] : [];
        }
      }
      const wee = pt("labelService"), yee = pt("progressService");
      const _xge = class _xge {
        constructor(e) {
          this.callback = e;
        }
        report(e) {
          this._value = e, this.callback(this._value);
        }
      };
      _xge.None = Object.freeze({
        report() {
        }
      });
      let xge = _xge;
      const YT = pt("editorProgressService");
      class See {
        constructor() {
          this._value = "", this._pos = 0;
        }
        reset(e) {
          return this._value = e, this._pos = 0, this;
        }
        next() {
          return this._pos += 1, this;
        }
        hasNext() {
          return this._pos < this._value.length - 1;
        }
        cmp(e) {
          const t = e.charCodeAt(0), i = this._value.charCodeAt(this._pos);
          return t - i;
        }
        value() {
          return this._value[this._pos];
        }
      }
      class Lee {
        constructor(e = true) {
          this._caseSensitive = e;
        }
        reset(e) {
          return this._value = e, this._from = 0, this._to = 0, this.next();
        }
        hasNext() {
          return this._to < this._value.length;
        }
        next() {
          this._from = this._to;
          let e = true;
          for (; this._to < this._value.length; this._to++) if (this._value.charCodeAt(this._to) === 46) if (e) this._from++;
          else break;
          else e = false;
          return this;
        }
        cmp(e) {
          return this._caseSensitive ? qE(e, this._value, 0, e.length, this._from, this._to) : F_(e, this._value, 0, e.length, this._from, this._to);
        }
        value() {
          return this._value.substring(this._from, this._to);
        }
      }
      class xee {
        constructor(e = true, t = true) {
          this._splitOnBackslash = e, this._caseSensitive = t;
        }
        reset(e) {
          this._from = 0, this._to = 0, this._value = e, this._valueLen = e.length;
          for (let t = e.length - 1; t >= 0; t--, this._valueLen--) {
            const i = this._value.charCodeAt(t);
            if (!(i === 47 || this._splitOnBackslash && i === 92)) break;
          }
          return this.next();
        }
        hasNext() {
          return this._to < this._valueLen;
        }
        next() {
          this._from = this._to;
          let e = true;
          for (; this._to < this._valueLen; this._to++) {
            const t = this._value.charCodeAt(this._to);
            if (t === 47 || this._splitOnBackslash && t === 92) if (e) this._from++;
            else break;
            else e = false;
          }
          return this;
        }
        cmp(e) {
          return this._caseSensitive ? qE(e, this._value, 0, e.length, this._from, this._to) : F_(e, this._value, 0, e.length, this._from, this._to);
        }
        value() {
          return this._value.substring(this._from, this._to);
        }
      }
      class kee {
        constructor(e, t) {
          this._ignorePathCasing = e, this._ignoreQueryAndFragment = t, this._states = [], this._stateIdx = 0;
        }
        reset(e) {
          return this._value = e, this._states = [], this._value.scheme && this._states.push(1), this._value.authority && this._states.push(2), this._value.path && (this._pathIterator = new xee(false, !this._ignorePathCasing(e)), this._pathIterator.reset(e.path), this._pathIterator.value() && this._states.push(3)), this._ignoreQueryAndFragment(e) || (this._value.query && this._states.push(4), this._value.fragment && this._states.push(5)), this._stateIdx = 0, this;
        }
        next() {
          return this._states[this._stateIdx] === 3 && this._pathIterator.hasNext() ? this._pathIterator.next() : this._stateIdx += 1, this;
        }
        hasNext() {
          return this._states[this._stateIdx] === 3 && this._pathIterator.hasNext() || this._stateIdx < this._states.length - 1;
        }
        cmp(e) {
          if (this._states[this._stateIdx] === 1) return K4(e, this._value.scheme);
          if (this._states[this._stateIdx] === 2) return K4(e, this._value.authority);
          if (this._states[this._stateIdx] === 3) return this._pathIterator.cmp(e);
          if (this._states[this._stateIdx] === 4) return Rk(e, this._value.query);
          if (this._states[this._stateIdx] === 5) return Rk(e, this._value.fragment);
          throw new Error();
        }
        value() {
          if (this._states[this._stateIdx] === 1) return this._value.scheme;
          if (this._states[this._stateIdx] === 2) return this._value.authority;
          if (this._states[this._stateIdx] === 3) return this._pathIterator.value();
          if (this._states[this._stateIdx] === 4) return this._value.query;
          if (this._states[this._stateIdx] === 5) return this._value.fragment;
          throw new Error();
        }
      }
      class zb {
        constructor() {
          this.height = 1;
        }
        rotateLeft() {
          const e = this.right;
          return this.right = e.left, e.left = this, this.updateHeight(), e.updateHeight(), e;
        }
        rotateRight() {
          const e = this.left;
          return this.left = e.right, e.right = this, this.updateHeight(), e.updateHeight(), e;
        }
        updateHeight() {
          this.height = 1 + Math.max(this.heightLeft, this.heightRight);
        }
        balanceFactor() {
          return this.heightRight - this.heightLeft;
        }
        get heightLeft() {
          var _a3;
          return ((_a3 = this.left) == null ? void 0 : _a3.height) ?? 0;
        }
        get heightRight() {
          var _a3;
          return ((_a3 = this.right) == null ? void 0 : _a3.height) ?? 0;
        }
      }
      class Sp {
        static forUris(e = () => false, t = () => false) {
          return new Sp(new kee(e, t));
        }
        static forStrings() {
          return new Sp(new See());
        }
        static forConfigKeys() {
          return new Sp(new Lee());
        }
        constructor(e) {
          this._iter = e;
        }
        clear() {
          this._root = void 0;
        }
        set(e, t) {
          const i = this._iter.reset(e);
          let n;
          this._root || (this._root = new zb(), this._root.segment = i.value());
          const o = [];
          for (n = this._root; ; ) {
            const a = i.cmp(n.segment);
            if (a > 0) n.left || (n.left = new zb(), n.left.segment = i.value()), o.push([
              -1,
              n
            ]), n = n.left;
            else if (a < 0) n.right || (n.right = new zb(), n.right.segment = i.value()), o.push([
              1,
              n
            ]), n = n.right;
            else if (i.hasNext()) i.next(), n.mid || (n.mid = new zb(), n.mid.segment = i.value()), o.push([
              0,
              n
            ]), n = n.mid;
            else break;
          }
          const r = n.value;
          n.value = t, n.key = e;
          for (let a = o.length - 1; a >= 0; a--) {
            const l = o[a][1];
            l.updateHeight();
            const u = l.balanceFactor();
            if (u < -1 || u > 1) {
              const d = o[a][0], f = o[a + 1][0];
              if (d === 1 && f === 1) o[a][1] = l.rotateLeft();
              else if (d === -1 && f === -1) o[a][1] = l.rotateRight();
              else if (d === 1 && f === -1) l.right = o[a + 1][1] = o[a + 1][1].rotateRight(), o[a][1] = l.rotateLeft();
              else if (d === -1 && f === 1) l.left = o[a + 1][1] = o[a + 1][1].rotateLeft(), o[a][1] = l.rotateRight();
              else throw new Error();
              if (a > 0) switch (o[a - 1][0]) {
                case -1:
                  o[a - 1][1].left = o[a][1];
                  break;
                case 1:
                  o[a - 1][1].right = o[a][1];
                  break;
                case 0:
                  o[a - 1][1].mid = o[a][1];
                  break;
              }
              else this._root = o[0][1];
            }
          }
          return r;
        }
        get(e) {
          var _a3;
          return (_a3 = this._getNode(e)) == null ? void 0 : _a3.value;
        }
        _getNode(e) {
          const t = this._iter.reset(e);
          let i = this._root;
          for (; i; ) {
            const n = t.cmp(i.segment);
            if (n > 0) i = i.left;
            else if (n < 0) i = i.right;
            else if (t.hasNext()) t.next(), i = i.mid;
            else break;
          }
          return i;
        }
        has(e) {
          const t = this._getNode(e);
          return !((t == null ? void 0 : t.value) === void 0 && (t == null ? void 0 : t.mid) === void 0);
        }
        delete(e) {
          return this._delete(e, false);
        }
        deleteSuperstr(e) {
          return this._delete(e, true);
        }
        _delete(e, t) {
          const i = this._iter.reset(e), n = [];
          let o = this._root;
          for (; o; ) {
            const r = i.cmp(o.segment);
            if (r > 0) n.push([
              -1,
              o
            ]), o = o.left;
            else if (r < 0) n.push([
              1,
              o
            ]), o = o.right;
            else if (i.hasNext()) i.next(), n.push([
              0,
              o
            ]), o = o.mid;
            else break;
          }
          if (o) {
            if (t ? (o.left = void 0, o.mid = void 0, o.right = void 0, o.height = 1) : (o.key = void 0, o.value = void 0), !o.mid && !o.value) if (o.left && o.right) {
              const r = this._min(o.right);
              if (r.key) {
                const { key: a, value: l, segment: u } = r;
                this._delete(r.key, false), o.key = a, o.value = l, o.segment = u;
              }
            } else {
              const r = o.left ?? o.right;
              if (n.length > 0) {
                const [a, l] = n[n.length - 1];
                switch (a) {
                  case -1:
                    l.left = r;
                    break;
                  case 0:
                    l.mid = r;
                    break;
                  case 1:
                    l.right = r;
                    break;
                }
              } else this._root = r;
            }
            for (let r = n.length - 1; r >= 0; r--) {
              const a = n[r][1];
              a.updateHeight();
              const l = a.balanceFactor();
              if (l > 1 ? (a.right.balanceFactor() >= 0 || (a.right = a.right.rotateRight()), n[r][1] = a.rotateLeft()) : l < -1 && (a.left.balanceFactor() <= 0 || (a.left = a.left.rotateLeft()), n[r][1] = a.rotateRight()), r > 0) switch (n[r - 1][0]) {
                case -1:
                  n[r - 1][1].left = n[r][1];
                  break;
                case 1:
                  n[r - 1][1].right = n[r][1];
                  break;
                case 0:
                  n[r - 1][1].mid = n[r][1];
                  break;
              }
              else this._root = n[0][1];
            }
          }
        }
        _min(e) {
          for (; e.left; ) e = e.left;
          return e;
        }
        findSubstr(e) {
          const t = this._iter.reset(e);
          let i = this._root, n;
          for (; i; ) {
            const o = t.cmp(i.segment);
            if (o > 0) i = i.left;
            else if (o < 0) i = i.right;
            else if (t.hasNext()) t.next(), n = i.value || n, i = i.mid;
            else break;
          }
          return i && i.value || n;
        }
        findSuperstr(e) {
          return this._findSuperstrOrElement(e, false);
        }
        _findSuperstrOrElement(e, t) {
          const i = this._iter.reset(e);
          let n = this._root;
          for (; n; ) {
            const o = i.cmp(n.segment);
            if (o > 0) n = n.left;
            else if (o < 0) n = n.right;
            else if (i.hasNext()) i.next(), n = n.mid;
            else return n.mid ? this._entries(n.mid) : t ? n.value : void 0;
          }
        }
        forEach(e) {
          for (const [t, i] of this) e(i, t);
        }
        *[Symbol.iterator]() {
          yield* this._entries(this._root);
        }
        _entries(e) {
          const t = [];
          return this._dfsEntries(e, t), t[Symbol.iterator]();
        }
        _dfsEntries(e, t) {
          e && (e.left && this._dfsEntries(e.left, t), e.value && t.push([
            e.key,
            e.value
          ]), e.mid && this._dfsEntries(e.mid, t), e.right && this._dfsEntries(e.right, t));
        }
      }
      const Dee = pt("contextService");
      class Eee {
        constructor(e, t) {
          this.raw = t, this.uri = e.uri, this.index = e.index, this.name = e.name;
        }
        toJSON() {
          return {
            uri: this.uri,
            name: this.name,
            index: this.index
          };
        }
      }
      const Tee = "code-workspace";
      C("codeWorkspace", "Code Workspace");
      const Nee = "4064f6ec-cb38-4ad0-af64-ee6467e63c82";
      var X5;
      (function(s) {
        s.inspectTokensAction = C("inspectTokens", "Developer: Inspect Tokens");
      })(X5 || (X5 = {}));
      var J5;
      (function(s) {
        s.gotoLineActionLabel = C("gotoLineActionLabel", "Go to Line/Column...");
      })(J5 || (J5 = {}));
      var eP;
      (function(s) {
        s.helpQuickAccessActionLabel = C("helpQuickAccess", "Show all Quick Access Providers");
      })(eP || (eP = {}));
      var tP;
      (function(s) {
        s.quickCommandActionLabel = C("quickCommandActionLabel", "Command Palette"), s.quickCommandHelp = C("quickCommandActionHelp", "Show And Run Commands");
      })(tP || (tP = {}));
      var iP;
      (function(s) {
        s.quickOutlineActionLabel = C("quickOutlineActionLabel", "Go to Symbol..."), s.quickOutlineByCategoryActionLabel = C("quickOutlineByCategoryActionLabel", "Go to Symbol by Category...");
      })(iP || (iP = {}));
      var VD;
      (function(s) {
        s.editorViewAccessibleLabel = C("editorViewAccessibleLabel", "Editor content");
      })(VD || (VD = {}));
      var nP;
      (function(s) {
        s.toggleHighContrast = C("toggleHighContrast", "Toggle High Contrast Theme");
      })(nP || (nP = {}));
      var WD;
      (function(s) {
        s.bulkEditServiceSummary = C("bulkEditServiceSummary", "Made {0} edits in {1} files");
      })(WD || (WD = {}));
      const Iee = pt("workspaceTrustManagementService");
      let gg = [], ZT = [], W6 = [];
      function Ub(s, e = false) {
        Mee(s, false, e);
      }
      function Mee(s, e, t) {
        const i = Aee(s, e);
        gg.push(i), i.userConfigured ? W6.push(i) : ZT.push(i), t && !i.userConfigured && gg.forEach((n) => {
          n.mime === i.mime || n.userConfigured || (i.extension && n.extension === i.extension && console.warn(`Overwriting extension <<${i.extension}>> to now point to mime <<${i.mime}>>`), i.filename && n.filename === i.filename && console.warn(`Overwriting filename <<${i.filename}>> to now point to mime <<${i.mime}>>`), i.filepattern && n.filepattern === i.filepattern && console.warn(`Overwriting filepattern <<${i.filepattern}>> to now point to mime <<${i.mime}>>`), i.firstline && n.firstline === i.firstline && console.warn(`Overwriting firstline <<${i.firstline}>> to now point to mime <<${i.mime}>>`));
        });
      }
      function Aee(s, e) {
        return {
          id: s.id,
          mime: s.mime,
          filename: s.filename,
          extension: s.extension,
          filepattern: s.filepattern,
          firstline: s.firstline,
          userConfigured: e,
          filenameLowercase: s.filename ? s.filename.toLowerCase() : void 0,
          extensionLowercase: s.extension ? s.extension.toLowerCase() : void 0,
          filepatternLowercase: s.filepattern ? G8(s.filepattern.toLowerCase()) : void 0,
          filepatternOnPath: s.filepattern ? s.filepattern.indexOf(Ii.sep) >= 0 : false
        };
      }
      function Ree() {
        gg = gg.filter((s) => s.userConfigured), ZT = [];
      }
      function Oee(s, e) {
        return Pee(s, e).map((t) => t.id);
      }
      function Pee(s, e) {
        let t;
        if (s) switch (s.scheme) {
          case it.file:
            t = s.fsPath;
            break;
          case it.data: {
            t = kv.parseMetaData(s).get(kv.META_DATA_LABEL);
            break;
          }
          case it.vscodeNotebookCell:
            t = void 0;
            break;
          default:
            t = s.path;
        }
        if (!t) return [
          {
            id: "unknown",
            mime: kl.unknown
          }
        ];
        t = t.toLowerCase();
        const i = p9(t), n = sP(t, i, W6);
        if (n) return [
          n,
          {
            id: gr,
            mime: kl.text
          }
        ];
        const o = sP(t, i, ZT);
        if (o) return [
          o,
          {
            id: gr,
            mime: kl.text
          }
        ];
        if (e) {
          const r = Bee(e);
          if (r) return [
            r,
            {
              id: gr,
              mime: kl.text
            }
          ];
        }
        return [
          {
            id: "unknown",
            mime: kl.unknown
          }
        ];
      }
      function sP(s, e, t) {
        var _a3;
        let i, n, o;
        for (let r = t.length - 1; r >= 0; r--) {
          const a = t[r];
          if (e === a.filenameLowercase) {
            i = a;
            break;
          }
          if (a.filepattern && (!n || a.filepattern.length > n.filepattern.length)) {
            const l = a.filepatternOnPath ? s : e;
            ((_a3 = a.filepatternLowercase) == null ? void 0 : _a3.call(a, l)) && (n = a);
          }
          a.extension && (!o || a.extension.length > o.extension.length) && e.endsWith(a.extensionLowercase) && (o = a);
        }
        if (i) return i;
        if (n) return n;
        if (o) return o;
      }
      function Bee(s) {
        if (XE(s) && (s = s.substr(1)), s.length > 0) for (let e = gg.length - 1; e >= 0; e--) {
          const t = gg[e];
          if (!t.firstline) continue;
          const i = s.match(t.firstline);
          if (i && i.length > 0) return t;
        }
      }
      const $b = Object.prototype.hasOwnProperty, oP = "vs.editor.nullLanguage";
      class Fee {
        constructor() {
          this._languageIdToLanguage = [], this._languageToLanguageId = /* @__PURE__ */ new Map(), this._register(oP, 0), this._register(gr, 1), this._nextLanguageId = 2;
        }
        _register(e, t) {
          this._languageIdToLanguage[t] = e, this._languageToLanguageId.set(e, t);
        }
        register(e) {
          if (this._languageToLanguageId.has(e)) return;
          const t = this._nextLanguageId++;
          this._register(e, t);
        }
        encodeLanguageId(e) {
          return this._languageToLanguageId.get(e) || 0;
        }
        decodeLanguageId(e) {
          return this._languageIdToLanguage[e] || oP;
        }
      }
      const _Rv = class _Rv extends he {
        constructor(e = true, t = false) {
          super(), this._onDidChange = this._register(new G()), this.onDidChange = this._onDidChange.event, _Rv.instanceCount++, this._warnOnOverwrite = t, this.languageIdCodec = new Fee(), this._dynamicLanguages = [], this._languages = {}, this._mimeTypesMap = {}, this._nameMap = {}, this._lowercaseNameMap = {}, e && (this._initializeFromRegistry(), this._register(og.onDidChangeLanguages((i) => {
            this._initializeFromRegistry();
          })));
        }
        dispose() {
          _Rv.instanceCount--, super.dispose();
        }
        _initializeFromRegistry() {
          this._languages = {}, this._mimeTypesMap = {}, this._nameMap = {}, this._lowercaseNameMap = {}, Ree();
          const e = [].concat(og.getLanguages()).concat(this._dynamicLanguages);
          this._registerLanguages(e);
        }
        _registerLanguages(e) {
          for (const t of e) this._registerLanguage(t);
          this._mimeTypesMap = {}, this._nameMap = {}, this._lowercaseNameMap = {}, Object.keys(this._languages).forEach((t) => {
            const i = this._languages[t];
            i.name && (this._nameMap[i.name] = i.identifier), i.aliases.forEach((n) => {
              this._lowercaseNameMap[n.toLowerCase()] = i.identifier;
            }), i.mimetypes.forEach((n) => {
              this._mimeTypesMap[n] = i.identifier;
            });
          }), yn.as(Jh.Configuration).registerOverrideIdentifiers(this.getRegisteredLanguageIds()), this._onDidChange.fire();
        }
        _registerLanguage(e) {
          const t = e.id;
          let i;
          $b.call(this._languages, t) ? i = this._languages[t] : (this.languageIdCodec.register(t), i = {
            identifier: t,
            name: null,
            mimetypes: [],
            aliases: [],
            extensions: [],
            filenames: [],
            configurationFiles: [],
            icons: []
          }, this._languages[t] = i), this._mergeLanguage(i, e);
        }
        _mergeLanguage(e, t) {
          const i = t.id;
          let n = null;
          if (Array.isArray(t.mimetypes) && t.mimetypes.length > 0 && (e.mimetypes.push(...t.mimetypes), n = t.mimetypes[0]), n || (n = `text/x-${i}`, e.mimetypes.push(n)), Array.isArray(t.extensions)) {
            t.configuration ? e.extensions = t.extensions.concat(e.extensions) : e.extensions = e.extensions.concat(t.extensions);
            for (const a of t.extensions) Ub({
              id: i,
              mime: n,
              extension: a
            }, this._warnOnOverwrite);
          }
          if (Array.isArray(t.filenames)) for (const a of t.filenames) Ub({
            id: i,
            mime: n,
            filename: a
          }, this._warnOnOverwrite), e.filenames.push(a);
          if (Array.isArray(t.filenamePatterns)) for (const a of t.filenamePatterns) Ub({
            id: i,
            mime: n,
            filepattern: a
          }, this._warnOnOverwrite);
          if (typeof t.firstLine == "string" && t.firstLine.length > 0) {
            let a = t.firstLine;
            a.charAt(0) !== "^" && (a = "^" + a);
            try {
              const l = new RegExp(a);
              Nq(l) || Ub({
                id: i,
                mime: n,
                firstline: l
              }, this._warnOnOverwrite);
            } catch (l) {
              console.warn(`[${t.id}]: Invalid regular expression \`${a}\`: `, l);
            }
          }
          e.aliases.push(i);
          let o = null;
          if (typeof t.aliases < "u" && Array.isArray(t.aliases) && (t.aliases.length === 0 ? o = [
            null
          ] : o = t.aliases), o !== null) for (const a of o) !a || a.length === 0 || e.aliases.push(a);
          const r = o !== null && o.length > 0;
          if (!(r && o[0] === null)) {
            const a = (r ? o[0] : null) || i;
            (r || !e.name) && (e.name = a);
          }
          t.configuration && e.configurationFiles.push(t.configuration), t.icon && e.icons.push(t.icon);
        }
        isRegisteredLanguageId(e) {
          return e ? $b.call(this._languages, e) : false;
        }
        getRegisteredLanguageIds() {
          return Object.keys(this._languages);
        }
        getLanguageIdByLanguageName(e) {
          const t = e.toLowerCase();
          return $b.call(this._lowercaseNameMap, t) ? this._lowercaseNameMap[t] : null;
        }
        getLanguageIdByMimeType(e) {
          return e && $b.call(this._mimeTypesMap, e) ? this._mimeTypesMap[e] : null;
        }
        guessLanguageIdByFilepathOrFirstLine(e, t) {
          return !e && !t ? [] : Oee(e, t);
        }
      };
      _Rv.instanceCount = 0;
      let Rv = _Rv;
      const br = (s, e) => s === e;
      function Vee(s = br) {
        return (e, t) => Qi(e, t, s);
      }
      function rP(s, e, t) {
        {
          const i = s;
          return (n, o) => n == null || o === void 0 || o === null ? o === n : i(n, o);
        }
      }
      class ps {
        constructor(e, t, i) {
          this.owner = e, this.debugNameSource = t, this.referenceFn = i;
        }
        getDebugName(e) {
          return Wee(e, this);
        }
      }
      const aP = /* @__PURE__ */ new Map(), HD = /* @__PURE__ */ new WeakMap();
      function Wee(s, e) {
        const t = HD.get(s);
        if (t) return t;
        const i = Hee(s, e);
        if (i) {
          let n = aP.get(i) ?? 0;
          n++, aP.set(i, n);
          const o = n === 1 ? i : `${i}#${n}`;
          return HD.set(s, o), o;
        }
      }
      function Hee(s, e) {
        const t = HD.get(s);
        if (t) return t;
        const i = e.owner ? Uee(e.owner) + "." : "";
        let n;
        const o = e.debugNameSource;
        if (o !== void 0) if (typeof o == "function") {
          if (n = o(), n !== void 0) return i + n;
        } else return i + o;
        const r = e.referenceFn;
        if (r !== void 0 && (n = QT(r), n !== void 0)) return i + n;
        if (e.owner !== void 0) {
          const a = zee(e.owner, s);
          if (a !== void 0) return i + a;
        }
      }
      function zee(s, e) {
        for (const t in s) if (s[t] === e) return t;
      }
      const lP = /* @__PURE__ */ new Map(), cP = /* @__PURE__ */ new WeakMap();
      function Uee(s) {
        const e = cP.get(s);
        if (e) return e;
        const t = $ee(s);
        let i = lP.get(t) ?? 0;
        i++, lP.set(t, i);
        const n = i === 1 ? t : `${t}#${i}`;
        return cP.set(s, n), n;
      }
      function $ee(s) {
        const e = s.constructor;
        return e ? e.name : "Object";
      }
      function QT(s) {
        var _a3;
        const e = s.toString(), i = /\/\*\*\s*@description\s*([^*]*)\*\//.exec(e);
        return (_a3 = i ? i[1] : void 0) == null ? void 0 : _a3.trim();
      }
      let qee;
      function H6() {
        return qee;
      }
      let z6;
      function Kee(s) {
        z6 = s;
      }
      let U6;
      function jee(s) {
        U6 = s;
      }
      let zD;
      function Gee(s) {
        zD = s;
      }
      class $6 {
        get TChange() {
          return null;
        }
        reportChanges() {
          this.get();
        }
        read(e) {
          return e ? e.readObservable(this) : this.get();
        }
        map(e, t) {
          const i = t === void 0 ? void 0 : e, n = t === void 0 ? e : t;
          return zD({
            owner: i,
            debugName: () => {
              const o = QT(n);
              if (o !== void 0) return o;
              const a = /^\s*\(?\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\s*\)?\s*=>\s*\1(?:\??)\.([a-zA-Z_$][a-zA-Z_$0-9]*)\s*$/.exec(n.toString());
              if (a) return `${this.debugName}.${a[2]}`;
              if (!i) return `${this.debugName} (mapped)`;
            },
            debugReferenceFn: n
          }, (o) => n(this.read(o), o));
        }
        flatten() {
          return zD({
            owner: void 0,
            debugName: () => `${this.debugName} (flattened)`
          }, (e) => this.read(e).read(e));
        }
        recomputeInitiallyAndOnChange(e, t) {
          return e.add(z6(this, t)), this;
        }
        keepObserved(e) {
          return e.add(U6(this)), this;
        }
      }
      class Eg extends $6 {
        constructor() {
          super(...arguments), this.observers = /* @__PURE__ */ new Set();
        }
        addObserver(e) {
          const t = this.observers.size;
          this.observers.add(e), t === 0 && this.onFirstObserverAdded();
        }
        removeObserver(e) {
          this.observers.delete(e) && this.observers.size === 0 && this.onLastObserverRemoved();
        }
        onFirstObserverAdded() {
        }
        onLastObserverRemoved() {
        }
      }
      function Yi(s, e) {
        const t = new J_(s, e);
        try {
          s(t);
        } finally {
          t.finish();
        }
      }
      let qb;
      function op(s) {
        if (qb) s(qb);
        else {
          const e = new J_(s, void 0);
          qb = e;
          try {
            s(e);
          } finally {
            e.finish(), qb = void 0;
          }
        }
      }
      function XT(s, e, t) {
        s ? e(s) : Yi(e, t);
      }
      class J_ {
        constructor(e, t) {
          this._fn = e, this._getDebugName = t, this.updatingObservers = [];
        }
        getDebugName() {
          return this._getDebugName ? this._getDebugName() : QT(this._fn);
        }
        updateObserver(e, t) {
          this.updatingObservers.push({
            observer: e,
            observable: t
          }), e.beginUpdate(t);
        }
        finish() {
          const e = this.updatingObservers;
          for (let t = 0; t < e.length; t++) {
            const { observer: i, observable: n } = e[t];
            i.endUpdate(n);
          }
          this.updatingObservers = null;
        }
      }
      function Ct(s, e) {
        let t;
        return typeof s == "string" ? t = new ps(void 0, s, void 0) : t = new ps(s, void 0, void 0), new JT(t, e, br);
      }
      class JT extends Eg {
        get debugName() {
          return this._debugNameData.getDebugName(this) ?? "ObservableValue";
        }
        constructor(e, t, i) {
          super(), this._debugNameData = e, this._equalityComparator = i, this._value = t;
        }
        get() {
          return this._value;
        }
        set(e, t, i) {
          var _a3;
          if (i === void 0 && this._equalityComparator(this._value, e)) return;
          let n;
          t || (t = n = new J_(() => {
          }, () => `Setting ${this.debugName}`));
          try {
            const o = this._value;
            this._setValue(e), (_a3 = H6()) == null ? void 0 : _a3.handleObservableChanged(this, {
              oldValue: o,
              newValue: e,
              change: i,
              didChange: true,
              hadValue: true
            });
            for (const r of this.observers) t.updateObserver(r, this), r.handleChange(this, i);
          } finally {
            n && n.finish();
          }
        }
        toString() {
          return `${this.debugName}: ${this._value}`;
        }
        _setValue(e) {
          this._value = e;
        }
      }
      function q6(s, e) {
        let t;
        return typeof s == "string" ? t = new ps(void 0, s, void 0) : t = new ps(s, void 0, void 0), new Yee(t, e, br);
      }
      class Yee extends JT {
        _setValue(e) {
          this._value !== e && (this._value && this._value.dispose(), this._value = e);
        }
        dispose() {
          var _a3;
          (_a3 = this._value) == null ? void 0 : _a3.dispose();
        }
      }
      function Ye(s, e) {
        return e !== void 0 ? new mg(new ps(s, void 0, e), e, void 0, void 0, void 0, br) : new mg(new ps(void 0, void 0, s), s, void 0, void 0, void 0, br);
      }
      function eN(s, e, t) {
        return new Zee(new ps(s, void 0, e), e, void 0, void 0, void 0, br, t);
      }
      function _w(s, e) {
        return new mg(new ps(s.owner, s.debugName, s.debugReferenceFn), e, void 0, void 0, s.onLastObserverRemoved, s.equalsFn ?? br);
      }
      Gee(_w);
      function Tg(s, e) {
        let t, i;
        e === void 0 ? (t = s, i = void 0) : (i = s, t = e);
        const n = new Me();
        return new mg(new ps(i, void 0, t), (o) => (n.clear(), t(o, n)), void 0, void 0, () => n.dispose(), br);
      }
      function _a(s, e) {
        let t, i;
        e === void 0 ? (t = s, i = void 0) : (i = s, t = e);
        let n;
        return new mg(new ps(i, void 0, t), (o) => {
          n ? n.clear() : n = new Me();
          const r = t(o);
          return r && n.add(r), r;
        }, void 0, void 0, () => {
          n && (n.dispose(), n = void 0);
        }, br);
      }
      class mg extends Eg {
        get debugName() {
          return this._debugNameData.getDebugName(this) ?? "(anonymous)";
        }
        constructor(e, t, i, n, o = void 0, r) {
          var _a3;
          super(), this._debugNameData = e, this._computeFn = t, this.createChangeSummary = i, this._handleChange = n, this._handleLastObserverRemoved = o, this._equalityComparator = r, this.state = 0, this.value = void 0, this.updateCount = 0, this.dependencies = /* @__PURE__ */ new Set(), this.dependenciesToBeRemoved = /* @__PURE__ */ new Set(), this.changeSummary = void 0, this.changeSummary = (_a3 = this.createChangeSummary) == null ? void 0 : _a3.call(this);
        }
        onLastObserverRemoved() {
          var _a3;
          this.state = 0, this.value = void 0;
          for (const e of this.dependencies) e.removeObserver(this);
          this.dependencies.clear(), (_a3 = this._handleLastObserverRemoved) == null ? void 0 : _a3.call(this);
        }
        get() {
          var _a3;
          if (this.observers.size === 0) {
            const e = this._computeFn(this, (_a3 = this.createChangeSummary) == null ? void 0 : _a3.call(this));
            return this.onLastObserverRemoved(), e;
          } else {
            do {
              if (this.state === 1) {
                for (const e of this.dependencies) if (e.reportChanges(), this.state === 2) break;
              }
              this.state === 1 && (this.state = 3), this._recomputeIfNeeded();
            } while (this.state !== 3);
            return this.value;
          }
        }
        _recomputeIfNeeded() {
          var _a3;
          if (this.state === 3) return;
          const e = this.dependenciesToBeRemoved;
          this.dependenciesToBeRemoved = this.dependencies, this.dependencies = e;
          const t = this.state !== 0, i = this.value;
          this.state = 3;
          const n = this.changeSummary;
          this.changeSummary = (_a3 = this.createChangeSummary) == null ? void 0 : _a3.call(this);
          try {
            this.value = this._computeFn(this, n);
          } finally {
            for (const r of this.dependenciesToBeRemoved) r.removeObserver(this);
            this.dependenciesToBeRemoved.clear();
          }
          if (t && !this._equalityComparator(i, this.value)) for (const r of this.observers) r.handleChange(this, void 0);
        }
        toString() {
          return `LazyDerived<${this.debugName}>`;
        }
        beginUpdate(e) {
          this.updateCount++;
          const t = this.updateCount === 1;
          if (this.state === 3 && (this.state = 1, !t)) for (const i of this.observers) i.handlePossibleChange(this);
          if (t) for (const i of this.observers) i.beginUpdate(this);
        }
        endUpdate(e) {
          if (this.updateCount--, this.updateCount === 0) {
            const t = [
              ...this.observers
            ];
            for (const i of t) i.endUpdate(this);
          }
          Oh(() => this.updateCount >= 0);
        }
        handlePossibleChange(e) {
          if (this.state === 3 && this.dependencies.has(e) && !this.dependenciesToBeRemoved.has(e)) {
            this.state = 1;
            for (const t of this.observers) t.handlePossibleChange(this);
          }
        }
        handleChange(e, t) {
          if (this.dependencies.has(e) && !this.dependenciesToBeRemoved.has(e)) {
            const i = this._handleChange ? this._handleChange({
              changedObservable: e,
              change: t,
              didChange: (o) => o === e
            }, this.changeSummary) : true, n = this.state === 3;
            if (i && (this.state === 1 || n) && (this.state = 2, n)) for (const o of this.observers) o.handlePossibleChange(this);
          }
        }
        readObservable(e) {
          e.addObserver(this);
          const t = e.get();
          return this.dependencies.add(e), this.dependenciesToBeRemoved.delete(e), t;
        }
        addObserver(e) {
          const t = !this.observers.has(e) && this.updateCount > 0;
          super.addObserver(e), t && e.beginUpdate(this);
        }
        removeObserver(e) {
          const t = this.observers.has(e) && this.updateCount > 0;
          super.removeObserver(e), t && e.endUpdate(this);
        }
      }
      class Zee extends mg {
        constructor(e, t, i, n, o = void 0, r, a) {
          super(e, t, i, n, o, r), this.set = a;
        }
      }
      function Dt(s) {
        return new Cw(new ps(void 0, void 0, s), s, void 0, void 0);
      }
      function bw(s, e) {
        return new Cw(new ps(s.owner, s.debugName, s.debugReferenceFn ?? e), e, void 0, void 0);
      }
      function vw(s, e) {
        return new Cw(new ps(s.owner, s.debugName, s.debugReferenceFn ?? e), e, s.createEmptyChangeSummary, s.handleChange);
      }
      function Ur(s) {
        const e = new Me(), t = bw({
          owner: void 0,
          debugName: void 0,
          debugReferenceFn: s
        }, (i) => {
          e.clear(), s(i, e);
        });
        return Ze(() => {
          t.dispose(), e.dispose();
        });
      }
      class Cw {
        get debugName() {
          return this._debugNameData.getDebugName(this) ?? "(anonymous)";
        }
        constructor(e, t, i, n) {
          var _a3;
          this._debugNameData = e, this._runFn = t, this.createChangeSummary = i, this._handleChange = n, this.state = 2, this.updateCount = 0, this.disposed = false, this.dependencies = /* @__PURE__ */ new Set(), this.dependenciesToBeRemoved = /* @__PURE__ */ new Set(), this.changeSummary = (_a3 = this.createChangeSummary) == null ? void 0 : _a3.call(this), this._runIfNeeded();
        }
        dispose() {
          this.disposed = true;
          for (const e of this.dependencies) e.removeObserver(this);
          this.dependencies.clear();
        }
        _runIfNeeded() {
          var _a3, _b3;
          if (this.state === 3) return;
          const e = this.dependenciesToBeRemoved;
          this.dependenciesToBeRemoved = this.dependencies, this.dependencies = e, this.state = 3;
          const t = this.disposed;
          try {
            if (!t) {
              (_a3 = H6()) == null ? void 0 : _a3.handleAutorunTriggered(this);
              const i = this.changeSummary;
              this.changeSummary = (_b3 = this.createChangeSummary) == null ? void 0 : _b3.call(this), this._runFn(this, i);
            }
          } finally {
            for (const i of this.dependenciesToBeRemoved) i.removeObserver(this);
            this.dependenciesToBeRemoved.clear();
          }
        }
        toString() {
          return `Autorun<${this.debugName}>`;
        }
        beginUpdate() {
          this.state === 3 && (this.state = 1), this.updateCount++;
        }
        endUpdate() {
          if (this.updateCount === 1) do {
            if (this.state === 1) {
              this.state = 3;
              for (const e of this.dependencies) if (e.reportChanges(), this.state === 2) break;
            }
            this._runIfNeeded();
          } while (this.state !== 3);
          this.updateCount--, Oh(() => this.updateCount >= 0);
        }
        handlePossibleChange(e) {
          this.state === 3 && this.dependencies.has(e) && !this.dependenciesToBeRemoved.has(e) && (this.state = 1);
        }
        handleChange(e, t) {
          this.dependencies.has(e) && !this.dependenciesToBeRemoved.has(e) && (!this._handleChange || this._handleChange({
            changedObservable: e,
            change: t,
            didChange: (n) => n === e
          }, this.changeSummary)) && (this.state = 2);
        }
        readObservable(e) {
          if (this.disposed) return e.get();
          e.addObserver(this);
          const t = e.get();
          return this.dependencies.add(e), this.dependenciesToBeRemoved.delete(e), t;
        }
      }
      (function(s) {
        s.Observer = Cw;
      })(Dt || (Dt = {}));
      function Ov(s) {
        return new Qee(s);
      }
      class Qee extends $6 {
        constructor(e) {
          super(), this.value = e;
        }
        get debugName() {
          return this.toString();
        }
        get() {
          return this.value;
        }
        addObserver(e) {
        }
        removeObserver(e) {
        }
        toString() {
          return `Const: ${this.value}`;
        }
      }
      function yi(...s) {
        let e, t, i;
        return s.length === 3 ? [e, t, i] = s : [t, i] = s, new vf(new ps(e, void 0, i), t, i, () => vf.globalTransaction, br);
      }
      class vf extends Eg {
        constructor(e, t, i, n, o) {
          super(), this._debugNameData = e, this.event = t, this._getValue = i, this._getTransaction = n, this._equalityComparator = o, this.hasValue = false, this.handleEvent = (r) => {
            const a = this._getValue(r), l = this.value;
            (!this.hasValue || !this._equalityComparator(l, a)) && (this.value = a, this.hasValue && XT(this._getTransaction(), (d) => {
              for (const f of this.observers) d.updateObserver(f, this), f.handleChange(this, void 0);
            }, () => {
              const d = this.getDebugName();
              return "Event fired" + (d ? `: ${d}` : "");
            }), this.hasValue = true);
          };
        }
        getDebugName() {
          return this._debugNameData.getDebugName(this);
        }
        get debugName() {
          const e = this.getDebugName();
          return "From Event" + (e ? `: ${e}` : "");
        }
        onFirstObserverAdded() {
          this.subscription = this.event(this.handleEvent);
        }
        onLastObserverRemoved() {
          this.subscription.dispose(), this.subscription = void 0, this.hasValue = false, this.value = void 0;
        }
        get() {
          return this.subscription ? (this.hasValue || this.handleEvent(void 0), this.value) : this._getValue(void 0);
        }
      }
      (function(s) {
        s.Observer = vf;
        function e(t, i) {
          let n = false;
          vf.globalTransaction === void 0 && (vf.globalTransaction = t, n = true);
          try {
            i();
          } finally {
            n && (vf.globalTransaction = void 0);
          }
        }
        s.batchEventsGlobally = e;
      })(yi || (yi = {}));
      function Ao(s, e) {
        return new Xee(s, e);
      }
      class Xee extends Eg {
        constructor(e, t) {
          super(), this.debugName = e, this.event = t, this.handleEvent = () => {
            Yi((i) => {
              for (const n of this.observers) i.updateObserver(n, this), n.handleChange(this, void 0);
            }, () => this.debugName);
          };
        }
        onFirstObserverAdded() {
          this.subscription = this.event(this.handleEvent);
        }
        onLastObserverRemoved() {
          this.subscription.dispose(), this.subscription = void 0;
        }
        get() {
        }
      }
      function tN(s) {
        return typeof s == "string" ? new uP(s) : new uP(void 0, s);
      }
      class uP extends Eg {
        get debugName() {
          return new ps(this._owner, this._debugName, void 0).getDebugName(this) ?? "Observable Signal";
        }
        toString() {
          return this.debugName;
        }
        constructor(e, t) {
          super(), this._debugName = e, this._owner = t;
        }
        trigger(e, t) {
          if (!e) {
            Yi((i) => {
              this.trigger(i, t);
            }, () => `Trigger signal ${this.debugName}`);
            return;
          }
          for (const i of this.observers) e.updateObserver(i, this), i.handleChange(this, t);
        }
        get() {
        }
      }
      function Jee(s) {
        const e = new K6(false, void 0);
        return s.addObserver(e), Ze(() => {
          s.removeObserver(e);
        });
      }
      jee(Jee);
      function ww(s, e) {
        const t = new K6(true, e);
        return s.addObserver(t), e ? e(s.get()) : s.reportChanges(), Ze(() => {
          s.removeObserver(t);
        });
      }
      Kee(ww);
      class K6 {
        constructor(e, t) {
          this._forceRecompute = e, this._handleValue = t, this._counter = 0;
        }
        beginUpdate(e) {
          this._counter++;
        }
        endUpdate(e) {
          this._counter--, this._counter === 0 && this._forceRecompute && (this._handleValue ? this._handleValue(e.get()) : e.reportChanges());
        }
        handlePossibleChange(e) {
        }
        handleChange(e, t) {
        }
      }
      function ete(s, e) {
        let t;
        return _w({
          owner: s,
          debugReferenceFn: e
        }, (n) => (t = e(n, t), t));
      }
      function tte(s, e) {
        return ete(s, (t, i) => i ?? e(t));
      }
      function ite(s, e, t, i) {
        return e || (e = (n) => n != null), new Promise((n, o) => {
          let r = true, a = false;
          const l = s.map((d) => ({
            isFinished: e(d),
            error: false,
            state: d
          })), u = Dt((d) => {
            const { isFinished: f, error: m, state: _ } = l.read(d);
            (f || m) && (r ? a = true : u.dispose(), m ? o(m === true ? _ : m) : n(_));
          });
          r = false, a && u.dispose();
        });
      }
      class nte extends Eg {
        get debugName() {
          return this._debugNameData.getDebugName(this) ?? "LazyObservableValue";
        }
        constructor(e, t, i) {
          super(), this._debugNameData = e, this._equalityComparator = i, this._isUpToDate = true, this._deltas = [], this._updateCounter = 0, this._value = t;
        }
        get() {
          return this._update(), this._value;
        }
        _update() {
          if (!this._isUpToDate) if (this._isUpToDate = true, this._deltas.length > 0) {
            for (const e of this.observers) for (const t of this._deltas) e.handleChange(this, t);
            this._deltas.length = 0;
          } else for (const e of this.observers) e.handleChange(this, void 0);
        }
        _beginUpdate() {
          if (this._updateCounter++, this._updateCounter === 1) for (const e of this.observers) e.beginUpdate(this);
        }
        _endUpdate() {
          if (this._updateCounter--, this._updateCounter === 0) {
            this._update();
            const e = [
              ...this.observers
            ];
            for (const t of e) t.endUpdate(this);
          }
        }
        addObserver(e) {
          const t = !this.observers.has(e) && this._updateCounter > 0;
          super.addObserver(e), t && e.beginUpdate(this);
        }
        removeObserver(e) {
          const t = this.observers.has(e) && this._updateCounter > 0;
          super.removeObserver(e), t && e.endUpdate(this);
        }
        set(e, t, i) {
          if (i === void 0 && this._equalityComparator(this._value, e)) return;
          let n;
          t || (t = n = new J_(() => {
          }, () => `Setting ${this.debugName}`));
          try {
            if (this._isUpToDate = false, this._setValue(e), i !== void 0 && this._deltas.push(i), t.updateObserver({
              beginUpdate: () => this._beginUpdate(),
              endUpdate: () => this._endUpdate(),
              handleChange: (o, r) => {
              },
              handlePossibleChange: (o) => {
              }
            }, this), this._updateCounter > 1) for (const o of this.observers) o.handlePossibleChange(this);
          } finally {
            n && n.finish();
          }
        }
        toString() {
          return `${this.debugName}: ${this._value}`;
        }
        _setValue(e) {
          this._value = e;
        }
      }
      function UD(s, e) {
        return s.lazy ? new nte(new ps(s.owner, s.debugName, void 0), e, s.equalsFn ?? br) : new JT(new ps(s.owner, s.debugName, void 0), e, s.equalsFn ?? br);
      }
      const _Pv = class _Pv extends he {
        constructor(e = false) {
          super(), this._onDidRequestBasicLanguageFeatures = this._register(new G()), this.onDidRequestBasicLanguageFeatures = this._onDidRequestBasicLanguageFeatures.event, this._onDidRequestRichLanguageFeatures = this._register(new G()), this.onDidRequestRichLanguageFeatures = this._onDidRequestRichLanguageFeatures.event, this._onDidChange = this._register(new G({
            leakWarningThreshold: 200
          })), this.onDidChange = this._onDidChange.event, this._requestedBasicLanguages = /* @__PURE__ */ new Set(), this._requestedRichLanguages = /* @__PURE__ */ new Set(), _Pv.instanceCount++, this._registry = this._register(new Rv(true, e)), this.languageIdCodec = this._registry.languageIdCodec, this._register(this._registry.onDidChange(() => this._onDidChange.fire()));
        }
        dispose() {
          _Pv.instanceCount--, super.dispose();
        }
        isRegisteredLanguageId(e) {
          return this._registry.isRegisteredLanguageId(e);
        }
        getLanguageIdByLanguageName(e) {
          return this._registry.getLanguageIdByLanguageName(e);
        }
        getLanguageIdByMimeType(e) {
          return this._registry.getLanguageIdByMimeType(e);
        }
        guessLanguageIdByFilepathOrFirstLine(e, t) {
          const i = this._registry.guessLanguageIdByFilepathOrFirstLine(e, t);
          return IE(i, null);
        }
        createById(e) {
          return new hP(this.onDidChange, () => this._createAndGetLanguageIdentifier(e));
        }
        createByFilepathOrFirstLine(e, t) {
          return new hP(this.onDidChange, () => {
            const i = this.guessLanguageIdByFilepathOrFirstLine(e, t);
            return this._createAndGetLanguageIdentifier(i);
          });
        }
        _createAndGetLanguageIdentifier(e) {
          return (!e || !this.isRegisteredLanguageId(e)) && (e = gr), e;
        }
        requestBasicLanguageFeatures(e) {
          this._requestedBasicLanguages.has(e) || (this._requestedBasicLanguages.add(e), this._onDidRequestBasicLanguageFeatures.fire(e));
        }
        requestRichLanguageFeatures(e) {
          this._requestedRichLanguages.has(e) || (this._requestedRichLanguages.add(e), this.requestBasicLanguageFeatures(e), Bi.getOrCreate(e), this._onDidRequestRichLanguageFeatures.fire(e));
        }
      };
      _Pv.instanceCount = 0;
      let Pv = _Pv;
      class hP {
        constructor(e, t) {
          this._value = yi(this, e, () => t()), this.onDidChange = be.fromObservable(this._value);
        }
        get languageId() {
          return this._value.get();
        }
      }
      const j6 = {
        TEXT: kl.text
      }, ste = () => ({
        get delay() {
          return -1;
        },
        dispose: () => {
        },
        showHover: () => {
        }
      });
      let yw = ste;
      const ote = new iu(() => yw("mouse", false)), rte = new iu(() => yw("element", false));
      function ate(s) {
        yw = s;
      }
      function $o(s) {
        return s === "element" ? rte.value : ote.value;
      }
      function iN() {
        return yw("element", true);
      }
      let G6 = {
        showHover: () => {
        },
        hideHover: () => {
        },
        showAndFocusLastHover: () => {
        },
        setupManagedHover: () => null,
        showManagedHover: () => {
        }
      };
      function lte(s) {
        G6 = s;
      }
      function Ba() {
        return G6;
      }
      class cte {
        constructor(e) {
          this.spliceables = e;
        }
        splice(e, t, i) {
          this.spliceables.forEach((n) => n.splice(e, t, i));
        }
      }
      class Fu extends Error {
        constructor(e, t) {
          super(`ListError [${e}] ${t}`);
        }
      }
      function dP(s, e) {
        const t = [];
        for (const i of e) {
          if (s.start >= i.range.end) continue;
          if (s.end < i.range.start) break;
          const n = Hn.intersect(s, i.range);
          Hn.isEmpty(n) || t.push({
            range: n,
            size: i.size
          });
        }
        return t;
      }
      function $D({ start: s, end: e }, t) {
        return {
          start: s + t,
          end: e + t
        };
      }
      function ute(s) {
        const e = [];
        let t = null;
        for (const i of s) {
          const n = i.range.start, o = i.range.end, r = i.size;
          if (t && r === t.size) {
            t.range.end = o;
            continue;
          }
          t = {
            range: {
              start: n,
              end: o
            },
            size: r
          }, e.push(t);
        }
        return e;
      }
      function hte(...s) {
        return ute(s.reduce((e, t) => e.concat(t), []));
      }
      class dte {
        get paddingTop() {
          return this._paddingTop;
        }
        set paddingTop(e) {
          this._size = this._size + e - this._paddingTop, this._paddingTop = e;
        }
        constructor(e) {
          this.groups = [], this._size = 0, this._paddingTop = 0, this._paddingTop = e ?? 0, this._size = this._paddingTop;
        }
        splice(e, t, i = []) {
          const n = i.length - t, o = dP({
            start: 0,
            end: e
          }, this.groups), r = dP({
            start: e + t,
            end: Number.POSITIVE_INFINITY
          }, this.groups).map((l) => ({
            range: $D(l.range, n),
            size: l.size
          })), a = i.map((l, u) => ({
            range: {
              start: e + u,
              end: e + u + 1
            },
            size: l.size
          }));
          this.groups = hte(o, a, r), this._size = this._paddingTop + this.groups.reduce((l, u) => l + u.size * (u.range.end - u.range.start), 0);
        }
        get count() {
          const e = this.groups.length;
          return e ? this.groups[e - 1].range.end : 0;
        }
        get size() {
          return this._size;
        }
        indexAt(e) {
          if (e < 0) return -1;
          if (e < this._paddingTop) return 0;
          let t = 0, i = this._paddingTop;
          for (const n of this.groups) {
            const o = n.range.end - n.range.start, r = i + o * n.size;
            if (e < r) return t + Math.floor((e - i) / n.size);
            t += o, i = r;
          }
          return t;
        }
        indexAfter(e) {
          return Math.min(this.indexAt(e) + 1, this.count);
        }
        positionAt(e) {
          if (e < 0) return -1;
          let t = 0, i = 0;
          for (const n of this.groups) {
            const o = n.range.end - n.range.start, r = i + o;
            if (e < r) return this._paddingTop + t + (e - i) * n.size;
            t += o * n.size, i = r;
          }
          return -1;
        }
      }
      class fte {
        constructor(e) {
          this.renderers = e, this.cache = /* @__PURE__ */ new Map(), this.transactionNodesPendingRemoval = /* @__PURE__ */ new Set(), this.inTransaction = false;
        }
        alloc(e) {
          let t = this.getTemplateCache(e).pop(), i = false;
          if (t) i = this.transactionNodesPendingRemoval.has(t.domNode), i && this.transactionNodesPendingRemoval.delete(t.domNode);
          else {
            const n = He(".monaco-list-row"), r = this.getRenderer(e).renderTemplate(n);
            t = {
              domNode: n,
              templateId: e,
              templateData: r
            };
          }
          return {
            row: t,
            isReusingConnectedDomNode: i
          };
        }
        release(e) {
          e && this.releaseRow(e);
        }
        transact(e) {
          if (this.inTransaction) throw new Error("Already in transaction");
          this.inTransaction = true;
          try {
            e();
          } finally {
            for (const t of this.transactionNodesPendingRemoval) this.doRemoveNode(t);
            this.transactionNodesPendingRemoval.clear(), this.inTransaction = false;
          }
        }
        releaseRow(e) {
          const { domNode: t, templateId: i } = e;
          t && (this.inTransaction ? this.transactionNodesPendingRemoval.add(t) : this.doRemoveNode(t)), this.getTemplateCache(i).push(e);
        }
        doRemoveNode(e) {
          e.classList.remove("scrolling"), e.remove();
        }
        getTemplateCache(e) {
          let t = this.cache.get(e);
          return t || (t = [], this.cache.set(e, t)), t;
        }
        dispose() {
          this.cache.forEach((e, t) => {
            for (const i of e) this.getRenderer(t).disposeTemplate(i.templateData), i.templateData = null;
          }), this.cache.clear(), this.transactionNodesPendingRemoval.clear();
        }
        getRenderer(e) {
          const t = this.renderers.get(e);
          if (!t) throw new Error(`No renderer found for ${e}`);
          return t;
        }
      }
      var Zl = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      };
      const Vu = {
        CurrentDragAndDropData: void 0
      }, fa = {
        useShadows: true,
        verticalScrollMode: 1,
        setRowLineHeight: true,
        setRowHeight: true,
        supportDynamicHeights: false,
        dnd: {
          getDragElements(s) {
            return [
              s
            ];
          },
          getDragURI() {
            return null;
          },
          onDragStart() {
          },
          onDragOver() {
            return false;
          },
          drop() {
          },
          dispose() {
          }
        },
        horizontalScrolling: false,
        transformOptimization: true,
        alwaysConsumeMouseWheel: true
      };
      class e1 {
        constructor(e) {
          this.elements = e;
        }
        update() {
        }
        getData() {
          return this.elements;
        }
      }
      class gte {
        constructor(e) {
          this.elements = e;
        }
        update() {
        }
        getData() {
          return this.elements;
        }
      }
      class mte {
        constructor() {
          this.types = [], this.files = [];
        }
        update(e) {
          if (e.types && this.types.splice(0, this.types.length, ...e.types), e.files) {
            this.files.splice(0, this.files.length);
            for (let t = 0; t < e.files.length; t++) {
              const i = e.files.item(t);
              i && (i.size || i.type) && this.files.push(i);
            }
          }
        }
        getData() {
          return {
            types: this.types,
            files: this.files
          };
        }
      }
      function pte(s, e) {
        return Array.isArray(s) && Array.isArray(e) ? Qi(s, e) : s === e;
      }
      class _te {
        constructor(e) {
          (e == null ? void 0 : e.getSetSize) ? this.getSetSize = e.getSetSize.bind(e) : this.getSetSize = (t, i, n) => n, (e == null ? void 0 : e.getPosInSet) ? this.getPosInSet = e.getPosInSet.bind(e) : this.getPosInSet = (t, i) => i + 1, (e == null ? void 0 : e.getRole) ? this.getRole = e.getRole.bind(e) : this.getRole = (t) => "listitem", (e == null ? void 0 : e.isChecked) ? this.isChecked = e.isChecked.bind(e) : this.isChecked = (t) => {
          };
        }
      }
      const _Cr = class _Cr {
        get contentHeight() {
          return this.rangeMap.size;
        }
        get onDidScroll() {
          return this.scrollableElement.onScroll;
        }
        get scrollableElementDomNode() {
          return this.scrollableElement.getDomNode();
        }
        get horizontalScrolling() {
          return this._horizontalScrolling;
        }
        set horizontalScrolling(e) {
          if (e !== this._horizontalScrolling) {
            if (e && this.supportDynamicHeights) throw new Error("Horizontal scrolling and dynamic heights not supported simultaneously");
            if (this._horizontalScrolling = e, this.domNode.classList.toggle("horizontal-scrolling", this._horizontalScrolling), this._horizontalScrolling) {
              for (const t of this.items) this.measureItemWidth(t);
              this.updateScrollWidth(), this.scrollableElement.setScrollDimensions({
                width: SL(this.domNode)
              }), this.rowsContainer.style.width = `${Math.max(this.scrollWidth || 0, this.renderWidth)}px`;
            } else this.scrollableElementWidthDelayer.cancel(), this.scrollableElement.setScrollDimensions({
              width: this.renderWidth,
              scrollWidth: this.renderWidth
            }), this.rowsContainer.style.width = "";
          }
        }
        constructor(e, t, i, n = fa) {
          var _a3, _b3;
          if (this.virtualDelegate = t, this.domId = `list_id_${++_Cr.InstanceCount}`, this.renderers = /* @__PURE__ */ new Map(), this.renderWidth = 0, this._scrollHeight = 0, this.scrollableElementUpdateDisposable = null, this.scrollableElementWidthDelayer = new W_(50), this.splicing = false, this.dragOverAnimationStopDisposable = he.None, this.dragOverMouseY = 0, this.canDrop = false, this.currentDragFeedbackDisposable = he.None, this.onDragLeaveTimeout = he.None, this.disposables = new Me(), this._onDidChangeContentHeight = new G(), this._onDidChangeContentWidth = new G(), this.onDidChangeContentHeight = be.latch(this._onDidChangeContentHeight.event, void 0, this.disposables), this._horizontalScrolling = false, n.horizontalScrolling && n.supportDynamicHeights) throw new Error("Horizontal scrolling and dynamic heights not supported simultaneously");
          this.items = [], this.itemId = 0, this.rangeMap = this.createRangeMap(n.paddingTop ?? 0);
          for (const r of i) this.renderers.set(r.templateId, r);
          this.cache = this.disposables.add(new fte(this.renderers)), this.lastRenderTop = 0, this.lastRenderHeight = 0, this.domNode = document.createElement("div"), this.domNode.className = "monaco-list", this.domNode.classList.add(this.domId), this.domNode.tabIndex = 0, this.domNode.classList.toggle("mouse-support", typeof n.mouseSupport == "boolean" ? n.mouseSupport : true), this._horizontalScrolling = n.horizontalScrolling ?? fa.horizontalScrolling, this.domNode.classList.toggle("horizontal-scrolling", this._horizontalScrolling), this.paddingBottom = typeof n.paddingBottom > "u" ? 0 : n.paddingBottom, this.accessibilityProvider = new _te(n.accessibilityProvider), this.rowsContainer = document.createElement("div"), this.rowsContainer.className = "monaco-list-rows", (n.transformOptimization ?? fa.transformOptimization) && (this.rowsContainer.style.transform = "translate3d(0px, 0px, 0px)", this.rowsContainer.style.overflow = "hidden", this.rowsContainer.style.contain = "strict"), this.disposables.add(ui.addTarget(this.rowsContainer)), this.scrollable = this.disposables.add(new Dg({
            forceIntegerValues: true,
            smoothScrollDuration: n.smoothScrolling ?? false ? 125 : 0,
            scheduleAtNextAnimationFrame: (r) => Gs(Oe(this.domNode), r)
          })), this.scrollableElement = this.disposables.add(new dw(this.rowsContainer, {
            alwaysConsumeMouseWheel: n.alwaysConsumeMouseWheel ?? fa.alwaysConsumeMouseWheel,
            horizontal: 1,
            vertical: n.verticalScrollMode ?? fa.verticalScrollMode,
            useShadows: n.useShadows ?? fa.useShadows,
            mouseWheelScrollSensitivity: n.mouseWheelScrollSensitivity,
            fastScrollSensitivity: n.fastScrollSensitivity,
            scrollByPage: n.scrollByPage
          }, this.scrollable)), this.domNode.appendChild(this.scrollableElement.getDomNode()), e.appendChild(this.domNode), this.scrollableElement.onScroll(this.onScroll, this, this.disposables), this.disposables.add(re(this.rowsContainer, Qt.Change, (r) => this.onTouchChange(r))), this.disposables.add(re(this.scrollableElement.getDomNode(), "scroll", (r) => r.target.scrollTop = 0)), this.disposables.add(re(this.domNode, "dragover", (r) => this.onDragOver(this.toDragEvent(r)))), this.disposables.add(re(this.domNode, "drop", (r) => this.onDrop(this.toDragEvent(r)))), this.disposables.add(re(this.domNode, "dragleave", (r) => this.onDragLeave(this.toDragEvent(r)))), this.disposables.add(re(this.domNode, "dragend", (r) => this.onDragEnd(r))), this.setRowLineHeight = n.setRowLineHeight ?? fa.setRowLineHeight, this.setRowHeight = n.setRowHeight ?? fa.setRowHeight, this.supportDynamicHeights = n.supportDynamicHeights ?? fa.supportDynamicHeights, this.dnd = n.dnd ?? this.disposables.add(fa.dnd), this.layout((_a3 = n.initialSize) == null ? void 0 : _a3.height, (_b3 = n.initialSize) == null ? void 0 : _b3.width);
        }
        updateOptions(e) {
          e.paddingBottom !== void 0 && (this.paddingBottom = e.paddingBottom, this.scrollableElement.setScrollDimensions({
            scrollHeight: this.scrollHeight
          })), e.smoothScrolling !== void 0 && this.scrollable.setSmoothScrollDuration(e.smoothScrolling ? 125 : 0), e.horizontalScrolling !== void 0 && (this.horizontalScrolling = e.horizontalScrolling);
          let t;
          if (e.scrollByPage !== void 0 && (t = {
            ...t ?? {},
            scrollByPage: e.scrollByPage
          }), e.mouseWheelScrollSensitivity !== void 0 && (t = {
            ...t ?? {},
            mouseWheelScrollSensitivity: e.mouseWheelScrollSensitivity
          }), e.fastScrollSensitivity !== void 0 && (t = {
            ...t ?? {},
            fastScrollSensitivity: e.fastScrollSensitivity
          }), t && this.scrollableElement.updateOptions(t), e.paddingTop !== void 0 && e.paddingTop !== this.rangeMap.paddingTop) {
            const i = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight), n = e.paddingTop - this.rangeMap.paddingTop;
            this.rangeMap.paddingTop = e.paddingTop, this.render(i, Math.max(0, this.lastRenderTop + n), this.lastRenderHeight, void 0, void 0, true), this.setScrollTop(this.lastRenderTop), this.eventuallyUpdateScrollDimensions(), this.supportDynamicHeights && this._rerender(this.lastRenderTop, this.lastRenderHeight);
          }
        }
        createRangeMap(e) {
          return new dte(e);
        }
        splice(e, t, i = []) {
          if (this.splicing) throw new Error("Can't run recursive splices.");
          this.splicing = true;
          try {
            return this._splice(e, t, i);
          } finally {
            this.splicing = false, this._onDidChangeContentHeight.fire(this.contentHeight);
          }
        }
        _splice(e, t, i = []) {
          var _a3;
          const n = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight), o = {
            start: e,
            end: e + t
          }, r = Hn.intersect(n, o), a = /* @__PURE__ */ new Map();
          for (let T = r.end - 1; T >= r.start; T--) {
            const M = this.items[T];
            if (M.dragStartDisposable.dispose(), M.checkedDisposable.dispose(), M.row) {
              let I = a.get(M.templateId);
              I || (I = [], a.set(M.templateId, I));
              const R = this.renderers.get(M.templateId);
              R && R.disposeElement && R.disposeElement(M.element, T, M.row.templateData, M.size), I.unshift(M.row);
            }
            M.row = null, M.stale = true;
          }
          const l = {
            start: e + t,
            end: this.items.length
          }, u = Hn.intersect(l, n), d = Hn.relativeComplement(l, n), f = i.map((T) => ({
            id: String(this.itemId++),
            element: T,
            templateId: this.virtualDelegate.getTemplateId(T),
            size: this.virtualDelegate.getHeight(T),
            width: void 0,
            hasDynamicHeight: !!this.virtualDelegate.hasDynamicHeight && this.virtualDelegate.hasDynamicHeight(T),
            lastDynamicHeightWidth: void 0,
            row: null,
            uri: void 0,
            dropTarget: false,
            dragStartDisposable: he.None,
            checkedDisposable: he.None,
            stale: false
          }));
          let m;
          e === 0 && t >= this.items.length ? (this.rangeMap = this.createRangeMap(this.rangeMap.paddingTop), this.rangeMap.splice(0, 0, f), m = this.items, this.items = f) : (this.rangeMap.splice(e, t, f), m = this.items.splice(e, t, ...f));
          const _ = i.length - t, b = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight), v = $D(u, _), y = Hn.intersect(b, v);
          for (let T = y.start; T < y.end; T++) this.updateItemInDOM(this.items[T], T);
          const x = Hn.relativeComplement(v, b);
          for (const T of x) for (let M = T.start; M < T.end; M++) this.removeItemFromDOM(M);
          const L = d.map((T) => $D(T, _)), k = [
            {
              start: e,
              end: e + i.length
            },
            ...L
          ].map((T) => Hn.intersect(b, T)).reverse();
          for (const T of k) for (let M = T.end - 1; M >= T.start; M--) {
            const I = this.items[M], A = (_a3 = a.get(I.templateId)) == null ? void 0 : _a3.pop();
            this.insertItemInDOM(M, A);
          }
          for (const T of a.values()) for (const M of T) this.cache.release(M);
          return this.eventuallyUpdateScrollDimensions(), this.supportDynamicHeights && this._rerender(this.scrollTop, this.renderHeight), m.map((T) => T.element);
        }
        eventuallyUpdateScrollDimensions() {
          this._scrollHeight = this.contentHeight, this.rowsContainer.style.height = `${this._scrollHeight}px`, this.scrollableElementUpdateDisposable || (this.scrollableElementUpdateDisposable = Gs(Oe(this.domNode), () => {
            this.scrollableElement.setScrollDimensions({
              scrollHeight: this.scrollHeight
            }), this.updateScrollWidth(), this.scrollableElementUpdateDisposable = null;
          }));
        }
        eventuallyUpdateScrollWidth() {
          if (!this.horizontalScrolling) {
            this.scrollableElementWidthDelayer.cancel();
            return;
          }
          this.scrollableElementWidthDelayer.trigger(() => this.updateScrollWidth());
        }
        updateScrollWidth() {
          if (!this.horizontalScrolling) return;
          let e = 0;
          for (const t of this.items) typeof t.width < "u" && (e = Math.max(e, t.width));
          this.scrollWidth = e, this.scrollableElement.setScrollDimensions({
            scrollWidth: e === 0 ? 0 : e + 10
          }), this._onDidChangeContentWidth.fire(this.scrollWidth);
        }
        rerender() {
          if (this.supportDynamicHeights) {
            for (const e of this.items) e.lastDynamicHeightWidth = void 0;
            this._rerender(this.lastRenderTop, this.lastRenderHeight);
          }
        }
        get length() {
          return this.items.length;
        }
        get renderHeight() {
          return this.scrollableElement.getScrollDimensions().height;
        }
        get firstVisibleIndex() {
          return this.getRenderRange(this.lastRenderTop, this.lastRenderHeight).start;
        }
        element(e) {
          return this.items[e].element;
        }
        indexOf(e) {
          return this.items.findIndex((t) => t.element === e);
        }
        domElement(e) {
          const t = this.items[e].row;
          return t && t.domNode;
        }
        elementHeight(e) {
          return this.items[e].size;
        }
        elementTop(e) {
          return this.rangeMap.positionAt(e);
        }
        indexAt(e) {
          return this.rangeMap.indexAt(e);
        }
        indexAfter(e) {
          return this.rangeMap.indexAfter(e);
        }
        layout(e, t) {
          const i = {
            height: typeof e == "number" ? e : RK(this.domNode)
          };
          this.scrollableElementUpdateDisposable && (this.scrollableElementUpdateDisposable.dispose(), this.scrollableElementUpdateDisposable = null, i.scrollHeight = this.scrollHeight), this.scrollableElement.setScrollDimensions(i), typeof t < "u" && (this.renderWidth = t, this.supportDynamicHeights && this._rerender(this.scrollTop, this.renderHeight)), this.horizontalScrolling && this.scrollableElement.setScrollDimensions({
            width: typeof t == "number" ? t : SL(this.domNode)
          });
        }
        render(e, t, i, n, o, r = false) {
          const a = this.getRenderRange(t, i), l = Hn.relativeComplement(a, e).reverse(), u = Hn.relativeComplement(e, a);
          if (r) {
            const d = Hn.intersect(e, a);
            for (let f = d.start; f < d.end; f++) this.updateItemInDOM(this.items[f], f);
          }
          this.cache.transact(() => {
            for (const d of u) for (let f = d.start; f < d.end; f++) this.removeItemFromDOM(f);
            for (const d of l) for (let f = d.end - 1; f >= d.start; f--) this.insertItemInDOM(f);
          }), n !== void 0 && (this.rowsContainer.style.left = `-${n}px`), this.rowsContainer.style.top = `-${t}px`, this.horizontalScrolling && o !== void 0 && (this.rowsContainer.style.width = `${Math.max(o, this.renderWidth)}px`), this.lastRenderTop = t, this.lastRenderHeight = i;
        }
        insertItemInDOM(e, t) {
          var _a3, _b3;
          const i = this.items[e];
          if (!i.row) if (t) i.row = t, i.stale = true;
          else {
            const l = this.cache.alloc(i.templateId);
            i.row = l.row, i.stale || (i.stale = l.isReusingConnectedDomNode);
          }
          const n = this.accessibilityProvider.getRole(i.element) || "listitem";
          i.row.domNode.setAttribute("role", n);
          const o = this.accessibilityProvider.isChecked(i.element);
          if (typeof o == "boolean") i.row.domNode.setAttribute("aria-checked", String(!!o));
          else if (o) {
            const l = (u) => i.row.domNode.setAttribute("aria-checked", String(!!u));
            l(o.value), i.checkedDisposable = o.onDidChange(() => l(o.value));
          }
          if (i.stale || !i.row.domNode.parentElement) {
            const l = ((_b3 = (_a3 = this.items.at(e + 1)) == null ? void 0 : _a3.row) == null ? void 0 : _b3.domNode) ?? null;
            (i.row.domNode.parentElement !== this.rowsContainer || i.row.domNode.nextElementSibling !== l) && this.rowsContainer.insertBefore(i.row.domNode, l), i.stale = false;
          }
          this.updateItemInDOM(i, e);
          const r = this.renderers.get(i.templateId);
          if (!r) throw new Error(`No renderer found for template id ${i.templateId}`);
          r == null ? void 0 : r.renderElement(i.element, e, i.row.templateData, i.size);
          const a = this.dnd.getDragURI(i.element);
          i.dragStartDisposable.dispose(), i.row.domNode.draggable = !!a, a && (i.dragStartDisposable = re(i.row.domNode, "dragstart", (l) => this.onDragStart(i.element, a, l))), this.horizontalScrolling && (this.measureItemWidth(i), this.eventuallyUpdateScrollWidth());
        }
        measureItemWidth(e) {
          if (!e.row || !e.row.domNode) return;
          e.row.domNode.style.width = "fit-content", e.width = SL(e.row.domNode);
          const t = Oe(e.row.domNode).getComputedStyle(e.row.domNode);
          t.paddingLeft && (e.width += parseFloat(t.paddingLeft)), t.paddingRight && (e.width += parseFloat(t.paddingRight)), e.row.domNode.style.width = "";
        }
        updateItemInDOM(e, t) {
          e.row.domNode.style.top = `${this.elementTop(t)}px`, this.setRowHeight && (e.row.domNode.style.height = `${e.size}px`), this.setRowLineHeight && (e.row.domNode.style.lineHeight = `${e.size}px`), e.row.domNode.setAttribute("data-index", `${t}`), e.row.domNode.setAttribute("data-last-element", t === this.length - 1 ? "true" : "false"), e.row.domNode.setAttribute("data-parity", t % 2 === 0 ? "even" : "odd"), e.row.domNode.setAttribute("aria-setsize", String(this.accessibilityProvider.getSetSize(e.element, t, this.length))), e.row.domNode.setAttribute("aria-posinset", String(this.accessibilityProvider.getPosInSet(e.element, t))), e.row.domNode.setAttribute("id", this.getElementDomId(t)), e.row.domNode.classList.toggle("drop-target", e.dropTarget);
        }
        removeItemFromDOM(e) {
          const t = this.items[e];
          if (t.dragStartDisposable.dispose(), t.checkedDisposable.dispose(), t.row) {
            const i = this.renderers.get(t.templateId);
            i && i.disposeElement && i.disposeElement(t.element, e, t.row.templateData, t.size), this.cache.release(t.row), t.row = null;
          }
          this.horizontalScrolling && this.eventuallyUpdateScrollWidth();
        }
        getScrollTop() {
          return this.scrollableElement.getScrollPosition().scrollTop;
        }
        setScrollTop(e, t) {
          this.scrollableElementUpdateDisposable && (this.scrollableElementUpdateDisposable.dispose(), this.scrollableElementUpdateDisposable = null, this.scrollableElement.setScrollDimensions({
            scrollHeight: this.scrollHeight
          })), this.scrollableElement.setScrollPosition({
            scrollTop: e,
            reuseAnimation: t
          });
        }
        get scrollTop() {
          return this.getScrollTop();
        }
        set scrollTop(e) {
          this.setScrollTop(e);
        }
        get scrollHeight() {
          return this._scrollHeight + (this.horizontalScrolling ? 10 : 0) + this.paddingBottom;
        }
        get onMouseClick() {
          return be.map(this.disposables.add(new ot(this.domNode, "click")).event, (e) => this.toMouseEvent(e), this.disposables);
        }
        get onMouseDblClick() {
          return be.map(this.disposables.add(new ot(this.domNode, "dblclick")).event, (e) => this.toMouseEvent(e), this.disposables);
        }
        get onMouseMiddleClick() {
          return be.filter(be.map(this.disposables.add(new ot(this.domNode, "auxclick")).event, (e) => this.toMouseEvent(e), this.disposables), (e) => e.browserEvent.button === 1, this.disposables);
        }
        get onMouseDown() {
          return be.map(this.disposables.add(new ot(this.domNode, "mousedown")).event, (e) => this.toMouseEvent(e), this.disposables);
        }
        get onMouseOver() {
          return be.map(this.disposables.add(new ot(this.domNode, "mouseover")).event, (e) => this.toMouseEvent(e), this.disposables);
        }
        get onMouseOut() {
          return be.map(this.disposables.add(new ot(this.domNode, "mouseout")).event, (e) => this.toMouseEvent(e), this.disposables);
        }
        get onContextMenu() {
          return be.any(be.map(this.disposables.add(new ot(this.domNode, "contextmenu")).event, (e) => this.toMouseEvent(e), this.disposables), be.map(this.disposables.add(new ot(this.domNode, Qt.Contextmenu)).event, (e) => this.toGestureEvent(e), this.disposables));
        }
        get onTouchStart() {
          return be.map(this.disposables.add(new ot(this.domNode, "touchstart")).event, (e) => this.toTouchEvent(e), this.disposables);
        }
        get onTap() {
          return be.map(this.disposables.add(new ot(this.rowsContainer, Qt.Tap)).event, (e) => this.toGestureEvent(e), this.disposables);
        }
        toMouseEvent(e) {
          const t = this.getItemIndexFromEventTarget(e.target || null), i = typeof t > "u" ? void 0 : this.items[t], n = i && i.element;
          return {
            browserEvent: e,
            index: t,
            element: n
          };
        }
        toTouchEvent(e) {
          const t = this.getItemIndexFromEventTarget(e.target || null), i = typeof t > "u" ? void 0 : this.items[t], n = i && i.element;
          return {
            browserEvent: e,
            index: t,
            element: n
          };
        }
        toGestureEvent(e) {
          const t = this.getItemIndexFromEventTarget(e.initialTarget || null), i = typeof t > "u" ? void 0 : this.items[t], n = i && i.element;
          return {
            browserEvent: e,
            index: t,
            element: n
          };
        }
        toDragEvent(e) {
          const t = this.getItemIndexFromEventTarget(e.target || null), i = typeof t > "u" ? void 0 : this.items[t], n = i && i.element, o = this.getTargetSector(e, t);
          return {
            browserEvent: e,
            index: t,
            element: n,
            sector: o
          };
        }
        onScroll(e) {
          try {
            const t = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight);
            this.render(t, e.scrollTop, e.height, e.scrollLeft, e.scrollWidth), this.supportDynamicHeights && this._rerender(e.scrollTop, e.height, e.inSmoothScrolling);
          } catch (t) {
            throw console.error("Got bad scroll event:", e), t;
          }
        }
        onTouchChange(e) {
          e.preventDefault(), e.stopPropagation(), this.scrollTop -= e.translationY;
        }
        onDragStart(e, t, i) {
          var _a3, _b3;
          if (!i.dataTransfer) return;
          const n = this.dnd.getDragElements(e);
          if (i.dataTransfer.effectAllowed = "copyMove", i.dataTransfer.setData(j6.TEXT, t), i.dataTransfer.setDragImage) {
            let o;
            this.dnd.getDragLabel && (o = this.dnd.getDragLabel(n, i)), typeof o > "u" && (o = String(n.length));
            const r = He(".monaco-drag-image");
            r.textContent = o, ((u) => {
              for (; u && !u.classList.contains("monaco-workbench"); ) u = u.parentElement;
              return u || this.domNode.ownerDocument;
            })(this.domNode).appendChild(r), i.dataTransfer.setDragImage(r, -10, -10), setTimeout(() => r.remove(), 0);
          }
          this.domNode.classList.add("dragging"), this.currentDragData = new e1(n), Vu.CurrentDragAndDropData = new gte(n), (_b3 = (_a3 = this.dnd).onDragStart) == null ? void 0 : _b3.call(_a3, this.currentDragData, i);
        }
        onDragOver(e) {
          var _a3, _b3;
          if (e.browserEvent.preventDefault(), this.onDragLeaveTimeout.dispose(), Vu.CurrentDragAndDropData && Vu.CurrentDragAndDropData.getData() === "vscode-ui" || (this.setupDragAndDropScrollTopAnimation(e.browserEvent), !e.browserEvent.dataTransfer)) return false;
          if (!this.currentDragData) if (Vu.CurrentDragAndDropData) this.currentDragData = Vu.CurrentDragAndDropData;
          else {
            if (!e.browserEvent.dataTransfer.types) return false;
            this.currentDragData = new mte();
          }
          const t = this.dnd.onDragOver(this.currentDragData, e.element, e.index, e.sector, e.browserEvent);
          if (this.canDrop = typeof t == "boolean" ? t : t.accept, !this.canDrop) return this.currentDragFeedback = void 0, this.currentDragFeedbackDisposable.dispose(), false;
          e.browserEvent.dataTransfer.dropEffect = typeof t != "boolean" && ((_a3 = t.effect) == null ? void 0 : _a3.type) === 0 ? "copy" : "move";
          let i;
          typeof t != "boolean" && t.feedback ? i = t.feedback : typeof e.index > "u" ? i = [
            -1
          ] : i = [
            e.index
          ], i = Nh(i).filter((o) => o >= -1 && o < this.length).sort((o, r) => o - r), i = i[0] === -1 ? [
            -1
          ] : i;
          let n = typeof t != "boolean" && t.effect && t.effect.position ? t.effect.position : "drop-target";
          if (pte(this.currentDragFeedback, i) && this.currentDragFeedbackPosition === n) return true;
          if (this.currentDragFeedback = i, this.currentDragFeedbackPosition = n, this.currentDragFeedbackDisposable.dispose(), i[0] === -1) this.domNode.classList.add(n), this.rowsContainer.classList.add(n), this.currentDragFeedbackDisposable = Ze(() => {
            this.domNode.classList.remove(n), this.rowsContainer.classList.remove(n);
          });
          else {
            if (i.length > 1 && n !== "drop-target") throw new Error("Can't use multiple feedbacks with position different than 'over'");
            n === "drop-target-after" && i[0] < this.length - 1 && (i[0] += 1, n = "drop-target-before");
            for (const o of i) {
              const r = this.items[o];
              r.dropTarget = true, (_b3 = r.row) == null ? void 0 : _b3.domNode.classList.add(n);
            }
            this.currentDragFeedbackDisposable = Ze(() => {
              var _a4;
              for (const o of i) {
                const r = this.items[o];
                r.dropTarget = false, (_a4 = r.row) == null ? void 0 : _a4.domNode.classList.remove(n);
              }
            });
          }
          return true;
        }
        onDragLeave(e) {
          var _a3, _b3;
          this.onDragLeaveTimeout.dispose(), this.onDragLeaveTimeout = Vk(() => this.clearDragOverFeedback(), 100, this.disposables), this.currentDragData && ((_b3 = (_a3 = this.dnd).onDragLeave) == null ? void 0 : _b3.call(_a3, this.currentDragData, e.element, e.index, e.browserEvent));
        }
        onDrop(e) {
          if (!this.canDrop) return;
          const t = this.currentDragData;
          this.teardownDragAndDropScrollTopAnimation(), this.clearDragOverFeedback(), this.domNode.classList.remove("dragging"), this.currentDragData = void 0, Vu.CurrentDragAndDropData = void 0, !(!t || !e.browserEvent.dataTransfer) && (e.browserEvent.preventDefault(), t.update(e.browserEvent.dataTransfer), this.dnd.drop(t, e.element, e.index, e.sector, e.browserEvent));
        }
        onDragEnd(e) {
          var _a3, _b3;
          this.canDrop = false, this.teardownDragAndDropScrollTopAnimation(), this.clearDragOverFeedback(), this.domNode.classList.remove("dragging"), this.currentDragData = void 0, Vu.CurrentDragAndDropData = void 0, (_b3 = (_a3 = this.dnd).onDragEnd) == null ? void 0 : _b3.call(_a3, e);
        }
        clearDragOverFeedback() {
          this.currentDragFeedback = void 0, this.currentDragFeedbackPosition = void 0, this.currentDragFeedbackDisposable.dispose(), this.currentDragFeedbackDisposable = he.None;
        }
        setupDragAndDropScrollTopAnimation(e) {
          if (!this.dragOverAnimationDisposable) {
            const t = AK(this.domNode).top;
            this.dragOverAnimationDisposable = KK(Oe(this.domNode), this.animateDragAndDropScrollTop.bind(this, t));
          }
          this.dragOverAnimationStopDisposable.dispose(), this.dragOverAnimationStopDisposable = Vk(() => {
            this.dragOverAnimationDisposable && (this.dragOverAnimationDisposable.dispose(), this.dragOverAnimationDisposable = void 0);
          }, 1e3, this.disposables), this.dragOverMouseY = e.pageY;
        }
        animateDragAndDropScrollTop(e) {
          if (this.dragOverMouseY === void 0) return;
          const t = this.dragOverMouseY - e, i = this.renderHeight - 35;
          t < 35 ? this.scrollTop += Math.max(-14, Math.floor(0.3 * (t - 35))) : t > i && (this.scrollTop += Math.min(14, Math.floor(0.3 * (t - i))));
        }
        teardownDragAndDropScrollTopAnimation() {
          this.dragOverAnimationStopDisposable.dispose(), this.dragOverAnimationDisposable && (this.dragOverAnimationDisposable.dispose(), this.dragOverAnimationDisposable = void 0);
        }
        getTargetSector(e, t) {
          if (t === void 0) return;
          const i = e.offsetY / this.items[t].size, n = Math.floor(i / 0.25);
          return xs(n, 0, 3);
        }
        getItemIndexFromEventTarget(e) {
          const t = this.scrollableElement.getDomNode();
          let i = e;
          for (; (wn(i) || WK(i)) && i !== this.rowsContainer && t.contains(i); ) {
            const n = i.getAttribute("data-index");
            if (n) {
              const o = Number(n);
              if (!isNaN(o)) return o;
            }
            i = i.parentElement;
          }
        }
        getRenderRange(e, t) {
          return {
            start: this.rangeMap.indexAt(e),
            end: this.rangeMap.indexAfter(e + t - 1)
          };
        }
        _rerender(e, t, i) {
          const n = this.getRenderRange(e, t);
          let o, r;
          e === this.elementTop(n.start) ? (o = n.start, r = 0) : n.end - n.start > 1 && (o = n.start + 1, r = this.elementTop(o) - e);
          let a = 0;
          for (; ; ) {
            const l = this.getRenderRange(e, t);
            let u = false;
            for (let d = l.start; d < l.end; d++) {
              const f = this.probeDynamicHeight(d);
              f !== 0 && this.rangeMap.splice(d, 1, [
                this.items[d]
              ]), a += f, u = u || f !== 0;
            }
            if (!u) {
              a !== 0 && this.eventuallyUpdateScrollDimensions();
              const d = Hn.relativeComplement(n, l);
              for (const m of d) for (let _ = m.start; _ < m.end; _++) this.items[_].row && this.removeItemFromDOM(_);
              const f = Hn.relativeComplement(l, n).reverse();
              for (const m of f) for (let _ = m.end - 1; _ >= m.start; _--) this.insertItemInDOM(_);
              for (let m = l.start; m < l.end; m++) this.items[m].row && this.updateItemInDOM(this.items[m], m);
              if (typeof o == "number") {
                const m = this.scrollable.getFutureScrollPosition().scrollTop - e, _ = this.elementTop(o) - r + m;
                this.setScrollTop(_, i);
              }
              this._onDidChangeContentHeight.fire(this.contentHeight);
              return;
            }
          }
        }
        probeDynamicHeight(e) {
          var _a3, _b3, _c2;
          const t = this.items[e];
          if (this.virtualDelegate.getDynamicHeight) {
            const r = this.virtualDelegate.getDynamicHeight(t.element);
            if (r !== null) {
              const a = t.size;
              return t.size = r, t.lastDynamicHeightWidth = this.renderWidth, r - a;
            }
          }
          if (!t.hasDynamicHeight || t.lastDynamicHeightWidth === this.renderWidth || this.virtualDelegate.hasDynamicHeight && !this.virtualDelegate.hasDynamicHeight(t.element)) return 0;
          const i = t.size;
          if (t.row) return t.row.domNode.style.height = "", t.size = t.row.domNode.offsetHeight, t.size === 0 && !an(t.row.domNode, Oe(t.row.domNode).document.body) && console.warn("Measuring item node that is not in DOM! Add ListView to the DOM before measuring row height!", new Error().stack), t.lastDynamicHeightWidth = this.renderWidth, t.size - i;
          const { row: n } = this.cache.alloc(t.templateId);
          n.domNode.style.height = "", this.rowsContainer.appendChild(n.domNode);
          const o = this.renderers.get(t.templateId);
          if (!o) throw new It("Missing renderer for templateId: " + t.templateId);
          return o.renderElement(t.element, e, n.templateData, void 0), t.size = n.domNode.offsetHeight, (_a3 = o.disposeElement) == null ? void 0 : _a3.call(o, t.element, e, n.templateData, void 0), (_c2 = (_b3 = this.virtualDelegate).setDynamicHeight) == null ? void 0 : _c2.call(_b3, t.element, t.size), t.lastDynamicHeightWidth = this.renderWidth, n.domNode.remove(), this.cache.release(n), t.size - i;
        }
        getElementDomId(e) {
          return `${this.domId}_${e}`;
        }
        dispose() {
          var _a3, _b3, _c2;
          for (const e of this.items) if (e.dragStartDisposable.dispose(), e.checkedDisposable.dispose(), e.row) {
            const t = this.renderers.get(e.row.templateId);
            t && ((_a3 = t.disposeElement) == null ? void 0 : _a3.call(t, e.element, -1, e.row.templateData, void 0), t.disposeTemplate(e.row.templateData));
          }
          this.items = [], (_b3 = this.domNode) == null ? void 0 : _b3.remove(), (_c2 = this.dragOverAnimationDisposable) == null ? void 0 : _c2.dispose(), this.disposables.dispose();
        }
      };
      _Cr.InstanceCount = 0;
      let Cr = _Cr;
      Zl([
        Li
      ], Cr.prototype, "onMouseClick", null);
      Zl([
        Li
      ], Cr.prototype, "onMouseDblClick", null);
      Zl([
        Li
      ], Cr.prototype, "onMouseMiddleClick", null);
      Zl([
        Li
      ], Cr.prototype, "onMouseDown", null);
      Zl([
        Li
      ], Cr.prototype, "onMouseOver", null);
      Zl([
        Li
      ], Cr.prototype, "onMouseOut", null);
      Zl([
        Li
      ], Cr.prototype, "onContextMenu", null);
      Zl([
        Li
      ], Cr.prototype, "onTouchStart", null);
      Zl([
        Li
      ], Cr.prototype, "onTap", null);
      var gu = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      };
      class bte {
        constructor(e) {
          this.trait = e, this.renderedElements = [];
        }
        get templateId() {
          return `template:${this.trait.name}`;
        }
        renderTemplate(e) {
          return e;
        }
        renderElement(e, t, i) {
          const n = this.renderedElements.findIndex((o) => o.templateData === i);
          if (n >= 0) {
            const o = this.renderedElements[n];
            this.trait.unrender(i), o.index = t;
          } else {
            const o = {
              index: t,
              templateData: i
            };
            this.renderedElements.push(o);
          }
          this.trait.renderIndex(t, i);
        }
        splice(e, t, i) {
          const n = [];
          for (const o of this.renderedElements) o.index < e ? n.push(o) : o.index >= e + t && n.push({
            index: o.index + i - t,
            templateData: o.templateData
          });
          this.renderedElements = n;
        }
        renderIndexes(e) {
          for (const { index: t, templateData: i } of this.renderedElements) e.indexOf(t) > -1 && this.trait.renderIndex(t, i);
        }
        disposeTemplate(e) {
          const t = this.renderedElements.findIndex((i) => i.templateData === e);
          t < 0 || this.renderedElements.splice(t, 1);
        }
      }
      let Bv = class {
        get name() {
          return this._trait;
        }
        get renderer() {
          return new bte(this);
        }
        constructor(e) {
          this._trait = e, this.indexes = [], this.sortedIndexes = [], this._onChange = new G(), this.onChange = this._onChange.event;
        }
        splice(e, t, i) {
          const n = i.length - t, o = e + t, r = [];
          let a = 0;
          for (; a < this.sortedIndexes.length && this.sortedIndexes[a] < e; ) r.push(this.sortedIndexes[a++]);
          for (let l = 0; l < i.length; l++) i[l] && r.push(l + e);
          for (; a < this.sortedIndexes.length && this.sortedIndexes[a] >= o; ) r.push(this.sortedIndexes[a++] + n);
          this.renderer.splice(e, t, i.length), this._set(r, r);
        }
        renderIndex(e, t) {
          t.classList.toggle(this._trait, this.contains(e));
        }
        unrender(e) {
          e.classList.remove(this._trait);
        }
        set(e, t) {
          return this._set(e, [
            ...e
          ].sort(gP), t);
        }
        _set(e, t, i) {
          const n = this.indexes, o = this.sortedIndexes;
          this.indexes = e, this.sortedIndexes = t;
          const r = qD(o, e);
          return this.renderer.renderIndexes(r), this._onChange.fire({
            indexes: e,
            browserEvent: i
          }), n;
        }
        get() {
          return this.indexes;
        }
        contains(e) {
          return gU(this.sortedIndexes, e, gP) >= 0;
        }
        dispose() {
          On(this._onChange);
        }
      };
      gu([
        Li
      ], Bv.prototype, "renderer", null);
      class vte extends Bv {
        constructor(e) {
          super("selected"), this.setAriaSelected = e;
        }
        renderIndex(e, t) {
          super.renderIndex(e, t), this.setAriaSelected && (this.contains(e) ? t.setAttribute("aria-selected", "true") : t.setAttribute("aria-selected", "false"));
        }
      }
      class ZL {
        constructor(e, t, i) {
          this.trait = e, this.view = t, this.identityProvider = i;
        }
        splice(e, t, i) {
          if (!this.identityProvider) return this.trait.splice(e, t, new Array(i.length).fill(false));
          const n = this.trait.get().map((a) => this.identityProvider.getId(this.view.element(a)).toString());
          if (n.length === 0) return this.trait.splice(e, t, new Array(i.length).fill(false));
          const o = new Set(n), r = i.map((a) => o.has(this.identityProvider.getId(a).toString()));
          this.trait.splice(e, t, r);
        }
      }
      function tu(s) {
        return s.tagName === "INPUT" || s.tagName === "TEXTAREA";
      }
      function t1(s, e) {
        return s.classList.contains(e) ? true : s.classList.contains("monaco-list") || !s.parentElement ? false : t1(s.parentElement, e);
      }
      function rp(s) {
        return t1(s, "monaco-editor");
      }
      function Cte(s) {
        return t1(s, "monaco-custom-toggle");
      }
      function wte(s) {
        return t1(s, "action-item");
      }
      function Lp(s) {
        return t1(s, "monaco-tree-sticky-row");
      }
      function u_(s) {
        return s.classList.contains("monaco-tree-sticky-container");
      }
      function Y6(s) {
        return s.tagName === "A" && s.classList.contains("monaco-button") || s.tagName === "DIV" && s.classList.contains("monaco-button-dropdown") ? true : s.classList.contains("monaco-list") || !s.parentElement ? false : Y6(s.parentElement);
      }
      class Z6 {
        get onKeyDown() {
          return be.chain(this.disposables.add(new ot(this.view.domNode, "keydown")).event, (e) => e.filter((t) => !tu(t.target)).map((t) => new si(t)));
        }
        constructor(e, t, i) {
          this.list = e, this.view = t, this.disposables = new Me(), this.multipleSelectionDisposables = new Me(), this.multipleSelectionSupport = i.multipleSelectionSupport, this.disposables.add(this.onKeyDown((n) => {
            switch (n.keyCode) {
              case 3:
                return this.onEnter(n);
              case 16:
                return this.onUpArrow(n);
              case 18:
                return this.onDownArrow(n);
              case 11:
                return this.onPageUpArrow(n);
              case 12:
                return this.onPageDownArrow(n);
              case 9:
                return this.onEscape(n);
              case 31:
                this.multipleSelectionSupport && (_t ? n.metaKey : n.ctrlKey) && this.onCtrlA(n);
            }
          }));
        }
        updateOptions(e) {
          e.multipleSelectionSupport !== void 0 && (this.multipleSelectionSupport = e.multipleSelectionSupport);
        }
        onEnter(e) {
          e.preventDefault(), e.stopPropagation(), this.list.setSelection(this.list.getFocus(), e.browserEvent);
        }
        onUpArrow(e) {
          e.preventDefault(), e.stopPropagation(), this.list.focusPrevious(1, false, e.browserEvent);
          const t = this.list.getFocus()[0];
          this.list.setAnchor(t), this.list.reveal(t), this.view.domNode.focus();
        }
        onDownArrow(e) {
          e.preventDefault(), e.stopPropagation(), this.list.focusNext(1, false, e.browserEvent);
          const t = this.list.getFocus()[0];
          this.list.setAnchor(t), this.list.reveal(t), this.view.domNode.focus();
        }
        onPageUpArrow(e) {
          e.preventDefault(), e.stopPropagation(), this.list.focusPreviousPage(e.browserEvent);
          const t = this.list.getFocus()[0];
          this.list.setAnchor(t), this.list.reveal(t), this.view.domNode.focus();
        }
        onPageDownArrow(e) {
          e.preventDefault(), e.stopPropagation(), this.list.focusNextPage(e.browserEvent);
          const t = this.list.getFocus()[0];
          this.list.setAnchor(t), this.list.reveal(t), this.view.domNode.focus();
        }
        onCtrlA(e) {
          e.preventDefault(), e.stopPropagation(), this.list.setSelection(Ls(this.list.length), e.browserEvent), this.list.setAnchor(void 0), this.view.domNode.focus();
        }
        onEscape(e) {
          this.list.getSelection().length && (e.preventDefault(), e.stopPropagation(), this.list.setSelection([], e.browserEvent), this.list.setAnchor(void 0), this.view.domNode.focus());
        }
        dispose() {
          this.disposables.dispose(), this.multipleSelectionDisposables.dispose();
        }
      }
      gu([
        Li
      ], Z6.prototype, "onKeyDown", null);
      var xa;
      (function(s) {
        s[s.Automatic = 0] = "Automatic", s[s.Trigger = 1] = "Trigger";
      })(xa || (xa = {}));
      var Cf;
      (function(s) {
        s[s.Idle = 0] = "Idle", s[s.Typing = 1] = "Typing";
      })(Cf || (Cf = {}));
      const yte = new class {
        mightProducePrintableCharacter(s) {
          return s.ctrlKey || s.metaKey || s.altKey ? false : s.keyCode >= 31 && s.keyCode <= 56 || s.keyCode >= 21 && s.keyCode <= 30 || s.keyCode >= 98 && s.keyCode <= 107 || s.keyCode >= 85 && s.keyCode <= 95;
        }
      }();
      class Ste {
        constructor(e, t, i, n, o) {
          this.list = e, this.view = t, this.keyboardNavigationLabelProvider = i, this.keyboardNavigationEventFilter = n, this.delegate = o, this.enabled = false, this.state = Cf.Idle, this.mode = xa.Automatic, this.triggered = false, this.previouslyFocused = -1, this.enabledDisposables = new Me(), this.disposables = new Me(), this.updateOptions(e.options);
        }
        updateOptions(e) {
          e.typeNavigationEnabled ?? true ? this.enable() : this.disable(), this.mode = e.typeNavigationMode ?? xa.Automatic;
        }
        enable() {
          if (this.enabled) return;
          let e = false;
          const t = be.chain(this.enabledDisposables.add(new ot(this.view.domNode, "keydown")).event, (o) => o.filter((r) => !tu(r.target)).filter(() => this.mode === xa.Automatic || this.triggered).map((r) => new si(r)).filter((r) => e || this.keyboardNavigationEventFilter(r)).filter((r) => this.delegate.mightProducePrintableCharacter(r)).forEach((r) => dt.stop(r, true)).map((r) => r.browserEvent.key)), i = be.debounce(t, () => null, 800, void 0, void 0, void 0, this.enabledDisposables);
          be.reduce(be.any(t, i), (o, r) => r === null ? null : (o || "") + r, void 0, this.enabledDisposables)(this.onInput, this, this.enabledDisposables), i(this.onClear, this, this.enabledDisposables), t(() => e = true, void 0, this.enabledDisposables), i(() => e = false, void 0, this.enabledDisposables), this.enabled = true, this.triggered = false;
        }
        disable() {
          this.enabled && (this.enabledDisposables.clear(), this.enabled = false, this.triggered = false);
        }
        onClear() {
          var _a3;
          const e = this.list.getFocus();
          if (e.length > 0 && e[0] === this.previouslyFocused) {
            const t = (_a3 = this.list.options.accessibilityProvider) == null ? void 0 : _a3.getAriaLabel(this.list.element(e[0]));
            typeof t == "string" ? l_(t) : t && l_(t.get());
          }
          this.previouslyFocused = -1;
        }
        onInput(e) {
          if (!e) {
            this.state = Cf.Idle, this.triggered = false;
            return;
          }
          const t = this.list.getFocus(), i = t.length > 0 ? t[0] : 0, n = this.state === Cf.Idle ? 1 : 0;
          this.state = Cf.Typing;
          for (let o = 0; o < this.list.length; o++) {
            const r = (i + o + n) % this.list.length, a = this.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(this.view.element(r)), l = a && a.toString();
            if (this.list.options.typeNavigationEnabled) {
              if (typeof l < "u") {
                if (xv(e, l)) {
                  this.previouslyFocused = i, this.list.setFocus([
                    r
                  ]), this.list.reveal(r);
                  return;
                }
                const u = qX(e, l);
                if (u && u[0].end - u[0].start > 1 && u.length === 1) {
                  this.previouslyFocused = i, this.list.setFocus([
                    r
                  ]), this.list.reveal(r);
                  return;
                }
              }
            } else if (typeof l > "u" || xv(e, l)) {
              this.previouslyFocused = i, this.list.setFocus([
                r
              ]), this.list.reveal(r);
              return;
            }
          }
        }
        dispose() {
          this.disable(), this.enabledDisposables.dispose(), this.disposables.dispose();
        }
      }
      class Lte {
        constructor(e, t) {
          this.list = e, this.view = t, this.disposables = new Me();
          const i = be.chain(this.disposables.add(new ot(t.domNode, "keydown")).event, (o) => o.filter((r) => !tu(r.target)).map((r) => new si(r)));
          be.chain(i, (o) => o.filter((r) => r.keyCode === 2 && !r.ctrlKey && !r.metaKey && !r.shiftKey && !r.altKey))(this.onTab, this, this.disposables);
        }
        onTab(e) {
          if (e.target !== this.view.domNode) return;
          const t = this.list.getFocus();
          if (t.length === 0) return;
          const i = this.view.domElement(t[0]);
          if (!i) return;
          const n = i.querySelector("[tabIndex]");
          if (!n || !wn(n) || n.tabIndex === -1) return;
          const o = Oe(n).getComputedStyle(n);
          o.visibility === "hidden" || o.display === "none" || (e.preventDefault(), e.stopPropagation(), n.focus());
        }
        dispose() {
          this.disposables.dispose();
        }
      }
      function Q6(s) {
        return _t ? s.browserEvent.metaKey : s.browserEvent.ctrlKey;
      }
      function X6(s) {
        return s.browserEvent.shiftKey;
      }
      function xte(s) {
        return cT(s) && s.button === 2;
      }
      const fP = {
        isSelectionSingleChangeEvent: Q6,
        isSelectionRangeChangeEvent: X6
      };
      class J6 {
        constructor(e) {
          this.list = e, this.disposables = new Me(), this._onPointer = new G(), this.onPointer = this._onPointer.event, e.options.multipleSelectionSupport !== false && (this.multipleSelectionController = this.list.options.multipleSelectionController || fP), this.mouseSupport = typeof e.options.mouseSupport > "u" || !!e.options.mouseSupport, this.mouseSupport && (e.onMouseDown(this.onMouseDown, this, this.disposables), e.onContextMenu(this.onContextMenu, this, this.disposables), e.onMouseDblClick(this.onDoubleClick, this, this.disposables), e.onTouchStart(this.onMouseDown, this, this.disposables), this.disposables.add(ui.addTarget(e.getHTMLElement()))), be.any(e.onMouseClick, e.onMouseMiddleClick, e.onTap)(this.onViewPointer, this, this.disposables);
        }
        updateOptions(e) {
          e.multipleSelectionSupport !== void 0 && (this.multipleSelectionController = void 0, e.multipleSelectionSupport && (this.multipleSelectionController = this.list.options.multipleSelectionController || fP));
        }
        isSelectionSingleChangeEvent(e) {
          return this.multipleSelectionController ? this.multipleSelectionController.isSelectionSingleChangeEvent(e) : false;
        }
        isSelectionRangeChangeEvent(e) {
          return this.multipleSelectionController ? this.multipleSelectionController.isSelectionRangeChangeEvent(e) : false;
        }
        isSelectionChangeEvent(e) {
          return this.isSelectionSingleChangeEvent(e) || this.isSelectionRangeChangeEvent(e);
        }
        onMouseDown(e) {
          rp(e.browserEvent.target) || ss() !== e.browserEvent.target && this.list.domFocus();
        }
        onContextMenu(e) {
          if (tu(e.browserEvent.target) || rp(e.browserEvent.target)) return;
          const t = typeof e.index > "u" ? [] : [
            e.index
          ];
          this.list.setFocus(t, e.browserEvent);
        }
        onViewPointer(e) {
          if (!this.mouseSupport || tu(e.browserEvent.target) || rp(e.browserEvent.target) || e.browserEvent.isHandledByList) return;
          e.browserEvent.isHandledByList = true;
          const t = e.index;
          if (typeof t > "u") {
            this.list.setFocus([], e.browserEvent), this.list.setSelection([], e.browserEvent), this.list.setAnchor(void 0);
            return;
          }
          if (this.isSelectionChangeEvent(e)) return this.changeSelection(e);
          this.list.setFocus([
            t
          ], e.browserEvent), this.list.setAnchor(t), xte(e.browserEvent) || this.list.setSelection([
            t
          ], e.browserEvent), this._onPointer.fire(e);
        }
        onDoubleClick(e) {
          if (tu(e.browserEvent.target) || rp(e.browserEvent.target) || this.isSelectionChangeEvent(e) || e.browserEvent.isHandledByList) return;
          e.browserEvent.isHandledByList = true;
          const t = this.list.getFocus();
          this.list.setSelection(t, e.browserEvent);
        }
        changeSelection(e) {
          const t = e.index;
          let i = this.list.getAnchor();
          if (this.isSelectionRangeChangeEvent(e)) {
            typeof i > "u" && (i = this.list.getFocus()[0] ?? t, this.list.setAnchor(i));
            const n = Math.min(i, t), o = Math.max(i, t), r = Ls(n, o + 1), a = this.list.getSelection(), l = Ete(qD(a, [
              i
            ]), i);
            if (l.length === 0) return;
            const u = qD(r, Tte(a, l));
            this.list.setSelection(u, e.browserEvent), this.list.setFocus([
              t
            ], e.browserEvent);
          } else if (this.isSelectionSingleChangeEvent(e)) {
            const n = this.list.getSelection(), o = n.filter((r) => r !== t);
            this.list.setFocus([
              t
            ]), this.list.setAnchor(t), n.length === o.length ? this.list.setSelection([
              ...o,
              t
            ], e.browserEvent) : this.list.setSelection(o, e.browserEvent);
          }
        }
        dispose() {
          this.disposables.dispose();
        }
      }
      class eB {
        constructor(e, t) {
          this.styleElement = e, this.selectorSuffix = t;
        }
        style(e) {
          const t = this.selectorSuffix && `.${this.selectorSuffix}`, i = [];
          e.listBackground && i.push(`.monaco-list${t} .monaco-list-rows { background: ${e.listBackground}; }`), e.listFocusBackground && (i.push(`.monaco-list${t}:focus .monaco-list-row.focused { background-color: ${e.listFocusBackground}; }`), i.push(`.monaco-list${t}:focus .monaco-list-row.focused:hover { background-color: ${e.listFocusBackground}; }`)), e.listFocusForeground && i.push(`.monaco-list${t}:focus .monaco-list-row.focused { color: ${e.listFocusForeground}; }`), e.listActiveSelectionBackground && (i.push(`.monaco-list${t}:focus .monaco-list-row.selected { background-color: ${e.listActiveSelectionBackground}; }`), i.push(`.monaco-list${t}:focus .monaco-list-row.selected:hover { background-color: ${e.listActiveSelectionBackground}; }`)), e.listActiveSelectionForeground && i.push(`.monaco-list${t}:focus .monaco-list-row.selected { color: ${e.listActiveSelectionForeground}; }`), e.listActiveSelectionIconForeground && i.push(`.monaco-list${t}:focus .monaco-list-row.selected .codicon { color: ${e.listActiveSelectionIconForeground}; }`), e.listFocusAndSelectionBackground && i.push(`
				.monaco-drag-image,
				.monaco-list${t}:focus .monaco-list-row.selected.focused { background-color: ${e.listFocusAndSelectionBackground}; }
			`), e.listFocusAndSelectionForeground && i.push(`
				.monaco-drag-image,
				.monaco-list${t}:focus .monaco-list-row.selected.focused { color: ${e.listFocusAndSelectionForeground}; }
			`), e.listInactiveFocusForeground && (i.push(`.monaco-list${t} .monaco-list-row.focused { color:  ${e.listInactiveFocusForeground}; }`), i.push(`.monaco-list${t} .monaco-list-row.focused:hover { color:  ${e.listInactiveFocusForeground}; }`)), e.listInactiveSelectionIconForeground && i.push(`.monaco-list${t} .monaco-list-row.focused .codicon { color:  ${e.listInactiveSelectionIconForeground}; }`), e.listInactiveFocusBackground && (i.push(`.monaco-list${t} .monaco-list-row.focused { background-color:  ${e.listInactiveFocusBackground}; }`), i.push(`.monaco-list${t} .monaco-list-row.focused:hover { background-color:  ${e.listInactiveFocusBackground}; }`)), e.listInactiveSelectionBackground && (i.push(`.monaco-list${t} .monaco-list-row.selected { background-color:  ${e.listInactiveSelectionBackground}; }`), i.push(`.monaco-list${t} .monaco-list-row.selected:hover { background-color:  ${e.listInactiveSelectionBackground}; }`)), e.listInactiveSelectionForeground && i.push(`.monaco-list${t} .monaco-list-row.selected { color: ${e.listInactiveSelectionForeground}; }`), e.listHoverBackground && i.push(`.monaco-list${t}:not(.drop-target):not(.dragging) .monaco-list-row:hover:not(.selected):not(.focused) { background-color: ${e.listHoverBackground}; }`), e.listHoverForeground && i.push(`.monaco-list${t}:not(.drop-target):not(.dragging) .monaco-list-row:hover:not(.selected):not(.focused) { color:  ${e.listHoverForeground}; }`);
          const n = Pl(e.listFocusAndSelectionOutline, Pl(e.listSelectionOutline, e.listFocusOutline ?? ""));
          n && i.push(`.monaco-list${t}:focus .monaco-list-row.focused.selected { outline: 1px solid ${n}; outline-offset: -1px;}`), e.listFocusOutline && i.push(`
				.monaco-drag-image,
				.monaco-list${t}:focus .monaco-list-row.focused { outline: 1px solid ${e.listFocusOutline}; outline-offset: -1px; }
				.monaco-workbench.context-menu-visible .monaco-list${t}.last-focused .monaco-list-row.focused { outline: 1px solid ${e.listFocusOutline}; outline-offset: -1px; }
			`);
          const o = Pl(e.listSelectionOutline, e.listInactiveFocusOutline ?? "");
          o && i.push(`.monaco-list${t} .monaco-list-row.focused.selected { outline: 1px dotted ${o}; outline-offset: -1px; }`), e.listSelectionOutline && i.push(`.monaco-list${t} .monaco-list-row.selected { outline: 1px dotted ${e.listSelectionOutline}; outline-offset: -1px; }`), e.listInactiveFocusOutline && i.push(`.monaco-list${t} .monaco-list-row.focused { outline: 1px dotted ${e.listInactiveFocusOutline}; outline-offset: -1px; }`), e.listHoverOutline && i.push(`.monaco-list${t} .monaco-list-row:hover { outline: 1px dashed ${e.listHoverOutline}; outline-offset: -1px; }`), e.listDropOverBackground && i.push(`
				.monaco-list${t}.drop-target,
				.monaco-list${t} .monaco-list-rows.drop-target,
				.monaco-list${t} .monaco-list-row.drop-target { background-color: ${e.listDropOverBackground} !important; color: inherit !important; }
			`), e.listDropBetweenBackground && (i.push(`
			.monaco-list${t} .monaco-list-rows.drop-target-before .monaco-list-row:first-child::before,
			.monaco-list${t} .monaco-list-row.drop-target-before::before {
				content: ""; position: absolute; top: 0px; left: 0px; width: 100%; height: 1px;
				background-color: ${e.listDropBetweenBackground};
			}`), i.push(`
			.monaco-list${t} .monaco-list-rows.drop-target-after .monaco-list-row:last-child::after,
			.monaco-list${t} .monaco-list-row.drop-target-after::after {
				content: ""; position: absolute; bottom: 0px; left: 0px; width: 100%; height: 1px;
				background-color: ${e.listDropBetweenBackground};
			}`)), e.tableColumnsBorder && i.push(`
				.monaco-table > .monaco-split-view2,
				.monaco-table > .monaco-split-view2 .monaco-sash.vertical::before,
				.monaco-workbench:not(.reduce-motion) .monaco-table:hover > .monaco-split-view2,
				.monaco-workbench:not(.reduce-motion) .monaco-table:hover > .monaco-split-view2 .monaco-sash.vertical::before {
					border-color: ${e.tableColumnsBorder};
				}

				.monaco-workbench:not(.reduce-motion) .monaco-table > .monaco-split-view2,
				.monaco-workbench:not(.reduce-motion) .monaco-table > .monaco-split-view2 .monaco-sash.vertical::before {
					border-color: transparent;
				}
			`), e.tableOddRowsBackgroundColor && i.push(`
				.monaco-table .monaco-list-row[data-parity=odd]:not(.focused):not(.selected):not(:hover) .monaco-table-tr,
				.monaco-table .monaco-list:not(:focus) .monaco-list-row[data-parity=odd].focused:not(.selected):not(:hover) .monaco-table-tr,
				.monaco-table .monaco-list:not(.focused) .monaco-list-row[data-parity=odd].focused:not(.selected):not(:hover) .monaco-table-tr {
					background-color: ${e.tableOddRowsBackgroundColor};
				}
			`), this.styleElement.textContent = i.join(`
`);
        }
      }
      const kte = {
        listFocusBackground: "#7FB0D0",
        listActiveSelectionBackground: "#0E639C",
        listActiveSelectionForeground: "#FFFFFF",
        listActiveSelectionIconForeground: "#FFFFFF",
        listFocusAndSelectionOutline: "#90C2F9",
        listFocusAndSelectionBackground: "#094771",
        listFocusAndSelectionForeground: "#FFFFFF",
        listInactiveSelectionBackground: "#3F3F46",
        listInactiveSelectionIconForeground: "#FFFFFF",
        listHoverBackground: "#2A2D2E",
        listDropOverBackground: "#383B3D",
        listDropBetweenBackground: "#EEEEEE",
        treeIndentGuidesStroke: "#a9a9a9",
        treeInactiveIndentGuidesStroke: le.fromHex("#a9a9a9").transparent(0.4).toString(),
        tableColumnsBorder: le.fromHex("#cccccc").transparent(0.2).toString(),
        tableOddRowsBackgroundColor: le.fromHex("#cccccc").transparent(0.04).toString(),
        listBackground: void 0,
        listFocusForeground: void 0,
        listInactiveSelectionForeground: void 0,
        listInactiveFocusForeground: void 0,
        listInactiveFocusBackground: void 0,
        listHoverForeground: void 0,
        listFocusOutline: void 0,
        listInactiveFocusOutline: void 0,
        listSelectionOutline: void 0,
        listHoverOutline: void 0,
        treeStickyScrollBackground: void 0,
        treeStickyScrollBorder: void 0,
        treeStickyScrollShadow: void 0
      }, Dte = {
        keyboardSupport: true,
        mouseSupport: true,
        multipleSelectionSupport: true,
        dnd: {
          getDragURI() {
            return null;
          },
          onDragStart() {
          },
          onDragOver() {
            return false;
          },
          drop() {
          },
          dispose() {
          }
        }
      };
      function Ete(s, e) {
        const t = s.indexOf(e);
        if (t === -1) return [];
        const i = [];
        let n = t - 1;
        for (; n >= 0 && s[n] === e - (t - n); ) i.push(s[n--]);
        for (i.reverse(), n = t; n < s.length && s[n] === e + (n - t); ) i.push(s[n++]);
        return i;
      }
      function qD(s, e) {
        const t = [];
        let i = 0, n = 0;
        for (; i < s.length || n < e.length; ) if (i >= s.length) t.push(e[n++]);
        else if (n >= e.length) t.push(s[i++]);
        else if (s[i] === e[n]) {
          t.push(s[i]), i++, n++;
          continue;
        } else s[i] < e[n] ? t.push(s[i++]) : t.push(e[n++]);
        return t;
      }
      function Tte(s, e) {
        const t = [];
        let i = 0, n = 0;
        for (; i < s.length || n < e.length; ) if (i >= s.length) t.push(e[n++]);
        else if (n >= e.length) t.push(s[i++]);
        else if (s[i] === e[n]) {
          i++, n++;
          continue;
        } else s[i] < e[n] ? t.push(s[i++]) : n++;
        return t;
      }
      const gP = (s, e) => s - e;
      class Nte {
        constructor(e, t) {
          this._templateId = e, this.renderers = t;
        }
        get templateId() {
          return this._templateId;
        }
        renderTemplate(e) {
          return this.renderers.map((t) => t.renderTemplate(e));
        }
        renderElement(e, t, i, n) {
          let o = 0;
          for (const r of this.renderers) r.renderElement(e, t, i[o++], n);
        }
        disposeElement(e, t, i, n) {
          var _a3;
          let o = 0;
          for (const r of this.renderers) (_a3 = r.disposeElement) == null ? void 0 : _a3.call(r, e, t, i[o], n), o += 1;
        }
        disposeTemplate(e) {
          let t = 0;
          for (const i of this.renderers) i.disposeTemplate(e[t++]);
        }
      }
      class Ite {
        constructor(e) {
          this.accessibilityProvider = e, this.templateId = "a18n";
        }
        renderTemplate(e) {
          return {
            container: e,
            disposables: new Me()
          };
        }
        renderElement(e, t, i) {
          const n = this.accessibilityProvider.getAriaLabel(e), o = n && typeof n != "string" ? n : Ov(n);
          i.disposables.add(Dt((a) => {
            this.setAriaLabel(a.readObservable(o), i.container);
          }));
          const r = this.accessibilityProvider.getAriaLevel && this.accessibilityProvider.getAriaLevel(e);
          typeof r == "number" ? i.container.setAttribute("aria-level", `${r}`) : i.container.removeAttribute("aria-level");
        }
        setAriaLabel(e, t) {
          e ? t.setAttribute("aria-label", e) : t.removeAttribute("aria-label");
        }
        disposeElement(e, t, i, n) {
          i.disposables.clear();
        }
        disposeTemplate(e) {
          e.disposables.dispose();
        }
      }
      class Mte {
        constructor(e, t) {
          this.list = e, this.dnd = t;
        }
        getDragElements(e) {
          const t = this.list.getSelectedElements();
          return t.indexOf(e) > -1 ? t : [
            e
          ];
        }
        getDragURI(e) {
          return this.dnd.getDragURI(e);
        }
        getDragLabel(e, t) {
          if (this.dnd.getDragLabel) return this.dnd.getDragLabel(e, t);
        }
        onDragStart(e, t) {
          var _a3, _b3;
          (_b3 = (_a3 = this.dnd).onDragStart) == null ? void 0 : _b3.call(_a3, e, t);
        }
        onDragOver(e, t, i, n, o) {
          return this.dnd.onDragOver(e, t, i, n, o);
        }
        onDragLeave(e, t, i, n) {
          var _a3, _b3;
          (_b3 = (_a3 = this.dnd).onDragLeave) == null ? void 0 : _b3.call(_a3, e, t, i, n);
        }
        onDragEnd(e) {
          var _a3, _b3;
          (_b3 = (_a3 = this.dnd).onDragEnd) == null ? void 0 : _b3.call(_a3, e);
        }
        drop(e, t, i, n, o) {
          this.dnd.drop(e, t, i, n, o);
        }
        dispose() {
          this.dnd.dispose();
        }
      }
      class ta {
        get onDidChangeFocus() {
          return be.map(this.eventBufferer.wrapEvent(this.focus.onChange), (e) => this.toListEvent(e), this.disposables);
        }
        get onDidChangeSelection() {
          return be.map(this.eventBufferer.wrapEvent(this.selection.onChange), (e) => this.toListEvent(e), this.disposables);
        }
        get domId() {
          return this.view.domId;
        }
        get onDidScroll() {
          return this.view.onDidScroll;
        }
        get onMouseClick() {
          return this.view.onMouseClick;
        }
        get onMouseDblClick() {
          return this.view.onMouseDblClick;
        }
        get onMouseMiddleClick() {
          return this.view.onMouseMiddleClick;
        }
        get onPointer() {
          return this.mouseController.onPointer;
        }
        get onMouseDown() {
          return this.view.onMouseDown;
        }
        get onMouseOver() {
          return this.view.onMouseOver;
        }
        get onMouseOut() {
          return this.view.onMouseOut;
        }
        get onTouchStart() {
          return this.view.onTouchStart;
        }
        get onTap() {
          return this.view.onTap;
        }
        get onContextMenu() {
          let e = false;
          const t = be.chain(this.disposables.add(new ot(this.view.domNode, "keydown")).event, (o) => o.map((r) => new si(r)).filter((r) => e = r.keyCode === 58 || r.shiftKey && r.keyCode === 68).map((r) => dt.stop(r, true)).filter(() => false)), i = be.chain(this.disposables.add(new ot(this.view.domNode, "keyup")).event, (o) => o.forEach(() => e = false).map((r) => new si(r)).filter((r) => r.keyCode === 58 || r.shiftKey && r.keyCode === 68).map((r) => dt.stop(r, true)).map(({ browserEvent: r }) => {
            const a = this.getFocus(), l = a.length ? a[0] : void 0, u = typeof l < "u" ? this.view.element(l) : void 0, d = typeof l < "u" ? this.view.domElement(l) : this.view.domNode;
            return {
              index: l,
              element: u,
              anchor: d,
              browserEvent: r
            };
          })), n = be.chain(this.view.onContextMenu, (o) => o.filter((r) => !e).map(({ element: r, index: a, browserEvent: l }) => ({
            element: r,
            index: a,
            anchor: new Vr(Oe(this.view.domNode), l),
            browserEvent: l
          })));
          return be.any(t, i, n);
        }
        get onKeyDown() {
          return this.disposables.add(new ot(this.view.domNode, "keydown")).event;
        }
        get onDidFocus() {
          return be.signal(this.disposables.add(new ot(this.view.domNode, "focus", true)).event);
        }
        get onDidBlur() {
          return be.signal(this.disposables.add(new ot(this.view.domNode, "blur", true)).event);
        }
        constructor(e, t, i, n, o = Dte) {
          var _a3, _b3, _c2;
          this.user = e, this._options = o, this.focus = new Bv("focused"), this.anchor = new Bv("anchor"), this.eventBufferer = new B_(), this._ariaLabel = "", this.disposables = new Me(), this._onDidDispose = new G(), this.onDidDispose = this._onDidDispose.event;
          const r = this._options.accessibilityProvider && this._options.accessibilityProvider.getWidgetRole ? (_a3 = this._options.accessibilityProvider) == null ? void 0 : _a3.getWidgetRole() : "list";
          this.selection = new vte(r !== "listbox");
          const a = [
            this.focus.renderer,
            this.selection.renderer
          ];
          this.accessibilityProvider = o.accessibilityProvider, this.accessibilityProvider && (a.push(new Ite(this.accessibilityProvider)), (_c2 = (_b3 = this.accessibilityProvider).onDidChangeActiveDescendant) == null ? void 0 : _c2.call(_b3, this.onDidChangeActiveDescendant, this, this.disposables)), n = n.map((u) => new Nte(u.templateId, [
            ...a,
            u
          ]));
          const l = {
            ...o,
            dnd: o.dnd && new Mte(this, o.dnd)
          };
          if (this.view = this.createListView(t, i, n, l), this.view.domNode.setAttribute("role", r), o.styleController) this.styleController = o.styleController(this.view.domId);
          else {
            const u = Uo(this.view.domNode);
            this.styleController = new eB(u, this.view.domId);
          }
          if (this.spliceable = new cte([
            new ZL(this.focus, this.view, o.identityProvider),
            new ZL(this.selection, this.view, o.identityProvider),
            new ZL(this.anchor, this.view, o.identityProvider),
            this.view
          ]), this.disposables.add(this.focus), this.disposables.add(this.selection), this.disposables.add(this.anchor), this.disposables.add(this.view), this.disposables.add(this._onDidDispose), this.disposables.add(new Lte(this, this.view)), (typeof o.keyboardSupport != "boolean" || o.keyboardSupport) && (this.keyboardController = new Z6(this, this.view, o), this.disposables.add(this.keyboardController)), o.keyboardNavigationLabelProvider) {
            const u = o.keyboardNavigationDelegate || yte;
            this.typeNavigationController = new Ste(this, this.view, o.keyboardNavigationLabelProvider, o.keyboardNavigationEventFilter ?? (() => true), u), this.disposables.add(this.typeNavigationController);
          }
          this.mouseController = this.createMouseController(o), this.disposables.add(this.mouseController), this.onDidChangeFocus(this._onFocusChange, this, this.disposables), this.onDidChangeSelection(this._onSelectionChange, this, this.disposables), this.accessibilityProvider && (this.ariaLabel = this.accessibilityProvider.getWidgetAriaLabel()), this._options.multipleSelectionSupport !== false && this.view.domNode.setAttribute("aria-multiselectable", "true");
        }
        createListView(e, t, i, n) {
          return new Cr(e, t, i, n);
        }
        createMouseController(e) {
          return new J6(this);
        }
        updateOptions(e = {}) {
          var _a3, _b3;
          this._options = {
            ...this._options,
            ...e
          }, (_a3 = this.typeNavigationController) == null ? void 0 : _a3.updateOptions(this._options), this._options.multipleSelectionController !== void 0 && (this._options.multipleSelectionSupport ? this.view.domNode.setAttribute("aria-multiselectable", "true") : this.view.domNode.removeAttribute("aria-multiselectable")), this.mouseController.updateOptions(e), (_b3 = this.keyboardController) == null ? void 0 : _b3.updateOptions(e), this.view.updateOptions(e);
        }
        get options() {
          return this._options;
        }
        splice(e, t, i = []) {
          if (e < 0 || e > this.view.length) throw new Fu(this.user, `Invalid start index: ${e}`);
          if (t < 0) throw new Fu(this.user, `Invalid delete count: ${t}`);
          t === 0 && i.length === 0 || this.eventBufferer.bufferEvents(() => this.spliceable.splice(e, t, i));
        }
        rerender() {
          this.view.rerender();
        }
        element(e) {
          return this.view.element(e);
        }
        indexOf(e) {
          return this.view.indexOf(e);
        }
        indexAt(e) {
          return this.view.indexAt(e);
        }
        get length() {
          return this.view.length;
        }
        get contentHeight() {
          return this.view.contentHeight;
        }
        get onDidChangeContentHeight() {
          return this.view.onDidChangeContentHeight;
        }
        get scrollTop() {
          return this.view.getScrollTop();
        }
        set scrollTop(e) {
          this.view.setScrollTop(e);
        }
        get scrollHeight() {
          return this.view.scrollHeight;
        }
        get renderHeight() {
          return this.view.renderHeight;
        }
        get firstVisibleIndex() {
          return this.view.firstVisibleIndex;
        }
        get ariaLabel() {
          return this._ariaLabel;
        }
        set ariaLabel(e) {
          this._ariaLabel = e, this.view.domNode.setAttribute("aria-label", e);
        }
        domFocus() {
          this.view.domNode.focus({
            preventScroll: true
          });
        }
        layout(e, t) {
          this.view.layout(e, t);
        }
        setSelection(e, t) {
          for (const i of e) if (i < 0 || i >= this.length) throw new Fu(this.user, `Invalid index ${i}`);
          this.selection.set(e, t);
        }
        getSelection() {
          return this.selection.get();
        }
        getSelectedElements() {
          return this.getSelection().map((e) => this.view.element(e));
        }
        setAnchor(e) {
          if (typeof e > "u") {
            this.anchor.set([]);
            return;
          }
          if (e < 0 || e >= this.length) throw new Fu(this.user, `Invalid index ${e}`);
          this.anchor.set([
            e
          ]);
        }
        getAnchor() {
          return IE(this.anchor.get(), void 0);
        }
        getAnchorElement() {
          const e = this.getAnchor();
          return typeof e > "u" ? void 0 : this.element(e);
        }
        setFocus(e, t) {
          for (const i of e) if (i < 0 || i >= this.length) throw new Fu(this.user, `Invalid index ${i}`);
          this.focus.set(e, t);
        }
        focusNext(e = 1, t = false, i, n) {
          if (this.length === 0) return;
          const o = this.focus.get(), r = this.findNextIndex(o.length > 0 ? o[0] + e : 0, t, n);
          r > -1 && this.setFocus([
            r
          ], i);
        }
        focusPrevious(e = 1, t = false, i, n) {
          if (this.length === 0) return;
          const o = this.focus.get(), r = this.findPreviousIndex(o.length > 0 ? o[0] - e : 0, t, n);
          r > -1 && this.setFocus([
            r
          ], i);
        }
        async focusNextPage(e, t) {
          let i = this.view.indexAt(this.view.getScrollTop() + this.view.renderHeight);
          i = i === 0 ? 0 : i - 1;
          const n = this.getFocus()[0];
          if (n !== i && (n === void 0 || i > n)) {
            const o = this.findPreviousIndex(i, false, t);
            o > -1 && n !== o ? this.setFocus([
              o
            ], e) : this.setFocus([
              i
            ], e);
          } else {
            const o = this.view.getScrollTop();
            let r = o + this.view.renderHeight;
            i > n && (r -= this.view.elementHeight(i)), this.view.setScrollTop(r), this.view.getScrollTop() !== o && (this.setFocus([]), await Zp(0), await this.focusNextPage(e, t));
          }
        }
        async focusPreviousPage(e, t, i = () => 0) {
          let n;
          const o = i(), r = this.view.getScrollTop() + o;
          r === 0 ? n = this.view.indexAt(r) : n = this.view.indexAfter(r - 1);
          const a = this.getFocus()[0];
          if (a !== n && (a === void 0 || a >= n)) {
            const l = this.findNextIndex(n, false, t);
            l > -1 && a !== l ? this.setFocus([
              l
            ], e) : this.setFocus([
              n
            ], e);
          } else {
            const l = r;
            this.view.setScrollTop(r - this.view.renderHeight - o), this.view.getScrollTop() + i() !== l && (this.setFocus([]), await Zp(0), await this.focusPreviousPage(e, t, i));
          }
        }
        focusLast(e, t) {
          if (this.length === 0) return;
          const i = this.findPreviousIndex(this.length - 1, false, t);
          i > -1 && this.setFocus([
            i
          ], e);
        }
        focusFirst(e, t) {
          this.focusNth(0, e, t);
        }
        focusNth(e, t, i) {
          if (this.length === 0) return;
          const n = this.findNextIndex(e, false, i);
          n > -1 && this.setFocus([
            n
          ], t);
        }
        findNextIndex(e, t = false, i) {
          for (let n = 0; n < this.length; n++) {
            if (e >= this.length && !t) return -1;
            if (e = e % this.length, !i || i(this.element(e))) return e;
            e++;
          }
          return -1;
        }
        findPreviousIndex(e, t = false, i) {
          for (let n = 0; n < this.length; n++) {
            if (e < 0 && !t) return -1;
            if (e = (this.length + e % this.length) % this.length, !i || i(this.element(e))) return e;
            e--;
          }
          return -1;
        }
        getFocus() {
          return this.focus.get();
        }
        getFocusedElements() {
          return this.getFocus().map((e) => this.view.element(e));
        }
        reveal(e, t, i = 0) {
          if (e < 0 || e >= this.length) throw new Fu(this.user, `Invalid index ${e}`);
          const n = this.view.getScrollTop(), o = this.view.elementTop(e), r = this.view.elementHeight(e);
          if (wg(t)) {
            const a = r - this.view.renderHeight + i;
            this.view.setScrollTop(a * xs(t, 0, 1) + o - i);
          } else {
            const a = o + r, l = n + this.view.renderHeight;
            o < n + i && a >= l || (o < n + i || a >= l && r >= this.view.renderHeight ? this.view.setScrollTop(o - i) : a >= l && this.view.setScrollTop(a - this.view.renderHeight));
          }
        }
        getRelativeTop(e, t = 0) {
          if (e < 0 || e >= this.length) throw new Fu(this.user, `Invalid index ${e}`);
          const i = this.view.getScrollTop(), n = this.view.elementTop(e), o = this.view.elementHeight(e);
          if (n < i + t || n + o > i + this.view.renderHeight) return null;
          const r = o - this.view.renderHeight + t;
          return Math.abs((i + t - n) / r);
        }
        getHTMLElement() {
          return this.view.domNode;
        }
        getScrollableElement() {
          return this.view.scrollableElementDomNode;
        }
        getElementID(e) {
          return this.view.getElementDomId(e);
        }
        getElementTop(e) {
          return this.view.elementTop(e);
        }
        style(e) {
          this.styleController.style(e);
        }
        toListEvent({ indexes: e, browserEvent: t }) {
          return {
            indexes: e,
            elements: e.map((i) => this.view.element(i)),
            browserEvent: t
          };
        }
        _onFocusChange() {
          const e = this.focus.get();
          this.view.domNode.classList.toggle("element-focused", e.length > 0), this.onDidChangeActiveDescendant();
        }
        onDidChangeActiveDescendant() {
          var _a3;
          const e = this.focus.get();
          if (e.length > 0) {
            let t;
            ((_a3 = this.accessibilityProvider) == null ? void 0 : _a3.getActiveDescendantId) && (t = this.accessibilityProvider.getActiveDescendantId(this.view.element(e[0]))), this.view.domNode.setAttribute("aria-activedescendant", t || this.view.getElementDomId(e[0]));
          } else this.view.domNode.removeAttribute("aria-activedescendant");
        }
        _onSelectionChange() {
          const e = this.selection.get();
          this.view.domNode.classList.toggle("selection-none", e.length === 0), this.view.domNode.classList.toggle("selection-single", e.length === 1), this.view.domNode.classList.toggle("selection-multiple", e.length > 1);
        }
        dispose() {
          this._onDidDispose.fire(), this.disposables.dispose(), this._onDidDispose.dispose();
        }
      }
      gu([
        Li
      ], ta.prototype, "onDidChangeFocus", null);
      gu([
        Li
      ], ta.prototype, "onDidChangeSelection", null);
      gu([
        Li
      ], ta.prototype, "onContextMenu", null);
      gu([
        Li
      ], ta.prototype, "onKeyDown", null);
      gu([
        Li
      ], ta.prototype, "onDidFocus", null);
      gu([
        Li
      ], ta.prototype, "onDidBlur", null);
      const mh = He, tB = "selectOption.entry.template";
      class Ate {
        get templateId() {
          return tB;
        }
        renderTemplate(e) {
          const t = /* @__PURE__ */ Object.create(null);
          return t.root = e, t.text = Ne(e, mh(".option-text")), t.detail = Ne(e, mh(".option-detail")), t.decoratorRight = Ne(e, mh(".option-decorator-right")), t;
        }
        renderElement(e, t, i) {
          const n = i, o = e.text, r = e.detail, a = e.decoratorRight, l = e.isDisabled;
          n.text.textContent = o, n.detail.textContent = r || "", n.decoratorRight.innerText = a || "", l ? n.root.classList.add("option-disabled") : n.root.classList.remove("option-disabled");
        }
        disposeTemplate(e) {
        }
      }
      const _ih = class _ih extends he {
        constructor(e, t, i, n, o) {
          super(), this.options = [], this._currentSelection = 0, this._hasDetails = false, this._skipLayout = false, this._sticky = false, this._isVisible = false, this.styles = n, this.selectBoxOptions = o || /* @__PURE__ */ Object.create(null), typeof this.selectBoxOptions.minBottomMargin != "number" ? this.selectBoxOptions.minBottomMargin = _ih.DEFAULT_DROPDOWN_MINIMUM_BOTTOM_MARGIN : this.selectBoxOptions.minBottomMargin < 0 && (this.selectBoxOptions.minBottomMargin = 0), this.selectElement = document.createElement("select"), this.selectElement.className = "monaco-select-box monaco-select-box-dropdown-padding", typeof this.selectBoxOptions.ariaLabel == "string" && this.selectElement.setAttribute("aria-label", this.selectBoxOptions.ariaLabel), typeof this.selectBoxOptions.ariaDescription == "string" && this.selectElement.setAttribute("aria-description", this.selectBoxOptions.ariaDescription), this._onDidSelect = new G(), this._register(this._onDidSelect), this.registerListeners(), this.constructSelectDropDown(i), this.selected = t || 0, e && this.setOptions(e, t), this.initStyleSheet();
        }
        setTitle(e) {
          !this._hover && e ? this._hover = this._register(Ba().setupManagedHover($o("mouse"), this.selectElement, e)) : this._hover && this._hover.update(e);
        }
        getHeight() {
          return 22;
        }
        getTemplateId() {
          return tB;
        }
        constructSelectDropDown(e) {
          this.contextViewProvider = e, this.selectDropDownContainer = He(".monaco-select-box-dropdown-container"), this.selectDropDownContainer.classList.add("monaco-select-box-dropdown-padding"), this.selectionDetailsPane = Ne(this.selectDropDownContainer, mh(".select-box-details-pane"));
          const t = Ne(this.selectDropDownContainer, mh(".select-box-dropdown-container-width-control")), i = Ne(t, mh(".width-control-div"));
          this.widthControlElement = document.createElement("span"), this.widthControlElement.className = "option-text-width-control", Ne(i, this.widthControlElement), this._dropDownPosition = 0, this.styleElement = Uo(this.selectDropDownContainer), this.selectDropDownContainer.setAttribute("draggable", "true"), this._register(re(this.selectDropDownContainer, Ce.DRAG_START, (n) => {
            dt.stop(n, true);
          }));
        }
        registerListeners() {
          this._register(ln(this.selectElement, "change", (t) => {
            this.selected = t.target.selectedIndex, this._onDidSelect.fire({
              index: t.target.selectedIndex,
              selected: t.target.value
            }), this.options[this.selected] && this.options[this.selected].text && this.setTitle(this.options[this.selected].text);
          })), this._register(re(this.selectElement, Ce.CLICK, (t) => {
            dt.stop(t), this._isVisible ? this.hideSelectDropDown(true) : this.showSelectDropDown();
          })), this._register(re(this.selectElement, Ce.MOUSE_DOWN, (t) => {
            dt.stop(t);
          }));
          let e;
          this._register(re(this.selectElement, "touchstart", (t) => {
            e = this._isVisible;
          })), this._register(re(this.selectElement, "touchend", (t) => {
            dt.stop(t), e ? this.hideSelectDropDown(true) : this.showSelectDropDown();
          })), this._register(re(this.selectElement, Ce.KEY_DOWN, (t) => {
            const i = new si(t);
            let n = false;
            _t ? (i.keyCode === 18 || i.keyCode === 16 || i.keyCode === 10 || i.keyCode === 3) && (n = true) : (i.keyCode === 18 && i.altKey || i.keyCode === 16 && i.altKey || i.keyCode === 10 || i.keyCode === 3) && (n = true), n && (this.showSelectDropDown(), dt.stop(t, true));
          }));
        }
        get onDidSelect() {
          return this._onDidSelect.event;
        }
        setOptions(e, t) {
          Qi(this.options, e) || (this.options = e, this.selectElement.options.length = 0, this._hasDetails = false, this._cachedMaxDetailsHeight = void 0, this.options.forEach((i, n) => {
            this.selectElement.add(this.createOption(i.text, n, i.isDisabled)), typeof i.description == "string" && (this._hasDetails = true);
          })), t !== void 0 && (this.select(t), this._currentSelection = this.selected);
        }
        setOptionsList() {
          var _a3;
          (_a3 = this.selectList) == null ? void 0 : _a3.splice(0, this.selectList.length, this.options);
        }
        select(e) {
          e >= 0 && e < this.options.length ? this.selected = e : e > this.options.length - 1 ? this.select(this.options.length - 1) : this.selected < 0 && (this.selected = 0), this.selectElement.selectedIndex = this.selected, this.options[this.selected] && this.options[this.selected].text && this.setTitle(this.options[this.selected].text);
        }
        focus() {
          this.selectElement && (this.selectElement.tabIndex = 0, this.selectElement.focus());
        }
        blur() {
          this.selectElement && (this.selectElement.tabIndex = -1, this.selectElement.blur());
        }
        setFocusable(e) {
          this.selectElement.tabIndex = e ? 0 : -1;
        }
        render(e) {
          this.container = e, e.classList.add("select-container"), e.appendChild(this.selectElement), this.styleSelectElement();
        }
        initStyleSheet() {
          const e = [];
          this.styles.listFocusBackground && e.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.focused { background-color: ${this.styles.listFocusBackground} !important; }`), this.styles.listFocusForeground && e.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.focused { color: ${this.styles.listFocusForeground} !important; }`), this.styles.decoratorRightForeground && e.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row:not(.focused) .option-decorator-right { color: ${this.styles.decoratorRightForeground}; }`), this.styles.selectBackground && this.styles.selectBorder && this.styles.selectBorder !== this.styles.selectBackground ? (e.push(`.monaco-select-box-dropdown-container { border: 1px solid ${this.styles.selectBorder} } `), e.push(`.monaco-select-box-dropdown-container > .select-box-details-pane.border-top { border-top: 1px solid ${this.styles.selectBorder} } `), e.push(`.monaco-select-box-dropdown-container > .select-box-details-pane.border-bottom { border-bottom: 1px solid ${this.styles.selectBorder} } `)) : this.styles.selectListBorder && (e.push(`.monaco-select-box-dropdown-container > .select-box-details-pane.border-top { border-top: 1px solid ${this.styles.selectListBorder} } `), e.push(`.monaco-select-box-dropdown-container > .select-box-details-pane.border-bottom { border-bottom: 1px solid ${this.styles.selectListBorder} } `)), this.styles.listHoverForeground && e.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row:not(.option-disabled):not(.focused):hover { color: ${this.styles.listHoverForeground} !important; }`), this.styles.listHoverBackground && e.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row:not(.option-disabled):not(.focused):hover { background-color: ${this.styles.listHoverBackground} !important; }`), this.styles.listFocusOutline && e.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.focused { outline: 1.6px dotted ${this.styles.listFocusOutline} !important; outline-offset: -1.6px !important; }`), this.styles.listHoverOutline && e.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row:not(.option-disabled):not(.focused):hover { outline: 1.6px dashed ${this.styles.listHoverOutline} !important; outline-offset: -1.6px !important; }`), e.push(".monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.option-disabled.focused { background-color: transparent !important; color: inherit !important; outline: none !important; }"), e.push(".monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.option-disabled:hover { background-color: transparent !important; color: inherit !important; outline: none !important; }"), this.styleElement.textContent = e.join(`
`);
        }
        styleSelectElement() {
          const e = this.styles.selectBackground ?? "", t = this.styles.selectForeground ?? "", i = this.styles.selectBorder ?? "";
          this.selectElement.style.backgroundColor = e, this.selectElement.style.color = t, this.selectElement.style.borderColor = i;
        }
        styleList() {
          const e = this.styles.selectBackground ?? "", t = Pl(this.styles.selectListBackground, e);
          this.selectDropDownListContainer.style.backgroundColor = t, this.selectionDetailsPane.style.backgroundColor = t;
          const i = this.styles.focusBorder ?? "";
          this.selectDropDownContainer.style.outlineColor = i, this.selectDropDownContainer.style.outlineOffset = "-1px", this.selectList.style(this.styles);
        }
        createOption(e, t, i) {
          const n = document.createElement("option");
          return n.value = e, n.text = e, n.disabled = !!i, n;
        }
        showSelectDropDown() {
          this.selectionDetailsPane.innerText = "", !(!this.contextViewProvider || this._isVisible) && (this.createSelectList(this.selectDropDownContainer), this.setOptionsList(), this.contextViewProvider.showContextView({
            getAnchor: () => this.selectElement,
            render: (e) => this.renderSelectDropDown(e, true),
            layout: () => {
              this.layoutSelectDropDown();
            },
            onHide: () => {
              this.selectDropDownContainer.classList.remove("visible"), this.selectElement.classList.remove("synthetic-focus");
            },
            anchorPosition: this._dropDownPosition
          }, this.selectBoxOptions.optionsAsChildren ? this.container : void 0), this._isVisible = true, this.hideSelectDropDown(false), this.contextViewProvider.showContextView({
            getAnchor: () => this.selectElement,
            render: (e) => this.renderSelectDropDown(e),
            layout: () => this.layoutSelectDropDown(),
            onHide: () => {
              this.selectDropDownContainer.classList.remove("visible"), this.selectElement.classList.remove("synthetic-focus");
            },
            anchorPosition: this._dropDownPosition
          }, this.selectBoxOptions.optionsAsChildren ? this.container : void 0), this._currentSelection = this.selected, this._isVisible = true, this.selectElement.setAttribute("aria-expanded", "true"));
        }
        hideSelectDropDown(e) {
          !this.contextViewProvider || !this._isVisible || (this._isVisible = false, this.selectElement.setAttribute("aria-expanded", "false"), e && this.selectElement.focus(), this.contextViewProvider.hideContextView());
        }
        renderSelectDropDown(e, t) {
          return e.appendChild(this.selectDropDownContainer), this.layoutSelectDropDown(t), {
            dispose: () => {
              this.selectDropDownContainer.remove();
            }
          };
        }
        measureMaxDetailsHeight() {
          let e = 0;
          return this.options.forEach((t, i) => {
            this.updateDetail(i), this.selectionDetailsPane.offsetHeight > e && (e = this.selectionDetailsPane.offsetHeight);
          }), e;
        }
        layoutSelectDropDown(e) {
          if (this._skipLayout) return false;
          if (this.selectList) {
            this.selectDropDownContainer.classList.add("visible");
            const t = Oe(this.selectElement), i = Bo(this.selectElement), n = Oe(this.selectElement).getComputedStyle(this.selectElement), o = parseFloat(n.getPropertyValue("--dropdown-padding-top")) + parseFloat(n.getPropertyValue("--dropdown-padding-bottom")), r = t.innerHeight - i.top - i.height - (this.selectBoxOptions.minBottomMargin || 0), a = i.top - _ih.DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN, l = this.selectElement.offsetWidth, u = this.setWidthControlElement(this.widthControlElement), d = Math.max(u, Math.round(l)).toString() + "px";
            this.selectDropDownContainer.style.width = d, this.selectList.getHTMLElement().style.height = "", this.selectList.layout();
            let f = this.selectList.contentHeight;
            this._hasDetails && this._cachedMaxDetailsHeight === void 0 && (this._cachedMaxDetailsHeight = this.measureMaxDetailsHeight());
            const m = this._hasDetails ? this._cachedMaxDetailsHeight : 0, _ = f + o + m, b = Math.floor((r - o - m) / this.getHeight()), v = Math.floor((a - o - m) / this.getHeight());
            if (e) return i.top + i.height > t.innerHeight - 22 || i.top < _ih.DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN || b < 1 && v < 1 ? false : (b < _ih.DEFAULT_MINIMUM_VISIBLE_OPTIONS && v > b && this.options.length > b ? (this._dropDownPosition = 1, this.selectDropDownListContainer.remove(), this.selectionDetailsPane.remove(), this.selectDropDownContainer.appendChild(this.selectionDetailsPane), this.selectDropDownContainer.appendChild(this.selectDropDownListContainer), this.selectionDetailsPane.classList.remove("border-top"), this.selectionDetailsPane.classList.add("border-bottom")) : (this._dropDownPosition = 0, this.selectDropDownListContainer.remove(), this.selectionDetailsPane.remove(), this.selectDropDownContainer.appendChild(this.selectDropDownListContainer), this.selectDropDownContainer.appendChild(this.selectionDetailsPane), this.selectionDetailsPane.classList.remove("border-bottom"), this.selectionDetailsPane.classList.add("border-top")), true);
            if (i.top + i.height > t.innerHeight - 22 || i.top < _ih.DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN || this._dropDownPosition === 0 && b < 1 || this._dropDownPosition === 1 && v < 1) return this.hideSelectDropDown(true), false;
            if (this._dropDownPosition === 0) {
              if (this._isVisible && b + v < 1) return this.hideSelectDropDown(true), false;
              _ > r && (f = b * this.getHeight());
            } else _ > a && (f = v * this.getHeight());
            return this.selectList.layout(f), this.selectList.domFocus(), this.selectList.length > 0 && (this.selectList.setFocus([
              this.selected || 0
            ]), this.selectList.reveal(this.selectList.getFocus()[0] || 0)), this._hasDetails ? (this.selectList.getHTMLElement().style.height = f + o + "px", this.selectDropDownContainer.style.height = "") : this.selectDropDownContainer.style.height = f + o + "px", this.updateDetail(this.selected), this.selectDropDownContainer.style.width = d, this.selectDropDownListContainer.setAttribute("tabindex", "0"), this.selectElement.classList.add("synthetic-focus"), this.selectDropDownContainer.classList.add("synthetic-focus"), true;
          } else return false;
        }
        setWidthControlElement(e) {
          let t = 0;
          if (e) {
            let i = 0, n = 0;
            this.options.forEach((o, r) => {
              const a = o.detail ? o.detail.length : 0, l = o.decoratorRight ? o.decoratorRight.length : 0, u = o.text.length + a + l;
              u > n && (i = r, n = u);
            }), e.textContent = this.options[i].text + (this.options[i].decoratorRight ? this.options[i].decoratorRight + " " : ""), t = rT(e);
          }
          return t;
        }
        createSelectList(e) {
          if (this.selectList) return;
          this.selectDropDownListContainer = Ne(e, mh(".select-box-dropdown-list-container")), this.listRenderer = new Ate(), this.selectList = this._register(new ta("SelectBoxCustom", this.selectDropDownListContainer, this, [
            this.listRenderer
          ], {
            useShadows: false,
            verticalScrollMode: 3,
            keyboardSupport: false,
            mouseSupport: false,
            accessibilityProvider: {
              getAriaLabel: (n) => {
                let o = n.text;
                return n.detail && (o += `. ${n.detail}`), n.decoratorRight && (o += `. ${n.decoratorRight}`), n.description && (o += `. ${n.description}`), o;
              },
              getWidgetAriaLabel: () => C({
                key: "selectBox",
                comment: [
                  "Behave like native select dropdown element."
                ]
              }, "Select Box"),
              getRole: () => _t ? "" : "option",
              getWidgetRole: () => "listbox"
            }
          })), this.selectBoxOptions.ariaLabel && (this.selectList.ariaLabel = this.selectBoxOptions.ariaLabel);
          const t = this._register(new ot(this.selectDropDownListContainer, "keydown")), i = be.chain(t.event, (n) => n.filter(() => this.selectList.length > 0).map((o) => new si(o)));
          this._register(be.chain(i, (n) => n.filter((o) => o.keyCode === 3))(this.onEnter, this)), this._register(be.chain(i, (n) => n.filter((o) => o.keyCode === 2))(this.onEnter, this)), this._register(be.chain(i, (n) => n.filter((o) => o.keyCode === 9))(this.onEscape, this)), this._register(be.chain(i, (n) => n.filter((o) => o.keyCode === 16))(this.onUpArrow, this)), this._register(be.chain(i, (n) => n.filter((o) => o.keyCode === 18))(this.onDownArrow, this)), this._register(be.chain(i, (n) => n.filter((o) => o.keyCode === 12))(this.onPageDown, this)), this._register(be.chain(i, (n) => n.filter((o) => o.keyCode === 11))(this.onPageUp, this)), this._register(be.chain(i, (n) => n.filter((o) => o.keyCode === 14))(this.onHome, this)), this._register(be.chain(i, (n) => n.filter((o) => o.keyCode === 13))(this.onEnd, this)), this._register(be.chain(i, (n) => n.filter((o) => o.keyCode >= 21 && o.keyCode <= 56 || o.keyCode >= 85 && o.keyCode <= 113))(this.onCharacter, this)), this._register(re(this.selectList.getHTMLElement(), Ce.POINTER_UP, (n) => this.onPointerUp(n))), this._register(this.selectList.onMouseOver((n) => typeof n.index < "u" && this.selectList.setFocus([
            n.index
          ]))), this._register(this.selectList.onDidChangeFocus((n) => this.onListFocus(n))), this._register(re(this.selectDropDownContainer, Ce.FOCUS_OUT, (n) => {
            !this._isVisible || an(n.relatedTarget, this.selectDropDownContainer) || this.onListBlur();
          })), this.selectList.getHTMLElement().setAttribute("aria-label", this.selectBoxOptions.ariaLabel || ""), this.selectList.getHTMLElement().setAttribute("aria-expanded", "true"), this.styleList();
        }
        onPointerUp(e) {
          if (!this.selectList.length) return;
          dt.stop(e);
          const t = e.target;
          if (!t || t.classList.contains("slider")) return;
          const i = t.closest(".monaco-list-row");
          if (!i) return;
          const n = Number(i.getAttribute("data-index")), o = i.classList.contains("option-disabled");
          n >= 0 && n < this.options.length && !o && (this.selected = n, this.select(this.selected), this.selectList.setFocus([
            this.selected
          ]), this.selectList.reveal(this.selectList.getFocus()[0]), this.selected !== this._currentSelection && (this._currentSelection = this.selected, this._onDidSelect.fire({
            index: this.selectElement.selectedIndex,
            selected: this.options[this.selected].text
          }), this.options[this.selected] && this.options[this.selected].text && this.setTitle(this.options[this.selected].text)), this.hideSelectDropDown(true));
        }
        onListBlur() {
          this._sticky || (this.selected !== this._currentSelection && this.select(this._currentSelection), this.hideSelectDropDown(false));
        }
        renderDescriptionMarkdown(e, t) {
          const i = (o) => {
            for (let r = 0; r < o.childNodes.length; r++) {
              const a = o.childNodes.item(r);
              (a.tagName && a.tagName.toLowerCase()) === "img" ? a.remove() : i(a);
            }
          }, n = $T({
            value: e,
            supportThemeIcons: true
          }, {
            actionHandler: t
          });
          return n.element.classList.add("select-box-description-markdown"), i(n.element), n.element;
        }
        onListFocus(e) {
          !this._isVisible || !this._hasDetails || this.updateDetail(e.indexes[0]);
        }
        updateDetail(e) {
          this.selectionDetailsPane.innerText = "";
          const t = this.options[e], i = (t == null ? void 0 : t.description) ?? "", n = (t == null ? void 0 : t.descriptionIsMarkdown) ?? false;
          if (i) {
            if (n) {
              const o = t.descriptionMarkdownActionHandler;
              this.selectionDetailsPane.appendChild(this.renderDescriptionMarkdown(i, o));
            } else this.selectionDetailsPane.innerText = i;
            this.selectionDetailsPane.style.display = "block";
          } else this.selectionDetailsPane.style.display = "none";
          this._skipLayout = true, this.contextViewProvider.layout(), this._skipLayout = false;
        }
        onEscape(e) {
          dt.stop(e), this.select(this._currentSelection), this.hideSelectDropDown(true);
        }
        onEnter(e) {
          dt.stop(e), this.selected !== this._currentSelection && (this._currentSelection = this.selected, this._onDidSelect.fire({
            index: this.selectElement.selectedIndex,
            selected: this.options[this.selected].text
          }), this.options[this.selected] && this.options[this.selected].text && this.setTitle(this.options[this.selected].text)), this.hideSelectDropDown(true);
        }
        onDownArrow(e) {
          if (this.selected < this.options.length - 1) {
            dt.stop(e, true);
            const t = this.options[this.selected + 1].isDisabled;
            if (t && this.options.length > this.selected + 2) this.selected += 2;
            else {
              if (t) return;
              this.selected++;
            }
            this.select(this.selected), this.selectList.setFocus([
              this.selected
            ]), this.selectList.reveal(this.selectList.getFocus()[0]);
          }
        }
        onUpArrow(e) {
          this.selected > 0 && (dt.stop(e, true), this.options[this.selected - 1].isDisabled && this.selected > 1 ? this.selected -= 2 : this.selected--, this.select(this.selected), this.selectList.setFocus([
            this.selected
          ]), this.selectList.reveal(this.selectList.getFocus()[0]));
        }
        onPageUp(e) {
          dt.stop(e), this.selectList.focusPreviousPage(), setTimeout(() => {
            this.selected = this.selectList.getFocus()[0], this.options[this.selected].isDisabled && this.selected < this.options.length - 1 && (this.selected++, this.selectList.setFocus([
              this.selected
            ])), this.selectList.reveal(this.selected), this.select(this.selected);
          }, 1);
        }
        onPageDown(e) {
          dt.stop(e), this.selectList.focusNextPage(), setTimeout(() => {
            this.selected = this.selectList.getFocus()[0], this.options[this.selected].isDisabled && this.selected > 0 && (this.selected--, this.selectList.setFocus([
              this.selected
            ])), this.selectList.reveal(this.selected), this.select(this.selected);
          }, 1);
        }
        onHome(e) {
          dt.stop(e), !(this.options.length < 2) && (this.selected = 0, this.options[this.selected].isDisabled && this.selected > 1 && this.selected++, this.selectList.setFocus([
            this.selected
          ]), this.selectList.reveal(this.selected), this.select(this.selected));
        }
        onEnd(e) {
          dt.stop(e), !(this.options.length < 2) && (this.selected = this.options.length - 1, this.options[this.selected].isDisabled && this.selected > 1 && this.selected--, this.selectList.setFocus([
            this.selected
          ]), this.selectList.reveal(this.selected), this.select(this.selected));
        }
        onCharacter(e) {
          const t = Ll.toString(e.keyCode);
          let i = -1;
          for (let n = 0; n < this.options.length - 1; n++) if (i = (n + this.selected + 1) % this.options.length, this.options[i].text.charAt(0).toUpperCase() === t && !this.options[i].isDisabled) {
            this.select(i), this.selectList.setFocus([
              i
            ]), this.selectList.reveal(this.selectList.getFocus()[0]), dt.stop(e);
            break;
          }
        }
        dispose() {
          this.hideSelectDropDown(false), super.dispose();
        }
      };
      _ih.DEFAULT_DROPDOWN_MINIMUM_BOTTOM_MARGIN = 32;
      _ih.DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN = 2;
      _ih.DEFAULT_MINIMUM_VISIBLE_OPTIONS = 3;
      let ih = _ih;
      class Rte extends he {
        constructor(e, t, i, n) {
          super(), this.selected = 0, this.selectBoxOptions = n || /* @__PURE__ */ Object.create(null), this.options = [], this.selectElement = document.createElement("select"), this.selectElement.className = "monaco-select-box", typeof this.selectBoxOptions.ariaLabel == "string" && this.selectElement.setAttribute("aria-label", this.selectBoxOptions.ariaLabel), typeof this.selectBoxOptions.ariaDescription == "string" && this.selectElement.setAttribute("aria-description", this.selectBoxOptions.ariaDescription), this._onDidSelect = this._register(new G()), this.styles = i, this.registerListeners(), this.setOptions(e, t);
        }
        registerListeners() {
          this._register(ui.addTarget(this.selectElement)), [
            Qt.Tap
          ].forEach((e) => {
            this._register(re(this.selectElement, e, (t) => {
              this.selectElement.focus();
            }));
          }), this._register(ln(this.selectElement, "click", (e) => {
            dt.stop(e, true);
          })), this._register(ln(this.selectElement, "change", (e) => {
            this.selectElement.title = e.target.value, this._onDidSelect.fire({
              index: e.target.selectedIndex,
              selected: e.target.value
            });
          })), this._register(ln(this.selectElement, "keydown", (e) => {
            let t = false;
            _t ? (e.keyCode === 18 || e.keyCode === 16 || e.keyCode === 10) && (t = true) : (e.keyCode === 18 && e.altKey || e.keyCode === 10 || e.keyCode === 3) && (t = true), t && e.stopPropagation();
          }));
        }
        get onDidSelect() {
          return this._onDidSelect.event;
        }
        setOptions(e, t) {
          (!this.options || !Qi(this.options, e)) && (this.options = e, this.selectElement.options.length = 0, this.options.forEach((i, n) => {
            this.selectElement.add(this.createOption(i.text, n, i.isDisabled));
          })), t !== void 0 && this.select(t);
        }
        select(e) {
          this.options.length === 0 ? this.selected = 0 : e >= 0 && e < this.options.length ? this.selected = e : e > this.options.length - 1 ? this.select(this.options.length - 1) : this.selected < 0 && (this.selected = 0), this.selectElement.selectedIndex = this.selected, this.selected < this.options.length && typeof this.options[this.selected].text == "string" ? this.selectElement.title = this.options[this.selected].text : this.selectElement.title = "";
        }
        focus() {
          this.selectElement && (this.selectElement.tabIndex = 0, this.selectElement.focus());
        }
        blur() {
          this.selectElement && (this.selectElement.tabIndex = -1, this.selectElement.blur());
        }
        setFocusable(e) {
          this.selectElement.tabIndex = e ? 0 : -1;
        }
        render(e) {
          e.classList.add("select-container"), e.appendChild(this.selectElement), this.setOptions(this.options, this.selected), this.applyStyles();
        }
        applyStyles() {
          this.selectElement && (this.selectElement.style.backgroundColor = this.styles.selectBackground ?? "", this.selectElement.style.color = this.styles.selectForeground ?? "", this.selectElement.style.borderColor = this.styles.selectBorder ?? "");
        }
        createOption(e, t, i) {
          const n = document.createElement("option");
          return n.value = e, n.text = e, n.disabled = !!i, n;
        }
      }
      class Ote extends Yl {
        constructor(e, t, i, n, o) {
          super(), _t && !(o == null ? void 0 : o.useCustomDrawn) ? this.selectBoxDelegate = new Rte(e, t, n, o) : this.selectBoxDelegate = new ih(e, t, i, n, o), this._register(this.selectBoxDelegate);
        }
        get onDidSelect() {
          return this.selectBoxDelegate.onDidSelect;
        }
        setOptions(e, t) {
          this.selectBoxDelegate.setOptions(e, t);
        }
        select(e) {
          this.selectBoxDelegate.select(e);
        }
        focus() {
          this.selectBoxDelegate.focus();
        }
        blur() {
          this.selectBoxDelegate.blur();
        }
        setFocusable(e) {
          this.selectBoxDelegate.setFocusable(e);
        }
        render(e) {
          this.selectBoxDelegate.render(e);
        }
      }
      class Br extends he {
        get action() {
          return this._action;
        }
        constructor(e, t, i = {}) {
          super(), this.options = i, this._context = e || this, this._action = t, t instanceof Bl && this._register(t.onDidChange((n) => {
            this.element && this.handleActionChangeEvent(n);
          }));
        }
        handleActionChangeEvent(e) {
          e.enabled !== void 0 && this.updateEnabled(), e.checked !== void 0 && this.updateChecked(), e.class !== void 0 && this.updateClass(), e.label !== void 0 && (this.updateLabel(), this.updateTooltip()), e.tooltip !== void 0 && this.updateTooltip();
        }
        get actionRunner() {
          return this._actionRunner || (this._actionRunner = this._register(new Rh())), this._actionRunner;
        }
        set actionRunner(e) {
          this._actionRunner = e;
        }
        isEnabled() {
          return this._action.enabled;
        }
        setActionContext(e) {
          this._context = e;
        }
        render(e) {
          const t = this.element = e;
          this._register(ui.addTarget(e));
          const i = this.options && this.options.draggable;
          i && (e.draggable = true, pr && this._register(re(e, Ce.DRAG_START, (n) => {
            var _a3;
            return (_a3 = n.dataTransfer) == null ? void 0 : _a3.setData(j6.TEXT, this._action.label);
          }))), this._register(re(t, Qt.Tap, (n) => this.onClick(n, true))), this._register(re(t, Ce.MOUSE_DOWN, (n) => {
            i || dt.stop(n, true), this._action.enabled && n.button === 0 && t.classList.add("active");
          })), _t && this._register(re(t, Ce.CONTEXT_MENU, (n) => {
            n.button === 0 && n.ctrlKey === true && this.onClick(n);
          })), this._register(re(t, Ce.CLICK, (n) => {
            dt.stop(n, true), this.options && this.options.isMenu || this.onClick(n);
          })), this._register(re(t, Ce.DBLCLICK, (n) => {
            dt.stop(n, true);
          })), [
            Ce.MOUSE_UP,
            Ce.MOUSE_OUT
          ].forEach((n) => {
            this._register(re(t, n, (o) => {
              dt.stop(o), t.classList.remove("active");
            }));
          });
        }
        onClick(e, t = false) {
          var _a3;
          dt.stop(e, true);
          const i = ao(this._context) ? ((_a3 = this.options) == null ? void 0 : _a3.useEventAsContext) ? e : {
            preserveFocus: t
          } : this._context;
          this.actionRunner.run(this._action, i);
        }
        focus() {
          this.element && (this.element.tabIndex = 0, this.element.focus(), this.element.classList.add("focused"));
        }
        blur() {
          this.element && (this.element.blur(), this.element.tabIndex = -1, this.element.classList.remove("focused"));
        }
        setFocusable(e) {
          this.element && (this.element.tabIndex = e ? 0 : -1);
        }
        get trapsArrowNavigation() {
          return false;
        }
        updateEnabled() {
        }
        updateLabel() {
        }
        getClass() {
          return this.action.class;
        }
        getTooltip() {
          return this.action.tooltip;
        }
        updateTooltip() {
          var _a3;
          if (!this.element) return;
          const e = this.getTooltip() ?? "";
          if (this.updateAriaLabel(), (_a3 = this.options.hoverDelegate) == null ? void 0 : _a3.showNativeHover) this.element.title = e;
          else if (!this.customHover && e !== "") {
            const t = this.options.hoverDelegate ?? $o("element");
            this.customHover = this._store.add(Ba().setupManagedHover(t, this.element, e));
          } else this.customHover && this.customHover.update(e);
        }
        updateAriaLabel() {
          if (this.element) {
            const e = this.getTooltip() ?? "";
            this.element.setAttribute("aria-label", e);
          }
        }
        updateClass() {
        }
        updateChecked() {
        }
        dispose() {
          this.element && (this.element.remove(), this.element = void 0), this._context = void 0, super.dispose();
        }
      }
      class nN extends Br {
        constructor(e, t, i) {
          super(e, t, i), this.options = i, this.options.icon = i.icon !== void 0 ? i.icon : false, this.options.label = i.label !== void 0 ? i.label : true, this.cssClass = "";
        }
        render(e) {
          super.render(e), Qc(this.element);
          const t = document.createElement("a");
          if (t.classList.add("action-label"), t.setAttribute("role", this.getDefaultAriaRole()), this.label = t, this.element.appendChild(t), this.options.label && this.options.keybinding) {
            const i = document.createElement("span");
            i.classList.add("keybinding"), i.textContent = this.options.keybinding, this.element.appendChild(i);
          }
          this.updateClass(), this.updateLabel(), this.updateTooltip(), this.updateEnabled(), this.updateChecked();
        }
        getDefaultAriaRole() {
          return this._action.id === $n.ID ? "presentation" : this.options.isMenu ? "menuitem" : this.options.isTabList ? "tab" : "button";
        }
        focus() {
          this.label && (this.label.tabIndex = 0, this.label.focus());
        }
        blur() {
          this.label && (this.label.tabIndex = -1);
        }
        setFocusable(e) {
          this.label && (this.label.tabIndex = e ? 0 : -1);
        }
        updateLabel() {
          this.options.label && this.label && (this.label.textContent = this.action.label);
        }
        getTooltip() {
          let e = null;
          return this.action.tooltip ? e = this.action.tooltip : !this.options.label && this.action.label && this.options.icon && (e = this.action.label, this.options.keybinding && (e = C({
            key: "titleLabel",
            comment: [
              "action title",
              "action keybinding"
            ]
          }, "{0} ({1})", e, this.options.keybinding))), e ?? void 0;
        }
        updateClass() {
          var _a3;
          this.cssClass && this.label && this.label.classList.remove(...this.cssClass.split(" ")), this.options.icon ? (this.cssClass = this.getClass(), this.label && (this.label.classList.add("codicon"), this.cssClass && this.label.classList.add(...this.cssClass.split(" "))), this.updateEnabled()) : (_a3 = this.label) == null ? void 0 : _a3.classList.remove("codicon");
        }
        updateEnabled() {
          var _a3, _b3;
          this.action.enabled ? (this.label && (this.label.removeAttribute("aria-disabled"), this.label.classList.remove("disabled")), (_a3 = this.element) == null ? void 0 : _a3.classList.remove("disabled")) : (this.label && (this.label.setAttribute("aria-disabled", "true"), this.label.classList.add("disabled")), (_b3 = this.element) == null ? void 0 : _b3.classList.add("disabled"));
        }
        updateAriaLabel() {
          if (this.label) {
            const e = this.getTooltip() ?? "";
            this.label.setAttribute("aria-label", e);
          }
        }
        updateChecked() {
          this.label && (this.action.checked !== void 0 ? (this.label.classList.toggle("checked", this.action.checked), this.options.isTabList ? this.label.setAttribute("aria-selected", this.action.checked ? "true" : "false") : (this.label.setAttribute("aria-checked", this.action.checked ? "true" : "false"), this.label.setAttribute("role", "checkbox"))) : (this.label.classList.remove("checked"), this.label.removeAttribute(this.options.isTabList ? "aria-selected" : "aria-checked"), this.label.setAttribute("role", this.getDefaultAriaRole())));
        }
      }
      class Pte extends Br {
        constructor(e, t, i, n, o, r, a) {
          super(e, t), this.selectBox = new Ote(i, n, o, r, a), this.selectBox.setFocusable(false), this._register(this.selectBox), this.registerListeners();
        }
        select(e) {
          this.selectBox.select(e);
        }
        registerListeners() {
          this._register(this.selectBox.onDidSelect((e) => this.runAction(e.selected, e.index)));
        }
        runAction(e, t) {
          this.actionRunner.run(this._action, this.getActionContext(e, t));
        }
        getActionContext(e, t) {
          return e;
        }
        setFocusable(e) {
          this.selectBox.setFocusable(e);
        }
        focus() {
          var _a3;
          (_a3 = this.selectBox) == null ? void 0 : _a3.focus();
        }
        blur() {
          var _a3;
          (_a3 = this.selectBox) == null ? void 0 : _a3.blur();
        }
        render(e) {
          this.selectBox.render(e);
        }
      }
      class Bte extends Rh {
        constructor(e, t) {
          super(), this._onDidChangeVisibility = this._register(new G()), this.onDidChangeVisibility = this._onDidChangeVisibility.event, this._element = Ne(e, He(".monaco-dropdown")), this._label = Ne(this._element, He(".dropdown-label"));
          let i = t.labelRenderer;
          i || (i = (o) => (o.textContent = t.label || "", null));
          for (const o of [
            Ce.CLICK,
            Ce.MOUSE_DOWN,
            Qt.Tap
          ]) this._register(re(this.element, o, (r) => dt.stop(r, true)));
          for (const o of [
            Ce.MOUSE_DOWN,
            Qt.Tap
          ]) this._register(re(this._label, o, (r) => {
            cT(r) && (r.detail > 1 || r.button !== 0) || (this.visible ? this.hide() : this.show());
          }));
          this._register(re(this._label, Ce.KEY_UP, (o) => {
            const r = new si(o);
            (r.equals(3) || r.equals(10)) && (dt.stop(o, true), this.visible ? this.hide() : this.show());
          }));
          const n = i(this._label);
          n && this._register(n), this._register(ui.addTarget(this._label));
        }
        get element() {
          return this._element;
        }
        show() {
          this.visible || (this.visible = true, this._onDidChangeVisibility.fire(true));
        }
        hide() {
          this.visible && (this.visible = false, this._onDidChangeVisibility.fire(false));
        }
        dispose() {
          super.dispose(), this.hide(), this.boxContainer && (this.boxContainer.remove(), this.boxContainer = void 0), this.contents && (this.contents.remove(), this.contents = void 0), this._label && (this._label.remove(), this._label = void 0);
        }
      }
      class Fte extends Bte {
        constructor(e, t) {
          super(e, t), this._options = t, this._actions = [], this.actions = t.actions || [];
        }
        set menuOptions(e) {
          this._menuOptions = e;
        }
        get menuOptions() {
          return this._menuOptions;
        }
        get actions() {
          return this._options.actionProvider ? this._options.actionProvider.getActions() : this._actions;
        }
        set actions(e) {
          this._actions = e;
        }
        show() {
          super.show(), this.element.classList.add("active"), this._options.contextMenuProvider.showContextMenu({
            getAnchor: () => this.element,
            getActions: () => this.actions,
            getActionsContext: () => this.menuOptions ? this.menuOptions.context : null,
            getActionViewItem: (e, t) => this.menuOptions && this.menuOptions.actionViewItemProvider ? this.menuOptions.actionViewItemProvider(e, t) : void 0,
            getKeyBinding: (e) => this.menuOptions && this.menuOptions.getKeyBinding ? this.menuOptions.getKeyBinding(e) : void 0,
            getMenuClassName: () => this._options.menuClassName || "",
            onHide: () => this.onHide(),
            actionRunner: this.menuOptions ? this.menuOptions.actionRunner : void 0,
            anchorAlignment: this.menuOptions ? this.menuOptions.anchorAlignment : 0,
            domForShadowRoot: this._options.menuAsChild ? this.element : void 0,
            skipTelemetry: this._options.skipTelemetry
          });
        }
        hide() {
          super.hide();
        }
        onHide() {
          this.hide(), this.element.classList.remove("active");
        }
      }
      class Fv extends Br {
        constructor(e, t, i, n = /* @__PURE__ */ Object.create(null)) {
          super(null, e, n), this.actionItem = null, this._onDidChangeVisibility = this._register(new G()), this.onDidChangeVisibility = this._onDidChangeVisibility.event, this.menuActionsOrProvider = t, this.contextMenuProvider = i, this.options = n, this.options.actionRunner && (this.actionRunner = this.options.actionRunner);
        }
        render(e) {
          this.actionItem = e;
          const t = (o) => {
            this.element = Ne(o, He("a.action-label"));
            let r = [];
            return typeof this.options.classNames == "string" ? r = this.options.classNames.split(/\s+/g).filter((a) => !!a) : this.options.classNames && (r = this.options.classNames), r.find((a) => a === "icon") || r.push("codicon"), this.element.classList.add(...r), this.element.setAttribute("role", "button"), this.element.setAttribute("aria-haspopup", "true"), this.element.setAttribute("aria-expanded", "false"), this._action.label && this._register(Ba().setupManagedHover(this.options.hoverDelegate ?? $o("mouse"), this.element, this._action.label)), this.element.ariaLabel = this._action.label || "", null;
          }, i = Array.isArray(this.menuActionsOrProvider), n = {
            contextMenuProvider: this.contextMenuProvider,
            labelRenderer: t,
            menuAsChild: this.options.menuAsChild,
            actions: i ? this.menuActionsOrProvider : void 0,
            actionProvider: i ? void 0 : this.menuActionsOrProvider,
            skipTelemetry: this.options.skipTelemetry
          };
          if (this.dropdownMenu = this._register(new Fte(e, n)), this._register(this.dropdownMenu.onDidChangeVisibility((o) => {
            var _a3;
            (_a3 = this.element) == null ? void 0 : _a3.setAttribute("aria-expanded", `${o}`), this._onDidChangeVisibility.fire(o);
          })), this.dropdownMenu.menuOptions = {
            actionViewItemProvider: this.options.actionViewItemProvider,
            actionRunner: this.actionRunner,
            getKeyBinding: this.options.keybindingProvider,
            context: this._context
          }, this.options.anchorAlignmentProvider) {
            const o = this;
            this.dropdownMenu.menuOptions = {
              ...this.dropdownMenu.menuOptions,
              get anchorAlignment() {
                return o.options.anchorAlignmentProvider();
              }
            };
          }
          this.updateTooltip(), this.updateEnabled();
        }
        getTooltip() {
          let e = null;
          return this.action.tooltip ? e = this.action.tooltip : this.action.label && (e = this.action.label), e ?? void 0;
        }
        setActionContext(e) {
          super.setActionContext(e), this.dropdownMenu && (this.dropdownMenu.menuOptions ? this.dropdownMenu.menuOptions.context = e : this.dropdownMenu.menuOptions = {
            context: e
          });
        }
        show() {
          var _a3;
          (_a3 = this.dropdownMenu) == null ? void 0 : _a3.show();
        }
        updateEnabled() {
          var _a3, _b3;
          const e = !this.action.enabled;
          (_a3 = this.actionItem) == null ? void 0 : _a3.classList.toggle("disabled", e), (_b3 = this.element) == null ? void 0 : _b3.classList.toggle("disabled", e);
        }
      }
      function Vte(s) {
        return s ? s.condition !== void 0 : false;
      }
      var Hf;
      (function(s) {
        s[s.STORAGE_DOES_NOT_EXIST = 0] = "STORAGE_DOES_NOT_EXIST", s[s.STORAGE_IN_MEMORY = 1] = "STORAGE_IN_MEMORY";
      })(Hf || (Hf = {}));
      var wf;
      (function(s) {
        s[s.None = 0] = "None", s[s.Initialized = 1] = "Initialized", s[s.Closed = 2] = "Closed";
      })(wf || (wf = {}));
      const _xp = class _xp extends he {
        constructor(e, t = /* @__PURE__ */ Object.create(null)) {
          super(), this.database = e, this.options = t, this._onDidChangeStorage = this._register(new jp()), this.onDidChangeStorage = this._onDidChangeStorage.event, this.state = wf.None, this.cache = /* @__PURE__ */ new Map(), this.flushDelayer = this._register(new R9(_xp.DEFAULT_FLUSH_DELAY)), this.pendingDeletes = /* @__PURE__ */ new Set(), this.pendingInserts = /* @__PURE__ */ new Map(), this.whenFlushedCallbacks = [], this.registerListeners();
        }
        registerListeners() {
          this._register(this.database.onDidChangeItemsExternal((e) => this.onDidChangeItemsExternal(e)));
        }
        onDidChangeItemsExternal(e) {
          var _a3, _b3;
          this._onDidChangeStorage.pause();
          try {
            (_a3 = e.changed) == null ? void 0 : _a3.forEach((t, i) => this.acceptExternal(i, t)), (_b3 = e.deleted) == null ? void 0 : _b3.forEach((t) => this.acceptExternal(t, void 0));
          } finally {
            this._onDidChangeStorage.resume();
          }
        }
        acceptExternal(e, t) {
          if (this.state === wf.Closed) return;
          let i = false;
          ao(t) ? i = this.cache.delete(e) : this.cache.get(e) !== t && (this.cache.set(e, t), i = true), i && this._onDidChangeStorage.fire({
            key: e,
            external: true
          });
        }
        get(e, t) {
          const i = this.cache.get(e);
          return ao(i) ? t : i;
        }
        getBoolean(e, t) {
          const i = this.get(e);
          return ao(i) ? t : i === "true";
        }
        getNumber(e, t) {
          const i = this.get(e);
          return ao(i) ? t : parseInt(i, 10);
        }
        async set(e, t, i = false) {
          if (this.state === wf.Closed) return;
          if (ao(t)) return this.delete(e, i);
          const n = Es(t) || Array.isArray(t) ? gJ(t) : String(t);
          if (this.cache.get(e) !== n) return this.cache.set(e, n), this.pendingInserts.set(e, n), this.pendingDeletes.delete(e), this._onDidChangeStorage.fire({
            key: e,
            external: i
          }), this.doFlush();
        }
        async delete(e, t = false) {
          if (!(this.state === wf.Closed || !this.cache.delete(e))) return this.pendingDeletes.has(e) || this.pendingDeletes.add(e), this.pendingInserts.delete(e), this._onDidChangeStorage.fire({
            key: e,
            external: t
          }), this.doFlush();
        }
        get hasPending() {
          return this.pendingInserts.size > 0 || this.pendingDeletes.size > 0;
        }
        async flushPending() {
          if (!this.hasPending) return;
          const e = {
            insert: this.pendingInserts,
            delete: this.pendingDeletes
          };
          return this.pendingDeletes = /* @__PURE__ */ new Set(), this.pendingInserts = /* @__PURE__ */ new Map(), this.database.updateItems(e).finally(() => {
            var _a3;
            if (!this.hasPending) for (; this.whenFlushedCallbacks.length; ) (_a3 = this.whenFlushedCallbacks.pop()) == null ? void 0 : _a3();
          });
        }
        async doFlush(e) {
          return this.options.hint === Hf.STORAGE_IN_MEMORY ? this.flushPending() : this.flushDelayer.trigger(() => this.flushPending(), e);
        }
      };
      _xp.DEFAULT_FLUSH_DELAY = 100;
      let xp = _xp;
      class QL {
        constructor() {
          this.onDidChangeItemsExternal = be.None, this.items = /* @__PURE__ */ new Map();
        }
        async updateItems(e) {
          var _a3, _b3;
          (_a3 = e.insert) == null ? void 0 : _a3.forEach((t, i) => this.items.set(i, t)), (_b3 = e.delete) == null ? void 0 : _b3.forEach((t) => this.items.delete(t));
        }
      }
      const T0 = "__$__targetStorageMarker", Sw = pt("storageService");
      var mP;
      (function(s) {
        s[s.NONE = 0] = "NONE", s[s.SHUTDOWN = 1] = "SHUTDOWN";
      })(mP || (mP = {}));
      function Wte(s) {
        const e = s.get(T0);
        if (e) try {
          return JSON.parse(e);
        } catch {
        }
        return /* @__PURE__ */ Object.create(null);
      }
      const _sN = class _sN extends he {
        constructor(e = {
          flushInterval: _sN.DEFAULT_FLUSH_INTERVAL
        }) {
          super(), this.options = e, this._onDidChangeValue = this._register(new jp()), this._onDidChangeTarget = this._register(new jp()), this._onWillSaveState = this._register(new G()), this.onWillSaveState = this._onWillSaveState.event, this._workspaceKeyTargets = void 0, this._profileKeyTargets = void 0, this._applicationKeyTargets = void 0;
        }
        onDidChangeValue(e, t, i) {
          return be.filter(this._onDidChangeValue.event, (n) => n.scope === e && (t === void 0 || n.key === t), i);
        }
        emitDidChangeValue(e, t) {
          const { key: i, external: n } = t;
          if (i === T0) {
            switch (e) {
              case -1:
                this._applicationKeyTargets = void 0;
                break;
              case 0:
                this._profileKeyTargets = void 0;
                break;
              case 1:
                this._workspaceKeyTargets = void 0;
                break;
            }
            this._onDidChangeTarget.fire({
              scope: e
            });
          } else this._onDidChangeValue.fire({
            scope: e,
            key: i,
            target: this.getKeyTargets(e)[i],
            external: n
          });
        }
        get(e, t, i) {
          var _a3;
          return (_a3 = this.getStorage(t)) == null ? void 0 : _a3.get(e, i);
        }
        getBoolean(e, t, i) {
          var _a3;
          return (_a3 = this.getStorage(t)) == null ? void 0 : _a3.getBoolean(e, i);
        }
        getNumber(e, t, i) {
          var _a3;
          return (_a3 = this.getStorage(t)) == null ? void 0 : _a3.getNumber(e, i);
        }
        store(e, t, i, n, o = false) {
          if (ao(t)) {
            this.remove(e, i, o);
            return;
          }
          this.withPausedEmitters(() => {
            var _a3;
            this.updateKeyTarget(e, i, n), (_a3 = this.getStorage(i)) == null ? void 0 : _a3.set(e, t, o);
          });
        }
        remove(e, t, i = false) {
          this.withPausedEmitters(() => {
            var _a3;
            this.updateKeyTarget(e, t, void 0), (_a3 = this.getStorage(t)) == null ? void 0 : _a3.delete(e, i);
          });
        }
        withPausedEmitters(e) {
          this._onDidChangeValue.pause(), this._onDidChangeTarget.pause();
          try {
            e();
          } finally {
            this._onDidChangeValue.resume(), this._onDidChangeTarget.resume();
          }
        }
        updateKeyTarget(e, t, i, n = false) {
          var _a3, _b3;
          const o = this.getKeyTargets(t);
          typeof i == "number" ? o[e] !== i && (o[e] = i, (_a3 = this.getStorage(t)) == null ? void 0 : _a3.set(T0, JSON.stringify(o), n)) : typeof o[e] == "number" && (delete o[e], (_b3 = this.getStorage(t)) == null ? void 0 : _b3.set(T0, JSON.stringify(o), n));
        }
        get workspaceKeyTargets() {
          return this._workspaceKeyTargets || (this._workspaceKeyTargets = this.loadKeyTargets(1)), this._workspaceKeyTargets;
        }
        get profileKeyTargets() {
          return this._profileKeyTargets || (this._profileKeyTargets = this.loadKeyTargets(0)), this._profileKeyTargets;
        }
        get applicationKeyTargets() {
          return this._applicationKeyTargets || (this._applicationKeyTargets = this.loadKeyTargets(-1)), this._applicationKeyTargets;
        }
        getKeyTargets(e) {
          switch (e) {
            case -1:
              return this.applicationKeyTargets;
            case 0:
              return this.profileKeyTargets;
            default:
              return this.workspaceKeyTargets;
          }
        }
        loadKeyTargets(e) {
          const t = this.getStorage(e);
          return t ? Wte(t) : /* @__PURE__ */ Object.create(null);
        }
      };
      _sN.DEFAULT_FLUSH_INTERVAL = 60 * 1e3;
      let sN = _sN;
      class Hte extends sN {
        constructor() {
          super(), this.applicationStorage = this._register(new xp(new QL(), {
            hint: Hf.STORAGE_IN_MEMORY
          })), this.profileStorage = this._register(new xp(new QL(), {
            hint: Hf.STORAGE_IN_MEMORY
          })), this.workspaceStorage = this._register(new xp(new QL(), {
            hint: Hf.STORAGE_IN_MEMORY
          })), this._register(this.workspaceStorage.onDidChangeStorage((e) => this.emitDidChangeValue(1, e))), this._register(this.profileStorage.onDidChangeStorage((e) => this.emitDidChangeValue(0, e))), this._register(this.applicationStorage.onDidChangeStorage((e) => this.emitDidChangeValue(-1, e)));
        }
        getStorage(e) {
          switch (e) {
            case -1:
              return this.applicationStorage;
            case 0:
              return this.profileStorage;
            default:
              return this.workspaceStorage;
          }
        }
      }
      function zte(s, e) {
        const t = {
          ...e
        };
        for (const i in s) {
          const n = s[i];
          t[i] = n !== void 0 ? we(n) : void 0;
        }
        return t;
      }
      const Ute = {
        keybindingLabelBackground: we(IQ),
        keybindingLabelForeground: we(MQ),
        keybindingLabelBorder: we(AQ),
        keybindingLabelBottomBorder: we(RQ),
        keybindingLabelShadow: we(Y_)
      }, $te = {
        buttonForeground: we(f6),
        buttonSeparator: we(_Q),
        buttonBackground: we(ip),
        buttonHoverBackground: we(bQ),
        buttonSecondaryForeground: we(CQ),
        buttonSecondaryBackground: we(yD),
        buttonSecondaryHoverBackground: we(wQ),
        buttonBorder: we(vQ)
      }, qte = {
        progressBarBackground: we(RZ)
      }, iB = {
        inputActiveOptionBorder: we(u6),
        inputActiveOptionForeground: we(d6),
        inputActiveOptionBackground: we(h6)
      };
      we(np), we(yQ), we(SQ), we(LQ), we(xQ), we(kQ), we(DQ);
      we(EQ), we(NQ), we(TQ);
      we(hr), we(lw), we(Y_), we(Et), we(GZ), we(YZ), we(ZZ), we(MZ);
      const nB = {
        inputBackground: we(nQ),
        inputForeground: we(sQ),
        inputBorder: we(oQ),
        inputValidationInfoBorder: we(cQ),
        inputValidationInfoBackground: we(aQ),
        inputValidationInfoForeground: we(lQ),
        inputValidationWarningBorder: we(dQ),
        inputValidationWarningBackground: we(uQ),
        inputValidationWarningForeground: we(hQ),
        inputValidationErrorBorder: we(mQ),
        inputValidationErrorBackground: we(fQ),
        inputValidationErrorForeground: we(gQ)
      }, Kte = {
        listFilterWidgetBackground: we(KQ),
        listFilterWidgetOutline: we(jQ),
        listFilterWidgetNoMatchesOutline: we(GQ),
        listFilterWidgetShadow: we(YQ),
        inputBoxStyles: nB,
        toggleStyles: iB
      }, jte = {
        badgeBackground: we(x0),
        badgeForeground: we(AZ),
        badgeBorder: we(Et)
      };
      we(KZ), we(qZ), we(S5), we(S5), we(jZ);
      const Ng = {
        listBackground: void 0,
        listInactiveFocusForeground: void 0,
        listFocusBackground: we(OQ),
        listFocusForeground: we(PQ),
        listFocusOutline: we(BQ),
        listActiveSelectionBackground: we(Fh),
        listActiveSelectionForeground: we(s_),
        listActiveSelectionIconForeground: we(g6),
        listFocusAndSelectionOutline: we(FQ),
        listFocusAndSelectionBackground: we(Fh),
        listFocusAndSelectionForeground: we(s_),
        listInactiveSelectionBackground: we(VQ),
        listInactiveSelectionIconForeground: we(HQ),
        listInactiveSelectionForeground: we(WQ),
        listInactiveFocusBackground: we(zQ),
        listInactiveFocusOutline: we(UQ),
        listHoverBackground: we(m6),
        listHoverForeground: we(p6),
        listDropOverBackground: we($Q),
        listDropBetweenBackground: we(qQ),
        listSelectionOutline: we(Ai),
        listHoverOutline: we(Ai),
        treeIndentGuidesStroke: we(_6),
        treeInactiveIndentGuidesStroke: we(ZQ),
        treeStickyScrollBackground: void 0,
        treeStickyScrollBorder: void 0,
        treeStickyScrollShadow: we(NT),
        tableColumnsBorder: we(QQ),
        tableOddRowsBackgroundColor: we(XQ)
      };
      function i1(s) {
        return zte(s, Ng);
      }
      const Gte = {
        selectBackground: we(cw),
        selectListBackground: we(pQ),
        selectForeground: we(AT),
        decoratorRightForeground: we(b6),
        selectBorder: we(RT),
        focusBorder: we(Na),
        listFocusBackground: we(LD),
        listInactiveSelectionIconForeground: we(v6),
        listFocusForeground: we(SD),
        listFocusOutline: kZ(Ai, le.transparent.toString()),
        listHoverBackground: we(m6),
        listHoverForeground: we(p6),
        listHoverOutline: we(Ai),
        selectListBorder: we(s6),
        listBackground: void 0,
        listActiveSelectionBackground: void 0,
        listActiveSelectionForeground: void 0,
        listActiveSelectionIconForeground: void 0,
        listFocusAndSelectionBackground: void 0,
        listDropOverBackground: void 0,
        listDropBetweenBackground: void 0,
        listInactiveSelectionBackground: void 0,
        listInactiveSelectionForeground: void 0,
        listInactiveFocusBackground: void 0,
        listInactiveFocusOutline: void 0,
        listSelectionOutline: void 0,
        listFocusAndSelectionForeground: void 0,
        listFocusAndSelectionOutline: void 0,
        listInactiveFocusForeground: void 0,
        tableColumnsBorder: void 0,
        tableOddRowsBackgroundColor: void 0,
        treeIndentGuidesStroke: void 0,
        treeInactiveIndentGuidesStroke: void 0,
        treeStickyScrollBackground: void 0,
        treeStickyScrollBorder: void 0,
        treeStickyScrollShadow: void 0
      }, Yte = {
        shadowColor: we(Y_),
        borderColor: we(JQ),
        foregroundColor: we(eX),
        backgroundColor: we(tX),
        selectionForegroundColor: we(iX),
        selectionBackgroundColor: we(nX),
        selectionBorderColor: we(sX),
        separatorColor: we(oX),
        scrollbarShadow: we(NT),
        scrollbarSliderBackground: we(t6),
        scrollbarSliderHoverBackground: we(i6),
        scrollbarSliderActiveBackground: we(n6)
      };
      var Lw = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      }, Ds = function(s, e) {
        return function(t, i) {
          e(t, i, s);
        };
      };
      function Zte(s, e, t, i) {
        let n, o, r;
        if (Array.isArray(s)) r = s, n = e, o = t;
        else {
          const u = e;
          r = s.getActions(u), n = t, o = i;
        }
        const a = Hc.getInstance(), l = a.keyStatus.altKey || (Ks || Is) && a.keyStatus.shiftKey;
        sB(r, n, l, o ? (u) => u === o : (u) => u === "navigation");
      }
      function Qte(s, e, t, i, n, o) {
        let r, a, l, u, d;
        if (Array.isArray(s)) d = s, r = e, a = t, l = i, u = n;
        else {
          const m = e;
          d = s.getActions(m), r = t, a = i, l = n, u = o;
        }
        sB(d, r, false, typeof a == "string" ? (m) => m === a : a, l, u);
      }
      function sB(s, e, t, i = (r) => r === "navigation", n = () => false, o = false) {
        let r, a;
        Array.isArray(e) ? (r = e, a = e) : (r = e.primary, a = e.secondary);
        const l = /* @__PURE__ */ new Set();
        for (const [u, d] of s) {
          let f;
          i(u) ? (f = r, f.length > 0 && o && f.push(new $n())) : (f = a, f.length > 0 && f.push(new $n()));
          for (let m of d) {
            t && (m = m instanceof Fl && m.alt ? m.alt : m);
            const _ = f.push(m);
            m instanceof KC && l.add({
              group: u,
              action: m,
              index: _ - 1
            });
          }
        }
        for (const { group: u, action: d, index: f } of l) {
          const m = i(u) ? r : a, _ = d.actions;
          n(d, u, m.length) && m.splice(f, 1, ..._);
        }
      }
      let h_ = class extends nN {
        constructor(e, t, i, n, o, r, a, l) {
          super(void 0, e, {
            icon: !!(e.class || e.item.icon),
            label: !e.class && !e.item.icon,
            draggable: t == null ? void 0 : t.draggable,
            keybinding: t == null ? void 0 : t.keybinding,
            hoverDelegate: t == null ? void 0 : t.hoverDelegate
          }), this._options = t, this._keybindingService = i, this._notificationService = n, this._contextKeyService = o, this._themeService = r, this._contextMenuService = a, this._accessibilityService = l, this._wantsAltCommand = false, this._itemClassDispose = this._register(new Ul()), this._altKey = Hc.getInstance();
        }
        get _menuItemAction() {
          return this._action;
        }
        get _commandAction() {
          return this._wantsAltCommand && this._menuItemAction.alt || this._menuItemAction;
        }
        async onClick(e) {
          e.preventDefault(), e.stopPropagation();
          try {
            await this.actionRunner.run(this._commandAction, this._context);
          } catch (t) {
            this._notificationService.error(t);
          }
        }
        render(e) {
          if (super.render(e), e.classList.add("menu-entry"), this.options.icon && this._updateItemClass(this._menuItemAction.item), this._menuItemAction.alt) {
            let t = false;
            const i = () => {
              var _a3;
              const n = !!((_a3 = this._menuItemAction.alt) == null ? void 0 : _a3.enabled) && (!this._accessibilityService.isMotionReduced() || t) && (this._altKey.keyStatus.altKey || this._altKey.keyStatus.shiftKey && t);
              n !== this._wantsAltCommand && (this._wantsAltCommand = n, this.updateLabel(), this.updateTooltip(), this.updateClass());
            };
            this._register(this._altKey.event(i)), this._register(re(e, "mouseleave", (n) => {
              t = false, i();
            })), this._register(re(e, "mouseenter", (n) => {
              t = true, i();
            })), i();
          }
        }
        updateLabel() {
          this.options.label && this.label && (this.label.textContent = this._commandAction.label);
        }
        getTooltip() {
          var _a3;
          const e = this._keybindingService.lookupKeybinding(this._commandAction.id, this._contextKeyService), t = e && e.getLabel(), i = this._commandAction.tooltip || this._commandAction.label;
          let n = t ? C("titleAndKb", "{0} ({1})", i, t) : i;
          if (!this._wantsAltCommand && ((_a3 = this._menuItemAction.alt) == null ? void 0 : _a3.enabled)) {
            const o = this._menuItemAction.alt.tooltip || this._menuItemAction.alt.label, r = this._keybindingService.lookupKeybinding(this._menuItemAction.alt.id, this._contextKeyService), a = r && r.getLabel(), l = a ? C("titleAndKb", "{0} ({1})", o, a) : o;
            n = C("titleAndKbAndAlt", `{0}
[{1}] {2}`, n, GT.modifierLabels[ur].altKey, l);
          }
          return n;
        }
        updateClass() {
          this.options.icon && (this._commandAction !== this._menuItemAction ? this._menuItemAction.alt && this._updateItemClass(this._menuItemAction.alt.item) : this._updateItemClass(this._menuItemAction.item));
        }
        _updateItemClass(e) {
          this._itemClassDispose.value = void 0;
          const { element: t, label: i } = this;
          if (!t || !i) return;
          const n = this._commandAction.checked && Vte(e.toggled) && e.toggled.icon ? e.toggled.icon : e.icon;
          if (n) if (wt.isThemeIcon(n)) {
            const o = wt.asClassNameArray(n);
            i.classList.add(...o), this._itemClassDispose.value = Ze(() => {
              i.classList.remove(...o);
            });
          } else i.style.backgroundImage = rw(this._themeService.getColorTheme().type) ? ql(n.dark) : ql(n.light), i.classList.add("icon"), this._itemClassDispose.value = ka(Ze(() => {
            i.style.backgroundImage = "", i.classList.remove("icon");
          }), this._themeService.onDidColorThemeChange(() => {
            this.updateClass();
          }));
        }
      };
      h_ = Lw([
        Ds(2, Pn),
        Ds(3, Jr),
        Ds(4, Mt),
        Ds(5, vr),
        Ds(6, Gl),
        Ds(7, ea)
      ], h_);
      let KD = class extends Fv {
        constructor(e, t, i, n, o) {
          const r = {
            ...t,
            menuAsChild: (t == null ? void 0 : t.menuAsChild) ?? false,
            classNames: (t == null ? void 0 : t.classNames) ?? (wt.isThemeIcon(e.item.icon) ? wt.asClassName(e.item.icon) : void 0),
            keybindingProvider: (t == null ? void 0 : t.keybindingProvider) ?? ((a) => i.lookupKeybinding(a.id))
          };
          super(e, {
            getActions: () => e.actions
          }, n, r), this._keybindingService = i, this._contextMenuService = n, this._themeService = o;
        }
        render(e) {
          super.render(e), Qc(this.element), e.classList.add("menu-entry");
          const t = this._action, { icon: i } = t.item;
          if (i && !wt.isThemeIcon(i)) {
            this.element.classList.add("icon");
            const n = () => {
              this.element && (this.element.style.backgroundImage = rw(this._themeService.getColorTheme().type) ? ql(i.dark) : ql(i.light));
            };
            n(), this._register(this._themeService.onDidColorThemeChange(() => {
              n();
            }));
          }
        }
      };
      KD = Lw([
        Ds(2, Pn),
        Ds(3, Gl),
        Ds(4, vr)
      ], KD);
      let jD = class extends Br {
        constructor(e, t, i, n, o, r, a, l) {
          super(null, e), this._keybindingService = i, this._notificationService = n, this._contextMenuService = o, this._menuService = r, this._instaService = a, this._storageService = l, this._container = null, this._options = t, this._storageKey = `${e.item.submenu.id}_lastActionId`;
          let u;
          const d = (t == null ? void 0 : t.persistLastActionId) ? l.get(this._storageKey, 1) : void 0;
          d && (u = e.actions.find((m) => d === m.id)), u || (u = e.actions[0]), this._defaultAction = this._instaService.createInstance(h_, u, {
            keybinding: this._getDefaultActionKeybindingLabel(u)
          });
          const f = {
            keybindingProvider: (m) => this._keybindingService.lookupKeybinding(m.id),
            ...t,
            menuAsChild: (t == null ? void 0 : t.menuAsChild) ?? true,
            classNames: (t == null ? void 0 : t.classNames) ?? [
              "codicon",
              "codicon-chevron-down"
            ],
            actionRunner: (t == null ? void 0 : t.actionRunner) ?? new Rh()
          };
          this._dropdown = new Fv(e, e.actions, this._contextMenuService, f), this._register(this._dropdown.actionRunner.onDidRun((m) => {
            m.action instanceof Fl && this.update(m.action);
          }));
        }
        update(e) {
          var _a3;
          ((_a3 = this._options) == null ? void 0 : _a3.persistLastActionId) && this._storageService.store(this._storageKey, e.id, 1, 1), this._defaultAction.dispose(), this._defaultAction = this._instaService.createInstance(h_, e, {
            keybinding: this._getDefaultActionKeybindingLabel(e)
          }), this._defaultAction.actionRunner = new class extends Rh {
            async runAction(t, i) {
              await t.run(void 0);
            }
          }(), this._container && this._defaultAction.render(uT(this._container, He(".action-container")));
        }
        _getDefaultActionKeybindingLabel(e) {
          var _a3;
          let t;
          if ((_a3 = this._options) == null ? void 0 : _a3.renderKeybindingWithDefaultActionLabel) {
            const i = this._keybindingService.lookupKeybinding(e.id);
            i && (t = `(${i.getLabel()})`);
          }
          return t;
        }
        setActionContext(e) {
          super.setActionContext(e), this._defaultAction.setActionContext(e), this._dropdown.setActionContext(e);
        }
        render(e) {
          this._container = e, super.render(this._container), this._container.classList.add("monaco-dropdown-with-default");
          const t = He(".action-container");
          this._defaultAction.render(Ne(this._container, t)), this._register(re(t, Ce.KEY_DOWN, (n) => {
            const o = new si(n);
            o.equals(17) && (this._defaultAction.element.tabIndex = -1, this._dropdown.focus(), o.stopPropagation());
          }));
          const i = He(".dropdown-action-container");
          this._dropdown.render(Ne(this._container, i)), this._register(re(i, Ce.KEY_DOWN, (n) => {
            var _a3;
            const o = new si(n);
            o.equals(15) && (this._defaultAction.element.tabIndex = 0, this._dropdown.setFocusable(false), (_a3 = this._defaultAction.element) == null ? void 0 : _a3.focus(), o.stopPropagation());
          }));
        }
        focus(e) {
          e ? this._dropdown.focus() : (this._defaultAction.element.tabIndex = 0, this._defaultAction.element.focus());
        }
        blur() {
          this._defaultAction.element.tabIndex = -1, this._dropdown.blur(), this._container.blur();
        }
        setFocusable(e) {
          e ? this._defaultAction.element.tabIndex = 0 : (this._defaultAction.element.tabIndex = -1, this._dropdown.setFocusable(false));
        }
        dispose() {
          this._defaultAction.dispose(), this._dropdown.dispose(), super.dispose();
        }
      };
      jD = Lw([
        Ds(2, Pn),
        Ds(3, Jr),
        Ds(4, Gl),
        Ds(5, Zh),
        Ds(6, Ft),
        Ds(7, Sw)
      ], jD);
      let GD = class extends Pte {
        constructor(e, t) {
          super(null, e, e.actions.map((i) => ({
            text: i.id === $n.ID ? "\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500" : i.label,
            isDisabled: !i.enabled
          })), 0, t, Gte, {
            ariaLabel: e.tooltip,
            optionsAsChildren: true
          }), this.select(Math.max(0, e.actions.findIndex((i) => i.checked)));
        }
        render(e) {
          super.render(e), e.style.borderColor = we(RT);
        }
        runAction(e, t) {
          const i = this.action.actions[t];
          i && this.actionRunner.run(i);
        }
      };
      GD = Lw([
        Ds(1, Q_)
      ], GD);
      function Xte(s, e, t) {
        return e instanceof Fl ? s.createInstance(h_, e, t) : e instanceof vp ? e.item.isSelection ? s.createInstance(GD, e) : e.item.rememberDefaultAction ? s.createInstance(jD, e, {
          ...t,
          persistLastActionId: true
        }) : s.createInstance(KD, e, t) : void 0;
      }
      class Wl extends he {
        constructor(e, t = {}) {
          var _a3, _b3;
          super(), this._actionRunnerDisposables = this._register(new Me()), this.viewItemDisposables = this._register(new VE()), this.triggerKeyDown = false, this.focusable = true, this._onDidBlur = this._register(new G()), this.onDidBlur = this._onDidBlur.event, this._onDidCancel = this._register(new G({
            onWillAddFirstListener: () => this.cancelHasListener = true
          })), this.onDidCancel = this._onDidCancel.event, this.cancelHasListener = false, this._onDidRun = this._register(new G()), this.onDidRun = this._onDidRun.event, this._onWillRun = this._register(new G()), this.onWillRun = this._onWillRun.event, this.options = t, this._context = t.context ?? null, this._orientation = this.options.orientation ?? 0, this._triggerKeys = {
            keyDown: ((_a3 = this.options.triggerKeys) == null ? void 0 : _a3.keyDown) ?? false,
            keys: ((_b3 = this.options.triggerKeys) == null ? void 0 : _b3.keys) ?? [
              3,
              10
            ]
          }, this._hoverDelegate = t.hoverDelegate ?? this._register(iN()), this.options.actionRunner ? this._actionRunner = this.options.actionRunner : (this._actionRunner = new Rh(), this._actionRunnerDisposables.add(this._actionRunner)), this._actionRunnerDisposables.add(this._actionRunner.onDidRun((o) => this._onDidRun.fire(o))), this._actionRunnerDisposables.add(this._actionRunner.onWillRun((o) => this._onWillRun.fire(o))), this.viewItems = [], this.focusedItem = void 0, this.domNode = document.createElement("div"), this.domNode.className = "monaco-action-bar";
          let i, n;
          switch (this._orientation) {
            case 0:
              i = [
                15
              ], n = [
                17
              ];
              break;
            case 1:
              i = [
                16
              ], n = [
                18
              ], this.domNode.className += " vertical";
              break;
          }
          this._register(re(this.domNode, Ce.KEY_DOWN, (o) => {
            const r = new si(o);
            let a = true;
            const l = typeof this.focusedItem == "number" ? this.viewItems[this.focusedItem] : void 0;
            i && (r.equals(i[0]) || r.equals(i[1])) ? a = this.focusPrevious() : n && (r.equals(n[0]) || r.equals(n[1])) ? a = this.focusNext() : r.equals(9) && this.cancelHasListener ? this._onDidCancel.fire() : r.equals(14) ? a = this.focusFirst() : r.equals(13) ? a = this.focusLast() : r.equals(2) && l instanceof Br && l.trapsArrowNavigation ? a = this.focusNext(void 0, true) : this.isTriggerKeyEvent(r) ? this._triggerKeys.keyDown ? this.doTrigger(r) : this.triggerKeyDown = true : a = false, a && (r.preventDefault(), r.stopPropagation());
          })), this._register(re(this.domNode, Ce.KEY_UP, (o) => {
            const r = new si(o);
            this.isTriggerKeyEvent(r) ? (!this._triggerKeys.keyDown && this.triggerKeyDown && (this.triggerKeyDown = false, this.doTrigger(r)), r.preventDefault(), r.stopPropagation()) : (r.equals(2) || r.equals(1026) || r.equals(16) || r.equals(18) || r.equals(15) || r.equals(17)) && this.updateFocusedItem();
          })), this.focusTracker = this._register(Qp(this.domNode)), this._register(this.focusTracker.onDidBlur(() => {
            (ss() === this.domNode || !an(ss(), this.domNode)) && (this._onDidBlur.fire(), this.previouslyFocusedItem = this.focusedItem, this.focusedItem = void 0, this.triggerKeyDown = false);
          })), this._register(this.focusTracker.onDidFocus(() => this.updateFocusedItem())), this.actionsList = document.createElement("ul"), this.actionsList.className = "actions-container", this.options.highlightToggledItems && this.actionsList.classList.add("highlight-toggled"), this.actionsList.setAttribute("role", this.options.ariaRole || "toolbar"), this.options.ariaLabel && this.actionsList.setAttribute("aria-label", this.options.ariaLabel), this.domNode.appendChild(this.actionsList), e.appendChild(this.domNode);
        }
        refreshRole() {
          this.length() >= 1 ? this.actionsList.setAttribute("role", this.options.ariaRole || "toolbar") : this.actionsList.setAttribute("role", "presentation");
        }
        setFocusable(e) {
          if (this.focusable = e, this.focusable) {
            const t = this.viewItems.find((i) => i instanceof Br && i.isEnabled());
            t instanceof Br && t.setFocusable(true);
          } else this.viewItems.forEach((t) => {
            t instanceof Br && t.setFocusable(false);
          });
        }
        isTriggerKeyEvent(e) {
          let t = false;
          return this._triggerKeys.keys.forEach((i) => {
            t = t || e.equals(i);
          }), t;
        }
        updateFocusedItem() {
          var _a3, _b3;
          for (let e = 0; e < this.actionsList.children.length; e++) {
            const t = this.actionsList.children[e];
            if (an(ss(), t)) {
              this.focusedItem = e, (_b3 = (_a3 = this.viewItems[this.focusedItem]) == null ? void 0 : _a3.showHover) == null ? void 0 : _b3.call(_a3);
              break;
            }
          }
        }
        get context() {
          return this._context;
        }
        set context(e) {
          this._context = e, this.viewItems.forEach((t) => t.setActionContext(e));
        }
        get actionRunner() {
          return this._actionRunner;
        }
        set actionRunner(e) {
          this._actionRunner = e, this._actionRunnerDisposables.clear(), this._actionRunnerDisposables.add(this._actionRunner.onDidRun((t) => this._onDidRun.fire(t))), this._actionRunnerDisposables.add(this._actionRunner.onWillRun((t) => this._onWillRun.fire(t))), this.viewItems.forEach((t) => t.actionRunner = e);
        }
        getContainer() {
          return this.domNode;
        }
        getAction(e) {
          var _a3;
          if (typeof e == "number") return (_a3 = this.viewItems[e]) == null ? void 0 : _a3.action;
          if (wn(e)) {
            for (; e.parentElement !== this.actionsList; ) {
              if (!e.parentElement) return;
              e = e.parentElement;
            }
            for (let t = 0; t < this.actionsList.childNodes.length; t++) if (this.actionsList.childNodes[t] === e) return this.viewItems[t].action;
          }
        }
        push(e, t = {}) {
          const i = Array.isArray(e) ? e : [
            e
          ];
          let n = wg(t.index) ? t.index : null;
          i.forEach((o) => {
            const r = document.createElement("li");
            r.className = "action-item", r.setAttribute("role", "presentation");
            let a;
            const l = {
              hoverDelegate: this._hoverDelegate,
              ...t,
              isTabList: this.options.ariaRole === "tablist"
            };
            this.options.actionViewItemProvider && (a = this.options.actionViewItemProvider(o, l)), a || (a = new nN(this.context, o, l)), this.options.allowContextMenu || this.viewItemDisposables.set(a, re(r, Ce.CONTEXT_MENU, (u) => {
              dt.stop(u, true);
            })), a.actionRunner = this._actionRunner, a.setActionContext(this.context), a.render(r), this.focusable && a instanceof Br && this.viewItems.length === 0 && a.setFocusable(true), n === null || n < 0 || n >= this.actionsList.children.length ? (this.actionsList.appendChild(r), this.viewItems.push(a)) : (this.actionsList.insertBefore(r, this.actionsList.children[n]), this.viewItems.splice(n, 0, a), n++);
          }), typeof this.focusedItem == "number" && this.focus(this.focusedItem), this.refreshRole();
        }
        clear() {
          this.isEmpty() || (this.viewItems = On(this.viewItems), this.viewItemDisposables.clearAndDisposeAll(), $r(this.actionsList), this.refreshRole());
        }
        length() {
          return this.viewItems.length;
        }
        isEmpty() {
          return this.viewItems.length === 0;
        }
        focus(e) {
          let t = false, i;
          if (e === void 0 ? t = true : typeof e == "number" ? i = e : typeof e == "boolean" && (t = e), t && typeof this.focusedItem > "u") {
            const n = this.viewItems.findIndex((o) => o.isEnabled());
            this.focusedItem = n === -1 ? void 0 : n, this.updateFocus(void 0, void 0, true);
          } else i !== void 0 && (this.focusedItem = i), this.updateFocus(void 0, void 0, true);
        }
        focusFirst() {
          return this.focusedItem = this.length() - 1, this.focusNext(true);
        }
        focusLast() {
          return this.focusedItem = 0, this.focusPrevious(true);
        }
        focusNext(e, t) {
          if (typeof this.focusedItem > "u") this.focusedItem = this.viewItems.length - 1;
          else if (this.viewItems.length <= 1) return false;
          const i = this.focusedItem;
          let n;
          do {
            if (!e && this.options.preventLoopNavigation && this.focusedItem + 1 >= this.viewItems.length) return this.focusedItem = i, false;
            this.focusedItem = (this.focusedItem + 1) % this.viewItems.length, n = this.viewItems[this.focusedItem];
          } while (this.focusedItem !== i && (this.options.focusOnlyEnabledItems && !n.isEnabled() || n.action.id === $n.ID));
          return this.updateFocus(void 0, void 0, t), true;
        }
        focusPrevious(e) {
          if (typeof this.focusedItem > "u") this.focusedItem = 0;
          else if (this.viewItems.length <= 1) return false;
          const t = this.focusedItem;
          let i;
          do {
            if (this.focusedItem = this.focusedItem - 1, this.focusedItem < 0) {
              if (!e && this.options.preventLoopNavigation) return this.focusedItem = t, false;
              this.focusedItem = this.viewItems.length - 1;
            }
            i = this.viewItems[this.focusedItem];
          } while (this.focusedItem !== t && (this.options.focusOnlyEnabledItems && !i.isEnabled() || i.action.id === $n.ID));
          return this.updateFocus(true), true;
        }
        updateFocus(e, t, i = false) {
          var _a3, _b3;
          typeof this.focusedItem > "u" && this.actionsList.focus({
            preventScroll: t
          }), this.previouslyFocusedItem !== void 0 && this.previouslyFocusedItem !== this.focusedItem && ((_a3 = this.viewItems[this.previouslyFocusedItem]) == null ? void 0 : _a3.blur());
          const n = this.focusedItem !== void 0 ? this.viewItems[this.focusedItem] : void 0;
          if (n) {
            let o = true;
            $0(n.focus) || (o = false), this.options.focusOnlyEnabledItems && $0(n.isEnabled) && !n.isEnabled() && (o = false), n.action.id === $n.ID && (o = false), o ? (i || this.previouslyFocusedItem !== this.focusedItem) && (n.focus(e), this.previouslyFocusedItem = this.focusedItem) : (this.actionsList.focus({
              preventScroll: t
            }), this.previouslyFocusedItem = void 0), o && ((_b3 = n.showHover) == null ? void 0 : _b3.call(n));
          }
        }
        doTrigger(e) {
          if (typeof this.focusedItem > "u") return;
          const t = this.viewItems[this.focusedItem];
          if (t instanceof Br) {
            const i = t._context === null || t._context === void 0 ? e : t._context;
            this.run(t._action, i);
          }
        }
        async run(e, t) {
          await this._actionRunner.run(e, t);
        }
        dispose() {
          this._context = void 0, this.viewItems = On(this.viewItems), this.getContainer().remove(), super.dispose();
        }
      }
      const YD = /\(&([^\s&])\)|(^|[^&])&([^\s&])/, XL = /(&amp;)?(&amp;)([^\s&])/g;
      var Vv;
      (function(s) {
        s[s.Right = 0] = "Right", s[s.Left = 1] = "Left";
      })(Vv || (Vv = {}));
      var ZD;
      (function(s) {
        s[s.Above = 0] = "Above", s[s.Below = 1] = "Below";
      })(ZD || (ZD = {}));
      class zf extends Wl {
        constructor(e, t, i, n) {
          e.classList.add("monaco-menu-container"), e.setAttribute("role", "presentation");
          const o = document.createElement("div");
          o.classList.add("monaco-menu"), o.setAttribute("role", "presentation"), super(o, {
            orientation: 1,
            actionViewItemProvider: (u) => this.doGetActionViewItem(u, i, r),
            context: i.context,
            actionRunner: i.actionRunner,
            ariaLabel: i.ariaLabel,
            ariaRole: "menu",
            focusOnlyEnabledItems: true,
            triggerKeys: {
              keys: [
                3,
                ..._t || Is ? [
                  10
                ] : []
              ],
              keyDown: true
            }
          }), this.menuStyles = n, this.menuElement = o, this.actionsList.tabIndex = 0, this.initializeOrUpdateStyleSheet(e, n), this._register(ui.addTarget(o)), this._register(re(o, Ce.KEY_DOWN, (u) => {
            new si(u).equals(2) && u.preventDefault();
          })), i.enableMnemonics && this._register(re(o, Ce.KEY_DOWN, (u) => {
            const d = u.key.toLocaleLowerCase();
            if (this.mnemonics.has(d)) {
              dt.stop(u, true);
              const f = this.mnemonics.get(d);
              if (f.length === 1 && (f[0] instanceof pP && f[0].container && this.focusItemByElement(f[0].container), f[0].onClick(u)), f.length > 1) {
                const m = f.shift();
                m && m.container && (this.focusItemByElement(m.container), f.push(m)), this.mnemonics.set(d, f);
              }
            }
          })), Is && this._register(re(o, Ce.KEY_DOWN, (u) => {
            const d = new si(u);
            d.equals(14) || d.equals(11) ? (this.focusedItem = this.viewItems.length - 1, this.focusNext(), dt.stop(u, true)) : (d.equals(13) || d.equals(12)) && (this.focusedItem = 0, this.focusPrevious(), dt.stop(u, true));
          })), this._register(re(this.domNode, Ce.MOUSE_OUT, (u) => {
            const d = u.relatedTarget;
            an(d, this.domNode) || (this.focusedItem = void 0, this.updateFocus(), u.stopPropagation());
          })), this._register(re(this.actionsList, Ce.MOUSE_OVER, (u) => {
            let d = u.target;
            if (!(!d || !an(d, this.actionsList) || d === this.actionsList)) {
              for (; d.parentElement !== this.actionsList && d.parentElement !== null; ) d = d.parentElement;
              if (d.classList.contains("action-item")) {
                const f = this.focusedItem;
                this.setFocusedItem(d), f !== this.focusedItem && this.updateFocus();
              }
            }
          })), this._register(ui.addTarget(this.actionsList)), this._register(re(this.actionsList, Qt.Tap, (u) => {
            let d = u.initialTarget;
            if (!(!d || !an(d, this.actionsList) || d === this.actionsList)) {
              for (; d.parentElement !== this.actionsList && d.parentElement !== null; ) d = d.parentElement;
              if (d.classList.contains("action-item")) {
                const f = this.focusedItem;
                this.setFocusedItem(d), f !== this.focusedItem && this.updateFocus();
              }
            }
          }));
          const r = {
            parent: this
          };
          this.mnemonics = /* @__PURE__ */ new Map(), this.scrollableElement = this._register(new PT(o, {
            alwaysConsumeMouseWheel: true,
            horizontal: 2,
            vertical: 3,
            verticalScrollbarSize: 7,
            handleMouseWheel: true,
            useShadows: true
          }));
          const a = this.scrollableElement.getDomNode();
          a.style.position = "", this.styleScrollElement(a, n), this._register(re(o, Qt.Change, (u) => {
            dt.stop(u, true);
            const d = this.scrollableElement.getScrollPosition().scrollTop;
            this.scrollableElement.setScrollPosition({
              scrollTop: d - u.translationY
            });
          })), this._register(re(a, Ce.MOUSE_UP, (u) => {
            u.preventDefault();
          }));
          const l = Oe(e);
          o.style.maxHeight = `${Math.max(10, l.innerHeight - e.getBoundingClientRect().top - 35)}px`, t = t.filter((u, d) => {
            var _a3;
            return ((_a3 = i.submenuIds) == null ? void 0 : _a3.has(u.id)) ? (console.warn(`Found submenu cycle: ${u.id}`), false) : !(u instanceof $n && (d === t.length - 1 || d === 0 || t[d - 1] instanceof $n));
          }), this.push(t, {
            icon: true,
            label: true,
            isMenu: true
          }), e.appendChild(this.scrollableElement.getDomNode()), this.scrollableElement.scanDomNode(), this.viewItems.filter((u) => !(u instanceof _P)).forEach((u, d, f) => {
            u.updatePositionInSet(d + 1, f.length);
          });
        }
        initializeOrUpdateStyleSheet(e, t) {
          this.styleSheet || (sv(e) ? this.styleSheet = Uo(e) : (zf.globalStyleSheet || (zf.globalStyleSheet = Uo()), this.styleSheet = zf.globalStyleSheet)), this.styleSheet.textContent = eie(t, sv(e));
        }
        styleScrollElement(e, t) {
          const i = t.foregroundColor ?? "", n = t.backgroundColor ?? "", o = t.borderColor ? `1px solid ${t.borderColor}` : "", r = "5px", a = t.shadowColor ? `0 2px 8px ${t.shadowColor}` : "";
          e.style.outline = o, e.style.borderRadius = r, e.style.color = i, e.style.backgroundColor = n, e.style.boxShadow = a;
        }
        getContainer() {
          return this.scrollableElement.getDomNode();
        }
        get onScroll() {
          return this.scrollableElement.onScroll;
        }
        focusItemByElement(e) {
          const t = this.focusedItem;
          this.setFocusedItem(e), t !== this.focusedItem && this.updateFocus();
        }
        setFocusedItem(e) {
          for (let t = 0; t < this.actionsList.children.length; t++) {
            const i = this.actionsList.children[t];
            if (e === i) {
              this.focusedItem = t;
              break;
            }
          }
        }
        updateFocus(e) {
          super.updateFocus(e, true, true), typeof this.focusedItem < "u" && this.scrollableElement.setScrollPosition({
            scrollTop: Math.round(this.menuElement.scrollTop)
          });
        }
        doGetActionViewItem(e, t, i) {
          if (e instanceof $n) return new _P(t.context, e, {
            icon: true
          }, this.menuStyles);
          if (e instanceof KC) {
            const n = new pP(e, e.actions, i, {
              ...t,
              submenuIds: /* @__PURE__ */ new Set([
                ...t.submenuIds || [],
                e.id
              ])
            }, this.menuStyles);
            if (t.enableMnemonics) {
              const o = n.getMnemonic();
              if (o && n.isEnabled()) {
                let r = [];
                this.mnemonics.has(o) && (r = this.mnemonics.get(o)), r.push(n), this.mnemonics.set(o, r);
              }
            }
            return n;
          } else {
            const n = {
              enableMnemonics: t.enableMnemonics,
              useEventAsContext: t.useEventAsContext
            };
            if (t.getKeyBinding) {
              const r = t.getKeyBinding(e);
              if (r) {
                const a = r.getLabel();
                a && (n.keybinding = a);
              }
            }
            const o = new oB(t.context, e, n, this.menuStyles);
            if (t.enableMnemonics) {
              const r = o.getMnemonic();
              if (r && o.isEnabled()) {
                let a = [];
                this.mnemonics.has(r) && (a = this.mnemonics.get(r)), a.push(o), this.mnemonics.set(r, a);
              }
            }
            return o;
          }
        }
      }
      class oB extends Br {
        constructor(e, t, i, n) {
          if (i.isMenu = true, super(t, t, i), this.menuStyle = n, this.options = i, this.options.icon = i.icon !== void 0 ? i.icon : false, this.options.label = i.label !== void 0 ? i.label : true, this.cssClass = "", this.options.label && i.enableMnemonics) {
            const o = this.action.label;
            if (o) {
              const r = YD.exec(o);
              r && (this.mnemonic = (r[1] ? r[1] : r[3]).toLocaleLowerCase());
            }
          }
          this.runOnceToEnableMouseUp = new ns(() => {
            this.element && (this._register(re(this.element, Ce.MOUSE_UP, (o) => {
              if (dt.stop(o, true), pr) {
                if (new Vr(Oe(this.element), o).rightButton) return;
                this.onClick(o);
              } else setTimeout(() => {
                this.onClick(o);
              }, 0);
            })), this._register(re(this.element, Ce.CONTEXT_MENU, (o) => {
              dt.stop(o, true);
            })));
          }, 100), this._register(this.runOnceToEnableMouseUp);
        }
        render(e) {
          super.render(e), this.element && (this.container = e, this.item = Ne(this.element, He("a.action-menu-item")), this._action.id === $n.ID ? this.item.setAttribute("role", "presentation") : (this.item.setAttribute("role", "menuitem"), this.mnemonic && this.item.setAttribute("aria-keyshortcuts", `${this.mnemonic}`)), this.check = Ne(this.item, He("span.menu-item-check" + wt.asCSSSelector(Te.menuSelection))), this.check.setAttribute("role", "none"), this.label = Ne(this.item, He("span.action-label")), this.options.label && this.options.keybinding && (Ne(this.item, He("span.keybinding")).textContent = this.options.keybinding), this.runOnceToEnableMouseUp.schedule(), this.updateClass(), this.updateLabel(), this.updateTooltip(), this.updateEnabled(), this.updateChecked(), this.applyStyle());
        }
        blur() {
          super.blur(), this.applyStyle();
        }
        focus() {
          var _a3;
          super.focus(), (_a3 = this.item) == null ? void 0 : _a3.focus(), this.applyStyle();
        }
        updatePositionInSet(e, t) {
          this.item && (this.item.setAttribute("aria-posinset", `${e}`), this.item.setAttribute("aria-setsize", `${t}`));
        }
        updateLabel() {
          var _a3;
          if (this.label && this.options.label) {
            $r(this.label);
            let e = I6(this.action.label);
            if (e) {
              const t = Jte(e);
              this.options.enableMnemonics || (e = t), this.label.setAttribute("aria-label", t.replace(/&&/g, "&"));
              const i = YD.exec(e);
              if (i) {
                e = mp(e), XL.lastIndex = 0;
                let n = XL.exec(e);
                for (; n && n[1]; ) n = XL.exec(e);
                const o = (r) => r.replace(/&amp;&amp;/g, "&amp;");
                n ? this.label.append(WC(o(e.substr(0, n.index)), " "), He("u", {
                  "aria-hidden": "true"
                }, n[3]), Eq(o(e.substr(n.index + n[0].length)), " ")) : this.label.innerText = o(e).trim(), (_a3 = this.item) == null ? void 0 : _a3.setAttribute("aria-keyshortcuts", (i[1] ? i[1] : i[3]).toLocaleLowerCase());
              } else this.label.innerText = e.replace(/&&/g, "&").trim();
            }
          }
        }
        updateTooltip() {
        }
        updateClass() {
          this.cssClass && this.item && this.item.classList.remove(...this.cssClass.split(" ")), this.options.icon && this.label ? (this.cssClass = this.action.class || "", this.label.classList.add("icon"), this.cssClass && this.label.classList.add(...this.cssClass.split(" ")), this.updateEnabled()) : this.label && this.label.classList.remove("icon");
        }
        updateEnabled() {
          this.action.enabled ? (this.element && (this.element.classList.remove("disabled"), this.element.removeAttribute("aria-disabled")), this.item && (this.item.classList.remove("disabled"), this.item.removeAttribute("aria-disabled"), this.item.tabIndex = 0)) : (this.element && (this.element.classList.add("disabled"), this.element.setAttribute("aria-disabled", "true")), this.item && (this.item.classList.add("disabled"), this.item.setAttribute("aria-disabled", "true")));
        }
        updateChecked() {
          if (!this.item) return;
          const e = this.action.checked;
          this.item.classList.toggle("checked", !!e), e !== void 0 ? (this.item.setAttribute("role", "menuitemcheckbox"), this.item.setAttribute("aria-checked", e ? "true" : "false")) : (this.item.setAttribute("role", "menuitem"), this.item.setAttribute("aria-checked", ""));
        }
        getMnemonic() {
          return this.mnemonic;
        }
        applyStyle() {
          const e = this.element && this.element.classList.contains("focused"), t = e && this.menuStyle.selectionForegroundColor ? this.menuStyle.selectionForegroundColor : this.menuStyle.foregroundColor, i = e && this.menuStyle.selectionBackgroundColor ? this.menuStyle.selectionBackgroundColor : void 0, n = e && this.menuStyle.selectionBorderColor ? `1px solid ${this.menuStyle.selectionBorderColor}` : "", o = e && this.menuStyle.selectionBorderColor ? "-1px" : "";
          this.item && (this.item.style.color = t ?? "", this.item.style.backgroundColor = i ?? "", this.item.style.outline = n, this.item.style.outlineOffset = o), this.check && (this.check.style.color = t ?? "");
        }
      }
      class pP extends oB {
        constructor(e, t, i, n, o) {
          super(e, e, n, o), this.submenuActions = t, this.parentData = i, this.submenuOptions = n, this.mysubmenu = null, this.submenuDisposables = this._register(new Me()), this.mouseOver = false, this.expandDirection = n && n.expandDirection !== void 0 ? n.expandDirection : {
            horizontal: Vv.Right,
            vertical: ZD.Below
          }, this.showScheduler = new ns(() => {
            this.mouseOver && (this.cleanupExistingSubmenu(false), this.createSubmenu(false));
          }, 250), this.hideScheduler = new ns(() => {
            this.element && !an(ss(), this.element) && this.parentData.submenu === this.mysubmenu && (this.parentData.parent.focus(false), this.cleanupExistingSubmenu(true));
          }, 750);
        }
        render(e) {
          super.render(e), this.element && (this.item && (this.item.classList.add("monaco-submenu-item"), this.item.tabIndex = 0, this.item.setAttribute("aria-haspopup", "true"), this.updateAriaExpanded("false"), this.submenuIndicator = Ne(this.item, He("span.submenu-indicator" + wt.asCSSSelector(Te.menuSubmenu))), this.submenuIndicator.setAttribute("aria-hidden", "true")), this._register(re(this.element, Ce.KEY_UP, (t) => {
            const i = new si(t);
            (i.equals(17) || i.equals(3)) && (dt.stop(t, true), this.createSubmenu(true));
          })), this._register(re(this.element, Ce.KEY_DOWN, (t) => {
            const i = new si(t);
            ss() === this.item && (i.equals(17) || i.equals(3)) && dt.stop(t, true);
          })), this._register(re(this.element, Ce.MOUSE_OVER, (t) => {
            this.mouseOver || (this.mouseOver = true, this.showScheduler.schedule());
          })), this._register(re(this.element, Ce.MOUSE_LEAVE, (t) => {
            this.mouseOver = false;
          })), this._register(re(this.element, Ce.FOCUS_OUT, (t) => {
            this.element && !an(ss(), this.element) && this.hideScheduler.schedule();
          })), this._register(this.parentData.parent.onScroll(() => {
            this.parentData.submenu === this.mysubmenu && (this.parentData.parent.focus(false), this.cleanupExistingSubmenu(true));
          })));
        }
        updateEnabled() {
        }
        onClick(e) {
          dt.stop(e, true), this.cleanupExistingSubmenu(false), this.createSubmenu(true);
        }
        cleanupExistingSubmenu(e) {
          if (this.parentData.submenu && (e || this.parentData.submenu !== this.mysubmenu)) {
            try {
              this.parentData.submenu.dispose();
            } catch {
            }
            this.parentData.submenu = void 0, this.updateAriaExpanded("false"), this.submenuContainer && (this.submenuDisposables.clear(), this.submenuContainer = void 0);
          }
        }
        calculateSubmenuMenuLayout(e, t, i, n) {
          const o = {
            top: 0,
            left: 0
          };
          return o.left = _f(e.width, t.width, {
            position: n.horizontal === Vv.Right ? 0 : 1,
            offset: i.left,
            size: i.width
          }), o.left >= i.left && o.left < i.left + i.width && (i.left + 10 + t.width <= e.width && (o.left = i.left + 10), i.top += 10, i.height = 0), o.top = _f(e.height, t.height, {
            position: 0,
            offset: i.top,
            size: 0
          }), o.top + t.height === i.top && o.top + i.height + t.height <= e.height && (o.top += i.height), o;
        }
        createSubmenu(e = true) {
          if (this.element) if (this.parentData.submenu) this.parentData.submenu.focus(false);
          else {
            this.updateAriaExpanded("true"), this.submenuContainer = Ne(this.element, He("div.monaco-submenu")), this.submenuContainer.classList.add("menubar-menu-items-holder", "context-view");
            const t = Oe(this.parentData.parent.domNode).getComputedStyle(this.parentData.parent.domNode), i = parseFloat(t.paddingTop || "0") || 0;
            this.submenuContainer.style.zIndex = "1", this.submenuContainer.style.position = "fixed", this.submenuContainer.style.top = "0", this.submenuContainer.style.left = "0", this.parentData.submenu = new zf(this.submenuContainer, this.submenuActions.length ? this.submenuActions : [
              new dT()
            ], this.submenuOptions, this.menuStyle);
            const n = this.element.getBoundingClientRect(), o = {
              top: n.top - i,
              left: n.left,
              height: n.height + 2 * i,
              width: n.width
            }, r = this.submenuContainer.getBoundingClientRect(), a = Oe(this.element), { top: l, left: u } = this.calculateSubmenuMenuLayout(new lr(a.innerWidth, a.innerHeight), lr.lift(r), o, this.expandDirection);
            this.submenuContainer.style.left = `${u - r.left}px`, this.submenuContainer.style.top = `${l - r.top}px`, this.submenuDisposables.add(re(this.submenuContainer, Ce.KEY_UP, (d) => {
              new si(d).equals(15) && (dt.stop(d, true), this.parentData.parent.focus(), this.cleanupExistingSubmenu(true));
            })), this.submenuDisposables.add(re(this.submenuContainer, Ce.KEY_DOWN, (d) => {
              new si(d).equals(15) && dt.stop(d, true);
            })), this.submenuDisposables.add(this.parentData.submenu.onDidCancel(() => {
              this.parentData.parent.focus(), this.cleanupExistingSubmenu(true);
            })), this.parentData.submenu.focus(e), this.mysubmenu = this.parentData.submenu;
          }
        }
        updateAriaExpanded(e) {
          var _a3;
          this.item && ((_a3 = this.item) == null ? void 0 : _a3.setAttribute("aria-expanded", e));
        }
        applyStyle() {
          super.applyStyle();
          const t = this.element && this.element.classList.contains("focused") && this.menuStyle.selectionForegroundColor ? this.menuStyle.selectionForegroundColor : this.menuStyle.foregroundColor;
          this.submenuIndicator && (this.submenuIndicator.style.color = t ?? "");
        }
        dispose() {
          super.dispose(), this.hideScheduler.dispose(), this.mysubmenu && (this.mysubmenu.dispose(), this.mysubmenu = null), this.submenuContainer && (this.submenuContainer = void 0);
        }
      }
      class _P extends nN {
        constructor(e, t, i, n) {
          super(e, t, i), this.menuStyles = n;
        }
        render(e) {
          super.render(e), this.label && (this.label.style.borderBottomColor = this.menuStyles.separatorColor ? `${this.menuStyles.separatorColor}` : "");
        }
      }
      function Jte(s) {
        const e = YD, t = e.exec(s);
        if (!t) return s;
        const i = !t[1];
        return s.replace(e, i ? "$2$3" : "").trim();
      }
      function bP(s) {
        const e = C9()[s.id];
        return `.codicon-${s.id}:before { content: '\\${e.toString(16)}'; }`;
      }
      function eie(s, e) {
        let t = `
.monaco-menu {
	font-size: 13px;
	border-radius: 5px;
	min-width: 160px;
}

${bP(Te.menuSelection)}
${bP(Te.menuSubmenu)}

.monaco-menu .monaco-action-bar {
	text-align: right;
	overflow: hidden;
	white-space: nowrap;
}

.monaco-menu .monaco-action-bar .actions-container {
	display: flex;
	margin: 0 auto;
	padding: 0;
	width: 100%;
	justify-content: flex-end;
}

.monaco-menu .monaco-action-bar.vertical .actions-container {
	display: inline-block;
}

.monaco-menu .monaco-action-bar.reverse .actions-container {
	flex-direction: row-reverse;
}

.monaco-menu .monaco-action-bar .action-item {
	cursor: pointer;
	display: inline-block;
	transition: transform 50ms ease;
	position: relative;  /* DO NOT REMOVE - this is the key to preventing the ghosting icon bug in Chrome 42 */
}

.monaco-menu .monaco-action-bar .action-item.disabled {
	cursor: default;
}

.monaco-menu .monaco-action-bar .action-item .icon,
.monaco-menu .monaco-action-bar .action-item .codicon {
	display: inline-block;
}

.monaco-menu .monaco-action-bar .action-item .codicon {
	display: flex;
	align-items: center;
}

.monaco-menu .monaco-action-bar .action-label {
	font-size: 11px;
	margin-right: 4px;
}

.monaco-menu .monaco-action-bar .action-item.disabled .action-label,
.monaco-menu .monaco-action-bar .action-item.disabled .action-label:hover {
	color: var(--vscode-disabledForeground);
}

/* Vertical actions */

.monaco-menu .monaco-action-bar.vertical {
	text-align: left;
}

.monaco-menu .monaco-action-bar.vertical .action-item {
	display: block;
}

.monaco-menu .monaco-action-bar.vertical .action-label.separator {
	display: block;
	border-bottom: 1px solid var(--vscode-menu-separatorBackground);
	padding-top: 1px;
	padding: 30px;
}

.monaco-menu .secondary-actions .monaco-action-bar .action-label {
	margin-left: 6px;
}

/* Action Items */
.monaco-menu .monaco-action-bar .action-item.select-container {
	overflow: hidden; /* somehow the dropdown overflows its container, we prevent it here to not push */
	flex: 1;
	max-width: 170px;
	min-width: 60px;
	display: flex;
	align-items: center;
	justify-content: center;
	margin-right: 10px;
}

.monaco-menu .monaco-action-bar.vertical {
	margin-left: 0;
	overflow: visible;
}

.monaco-menu .monaco-action-bar.vertical .actions-container {
	display: block;
}

.monaco-menu .monaco-action-bar.vertical .action-item {
	padding: 0;
	transform: none;
	display: flex;
}

.monaco-menu .monaco-action-bar.vertical .action-item.active {
	transform: none;
}

.monaco-menu .monaco-action-bar.vertical .action-menu-item {
	flex: 1 1 auto;
	display: flex;
	height: 2em;
	align-items: center;
	position: relative;
	margin: 0 4px;
	border-radius: 4px;
}

.monaco-menu .monaco-action-bar.vertical .action-menu-item:hover .keybinding,
.monaco-menu .monaco-action-bar.vertical .action-menu-item:focus .keybinding {
	opacity: unset;
}

.monaco-menu .monaco-action-bar.vertical .action-label {
	flex: 1 1 auto;
	text-decoration: none;
	padding: 0 1em;
	background: none;
	font-size: 12px;
	line-height: 1;
}

.monaco-menu .monaco-action-bar.vertical .keybinding,
.monaco-menu .monaco-action-bar.vertical .submenu-indicator {
	display: inline-block;
	flex: 2 1 auto;
	padding: 0 1em;
	text-align: right;
	font-size: 12px;
	line-height: 1;
}

.monaco-menu .monaco-action-bar.vertical .submenu-indicator {
	height: 100%;
}

.monaco-menu .monaco-action-bar.vertical .submenu-indicator.codicon {
	font-size: 16px !important;
	display: flex;
	align-items: center;
}

.monaco-menu .monaco-action-bar.vertical .submenu-indicator.codicon::before {
	margin-left: auto;
	margin-right: -20px;
}

.monaco-menu .monaco-action-bar.vertical .action-item.disabled .keybinding,
.monaco-menu .monaco-action-bar.vertical .action-item.disabled .submenu-indicator {
	opacity: 0.4;
}

.monaco-menu .monaco-action-bar.vertical .action-label:not(.separator) {
	display: inline-block;
	box-sizing: border-box;
	margin: 0;
}

.monaco-menu .monaco-action-bar.vertical .action-item {
	position: static;
	overflow: visible;
}

.monaco-menu .monaco-action-bar.vertical .action-item .monaco-submenu {
	position: absolute;
}

.monaco-menu .monaco-action-bar.vertical .action-label.separator {
	width: 100%;
	height: 0px !important;
	opacity: 1;
}

.monaco-menu .monaco-action-bar.vertical .action-label.separator.text {
	padding: 0.7em 1em 0.1em 1em;
	font-weight: bold;
	opacity: 1;
}

.monaco-menu .monaco-action-bar.vertical .action-label:hover {
	color: inherit;
}

.monaco-menu .monaco-action-bar.vertical .menu-item-check {
	position: absolute;
	visibility: hidden;
	width: 1em;
	height: 100%;
}

.monaco-menu .monaco-action-bar.vertical .action-menu-item.checked .menu-item-check {
	visibility: visible;
	display: flex;
	align-items: center;
	justify-content: center;
}

/* Context Menu */

.context-view.monaco-menu-container {
	outline: 0;
	border: none;
	animation: fadeIn 0.083s linear;
	-webkit-app-region: no-drag;
}

.context-view.monaco-menu-container :focus,
.context-view.monaco-menu-container .monaco-action-bar.vertical:focus,
.context-view.monaco-menu-container .monaco-action-bar.vertical :focus {
	outline: 0;
}

.hc-black .context-view.monaco-menu-container,
.hc-light .context-view.monaco-menu-container,
:host-context(.hc-black) .context-view.monaco-menu-container,
:host-context(.hc-light) .context-view.monaco-menu-container {
	box-shadow: none;
}

.hc-black .monaco-menu .monaco-action-bar.vertical .action-item.focused,
.hc-light .monaco-menu .monaco-action-bar.vertical .action-item.focused,
:host-context(.hc-black) .monaco-menu .monaco-action-bar.vertical .action-item.focused,
:host-context(.hc-light) .monaco-menu .monaco-action-bar.vertical .action-item.focused {
	background: none;
}

/* Vertical Action Bar Styles */

.monaco-menu .monaco-action-bar.vertical {
	padding: 4px 0;
}

.monaco-menu .monaco-action-bar.vertical .action-menu-item {
	height: 2em;
}

.monaco-menu .monaco-action-bar.vertical .action-label:not(.separator),
.monaco-menu .monaco-action-bar.vertical .keybinding {
	font-size: inherit;
	padding: 0 2em;
	max-height: 100%;
}

.monaco-menu .monaco-action-bar.vertical .menu-item-check {
	font-size: inherit;
	width: 2em;
}

.monaco-menu .monaco-action-bar.vertical .action-label.separator {
	font-size: inherit;
	margin: 5px 0 !important;
	padding: 0;
	border-radius: 0;
}

.linux .monaco-menu .monaco-action-bar.vertical .action-label.separator,
:host-context(.linux) .monaco-menu .monaco-action-bar.vertical .action-label.separator {
	margin-left: 0;
	margin-right: 0;
}

.monaco-menu .monaco-action-bar.vertical .submenu-indicator {
	font-size: 60%;
	padding: 0 1.8em;
}

.linux .monaco-menu .monaco-action-bar.vertical .submenu-indicator,
:host-context(.linux) .monaco-menu .monaco-action-bar.vertical .submenu-indicator {
	height: 100%;
	mask-size: 10px 10px;
	-webkit-mask-size: 10px 10px;
}

.monaco-menu .action-item {
	cursor: default;
}`;
        if (e) {
          t += `
			/* Arrows */
			.monaco-scrollable-element > .scrollbar > .scra {
				cursor: pointer;
				font-size: 11px !important;
			}

			.monaco-scrollable-element > .visible {
				opacity: 1;

				/* Background rule added for IE9 - to allow clicks on dom node */
				background:rgba(0,0,0,0);

				transition: opacity 100ms linear;
			}
			.monaco-scrollable-element > .invisible {
				opacity: 0;
				pointer-events: none;
			}
			.monaco-scrollable-element > .invisible.fade {
				transition: opacity 800ms linear;
			}

			/* Scrollable Content Inset Shadow */
			.monaco-scrollable-element > .shadow {
				position: absolute;
				display: none;
			}
			.monaco-scrollable-element > .shadow.top {
				display: block;
				top: 0;
				left: 3px;
				height: 3px;
				width: 100%;
			}
			.monaco-scrollable-element > .shadow.left {
				display: block;
				top: 3px;
				left: 0;
				height: 100%;
				width: 3px;
			}
			.monaco-scrollable-element > .shadow.top-left-corner {
				display: block;
				top: 0;
				left: 0;
				height: 3px;
				width: 3px;
			}
		`;
          const i = s.scrollbarShadow;
          i && (t += `
				.monaco-scrollable-element > .shadow.top {
					box-shadow: ${i} 0 6px 6px -6px inset;
				}

				.monaco-scrollable-element > .shadow.left {
					box-shadow: ${i} 6px 0 6px -6px inset;
				}

				.monaco-scrollable-element > .shadow.top.left {
					box-shadow: ${i} 6px 6px 6px -6px inset;
				}
			`);
          const n = s.scrollbarSliderBackground;
          n && (t += `
				.monaco-scrollable-element > .scrollbar > .slider {
					background: ${n};
				}
			`);
          const o = s.scrollbarSliderHoverBackground;
          o && (t += `
				.monaco-scrollable-element > .scrollbar > .slider:hover {
					background: ${o};
				}
			`);
          const r = s.scrollbarSliderActiveBackground;
          r && (t += `
				.monaco-scrollable-element > .scrollbar > .slider.active {
					background: ${r};
				}
			`);
        }
        return t;
      }
      class tie {
        constructor(e, t, i, n) {
          this.contextViewService = e, this.telemetryService = t, this.notificationService = i, this.keybindingService = n, this.focusToReturn = null, this.lastContainer = null, this.block = null, this.blockDisposable = null, this.options = {
            blockMouse: true
          };
        }
        configure(e) {
          this.options = e;
        }
        showContextMenu(e) {
          const t = e.getActions();
          if (!t.length) return;
          this.focusToReturn = ss();
          let i;
          const n = wn(e.domForShadowRoot) ? e.domForShadowRoot : void 0;
          this.contextViewService.showContextView({
            getAnchor: () => e.getAnchor(),
            canRelayout: false,
            anchorAlignment: e.anchorAlignment,
            anchorAxisAlignment: e.anchorAxisAlignment,
            render: (o) => {
              var _a3;
              this.lastContainer = o;
              const r = e.getMenuClassName ? e.getMenuClassName() : "";
              r && (o.className += " " + r), this.options.blockMouse && (this.block = o.appendChild(He(".context-view-block")), this.block.style.position = "fixed", this.block.style.cursor = "initial", this.block.style.left = "0", this.block.style.top = "0", this.block.style.width = "100%", this.block.style.height = "100%", this.block.style.zIndex = "-1", (_a3 = this.blockDisposable) == null ? void 0 : _a3.dispose(), this.blockDisposable = re(this.block, Ce.MOUSE_DOWN, (d) => d.stopPropagation()));
              const a = new Me(), l = e.actionRunner || new Rh();
              l.onWillRun((d) => this.onActionRun(d, !e.skipTelemetry), this, a), l.onDidRun(this.onDidActionRun, this, a), i = new zf(o, t, {
                actionViewItemProvider: e.getActionViewItem,
                context: e.getActionsContext ? e.getActionsContext() : null,
                actionRunner: l,
                getKeyBinding: e.getKeyBinding ? e.getKeyBinding : (d) => this.keybindingService.lookupKeybinding(d.id)
              }, Yte), i.onDidCancel(() => this.contextViewService.hideContextView(true), null, a), i.onDidBlur(() => this.contextViewService.hideContextView(true), null, a);
              const u = Oe(o);
              return a.add(re(u, Ce.BLUR, () => this.contextViewService.hideContextView(true))), a.add(re(u, Ce.MOUSE_DOWN, (d) => {
                if (d.defaultPrevented) return;
                const f = new Vr(u, d);
                let m = f.target;
                if (!f.rightButton) {
                  for (; m; ) {
                    if (m === o) return;
                    m = m.parentElement;
                  }
                  this.contextViewService.hideContextView(true);
                }
              })), ka(a, i);
            },
            focus: () => {
              i == null ? void 0 : i.focus(!!e.autoSelectFirstItem);
            },
            onHide: (o) => {
              var _a3, _b3, _c2;
              (_a3 = e.onHide) == null ? void 0 : _a3.call(e, !!o), this.block && (this.block.remove(), this.block = null), (_b3 = this.blockDisposable) == null ? void 0 : _b3.dispose(), this.blockDisposable = null, this.lastContainer && (ss() === this.lastContainer || an(ss(), this.lastContainer)) && ((_c2 = this.focusToReturn) == null ? void 0 : _c2.focus()), this.lastContainer = null;
            }
          }, n, !!n);
        }
        onActionRun(e, t) {
          t && this.telemetryService.publicLog2("workbenchActionExecuted", {
            id: e.action.id,
            from: "contextMenu"
          }), this.contextViewService.hideContextView(false);
        }
        onDidActionRun(e) {
          e.error && !O_(e.error) && this.notificationService.error(e.error);
        }
      }
      var iie = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      }, Xd = function(s, e) {
        return function(t, i) {
          e(t, i, s);
        };
      };
      let QD = class extends he {
        get contextMenuHandler() {
          return this._contextMenuHandler || (this._contextMenuHandler = new tie(this.contextViewService, this.telemetryService, this.notificationService, this.keybindingService)), this._contextMenuHandler;
        }
        constructor(e, t, i, n, o, r) {
          super(), this.telemetryService = e, this.notificationService = t, this.contextViewService = i, this.keybindingService = n, this.menuService = o, this.contextKeyService = r, this._contextMenuHandler = void 0, this._onDidShowContextMenu = this._store.add(new G()), this.onDidShowContextMenu = this._onDidShowContextMenu.event, this._onDidHideContextMenu = this._store.add(new G());
        }
        configure(e) {
          this.contextMenuHandler.configure(e);
        }
        showContextMenu(e) {
          e = XD.transform(e, this.menuService, this.contextKeyService), this.contextMenuHandler.showContextMenu({
            ...e,
            onHide: (t) => {
              var _a3;
              (_a3 = e.onHide) == null ? void 0 : _a3.call(e, t), this._onDidHideContextMenu.fire();
            }
          }), Hc.getInstance().resetKeyStatus(), this._onDidShowContextMenu.fire();
        }
      };
      QD = iie([
        Xd(0, Qh),
        Xd(1, Jr),
        Xd(2, Q_),
        Xd(3, Pn),
        Xd(4, Zh),
        Xd(5, Mt)
      ], QD);
      var XD;
      (function(s) {
        function e(i) {
          return i && i.menuId instanceof Q;
        }
        function t(i, n, o) {
          if (!e(i)) return i;
          const { menuId: r, menuActionOptions: a, contextKeyService: l } = i;
          return {
            ...i,
            getActions: () => {
              const u = [];
              if (r) {
                const d = n.getMenuActions(r, l ?? o, a);
                Zte(d, u);
              }
              return i.getActions ? $n.join(i.getActions(), u) : u;
            }
          };
        }
        s.transform = t;
      })(XD || (XD = {}));
      var Wv;
      (function(s) {
        s[s.API = 0] = "API", s[s.USER = 1] = "USER";
      })(Wv || (Wv = {}));
      var oN = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      }, Hv = function(s, e) {
        return function(t, i) {
          e(t, i, s);
        };
      };
      let JD = class {
        constructor(e) {
          this._commandService = e;
        }
        async open(e, t) {
          if (!tT(e, it.command)) return false;
          if (!(t == null ? void 0 : t.allowCommands) || (typeof e == "string" && (e = st.parse(e)), Array.isArray(t.allowCommands) && !t.allowCommands.includes(e.path))) return true;
          let i = [];
          try {
            i = TD(decodeURIComponent(e.query));
          } catch {
            try {
              i = TD(e.query);
            } catch {
            }
          }
          return Array.isArray(i) || (i = [
            i
          ]), await this._commandService.executeCommand(e.path, ...i), true;
        }
      };
      JD = oN([
        Hv(0, po)
      ], JD);
      let e2 = class {
        constructor(e) {
          this._editorService = e;
        }
        async open(e, t) {
          typeof e == "string" && (e = st.parse(e));
          const { selection: i, uri: n } = EX(e);
          return e = n, e.scheme === it.file && (e = aJ(e)), await this._editorService.openCodeEditor({
            resource: e,
            options: {
              selection: i,
              source: (t == null ? void 0 : t.fromUserGesture) ? Wv.USER : Wv.API,
              ...t == null ? void 0 : t.editorOptions
            }
          }, this._editorService.getFocusedCodeEditor(), t == null ? void 0 : t.openToSide), true;
        }
      };
      e2 = oN([
        Hv(0, Xi)
      ], e2);
      let t2 = class {
        constructor(e, t) {
          this._openers = new Us(), this._validators = new Us(), this._resolvers = new Us(), this._resolvedUriTargets = new fs((i) => i.with({
            path: null,
            fragment: null,
            query: null
          }).toString()), this._externalOpeners = new Us(), this._defaultExternalOpener = {
            openExternal: async (i) => (sO(i, it.http, it.https) ? t8(i) : Kt.location.href = i, true)
          }, this._openers.push({
            open: async (i, n) => (n == null ? void 0 : n.openExternal) || sO(i, it.mailto, it.http, it.https, it.vsls) ? (await this._doOpenExternal(i, n), true) : false
          }), this._openers.push(new JD(t)), this._openers.push(new e2(e));
        }
        registerOpener(e) {
          return {
            dispose: this._openers.unshift(e)
          };
        }
        async open(e, t) {
          const i = typeof e == "string" ? st.parse(e) : e, n = this._resolvedUriTargets.get(i) ?? e;
          for (const o of this._validators) if (!await o.shouldOpen(n, t)) return false;
          for (const o of this._openers) if (await o.open(e, t)) return true;
          return false;
        }
        async resolveExternalUri(e, t) {
          for (const i of this._resolvers) try {
            const n = await i.resolveExternalUri(e, t);
            if (n) return this._resolvedUriTargets.has(n.resolved) || this._resolvedUriTargets.set(n.resolved, e), n;
          } catch {
          }
          throw new Error("Could not resolve external URI: " + e.toString());
        }
        async _doOpenExternal(e, t) {
          const i = typeof e == "string" ? st.parse(e) : e;
          let n;
          try {
            n = (await this.resolveExternalUri(i, t)).resolved;
          } catch {
            n = i;
          }
          let o;
          if (typeof e == "string" && i.toString() === n.toString() ? o = e : o = encodeURI(n.toString(true)), t == null ? void 0 : t.allowContributedOpeners) {
            const r = typeof (t == null ? void 0 : t.allowContributedOpeners) == "string" ? t == null ? void 0 : t.allowContributedOpeners : void 0;
            for (const a of this._externalOpeners) if (await a.openExternal(o, {
              sourceUri: i,
              preferredOpenerId: r
            }, mr.None)) return true;
          }
          return this._defaultExternalOpener.openExternal(o, {
            sourceUri: i
          }, mr.None);
        }
        dispose() {
          this._validators.clear();
        }
      };
      t2 = oN([
        Hv(0, Xi),
        Hv(1, po)
      ], t2);
      const n1 = pt("editorWorkerService");
      var Ro;
      (function(s) {
        s[s.Hint = 1] = "Hint", s[s.Info = 2] = "Info", s[s.Warning = 4] = "Warning", s[s.Error = 8] = "Error";
      })(Ro || (Ro = {}));
      (function(s) {
        function e(r, a) {
          return a - r;
        }
        s.compare = e;
        const t = /* @__PURE__ */ Object.create(null);
        t[s.Error] = C("sev.error", "Error"), t[s.Warning] = C("sev.warning", "Warning"), t[s.Info] = C("sev.info", "Info");
        function i(r) {
          return t[r] || "";
        }
        s.toString = i;
        function n(r) {
          switch (r) {
            case Ui.Error:
              return s.Error;
            case Ui.Warning:
              return s.Warning;
            case Ui.Info:
              return s.Info;
            case Ui.Ignore:
              return s.Hint;
          }
        }
        s.fromSeverity = n;
        function o(r) {
          switch (r) {
            case s.Error:
              return Ui.Error;
            case s.Warning:
              return Ui.Warning;
            case s.Info:
              return Ui.Info;
            case s.Hint:
              return Ui.Ignore;
          }
        }
        s.toSeverity = o;
      })(Ro || (Ro = {}));
      var vP;
      (function(s) {
        const e = "";
        function t(n) {
          return i(n, true);
        }
        s.makeKey = t;
        function i(n, o) {
          const r = [
            e
          ];
          return n.source ? r.push(n.source.replace("\xA6", "\\\xA6")) : r.push(e), n.code ? typeof n.code == "string" ? r.push(n.code.replace("\xA6", "\\\xA6")) : r.push(n.code.value.replace("\xA6", "\\\xA6")) : r.push(e), n.severity !== void 0 && n.severity !== null ? r.push(Ro.toString(n.severity)) : r.push(e), n.message && o ? r.push(n.message.replace("\xA6", "\\\xA6")) : r.push(e), n.startLineNumber !== void 0 && n.startLineNumber !== null ? r.push(n.startLineNumber.toString()) : r.push(e), n.startColumn !== void 0 && n.startColumn !== null ? r.push(n.startColumn.toString()) : r.push(e), n.endLineNumber !== void 0 && n.endLineNumber !== null ? r.push(n.endLineNumber.toString()) : r.push(e), n.endColumn !== void 0 && n.endColumn !== null ? r.push(n.endColumn.toString()) : r.push(e), r.push(e), r.join("\xA6");
        }
        s.makeKeyOptionalMessage = i;
      })(vP || (vP = {}));
      const td = pt("markerService"), rB = B("editor.lineHighlightBackground", null, C("lineHighlight", "Background color for the highlight of line at the cursor position.")), CP = B("editor.lineHighlightBorder", {
        dark: "#282828",
        light: "#eeeeee",
        hcDark: "#f38518",
        hcLight: Et
      }, C("lineHighlightBorderBox", "Background color for the border around the line at the cursor position."));
      B("editor.rangeHighlightBackground", {
        dark: "#ffffff0b",
        light: "#fdff0033",
        hcDark: null,
        hcLight: null
      }, C("rangeHighlight", "Background color of highlighted ranges, like by quick open and find features. The color must not be opaque so as not to hide underlying decorations."), true);
      B("editor.rangeHighlightBorder", {
        dark: null,
        light: null,
        hcDark: Ai,
        hcLight: Ai
      }, C("rangeHighlightBorder", "Background color of the border around highlighted ranges."));
      B("editor.symbolHighlightBackground", {
        dark: zc,
        light: zc,
        hcDark: null,
        hcLight: null
      }, C("symbolHighlight", "Background color of highlighted symbol, like for go to definition or go next/previous symbol. The color must not be opaque so as not to hide underlying decorations."), true);
      B("editor.symbolHighlightBorder", {
        dark: null,
        light: null,
        hcDark: Ai,
        hcLight: Ai
      }, C("symbolHighlightBorder", "Background color of the border around highlighted symbols."));
      const xw = B("editorCursor.foreground", {
        dark: "#AEAFAD",
        light: le.black,
        hcDark: le.white,
        hcLight: "#0F4A85"
      }, C("caret", "Color of the editor cursor.")), rN = B("editorCursor.background", null, C("editorCursorBackground", "The background color of the editor cursor. Allows customizing the color of a character overlapped by a block cursor.")), aB = B("editorMultiCursor.primary.foreground", xw, C("editorMultiCursorPrimaryForeground", "Color of the primary editor cursor when multiple cursors are present.")), nie = B("editorMultiCursor.primary.background", rN, C("editorMultiCursorPrimaryBackground", "The background color of the primary editor cursor when multiple cursors are present. Allows customizing the color of a character overlapped by a block cursor.")), lB = B("editorMultiCursor.secondary.foreground", xw, C("editorMultiCursorSecondaryForeground", "Color of secondary editor cursors when multiple cursors are present.")), sie = B("editorMultiCursor.secondary.background", rN, C("editorMultiCursorSecondaryBackground", "The background color of secondary editor cursors when multiple cursors are present. Allows customizing the color of a character overlapped by a block cursor.")), aN = B("editorWhitespace.foreground", {
        dark: "#e3e4e229",
        light: "#33333333",
        hcDark: "#e3e4e229",
        hcLight: "#CCCCCC"
      }, C("editorWhitespaces", "Color of whitespace characters in the editor.")), oie = B("editorLineNumber.foreground", {
        dark: "#858585",
        light: "#237893",
        hcDark: le.white,
        hcLight: "#292929"
      }, C("editorLineNumbers", "Color of editor line numbers.")), rie = B("editorIndentGuide.background", aN, C("editorIndentGuides", "Color of the editor indentation guides."), false, C("deprecatedEditorIndentGuides", "'editorIndentGuide.background' is deprecated. Use 'editorIndentGuide.background1' instead.")), aie = B("editorIndentGuide.activeBackground", aN, C("editorActiveIndentGuide", "Color of the active editor indentation guides."), false, C("deprecatedEditorActiveIndentGuide", "'editorIndentGuide.activeBackground' is deprecated. Use 'editorIndentGuide.activeBackground1' instead.")), s1 = B("editorIndentGuide.background1", rie, C("editorIndentGuides1", "Color of the editor indentation guides (1).")), lie = B("editorIndentGuide.background2", "#00000000", C("editorIndentGuides2", "Color of the editor indentation guides (2).")), cie = B("editorIndentGuide.background3", "#00000000", C("editorIndentGuides3", "Color of the editor indentation guides (3).")), uie = B("editorIndentGuide.background4", "#00000000", C("editorIndentGuides4", "Color of the editor indentation guides (4).")), hie = B("editorIndentGuide.background5", "#00000000", C("editorIndentGuides5", "Color of the editor indentation guides (5).")), die = B("editorIndentGuide.background6", "#00000000", C("editorIndentGuides6", "Color of the editor indentation guides (6).")), o1 = B("editorIndentGuide.activeBackground1", aie, C("editorActiveIndentGuide1", "Color of the active editor indentation guides (1).")), fie = B("editorIndentGuide.activeBackground2", "#00000000", C("editorActiveIndentGuide2", "Color of the active editor indentation guides (2).")), gie = B("editorIndentGuide.activeBackground3", "#00000000", C("editorActiveIndentGuide3", "Color of the active editor indentation guides (3).")), mie = B("editorIndentGuide.activeBackground4", "#00000000", C("editorActiveIndentGuide4", "Color of the active editor indentation guides (4).")), pie = B("editorIndentGuide.activeBackground5", "#00000000", C("editorActiveIndentGuide5", "Color of the active editor indentation guides (5).")), _ie = B("editorIndentGuide.activeBackground6", "#00000000", C("editorActiveIndentGuide6", "Color of the active editor indentation guides (6).")), bie = B("editorActiveLineNumber.foreground", {
        dark: "#c6c6c6",
        light: "#0B216F",
        hcDark: Ai,
        hcLight: Ai
      }, C("editorActiveLineNumber", "Color of editor active line number"), false, C("deprecatedEditorActiveLineNumber", "Id is deprecated. Use 'editorLineNumber.activeForeground' instead."));
      B("editorLineNumber.activeForeground", bie, C("editorActiveLineNumber", "Color of editor active line number"));
      const vie = B("editorLineNumber.dimmedForeground", null, C("editorDimmedLineNumber", "Color of the final editor line when editor.renderFinalNewline is set to dimmed."));
      B("editorRuler.foreground", {
        dark: "#5A5A5A",
        light: le.lightgrey,
        hcDark: le.white,
        hcLight: "#292929"
      }, C("editorRuler", "Color of the editor rulers."));
      B("editorCodeLens.foreground", {
        dark: "#999999",
        light: "#919191",
        hcDark: "#999999",
        hcLight: "#292929"
      }, C("editorCodeLensForeground", "Foreground color of editor CodeLens"));
      B("editorBracketMatch.background", {
        dark: "#0064001a",
        light: "#0064001a",
        hcDark: "#0064001a",
        hcLight: "#0000"
      }, C("editorBracketMatchBackground", "Background color behind matching brackets"));
      B("editorBracketMatch.border", {
        dark: "#888",
        light: "#B9B9B9",
        hcDark: Et,
        hcLight: Et
      }, C("editorBracketMatchBorder", "Color for matching brackets boxes"));
      const Cie = B("editorOverviewRuler.border", {
        dark: "#7f7f7f4d",
        light: "#7f7f7f4d",
        hcDark: "#7f7f7f4d",
        hcLight: "#666666"
      }, C("editorOverviewRulerBorder", "Color of the overview ruler border.")), wie = B("editorOverviewRuler.background", null, C("editorOverviewRulerBackground", "Background color of the editor overview ruler."));
      B("editorGutter.background", qr, C("editorGutter", "Background color of the editor gutter. The gutter contains the glyph margins and the line numbers."));
      B("editorUnnecessaryCode.border", {
        dark: null,
        light: null,
        hcDark: le.fromHex("#fff").transparent(0.8),
        hcLight: Et
      }, C("unnecessaryCodeBorder", "Border color of unnecessary (unused) source code in the editor."));
      const yie = B("editorUnnecessaryCode.opacity", {
        dark: le.fromHex("#000a"),
        light: le.fromHex("#0007"),
        hcDark: null,
        hcLight: null
      }, C("unnecessaryCodeOpacity", `Opacity of unnecessary (unused) source code in the editor. For example, "#000000c0" will render the code with 75% opacity. For high contrast themes, use the  'editorUnnecessaryCode.border' theme color to underline unnecessary code instead of fading it out.`));
      B("editorGhostText.border", {
        dark: null,
        light: null,
        hcDark: le.fromHex("#fff").transparent(0.8),
        hcLight: le.fromHex("#292929").transparent(0.8)
      }, C("editorGhostTextBorder", "Border color of ghost text in the editor."));
      B("editorGhostText.foreground", {
        dark: le.fromHex("#ffffff56"),
        light: le.fromHex("#0007"),
        hcDark: null,
        hcLight: null
      }, C("editorGhostTextForeground", "Foreground color of the ghost text in the editor."));
      B("editorGhostText.background", null, C("editorGhostTextBackground", "Background color of the ghost text in the editor."));
      const Sie = new le(new yt(0, 122, 204, 0.6));
      B("editorOverviewRuler.rangeHighlightForeground", Sie, C("overviewRulerRangeHighlight", "Overview ruler marker color for range highlights. The color must not be opaque so as not to hide underlying decorations."), true);
      const Lie = B("editorOverviewRuler.errorForeground", {
        dark: new le(new yt(255, 18, 18, 0.7)),
        light: new le(new yt(255, 18, 18, 0.7)),
        hcDark: new le(new yt(255, 50, 50, 1)),
        hcLight: "#B5200D"
      }, C("overviewRuleError", "Overview ruler marker color for errors.")), xie = B("editorOverviewRuler.warningForeground", {
        dark: au,
        light: au,
        hcDark: wv,
        hcLight: wv
      }, C("overviewRuleWarning", "Overview ruler marker color for warnings.")), kie = B("editorOverviewRuler.infoForeground", {
        dark: Bh,
        light: Bh,
        hcDark: yv,
        hcLight: yv
      }, C("overviewRuleInfo", "Overview ruler marker color for infos.")), cB = B("editorBracketHighlight.foreground1", {
        dark: "#FFD700",
        light: "#0431FAFF",
        hcDark: "#FFD700",
        hcLight: "#0431FAFF"
      }, C("editorBracketHighlightForeground1", "Foreground color of brackets (1). Requires enabling bracket pair colorization.")), uB = B("editorBracketHighlight.foreground2", {
        dark: "#DA70D6",
        light: "#319331FF",
        hcDark: "#DA70D6",
        hcLight: "#319331FF"
      }, C("editorBracketHighlightForeground2", "Foreground color of brackets (2). Requires enabling bracket pair colorization.")), hB = B("editorBracketHighlight.foreground3", {
        dark: "#179FFF",
        light: "#7B3814FF",
        hcDark: "#87CEFA",
        hcLight: "#7B3814FF"
      }, C("editorBracketHighlightForeground3", "Foreground color of brackets (3). Requires enabling bracket pair colorization.")), dB = B("editorBracketHighlight.foreground4", "#00000000", C("editorBracketHighlightForeground4", "Foreground color of brackets (4). Requires enabling bracket pair colorization.")), fB = B("editorBracketHighlight.foreground5", "#00000000", C("editorBracketHighlightForeground5", "Foreground color of brackets (5). Requires enabling bracket pair colorization.")), gB = B("editorBracketHighlight.foreground6", "#00000000", C("editorBracketHighlightForeground6", "Foreground color of brackets (6). Requires enabling bracket pair colorization.")), Die = B("editorBracketHighlight.unexpectedBracket.foreground", {
        dark: new le(new yt(255, 18, 18, 0.8)),
        light: new le(new yt(255, 18, 18, 0.8)),
        hcDark: "new Color(new RGBA(255, 50, 50, 1))",
        hcLight: "#B5200D"
      }, C("editorBracketHighlightUnexpectedBracketForeground", "Foreground color of unexpected brackets.")), Eie = B("editorBracketPairGuide.background1", "#00000000", C("editorBracketPairGuide.background1", "Background color of inactive bracket pair guides (1). Requires enabling bracket pair guides.")), Tie = B("editorBracketPairGuide.background2", "#00000000", C("editorBracketPairGuide.background2", "Background color of inactive bracket pair guides (2). Requires enabling bracket pair guides.")), Nie = B("editorBracketPairGuide.background3", "#00000000", C("editorBracketPairGuide.background3", "Background color of inactive bracket pair guides (3). Requires enabling bracket pair guides.")), Iie = B("editorBracketPairGuide.background4", "#00000000", C("editorBracketPairGuide.background4", "Background color of inactive bracket pair guides (4). Requires enabling bracket pair guides.")), Mie = B("editorBracketPairGuide.background5", "#00000000", C("editorBracketPairGuide.background5", "Background color of inactive bracket pair guides (5). Requires enabling bracket pair guides.")), Aie = B("editorBracketPairGuide.background6", "#00000000", C("editorBracketPairGuide.background6", "Background color of inactive bracket pair guides (6). Requires enabling bracket pair guides.")), Rie = B("editorBracketPairGuide.activeBackground1", "#00000000", C("editorBracketPairGuide.activeBackground1", "Background color of active bracket pair guides (1). Requires enabling bracket pair guides.")), Oie = B("editorBracketPairGuide.activeBackground2", "#00000000", C("editorBracketPairGuide.activeBackground2", "Background color of active bracket pair guides (2). Requires enabling bracket pair guides.")), Pie = B("editorBracketPairGuide.activeBackground3", "#00000000", C("editorBracketPairGuide.activeBackground3", "Background color of active bracket pair guides (3). Requires enabling bracket pair guides.")), Bie = B("editorBracketPairGuide.activeBackground4", "#00000000", C("editorBracketPairGuide.activeBackground4", "Background color of active bracket pair guides (4). Requires enabling bracket pair guides.")), Fie = B("editorBracketPairGuide.activeBackground5", "#00000000", C("editorBracketPairGuide.activeBackground5", "Background color of active bracket pair guides (5). Requires enabling bracket pair guides.")), Vie = B("editorBracketPairGuide.activeBackground6", "#00000000", C("editorBracketPairGuide.activeBackground6", "Background color of active bracket pair guides (6). Requires enabling bracket pair guides."));
      B("editorUnicodeHighlight.border", au, C("editorUnicodeHighlight.border", "Border color used to highlight unicode characters."));
      B("editorUnicodeHighlight.background", OZ, C("editorUnicodeHighlight.background", "Background color used to highlight unicode characters."));
      jl((s, e) => {
        const t = s.getColor(qr), i = s.getColor(rB), n = i && !i.isTransparent() ? i : t;
        n && e.addRule(`.monaco-editor .inputarea.ime-input { background-color: ${n}; }`);
      });
      function Wie(s, e) {
        const t = [], i = [];
        for (const n of s) e.has(n) || t.push(n);
        for (const n of e) s.has(n) || i.push(n);
        return {
          removed: t,
          added: i
        };
      }
      function Hie(s, e) {
        const t = /* @__PURE__ */ new Set();
        for (const i of e) s.has(i) && t.add(i);
        return t;
      }
      var zie = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      }, wP = function(s, e) {
        return function(t, i) {
          e(t, i, s);
        };
      };
      let i2 = class extends he {
        constructor(e, t) {
          super(), this._markerService = t, this._onDidChangeMarker = this._register(new G()), this._markerDecorations = new fs(), e.getModels().forEach((i) => this._onModelAdded(i)), this._register(e.onModelAdded(this._onModelAdded, this)), this._register(e.onModelRemoved(this._onModelRemoved, this)), this._register(this._markerService.onMarkerChanged(this._handleMarkerChange, this));
        }
        dispose() {
          super.dispose(), this._markerDecorations.forEach((e) => e.dispose()), this._markerDecorations.clear();
        }
        getMarker(e, t) {
          const i = this._markerDecorations.get(e);
          return i && i.getMarker(t) || null;
        }
        _handleMarkerChange(e) {
          e.forEach((t) => {
            const i = this._markerDecorations.get(t);
            i && this._updateDecorations(i);
          });
        }
        _onModelAdded(e) {
          const t = new Uie(e);
          this._markerDecorations.set(e.uri, t), this._updateDecorations(t);
        }
        _onModelRemoved(e) {
          var _a3;
          const t = this._markerDecorations.get(e.uri);
          t && (t.dispose(), this._markerDecorations.delete(e.uri)), (e.uri.scheme === it.inMemory || e.uri.scheme === it.internal || e.uri.scheme === it.vscode) && ((_a3 = this._markerService) == null ? void 0 : _a3.read({
            resource: e.uri
          }).map((i) => i.owner).forEach((i) => this._markerService.remove(i, [
            e.uri
          ])));
        }
        _updateDecorations(e) {
          const t = this._markerService.read({
            resource: e.model.uri,
            take: 500
          });
          e.update(t) && this._onDidChangeMarker.fire(e.model);
        }
      };
      i2 = zie([
        wP(0, _s),
        wP(1, td)
      ], i2);
      class Uie extends he {
        constructor(e) {
          super(), this.model = e, this._map = new PG(), this._register(Ze(() => {
            this.model.deltaDecorations([
              ...this._map.values()
            ], []), this._map.clear();
          }));
        }
        update(e) {
          const { added: t, removed: i } = Wie(new Set(this._map.keys()), new Set(e));
          if (t.length === 0 && i.length === 0) return false;
          const n = i.map((a) => this._map.get(a)), o = t.map((a) => ({
            range: this._createDecorationRange(this.model, a),
            options: this._createDecorationOption(a)
          })), r = this.model.deltaDecorations(n, o);
          for (const a of i) this._map.delete(a);
          for (let a = 0; a < r.length; a++) this._map.set(t[a], r[a]);
          return true;
        }
        getMarker(e) {
          return this._map.getKey(e.id);
        }
        _createDecorationRange(e, t) {
          let i = z.lift(t);
          if (t.severity === Ro.Hint && !this._hasMarkerTag(t, 1) && !this._hasMarkerTag(t, 2) && (i = i.setEndPosition(i.startLineNumber, i.startColumn + 2)), i = e.validateRange(i), i.isEmpty()) {
            const n = e.getLineLastNonWhitespaceColumn(i.startLineNumber) || e.getLineMaxColumn(i.startLineNumber);
            if (n === 1 || i.endColumn >= n) return i;
            const o = e.getWordAtPosition(i.getStartPosition());
            o && (i = new z(i.startLineNumber, o.startColumn, i.endLineNumber, o.endColumn));
          } else if (t.endColumn === Number.MAX_VALUE && t.startColumn === 1 && i.startLineNumber === i.endLineNumber) {
            const n = e.getLineFirstNonWhitespaceColumn(t.startLineNumber);
            n < i.endColumn && (i = new z(i.startLineNumber, n, i.endLineNumber, i.endColumn), t.startColumn = n);
          }
          return i;
        }
        _createDecorationOption(e) {
          let t, i, n, o, r;
          switch (e.severity) {
            case Ro.Hint:
              this._hasMarkerTag(e, 2) ? t = void 0 : this._hasMarkerTag(e, 1) ? t = "squiggly-unnecessary" : t = "squiggly-hint", n = 0;
              break;
            case Ro.Info:
              t = "squiggly-info", i = Qd(kie), n = 10, r = {
                color: Qd(XZ),
                position: 1
              };
              break;
            case Ro.Warning:
              t = "squiggly-warning", i = Qd(xie), n = 20, r = {
                color: Qd(JZ),
                position: 1
              };
              break;
            case Ro.Error:
            default:
              t = "squiggly-error", i = Qd(Lie), n = 30, r = {
                color: Qd(eQ),
                position: 1
              };
              break;
          }
          return e.tags && (e.tags.indexOf(1) !== -1 && (o = "squiggly-inline-unnecessary"), e.tags.indexOf(2) !== -1 && (o = "squiggly-inline-deprecated")), {
            description: "marker-decoration",
            stickiness: 1,
            className: t,
            showIfCollapsed: true,
            overviewRuler: {
              color: i,
              position: fv.Right
            },
            minimap: r,
            zIndex: n,
            inlineClassName: o
          };
        }
        _hasMarkerTag(e, t) {
          return e.tags ? e.tags.indexOf(t) >= 0 : false;
        }
      }
      const mB = pt("markerDecorationsService");
      class Gi {
        static _nextVisibleColumn(e, t, i) {
          return e === 9 ? Gi.nextRenderTabStop(t, i) : nu(e) || QE(e) ? t + 2 : t + 1;
        }
        static visibleColumnFromColumn(e, t, i) {
          const n = Math.min(t - 1, e.length), o = e.substring(0, n), r = new tv(o);
          let a = 0;
          for (; !r.eol(); ) {
            const l = ev(o, n, r.offset);
            r.nextGraphemeLength(), a = this._nextVisibleColumn(l, a, i);
          }
          return a;
        }
        static columnFromVisibleColumn(e, t, i) {
          if (t <= 0) return 1;
          const n = e.length, o = new tv(e);
          let r = 0, a = 1;
          for (; !o.eol(); ) {
            const l = ev(e, n, o.offset);
            o.nextGraphemeLength();
            const u = this._nextVisibleColumn(l, r, i), d = o.offset + 1;
            if (u >= t) {
              const f = t - r;
              return u - t < f ? d : a;
            }
            r = u, a = d;
          }
          return n + 1;
        }
        static nextRenderTabStop(e, t) {
          return e + t - e % t;
        }
        static nextIndentTabStop(e, t) {
          return e + t - e % t;
        }
        static prevRenderTabStop(e, t) {
          return Math.max(0, e - 1 - (e - 1) % t);
        }
        static prevIndentTabStop(e, t) {
          return Math.max(0, e - 1 - (e - 1) % t);
        }
      }
      function $ie(s, e, t) {
        let i = 0;
        for (let o = 0; o < s.length; o++) s.charAt(o) === "	" ? i = Gi.nextIndentTabStop(i, e) : i++;
        let n = "";
        if (!t) {
          const o = Math.floor(i / e);
          i = i % e;
          for (let r = 0; r < o; r++) n += "	";
        }
        for (let o = 0; o < i; o++) n += " ";
        return n;
      }
      function pB(s, e, t) {
        let i = qs(s);
        return i === -1 && (i = s.length), $ie(s.substring(0, i), e, t) + s.substring(i);
      }
      class yP {
        constructor(e, t, i, n) {
          this.range = e, this.nestingLevel = t, this.nestingLevelOfEqualBracketType = i, this.isInvalid = n;
        }
      }
      class qie {
        constructor(e, t, i, n, o, r) {
          this.range = e, this.openingBracketRange = t, this.closingBracketRange = i, this.nestingLevel = n, this.nestingLevelOfEqualBracketType = o, this.bracketPairNode = r;
        }
        get openingBracketInfo() {
          return this.bracketPairNode.openingBracket.bracketInfo;
        }
      }
      class Kie extends qie {
        constructor(e, t, i, n, o, r, a) {
          super(e, t, i, n, o, r), this.minVisibleColumnIndentation = a;
        }
      }
      function jie(s, e, t, i) {
        return s !== t ? Ni(t - s, i) : Ni(0, i - e);
      }
      const Ns = 0;
      function zv(s) {
        return s === 0;
      }
      const uo = 2 ** 26;
      function Ni(s, e) {
        return s * uo + e;
      }
      function Vo(s) {
        const e = s, t = Math.floor(e / uo), i = e - t * uo;
        return new cr(t, i);
      }
      function Gie(s) {
        return Math.floor(s / uo);
      }
      function Wi(s, e) {
        let t = s + e;
        return e >= uo && (t = t - s % uo), t;
      }
      function Yie(s, e) {
        return s.reduce((t, i) => Wi(t, e(i)), Ns);
      }
      function _B(s, e) {
        return s === e;
      }
      function d_(s, e) {
        const t = s, i = e;
        if (i - t <= 0) return Ns;
        const o = Math.floor(t / uo), r = Math.floor(i / uo), a = i - r * uo;
        if (o === r) {
          const l = t - o * uo;
          return Ni(0, a - l);
        } else return Ni(r - o, a);
      }
      function Uf(s, e) {
        return s < e;
      }
      function $f(s, e) {
        return s <= e;
      }
      function ap(s, e) {
        return s >= e;
      }
      function yf(s) {
        return Ni(s.lineNumber - 1, s.column - 1);
      }
      function Sh(s, e) {
        const t = s, i = Math.floor(t / uo), n = t - i * uo, o = e, r = Math.floor(o / uo), a = o - r * uo;
        return new z(i + 1, n + 1, r + 1, a + 1);
      }
      function Zie(s) {
        const e = xg(s);
        return Ni(e.length - 1, e[e.length - 1].length);
      }
      class Il {
        static fromModelContentChanges(e) {
          return e.map((i) => {
            const n = z.lift(i.range);
            return new Il(yf(n.getStartPosition()), yf(n.getEndPosition()), Zie(i.text));
          }).reverse();
        }
        constructor(e, t, i) {
          this.startOffset = e, this.endOffset = t, this.newLength = i;
        }
        toString() {
          return `[${Vo(this.startOffset)}...${Vo(this.endOffset)}) -> ${Vo(this.newLength)}`;
        }
      }
      class Qie {
        constructor(e) {
          this.nextEditIdx = 0, this.deltaOldToNewLineCount = 0, this.deltaOldToNewColumnCount = 0, this.deltaLineIdxInOld = -1, this.edits = e.map((t) => lN.from(t));
        }
        getOffsetBeforeChange(e) {
          return this.adjustNextEdit(e), this.translateCurToOld(e);
        }
        getDistanceToNextChange(e) {
          this.adjustNextEdit(e);
          const t = this.edits[this.nextEditIdx], i = t ? this.translateOldToCur(t.offsetObj) : null;
          return i === null ? null : d_(e, i);
        }
        translateOldToCur(e) {
          return e.lineCount === this.deltaLineIdxInOld ? Ni(e.lineCount + this.deltaOldToNewLineCount, e.columnCount + this.deltaOldToNewColumnCount) : Ni(e.lineCount + this.deltaOldToNewLineCount, e.columnCount);
        }
        translateCurToOld(e) {
          const t = Vo(e);
          return t.lineCount - this.deltaOldToNewLineCount === this.deltaLineIdxInOld ? Ni(t.lineCount - this.deltaOldToNewLineCount, t.columnCount - this.deltaOldToNewColumnCount) : Ni(t.lineCount - this.deltaOldToNewLineCount, t.columnCount);
        }
        adjustNextEdit(e) {
          for (; this.nextEditIdx < this.edits.length; ) {
            const t = this.edits[this.nextEditIdx], i = this.translateOldToCur(t.endOffsetAfterObj);
            if ($f(i, e)) {
              this.nextEditIdx++;
              const n = Vo(i), o = Vo(this.translateOldToCur(t.endOffsetBeforeObj)), r = n.lineCount - o.lineCount;
              this.deltaOldToNewLineCount += r;
              const a = this.deltaLineIdxInOld === t.endOffsetBeforeObj.lineCount ? this.deltaOldToNewColumnCount : 0, l = n.columnCount - o.columnCount;
              this.deltaOldToNewColumnCount = a + l, this.deltaLineIdxInOld = t.endOffsetBeforeObj.lineCount;
            } else break;
          }
        }
      }
      class lN {
        static from(e) {
          return new lN(e.startOffset, e.endOffset, e.newLength);
        }
        constructor(e, t, i) {
          this.endOffsetBeforeObj = Vo(t), this.endOffsetAfterObj = Vo(Wi(e, i)), this.offsetObj = Vo(e);
        }
      }
      const Kb = [];
      const _Ki = class _Ki {
        static create(e, t) {
          if (e <= 128 && t.length === 0) {
            let i = _Ki.cache[e];
            return i || (i = new _Ki(e, t), _Ki.cache[e] = i), i;
          }
          return new _Ki(e, t);
        }
        static getEmpty() {
          return this.empty;
        }
        constructor(e, t) {
          this.items = e, this.additionalItems = t;
        }
        add(e, t) {
          const i = t.getKey(e);
          let n = i >> 5;
          if (n === 0) {
            const r = 1 << i | this.items;
            return r === this.items ? this : _Ki.create(r, this.additionalItems);
          }
          n--;
          const o = this.additionalItems.slice(0);
          for (; o.length < n; ) o.push(0);
          return o[n] |= 1 << (i & 31), _Ki.create(this.items, o);
        }
        merge(e) {
          const t = this.items | e.items;
          if (this.additionalItems === Kb && e.additionalItems === Kb) return t === this.items ? this : t === e.items ? e : _Ki.create(t, Kb);
          const i = [];
          for (let n = 0; n < Math.max(this.additionalItems.length, e.additionalItems.length); n++) {
            const o = this.additionalItems[n] || 0, r = e.additionalItems[n] || 0;
            i.push(o | r);
          }
          return _Ki.create(t, i);
        }
        intersects(e) {
          if ((this.items & e.items) !== 0) return true;
          for (let t = 0; t < Math.min(this.additionalItems.length, e.additionalItems.length); t++) if ((this.additionalItems[t] & e.additionalItems[t]) !== 0) return true;
          return false;
        }
      };
      _Ki.cache = new Array(129);
      _Ki.empty = _Ki.create(0, Kb);
      let Ki = _Ki;
      const SP = {
        getKey(s) {
          return s;
        }
      };
      class Xie {
        constructor() {
          this.items = /* @__PURE__ */ new Map();
        }
        getKey(e) {
          let t = this.items.get(e);
          return t === void 0 && (t = this.items.size, this.items.set(e, t)), t;
        }
      }
      class cN {
        get length() {
          return this._length;
        }
        constructor(e) {
          this._length = e;
        }
      }
      class f_ extends cN {
        static create(e, t, i) {
          let n = e.length;
          return t && (n = Wi(n, t.length)), i && (n = Wi(n, i.length)), new f_(n, e, t, i, t ? t.missingOpeningBracketIds : Ki.getEmpty());
        }
        get kind() {
          return 2;
        }
        get listHeight() {
          return 0;
        }
        get childrenLength() {
          return 3;
        }
        getChild(e) {
          switch (e) {
            case 0:
              return this.openingBracket;
            case 1:
              return this.child;
            case 2:
              return this.closingBracket;
          }
          throw new Error("Invalid child index");
        }
        get children() {
          const e = [];
          return e.push(this.openingBracket), this.child && e.push(this.child), this.closingBracket && e.push(this.closingBracket), e;
        }
        constructor(e, t, i, n, o) {
          super(e), this.openingBracket = t, this.child = i, this.closingBracket = n, this.missingOpeningBracketIds = o;
        }
        canBeReused(e) {
          return !(this.closingBracket === null || e.intersects(this.missingOpeningBracketIds));
        }
        deepClone() {
          return new f_(this.length, this.openingBracket.deepClone(), this.child && this.child.deepClone(), this.closingBracket && this.closingBracket.deepClone(), this.missingOpeningBracketIds);
        }
        computeMinIndentation(e, t) {
          return this.child ? this.child.computeMinIndentation(Wi(e, this.openingBracket.length), t) : Number.MAX_SAFE_INTEGER;
        }
      }
      class Ia extends cN {
        static create23(e, t, i, n = false) {
          let o = e.length, r = e.missingOpeningBracketIds;
          if (e.listHeight !== t.listHeight) throw new Error("Invalid list heights");
          if (o = Wi(o, t.length), r = r.merge(t.missingOpeningBracketIds), i) {
            if (e.listHeight !== i.listHeight) throw new Error("Invalid list heights");
            o = Wi(o, i.length), r = r.merge(i.missingOpeningBracketIds);
          }
          return n ? new Jie(o, e.listHeight + 1, e, t, i, r) : new g_(o, e.listHeight + 1, e, t, i, r);
        }
        static getEmpty() {
          return new ene(Ns, 0, [], Ki.getEmpty());
        }
        get kind() {
          return 4;
        }
        get missingOpeningBracketIds() {
          return this._missingOpeningBracketIds;
        }
        constructor(e, t, i) {
          super(e), this.listHeight = t, this._missingOpeningBracketIds = i, this.cachedMinIndentation = -1;
        }
        throwIfImmutable() {
        }
        makeLastElementMutable() {
          this.throwIfImmutable();
          const e = this.childrenLength;
          if (e === 0) return;
          const t = this.getChild(e - 1), i = t.kind === 4 ? t.toMutable() : t;
          return t !== i && this.setChild(e - 1, i), i;
        }
        makeFirstElementMutable() {
          if (this.throwIfImmutable(), this.childrenLength === 0) return;
          const t = this.getChild(0), i = t.kind === 4 ? t.toMutable() : t;
          return t !== i && this.setChild(0, i), i;
        }
        canBeReused(e) {
          if (e.intersects(this.missingOpeningBracketIds) || this.childrenLength === 0) return false;
          let t = this;
          for (; t.kind === 4; ) {
            const i = t.childrenLength;
            if (i === 0) throw new It();
            t = t.getChild(i - 1);
          }
          return t.canBeReused(e);
        }
        handleChildrenChanged() {
          this.throwIfImmutable();
          const e = this.childrenLength;
          let t = this.getChild(0).length, i = this.getChild(0).missingOpeningBracketIds;
          for (let n = 1; n < e; n++) {
            const o = this.getChild(n);
            t = Wi(t, o.length), i = i.merge(o.missingOpeningBracketIds);
          }
          this._length = t, this._missingOpeningBracketIds = i, this.cachedMinIndentation = -1;
        }
        computeMinIndentation(e, t) {
          if (this.cachedMinIndentation !== -1) return this.cachedMinIndentation;
          let i = Number.MAX_SAFE_INTEGER, n = e;
          for (let o = 0; o < this.childrenLength; o++) {
            const r = this.getChild(o);
            r && (i = Math.min(i, r.computeMinIndentation(n, t)), n = Wi(n, r.length));
          }
          return this.cachedMinIndentation = i, i;
        }
      }
      class g_ extends Ia {
        get childrenLength() {
          return this._item3 !== null ? 3 : 2;
        }
        getChild(e) {
          switch (e) {
            case 0:
              return this._item1;
            case 1:
              return this._item2;
            case 2:
              return this._item3;
          }
          throw new Error("Invalid child index");
        }
        setChild(e, t) {
          switch (e) {
            case 0:
              this._item1 = t;
              return;
            case 1:
              this._item2 = t;
              return;
            case 2:
              this._item3 = t;
              return;
          }
          throw new Error("Invalid child index");
        }
        get children() {
          return this._item3 ? [
            this._item1,
            this._item2,
            this._item3
          ] : [
            this._item1,
            this._item2
          ];
        }
        get item1() {
          return this._item1;
        }
        get item2() {
          return this._item2;
        }
        get item3() {
          return this._item3;
        }
        constructor(e, t, i, n, o, r) {
          super(e, t, r), this._item1 = i, this._item2 = n, this._item3 = o;
        }
        deepClone() {
          return new g_(this.length, this.listHeight, this._item1.deepClone(), this._item2.deepClone(), this._item3 ? this._item3.deepClone() : null, this.missingOpeningBracketIds);
        }
        appendChildOfSameHeight(e) {
          if (this._item3) throw new Error("Cannot append to a full (2,3) tree node");
          this.throwIfImmutable(), this._item3 = e, this.handleChildrenChanged();
        }
        unappendChild() {
          if (!this._item3) throw new Error("Cannot remove from a non-full (2,3) tree node");
          this.throwIfImmutable();
          const e = this._item3;
          return this._item3 = null, this.handleChildrenChanged(), e;
        }
        prependChildOfSameHeight(e) {
          if (this._item3) throw new Error("Cannot prepend to a full (2,3) tree node");
          this.throwIfImmutable(), this._item3 = this._item2, this._item2 = this._item1, this._item1 = e, this.handleChildrenChanged();
        }
        unprependChild() {
          if (!this._item3) throw new Error("Cannot remove from a non-full (2,3) tree node");
          this.throwIfImmutable();
          const e = this._item1;
          return this._item1 = this._item2, this._item2 = this._item3, this._item3 = null, this.handleChildrenChanged(), e;
        }
        toMutable() {
          return this;
        }
      }
      class Jie extends g_ {
        toMutable() {
          return new g_(this.length, this.listHeight, this.item1, this.item2, this.item3, this.missingOpeningBracketIds);
        }
        throwIfImmutable() {
          throw new Error("this instance is immutable");
        }
      }
      class Uv extends Ia {
        get childrenLength() {
          return this._children.length;
        }
        getChild(e) {
          return this._children[e];
        }
        setChild(e, t) {
          this._children[e] = t;
        }
        get children() {
          return this._children;
        }
        constructor(e, t, i, n) {
          super(e, t, n), this._children = i;
        }
        deepClone() {
          const e = new Array(this._children.length);
          for (let t = 0; t < this._children.length; t++) e[t] = this._children[t].deepClone();
          return new Uv(this.length, this.listHeight, e, this.missingOpeningBracketIds);
        }
        appendChildOfSameHeight(e) {
          this.throwIfImmutable(), this._children.push(e), this.handleChildrenChanged();
        }
        unappendChild() {
          this.throwIfImmutable();
          const e = this._children.pop();
          return this.handleChildrenChanged(), e;
        }
        prependChildOfSameHeight(e) {
          this.throwIfImmutable(), this._children.unshift(e), this.handleChildrenChanged();
        }
        unprependChild() {
          this.throwIfImmutable();
          const e = this._children.shift();
          return this.handleChildrenChanged(), e;
        }
        toMutable() {
          return this;
        }
      }
      class ene extends Uv {
        toMutable() {
          return new Uv(this.length, this.listHeight, [
            ...this.children
          ], this.missingOpeningBracketIds);
        }
        throwIfImmutable() {
          throw new Error("this instance is immutable");
        }
      }
      const tne = [];
      class uN extends cN {
        get listHeight() {
          return 0;
        }
        get childrenLength() {
          return 0;
        }
        getChild(e) {
          return null;
        }
        get children() {
          return tne;
        }
        deepClone() {
          return this;
        }
      }
      class nh extends uN {
        get kind() {
          return 0;
        }
        get missingOpeningBracketIds() {
          return Ki.getEmpty();
        }
        canBeReused(e) {
          return true;
        }
        computeMinIndentation(e, t) {
          const i = Vo(e), n = (i.columnCount === 0 ? i.lineCount : i.lineCount + 1) + 1, o = Gie(Wi(e, this.length)) + 1;
          let r = Number.MAX_SAFE_INTEGER;
          for (let a = n; a <= o; a++) {
            const l = t.getLineFirstNonWhitespaceColumn(a), u = t.getLineContent(a);
            if (l === 0) continue;
            const d = Gi.visibleColumnFromColumn(u, l, t.getOptions().tabSize);
            r = Math.min(r, d);
          }
          return r;
        }
      }
      class $v extends uN {
        static create(e, t, i) {
          return new $v(e, t, i);
        }
        get kind() {
          return 1;
        }
        get missingOpeningBracketIds() {
          return Ki.getEmpty();
        }
        constructor(e, t, i) {
          super(e), this.bracketInfo = t, this.bracketIds = i;
        }
        get text() {
          return this.bracketInfo.bracketText;
        }
        get languageId() {
          return this.bracketInfo.languageId;
        }
        canBeReused(e) {
          return false;
        }
        computeMinIndentation(e, t) {
          return Number.MAX_SAFE_INTEGER;
        }
      }
      class ine extends uN {
        get kind() {
          return 3;
        }
        constructor(e, t) {
          super(t), this.missingOpeningBracketIds = e;
        }
        canBeReused(e) {
          return !e.intersects(this.missingOpeningBracketIds);
        }
        computeMinIndentation(e, t) {
          return Number.MAX_SAFE_INTEGER;
        }
      }
      class Oc {
        constructor(e, t, i, n, o) {
          this.length = e, this.kind = t, this.bracketId = i, this.bracketIds = n, this.astNode = o;
        }
      }
      class nne {
        constructor(e, t) {
          this.textModel = e, this.bracketTokens = t, this.reader = new sne(this.textModel, this.bracketTokens), this._offset = Ns, this.didPeek = false, this.peeked = null, this.textBufferLineCount = e.getLineCount(), this.textBufferLastLineLength = e.getLineLength(this.textBufferLineCount);
        }
        get offset() {
          return this._offset;
        }
        get length() {
          return Ni(this.textBufferLineCount - 1, this.textBufferLastLineLength);
        }
        skip(e) {
          this.didPeek = false, this._offset = Wi(this._offset, e);
          const t = Vo(this._offset);
          this.reader.setPosition(t.lineCount, t.columnCount);
        }
        read() {
          let e;
          return this.peeked ? (this.didPeek = false, e = this.peeked) : e = this.reader.read(), e && (this._offset = Wi(this._offset, e.length)), e;
        }
        peek() {
          return this.didPeek || (this.peeked = this.reader.read(), this.didPeek = true), this.peeked;
        }
      }
      class sne {
        constructor(e, t) {
          this.textModel = e, this.bracketTokens = t, this.lineIdx = 0, this.line = null, this.lineCharOffset = 0, this.lineTokens = null, this.lineTokenOffset = 0, this.peekedToken = null, this.textBufferLineCount = e.getLineCount(), this.textBufferLastLineLength = e.getLineLength(this.textBufferLineCount);
        }
        setPosition(e, t) {
          e === this.lineIdx ? (this.lineCharOffset = t, this.line !== null && (this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset))) : (this.lineIdx = e, this.lineCharOffset = t, this.line = null), this.peekedToken = null;
        }
        read() {
          if (this.peekedToken) {
            const o = this.peekedToken;
            return this.peekedToken = null, this.lineCharOffset += o.length, o;
          }
          if (this.lineIdx > this.textBufferLineCount - 1 || this.lineIdx === this.textBufferLineCount - 1 && this.lineCharOffset >= this.textBufferLastLineLength) return null;
          this.line === null && (this.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1), this.line = this.lineTokens.getLineContent(), this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset));
          const e = this.lineIdx, t = this.lineCharOffset;
          let i = 0;
          for (; ; ) {
            const o = this.lineTokens, r = o.getCount();
            let a = null;
            if (this.lineTokenOffset < r) {
              const l = o.getMetadata(this.lineTokenOffset);
              for (; this.lineTokenOffset + 1 < r && l === o.getMetadata(this.lineTokenOffset + 1); ) this.lineTokenOffset++;
              const u = Pr.getTokenType(l) === 0, d = Pr.containsBalancedBrackets(l), f = o.getEndOffset(this.lineTokenOffset);
              if (d && u && this.lineCharOffset < f) {
                const m = o.getLanguageId(this.lineTokenOffset), _ = this.line.substring(this.lineCharOffset, f), b = this.bracketTokens.getSingleLanguageBracketTokens(m), v = b.regExpGlobal;
                if (v) {
                  v.lastIndex = 0;
                  const y = v.exec(_);
                  y && (a = b.getToken(y[0]), a && (this.lineCharOffset += y.index));
                }
              }
              if (i += f - this.lineCharOffset, a) if (e !== this.lineIdx || t !== this.lineCharOffset) {
                this.peekedToken = a;
                break;
              } else return this.lineCharOffset += a.length, a;
              else this.lineTokenOffset++, this.lineCharOffset = f;
            } else if (this.lineIdx === this.textBufferLineCount - 1 || (this.lineIdx++, this.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1), this.lineTokenOffset = 0, this.line = this.lineTokens.getLineContent(), this.lineCharOffset = 0, i += 33, i > 1e3)) break;
            if (i > 1500) break;
          }
          const n = jie(e, t, this.lineIdx, this.lineCharOffset);
          return new Oc(n, 0, -1, Ki.getEmpty(), new nh(n));
        }
      }
      class one {
        constructor(e, t) {
          this.text = e, this._offset = Ns, this.idx = 0;
          const i = t.getRegExpStr(), n = i ? new RegExp(i + `|
`, "gi") : null, o = [];
          let r, a = 0, l = 0, u = 0, d = 0;
          const f = [];
          for (let b = 0; b < 60; b++) f.push(new Oc(Ni(0, b), 0, -1, Ki.getEmpty(), new nh(Ni(0, b))));
          const m = [];
          for (let b = 0; b < 60; b++) m.push(new Oc(Ni(1, b), 0, -1, Ki.getEmpty(), new nh(Ni(1, b))));
          if (n) for (n.lastIndex = 0; (r = n.exec(e)) !== null; ) {
            const b = r.index, v = r[0];
            if (v === `
`) a++, l = b + 1;
            else {
              if (u !== b) {
                let y;
                if (d === a) {
                  const x = b - u;
                  if (x < f.length) y = f[x];
                  else {
                    const L = Ni(0, x);
                    y = new Oc(L, 0, -1, Ki.getEmpty(), new nh(L));
                  }
                } else {
                  const x = a - d, L = b - l;
                  if (x === 1 && L < m.length) y = m[L];
                  else {
                    const D = Ni(x, L);
                    y = new Oc(D, 0, -1, Ki.getEmpty(), new nh(D));
                  }
                }
                o.push(y);
              }
              o.push(t.getToken(v)), u = b + v.length, d = a;
            }
          }
          const _ = e.length;
          if (u !== _) {
            const b = d === a ? Ni(0, _ - u) : Ni(a - d, _ - l);
            o.push(new Oc(b, 0, -1, Ki.getEmpty(), new nh(b)));
          }
          this.length = Ni(a, _ - l), this.tokens = o;
        }
        get offset() {
          return this._offset;
        }
        read() {
          return this.tokens[this.idx++] || null;
        }
        peek() {
          return this.tokens[this.idx] || null;
        }
        skip(e) {
          throw new P$();
        }
      }
      class hN {
        static createFromLanguage(e, t) {
          function i(o) {
            return t.getKey(`${o.languageId}:::${o.bracketText}`);
          }
          const n = /* @__PURE__ */ new Map();
          for (const o of e.bracketsNew.openingBrackets) {
            const r = Ni(0, o.bracketText.length), a = i(o), l = Ki.getEmpty().add(a, SP);
            n.set(o.bracketText, new Oc(r, 1, a, l, $v.create(r, o, l)));
          }
          for (const o of e.bracketsNew.closingBrackets) {
            const r = Ni(0, o.bracketText.length);
            let a = Ki.getEmpty();
            const l = o.getOpeningBrackets();
            for (const u of l) a = a.add(i(u), SP);
            n.set(o.bracketText, new Oc(r, 2, i(l[0]), a, $v.create(r, o, a)));
          }
          return new hN(n);
        }
        constructor(e) {
          this.map = e, this.hasRegExp = false, this._regExpGlobal = null;
        }
        getRegExpStr() {
          if (this.isEmpty) return null;
          {
            const e = [
              ...this.map.keys()
            ];
            return e.sort(), e.reverse(), e.map((t) => rne(t)).join("|");
          }
        }
        get regExpGlobal() {
          if (!this.hasRegExp) {
            const e = this.getRegExpStr();
            this._regExpGlobal = e ? new RegExp(e, "gi") : null, this.hasRegExp = true;
          }
          return this._regExpGlobal;
        }
        getToken(e) {
          return this.map.get(e.toLowerCase());
        }
        findClosingTokenText(e) {
          for (const [t, i] of this.map) if (i.kind === 2 && i.bracketIds.intersects(e)) return t;
        }
        get isEmpty() {
          return this.map.size === 0;
        }
      }
      function rne(s) {
        let e = $l(s);
        return /^[\w ]+/.test(s) && (e = `\\b${e}`), /[\w ]+$/.test(s) && (e = `${e}\\b`), e;
      }
      class ane {
        constructor(e, t) {
          this.denseKeyProvider = e, this.getLanguageConfiguration = t, this.languageIdToBracketTokens = /* @__PURE__ */ new Map();
        }
        didLanguageChange(e) {
          return this.languageIdToBracketTokens.has(e);
        }
        getSingleLanguageBracketTokens(e) {
          let t = this.languageIdToBracketTokens.get(e);
          return t || (t = hN.createFromLanguage(this.getLanguageConfiguration(e), this.denseKeyProvider), this.languageIdToBracketTokens.set(e, t)), t;
        }
      }
      function lne(s) {
        if (s.length === 0) return null;
        if (s.length === 1) return s[0];
        let e = 0;
        function t() {
          if (e >= s.length) return null;
          const r = e, a = s[r].listHeight;
          for (e++; e < s.length && s[e].listHeight === a; ) e++;
          return e - r >= 2 ? bB(r === 0 && e === s.length ? s : s.slice(r, e), false) : s[r];
        }
        let i = t(), n = t();
        if (!n) return i;
        for (let r = t(); r; r = t()) LP(i, n) <= LP(n, r) ? (i = JL(i, n), n = r) : n = JL(n, r);
        return JL(i, n);
      }
      function bB(s, e = false) {
        if (s.length === 0) return null;
        if (s.length === 1) return s[0];
        let t = s.length;
        for (; t > 3; ) {
          const i = t >> 1;
          for (let n = 0; n < i; n++) {
            const o = n << 1;
            s[n] = Ia.create23(s[o], s[o + 1], o + 3 === t ? s[o + 2] : null, e);
          }
          t = i;
        }
        return Ia.create23(s[0], s[1], t >= 3 ? s[2] : null, e);
      }
      function LP(s, e) {
        return Math.abs(s.listHeight - e.listHeight);
      }
      function JL(s, e) {
        return s.listHeight === e.listHeight ? Ia.create23(s, e, null, false) : s.listHeight > e.listHeight ? cne(s, e) : une(e, s);
      }
      function cne(s, e) {
        s = s.toMutable();
        let t = s;
        const i = [];
        let n;
        for (; ; ) {
          if (e.listHeight === t.listHeight) {
            n = e;
            break;
          }
          if (t.kind !== 4) throw new Error("unexpected");
          i.push(t), t = t.makeLastElementMutable();
        }
        for (let o = i.length - 1; o >= 0; o--) {
          const r = i[o];
          n ? r.childrenLength >= 3 ? n = Ia.create23(r.unappendChild(), n, null, false) : (r.appendChildOfSameHeight(n), n = void 0) : r.handleChildrenChanged();
        }
        return n ? Ia.create23(s, n, null, false) : s;
      }
      function une(s, e) {
        s = s.toMutable();
        let t = s;
        const i = [];
        for (; e.listHeight !== t.listHeight; ) {
          if (t.kind !== 4) throw new Error("unexpected");
          i.push(t), t = t.makeFirstElementMutable();
        }
        let n = e;
        for (let o = i.length - 1; o >= 0; o--) {
          const r = i[o];
          n ? r.childrenLength >= 3 ? n = Ia.create23(n, r.unprependChild(), null, false) : (r.prependChildOfSameHeight(n), n = void 0) : r.handleChildrenChanged();
        }
        return n ? Ia.create23(n, s, null, false) : s;
      }
      class hne {
        constructor(e) {
          this.lastOffset = Ns, this.nextNodes = [
            e
          ], this.offsets = [
            Ns
          ], this.idxs = [];
        }
        readLongestNodeAt(e, t) {
          if (Uf(e, this.lastOffset)) throw new Error("Invalid offset");
          for (this.lastOffset = e; ; ) {
            const i = zm(this.nextNodes);
            if (!i) return;
            const n = zm(this.offsets);
            if (Uf(e, n)) return;
            if (Uf(n, e)) if (Wi(n, i.length) <= e) this.nextNodeAfterCurrent();
            else {
              const o = ex(i);
              o !== -1 ? (this.nextNodes.push(i.getChild(o)), this.offsets.push(n), this.idxs.push(o)) : this.nextNodeAfterCurrent();
            }
            else {
              if (t(i)) return this.nextNodeAfterCurrent(), i;
              {
                const o = ex(i);
                if (o === -1) {
                  this.nextNodeAfterCurrent();
                  return;
                } else this.nextNodes.push(i.getChild(o)), this.offsets.push(n), this.idxs.push(o);
              }
            }
          }
        }
        nextNodeAfterCurrent() {
          for (; ; ) {
            const e = zm(this.offsets), t = zm(this.nextNodes);
            if (this.nextNodes.pop(), this.offsets.pop(), this.idxs.length === 0) break;
            const i = zm(this.nextNodes), n = ex(i, this.idxs[this.idxs.length - 1]);
            if (n !== -1) {
              this.nextNodes.push(i.getChild(n)), this.offsets.push(Wi(e, t.length)), this.idxs[this.idxs.length - 1] = n;
              break;
            } else this.idxs.pop();
          }
        }
      }
      function ex(s, e = -1) {
        for (; ; ) {
          if (e++, e >= s.childrenLength) return -1;
          if (s.getChild(e)) return e;
        }
      }
      function zm(s) {
        return s.length > 0 ? s[s.length - 1] : void 0;
      }
      function xP(s, e, t, i) {
        return new dne(s, e, t, i).parseDocument();
      }
      class dne {
        constructor(e, t, i, n) {
          if (this.tokenizer = e, this.createImmutableLists = n, this._itemsConstructed = 0, this._itemsFromCache = 0, i && n) throw new Error("Not supported");
          this.oldNodeReader = i ? new hne(i) : void 0, this.positionMapper = new Qie(t);
        }
        parseDocument() {
          this._itemsConstructed = 0, this._itemsFromCache = 0;
          let e = this.parseList(Ki.getEmpty(), 0);
          return e || (e = Ia.getEmpty()), e;
        }
        parseList(e, t) {
          const i = [];
          for (; ; ) {
            let o = this.tryReadChildFromCache(e);
            if (!o) {
              const r = this.tokenizer.peek();
              if (!r || r.kind === 2 && r.bracketIds.intersects(e)) break;
              o = this.parseChild(e, t + 1);
            }
            o.kind === 4 && o.childrenLength === 0 || i.push(o);
          }
          return this.oldNodeReader ? lne(i) : bB(i, this.createImmutableLists);
        }
        tryReadChildFromCache(e) {
          if (this.oldNodeReader) {
            const t = this.positionMapper.getDistanceToNextChange(this.tokenizer.offset);
            if (t === null || !zv(t)) {
              const i = this.oldNodeReader.readLongestNodeAt(this.positionMapper.getOffsetBeforeChange(this.tokenizer.offset), (n) => t !== null && !Uf(n.length, t) ? false : n.canBeReused(e));
              if (i) return this._itemsFromCache++, this.tokenizer.skip(i.length), i;
            }
          }
        }
        parseChild(e, t) {
          this._itemsConstructed++;
          const i = this.tokenizer.read();
          switch (i.kind) {
            case 2:
              return new ine(i.bracketIds, i.length);
            case 0:
              return i.astNode;
            case 1: {
              if (t > 300) return new nh(i.length);
              const n = e.merge(i.bracketIds), o = this.parseList(n, t + 1), r = this.tokenizer.peek();
              return r && r.kind === 2 && (r.bracketId === i.bracketId || r.bracketIds.intersects(i.bracketIds)) ? (this.tokenizer.read(), f_.create(i.astNode, o, r.astNode)) : f_.create(i.astNode, o, null);
            }
            default:
              throw new Error("unexpected");
          }
        }
      }
      function qv(s, e) {
        if (s.length === 0) return e;
        if (e.length === 0) return s;
        const t = new zl(kP(s)), i = kP(e);
        i.push({
          modified: false,
          lengthBefore: void 0,
          lengthAfter: void 0
        });
        let n = t.dequeue();
        function o(u) {
          if (u === void 0) {
            const f = t.takeWhile((m) => true) || [];
            return n && f.unshift(n), f;
          }
          const d = [];
          for (; n && !zv(u); ) {
            const [f, m] = n.splitAt(u);
            d.push(f), u = d_(f.lengthAfter, u), n = m ?? t.dequeue();
          }
          return zv(u) || d.push(new qc(false, u, u)), d;
        }
        const r = [];
        function a(u, d, f) {
          if (r.length > 0 && _B(r[r.length - 1].endOffset, u)) {
            const m = r[r.length - 1];
            r[r.length - 1] = new Il(m.startOffset, d, Wi(m.newLength, f));
          } else r.push({
            startOffset: u,
            endOffset: d,
            newLength: f
          });
        }
        let l = Ns;
        for (const u of i) {
          const d = o(u.lengthBefore);
          if (u.modified) {
            const f = Yie(d, (_) => _.lengthBefore), m = Wi(l, f);
            a(l, m, u.lengthAfter), l = m;
          } else for (const f of d) {
            const m = l;
            l = Wi(l, f.lengthBefore), f.modified && a(m, l, f.lengthAfter);
          }
        }
        return r;
      }
      class qc {
        constructor(e, t, i) {
          this.modified = e, this.lengthBefore = t, this.lengthAfter = i;
        }
        splitAt(e) {
          const t = d_(e, this.lengthAfter);
          return _B(t, Ns) ? [
            this,
            void 0
          ] : this.modified ? [
            new qc(this.modified, this.lengthBefore, e),
            new qc(this.modified, Ns, t)
          ] : [
            new qc(this.modified, e, e),
            new qc(this.modified, t, t)
          ];
        }
        toString() {
          return `${this.modified ? "M" : "U"}:${Vo(this.lengthBefore)} -> ${Vo(this.lengthAfter)}`;
        }
      }
      function kP(s) {
        const e = [];
        let t = Ns;
        for (const i of s) {
          const n = d_(t, i.startOffset);
          zv(n) || e.push(new qc(false, n, n));
          const o = d_(i.startOffset, i.endOffset);
          e.push(new qc(true, o, i.newLength)), t = i.endOffset;
        }
        return e;
      }
      class fne extends he {
        didLanguageChange(e) {
          return this.brackets.didLanguageChange(e);
        }
        constructor(e, t) {
          if (super(), this.textModel = e, this.getLanguageConfiguration = t, this.didChangeEmitter = new G(), this.denseKeyProvider = new Xie(), this.brackets = new ane(this.denseKeyProvider, this.getLanguageConfiguration), this.onDidChange = this.didChangeEmitter.event, this.queuedTextEditsForInitialAstWithoutTokens = [], this.queuedTextEdits = [], e.tokenization.hasTokens) e.tokenization.backgroundTokenizationState === 2 ? (this.initialAstWithoutTokens = void 0, this.astWithTokens = this.parseDocumentFromTextBuffer([], void 0, false)) : (this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer([], void 0, true), this.astWithTokens = this.initialAstWithoutTokens);
          else {
            const i = this.brackets.getSingleLanguageBracketTokens(this.textModel.getLanguageId()), n = new one(this.textModel.getValue(), i);
            this.initialAstWithoutTokens = xP(n, [], void 0, true), this.astWithTokens = this.initialAstWithoutTokens;
          }
        }
        handleDidChangeBackgroundTokenizationState() {
          if (this.textModel.tokenization.backgroundTokenizationState === 2) {
            const e = this.initialAstWithoutTokens === void 0;
            this.initialAstWithoutTokens = void 0, e || this.didChangeEmitter.fire();
          }
        }
        handleDidChangeTokens({ ranges: e }) {
          const t = e.map((i) => new Il(Ni(i.fromLineNumber - 1, 0), Ni(i.toLineNumber, 0), Ni(i.toLineNumber - i.fromLineNumber + 1, 0)));
          this.handleEdits(t, true), this.initialAstWithoutTokens || this.didChangeEmitter.fire();
        }
        handleContentChanged(e) {
          const t = Il.fromModelContentChanges(e.changes);
          this.handleEdits(t, false);
        }
        handleEdits(e, t) {
          const i = qv(this.queuedTextEdits, e);
          this.queuedTextEdits = i, this.initialAstWithoutTokens && !t && (this.queuedTextEditsForInitialAstWithoutTokens = qv(this.queuedTextEditsForInitialAstWithoutTokens, e));
        }
        flushQueue() {
          this.queuedTextEdits.length > 0 && (this.astWithTokens = this.parseDocumentFromTextBuffer(this.queuedTextEdits, this.astWithTokens, false), this.queuedTextEdits = []), this.queuedTextEditsForInitialAstWithoutTokens.length > 0 && (this.initialAstWithoutTokens && (this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer(this.queuedTextEditsForInitialAstWithoutTokens, this.initialAstWithoutTokens, false)), this.queuedTextEditsForInitialAstWithoutTokens = []);
        }
        parseDocumentFromTextBuffer(e, t, i) {
          const n = t, o = new nne(this.textModel, this.brackets);
          return xP(o, e, n, i);
        }
        getBracketsInRange(e, t) {
          this.flushQueue();
          const i = Ni(e.startLineNumber - 1, e.startColumn - 1), n = Ni(e.endLineNumber - 1, e.endColumn - 1);
          return new Rl((o) => {
            const r = this.initialAstWithoutTokens || this.astWithTokens;
            n2(r, Ns, r.length, i, n, o, 0, 0, /* @__PURE__ */ new Map(), t);
          });
        }
        getBracketPairsInRange(e, t) {
          this.flushQueue();
          const i = yf(e.getStartPosition()), n = yf(e.getEndPosition());
          return new Rl((o) => {
            const r = this.initialAstWithoutTokens || this.astWithTokens, a = new gne(o, t, this.textModel);
            s2(r, Ns, r.length, i, n, a, 0, /* @__PURE__ */ new Map());
          });
        }
        getFirstBracketAfter(e) {
          this.flushQueue();
          const t = this.initialAstWithoutTokens || this.astWithTokens;
          return CB(t, Ns, t.length, yf(e));
        }
        getFirstBracketBefore(e) {
          this.flushQueue();
          const t = this.initialAstWithoutTokens || this.astWithTokens;
          return vB(t, Ns, t.length, yf(e));
        }
      }
      function vB(s, e, t, i) {
        if (s.kind === 4 || s.kind === 2) {
          const n = [];
          for (const o of s.children) t = Wi(e, o.length), n.push({
            nodeOffsetStart: e,
            nodeOffsetEnd: t
          }), e = t;
          for (let o = n.length - 1; o >= 0; o--) {
            const { nodeOffsetStart: r, nodeOffsetEnd: a } = n[o];
            if (Uf(r, i)) {
              const l = vB(s.children[o], r, a, i);
              if (l) return l;
            }
          }
          return null;
        } else {
          if (s.kind === 3) return null;
          if (s.kind === 1) {
            const n = Sh(e, t);
            return {
              bracketInfo: s.bracketInfo,
              range: n
            };
          }
        }
        return null;
      }
      function CB(s, e, t, i) {
        if (s.kind === 4 || s.kind === 2) {
          for (const n of s.children) {
            if (t = Wi(e, n.length), Uf(i, t)) {
              const o = CB(n, e, t, i);
              if (o) return o;
            }
            e = t;
          }
          return null;
        } else {
          if (s.kind === 3) return null;
          if (s.kind === 1) {
            const n = Sh(e, t);
            return {
              bracketInfo: s.bracketInfo,
              range: n
            };
          }
        }
        return null;
      }
      function n2(s, e, t, i, n, o, r, a, l, u, d = false) {
        if (r > 200) return true;
        e: for (; ; ) switch (s.kind) {
          case 4: {
            const f = s.childrenLength;
            for (let m = 0; m < f; m++) {
              const _ = s.getChild(m);
              if (_) {
                if (t = Wi(e, _.length), $f(e, n) && ap(t, i)) {
                  if (ap(t, n)) {
                    s = _;
                    continue e;
                  }
                  if (!n2(_, e, t, i, n, o, r, 0, l, u)) return false;
                }
                e = t;
              }
            }
            return true;
          }
          case 2: {
            const f = !u || !s.closingBracket || s.closingBracket.bracketInfo.closesColorized(s.openingBracket.bracketInfo);
            let m = 0;
            if (l) {
              let b = l.get(s.openingBracket.text);
              b === void 0 && (b = 0), m = b, f && (b++, l.set(s.openingBracket.text, b));
            }
            const _ = s.childrenLength;
            for (let b = 0; b < _; b++) {
              const v = s.getChild(b);
              if (v) {
                if (t = Wi(e, v.length), $f(e, n) && ap(t, i)) {
                  if (ap(t, n) && v.kind !== 1) {
                    s = v, f ? (r++, a = m + 1) : a = m;
                    continue e;
                  }
                  if ((f || v.kind !== 1 || !s.closingBracket) && !n2(v, e, t, i, n, o, f ? r + 1 : r, f ? m + 1 : m, l, u, !s.closingBracket)) return false;
                }
                e = t;
              }
            }
            return l == null ? void 0 : l.set(s.openingBracket.text, m), true;
          }
          case 3: {
            const f = Sh(e, t);
            return o(new yP(f, r - 1, 0, true));
          }
          case 1: {
            const f = Sh(e, t);
            return o(new yP(f, r - 1, a - 1, d));
          }
          case 0:
            return true;
        }
      }
      class gne {
        constructor(e, t, i) {
          this.push = e, this.includeMinIndentation = t, this.textModel = i;
        }
      }
      function s2(s, e, t, i, n, o, r, a) {
        var _a3;
        if (r > 200) return true;
        let l = true;
        if (s.kind === 2) {
          let u = 0;
          if (a) {
            let m = a.get(s.openingBracket.text);
            m === void 0 && (m = 0), u = m, m++, a.set(s.openingBracket.text, m);
          }
          const d = Wi(e, s.openingBracket.length);
          let f = -1;
          if (o.includeMinIndentation && (f = s.computeMinIndentation(e, o.textModel)), l = o.push(new Kie(Sh(e, t), Sh(e, d), s.closingBracket ? Sh(Wi(d, ((_a3 = s.child) == null ? void 0 : _a3.length) || Ns), t) : void 0, r, u, s, f)), e = d, l && s.child) {
            const m = s.child;
            if (t = Wi(e, m.length), $f(e, n) && ap(t, i) && (l = s2(m, e, t, i, n, o, r + 1, a), !l)) return false;
          }
          a == null ? void 0 : a.set(s.openingBracket.text, u);
        } else {
          let u = e;
          for (const d of s.children) {
            const f = u;
            if (u = Wi(u, d.length), $f(f, n) && $f(i, u) && (l = s2(d, f, u, i, n, o, r, a), !l)) return false;
          }
        }
        return l;
      }
      class mne extends he {
        get canBuildAST() {
          return this.textModel.getValueLength() <= 5e6;
        }
        constructor(e, t) {
          super(), this.textModel = e, this.languageConfigurationService = t, this.bracketPairsTree = this._register(new Ul()), this.onDidChangeEmitter = new G(), this.onDidChange = this.onDidChangeEmitter.event, this.bracketsRequested = false;
        }
        handleLanguageConfigurationServiceChange(e) {
          var _a3;
          (!e.languageId || ((_a3 = this.bracketPairsTree.value) == null ? void 0 : _a3.object.didLanguageChange(e.languageId))) && (this.bracketPairsTree.clear(), this.updateBracketPairsTree());
        }
        handleDidChangeOptions(e) {
          this.bracketPairsTree.clear(), this.updateBracketPairsTree();
        }
        handleDidChangeLanguage(e) {
          this.bracketPairsTree.clear(), this.updateBracketPairsTree();
        }
        handleDidChangeContent(e) {
          var _a3;
          (_a3 = this.bracketPairsTree.value) == null ? void 0 : _a3.object.handleContentChanged(e);
        }
        handleDidChangeBackgroundTokenizationState() {
          var _a3;
          (_a3 = this.bracketPairsTree.value) == null ? void 0 : _a3.object.handleDidChangeBackgroundTokenizationState();
        }
        handleDidChangeTokens(e) {
          var _a3;
          (_a3 = this.bracketPairsTree.value) == null ? void 0 : _a3.object.handleDidChangeTokens(e);
        }
        updateBracketPairsTree() {
          if (this.bracketsRequested && this.canBuildAST) {
            if (!this.bracketPairsTree.value) {
              const e = new Me();
              this.bracketPairsTree.value = pne(e.add(new fne(this.textModel, (t) => this.languageConfigurationService.getLanguageConfiguration(t))), e), e.add(this.bracketPairsTree.value.object.onDidChange((t) => this.onDidChangeEmitter.fire(t))), this.onDidChangeEmitter.fire();
            }
          } else this.bracketPairsTree.value && (this.bracketPairsTree.clear(), this.onDidChangeEmitter.fire());
        }
        getBracketPairsInRange(e) {
          var _a3;
          return this.bracketsRequested = true, this.updateBracketPairsTree(), ((_a3 = this.bracketPairsTree.value) == null ? void 0 : _a3.object.getBracketPairsInRange(e, false)) || Rl.empty;
        }
        getBracketPairsInRangeWithMinIndentation(e) {
          var _a3;
          return this.bracketsRequested = true, this.updateBracketPairsTree(), ((_a3 = this.bracketPairsTree.value) == null ? void 0 : _a3.object.getBracketPairsInRange(e, true)) || Rl.empty;
        }
        getBracketsInRange(e, t = false) {
          var _a3;
          return this.bracketsRequested = true, this.updateBracketPairsTree(), ((_a3 = this.bracketPairsTree.value) == null ? void 0 : _a3.object.getBracketsInRange(e, t)) || Rl.empty;
        }
        findMatchingBracketUp(e, t, i) {
          const n = this.textModel.validatePosition(t), o = this.textModel.getLanguageIdAtPosition(n.lineNumber, n.column);
          if (this.canBuildAST) {
            const r = this.languageConfigurationService.getLanguageConfiguration(o).bracketsNew.getClosingBracketInfo(e);
            if (!r) return null;
            const a = this.getBracketPairsInRange(z.fromPositions(t, t)).findLast((l) => r.closes(l.openingBracketInfo));
            return a ? a.openingBracketRange : null;
          } else {
            const r = e.toLowerCase(), a = this.languageConfigurationService.getLanguageConfiguration(o).brackets;
            if (!a) return null;
            const l = a.textIsBracket[r];
            return l ? jb(this._findMatchingBracketUp(l, n, tx(i))) : null;
          }
        }
        matchBracket(e, t) {
          if (this.canBuildAST) {
            const i = this.getBracketPairsInRange(z.fromPositions(e, e)).filter((n) => n.closingBracketRange !== void 0 && (n.openingBracketRange.containsPosition(e) || n.closingBracketRange.containsPosition(e))).findLastMaxBy(fr((n) => n.openingBracketRange.containsPosition(e) ? n.openingBracketRange : n.closingBracketRange, z.compareRangesUsingStarts));
            return i ? [
              i.openingBracketRange,
              i.closingBracketRange
            ] : null;
          } else {
            const i = tx(t);
            return this._matchBracket(this.textModel.validatePosition(e), i);
          }
        }
        _establishBracketSearchOffsets(e, t, i, n) {
          const o = t.getCount(), r = t.getLanguageId(n);
          let a = Math.max(0, e.column - 1 - i.maxBracketLength);
          for (let u = n - 1; u >= 0; u--) {
            const d = t.getEndOffset(u);
            if (d <= a) break;
            if (pa(t.getStandardTokenType(u)) || t.getLanguageId(u) !== r) {
              a = d;
              break;
            }
          }
          let l = Math.min(t.getLineContent().length, e.column - 1 + i.maxBracketLength);
          for (let u = n + 1; u < o; u++) {
            const d = t.getStartOffset(u);
            if (d >= l) break;
            if (pa(t.getStandardTokenType(u)) || t.getLanguageId(u) !== r) {
              l = d;
              break;
            }
          }
          return {
            searchStartOffset: a,
            searchEndOffset: l
          };
        }
        _matchBracket(e, t) {
          const i = e.lineNumber, n = this.textModel.tokenization.getLineTokens(i), o = this.textModel.getLineContent(i), r = n.findTokenIndexAtOffset(e.column - 1);
          if (r < 0) return null;
          const a = this.languageConfigurationService.getLanguageConfiguration(n.getLanguageId(r)).brackets;
          if (a && !pa(n.getStandardTokenType(r))) {
            let { searchStartOffset: l, searchEndOffset: u } = this._establishBracketSearchOffsets(e, n, a, r), d = null;
            for (; ; ) {
              const f = sr.findNextBracketInRange(a.forwardRegex, i, o, l, u);
              if (!f) break;
              if (f.startColumn <= e.column && e.column <= f.endColumn) {
                const m = o.substring(f.startColumn - 1, f.endColumn - 1).toLowerCase(), _ = this._matchFoundBracket(f, a.textIsBracket[m], a.textIsOpenBracket[m], t);
                if (_) {
                  if (_ instanceof wl) return null;
                  d = _;
                }
              }
              l = f.endColumn - 1;
            }
            if (d) return d;
          }
          if (r > 0 && n.getStartOffset(r) === e.column - 1) {
            const l = r - 1, u = this.languageConfigurationService.getLanguageConfiguration(n.getLanguageId(l)).brackets;
            if (u && !pa(n.getStandardTokenType(l))) {
              const { searchStartOffset: d, searchEndOffset: f } = this._establishBracketSearchOffsets(e, n, u, l), m = sr.findPrevBracketInRange(u.reversedRegex, i, o, d, f);
              if (m && m.startColumn <= e.column && e.column <= m.endColumn) {
                const _ = o.substring(m.startColumn - 1, m.endColumn - 1).toLowerCase(), b = this._matchFoundBracket(m, u.textIsBracket[_], u.textIsOpenBracket[_], t);
                if (b) return b instanceof wl ? null : b;
              }
            }
          }
          return null;
        }
        _matchFoundBracket(e, t, i, n) {
          if (!t) return null;
          const o = i ? this._findMatchingBracketDown(t, e.getEndPosition(), n) : this._findMatchingBracketUp(t, e.getStartPosition(), n);
          return o ? o instanceof wl ? o : [
            e,
            o
          ] : null;
        }
        _findMatchingBracketUp(e, t, i) {
          const n = e.languageId, o = e.reversedRegex;
          let r = -1, a = 0;
          const l = (u, d, f, m) => {
            for (; ; ) {
              if (i && ++a % 100 === 0 && !i()) return wl.INSTANCE;
              const _ = sr.findPrevBracketInRange(o, u, d, f, m);
              if (!_) break;
              const b = d.substring(_.startColumn - 1, _.endColumn - 1).toLowerCase();
              if (e.isOpen(b) ? r++ : e.isClose(b) && r--, r === 0) return _;
              m = _.startColumn - 1;
            }
            return null;
          };
          for (let u = t.lineNumber; u >= 1; u--) {
            const d = this.textModel.tokenization.getLineTokens(u), f = d.getCount(), m = this.textModel.getLineContent(u);
            let _ = f - 1, b = m.length, v = m.length;
            u === t.lineNumber && (_ = d.findTokenIndexAtOffset(t.column - 1), b = t.column - 1, v = t.column - 1);
            let y = true;
            for (; _ >= 0; _--) {
              const x = d.getLanguageId(_) === n && !pa(d.getStandardTokenType(_));
              if (x) y ? b = d.getStartOffset(_) : (b = d.getStartOffset(_), v = d.getEndOffset(_));
              else if (y && b !== v) {
                const L = l(u, m, b, v);
                if (L) return L;
              }
              y = x;
            }
            if (y && b !== v) {
              const x = l(u, m, b, v);
              if (x) return x;
            }
          }
          return null;
        }
        _findMatchingBracketDown(e, t, i) {
          const n = e.languageId, o = e.forwardRegex;
          let r = 1, a = 0;
          const l = (d, f, m, _) => {
            for (; ; ) {
              if (i && ++a % 100 === 0 && !i()) return wl.INSTANCE;
              const b = sr.findNextBracketInRange(o, d, f, m, _);
              if (!b) break;
              const v = f.substring(b.startColumn - 1, b.endColumn - 1).toLowerCase();
              if (e.isOpen(v) ? r++ : e.isClose(v) && r--, r === 0) return b;
              m = b.endColumn - 1;
            }
            return null;
          }, u = this.textModel.getLineCount();
          for (let d = t.lineNumber; d <= u; d++) {
            const f = this.textModel.tokenization.getLineTokens(d), m = f.getCount(), _ = this.textModel.getLineContent(d);
            let b = 0, v = 0, y = 0;
            d === t.lineNumber && (b = f.findTokenIndexAtOffset(t.column - 1), v = t.column - 1, y = t.column - 1);
            let x = true;
            for (; b < m; b++) {
              const L = f.getLanguageId(b) === n && !pa(f.getStandardTokenType(b));
              if (L) x || (v = f.getStartOffset(b)), y = f.getEndOffset(b);
              else if (x && v !== y) {
                const D = l(d, _, v, y);
                if (D) return D;
              }
              x = L;
            }
            if (x && v !== y) {
              const L = l(d, _, v, y);
              if (L) return L;
            }
          }
          return null;
        }
        findPrevBracket(e) {
          var _a3;
          const t = this.textModel.validatePosition(e);
          if (this.canBuildAST) return this.bracketsRequested = true, this.updateBracketPairsTree(), ((_a3 = this.bracketPairsTree.value) == null ? void 0 : _a3.object.getFirstBracketBefore(t)) || null;
          let i = null, n = null, o = null;
          for (let r = t.lineNumber; r >= 1; r--) {
            const a = this.textModel.tokenization.getLineTokens(r), l = a.getCount(), u = this.textModel.getLineContent(r);
            let d = l - 1, f = u.length, m = u.length;
            if (r === t.lineNumber) {
              d = a.findTokenIndexAtOffset(t.column - 1), f = t.column - 1, m = t.column - 1;
              const b = a.getLanguageId(d);
              i !== b && (i = b, n = this.languageConfigurationService.getLanguageConfiguration(i).brackets, o = this.languageConfigurationService.getLanguageConfiguration(i).bracketsNew);
            }
            let _ = true;
            for (; d >= 0; d--) {
              const b = a.getLanguageId(d);
              if (i !== b) {
                if (n && o && _ && f !== m) {
                  const y = sr.findPrevBracketInRange(n.reversedRegex, r, u, f, m);
                  if (y) return this._toFoundBracket(o, y);
                  _ = false;
                }
                i = b, n = this.languageConfigurationService.getLanguageConfiguration(i).brackets, o = this.languageConfigurationService.getLanguageConfiguration(i).bracketsNew;
              }
              const v = !!n && !pa(a.getStandardTokenType(d));
              if (v) _ ? f = a.getStartOffset(d) : (f = a.getStartOffset(d), m = a.getEndOffset(d));
              else if (o && n && _ && f !== m) {
                const y = sr.findPrevBracketInRange(n.reversedRegex, r, u, f, m);
                if (y) return this._toFoundBracket(o, y);
              }
              _ = v;
            }
            if (o && n && _ && f !== m) {
              const b = sr.findPrevBracketInRange(n.reversedRegex, r, u, f, m);
              if (b) return this._toFoundBracket(o, b);
            }
          }
          return null;
        }
        findNextBracket(e) {
          var _a3;
          const t = this.textModel.validatePosition(e);
          if (this.canBuildAST) return this.bracketsRequested = true, this.updateBracketPairsTree(), ((_a3 = this.bracketPairsTree.value) == null ? void 0 : _a3.object.getFirstBracketAfter(t)) || null;
          const i = this.textModel.getLineCount();
          let n = null, o = null, r = null;
          for (let a = t.lineNumber; a <= i; a++) {
            const l = this.textModel.tokenization.getLineTokens(a), u = l.getCount(), d = this.textModel.getLineContent(a);
            let f = 0, m = 0, _ = 0;
            if (a === t.lineNumber) {
              f = l.findTokenIndexAtOffset(t.column - 1), m = t.column - 1, _ = t.column - 1;
              const v = l.getLanguageId(f);
              n !== v && (n = v, o = this.languageConfigurationService.getLanguageConfiguration(n).brackets, r = this.languageConfigurationService.getLanguageConfiguration(n).bracketsNew);
            }
            let b = true;
            for (; f < u; f++) {
              const v = l.getLanguageId(f);
              if (n !== v) {
                if (r && o && b && m !== _) {
                  const x = sr.findNextBracketInRange(o.forwardRegex, a, d, m, _);
                  if (x) return this._toFoundBracket(r, x);
                  b = false;
                }
                n = v, o = this.languageConfigurationService.getLanguageConfiguration(n).brackets, r = this.languageConfigurationService.getLanguageConfiguration(n).bracketsNew;
              }
              const y = !!o && !pa(l.getStandardTokenType(f));
              if (y) b || (m = l.getStartOffset(f)), _ = l.getEndOffset(f);
              else if (r && o && b && m !== _) {
                const x = sr.findNextBracketInRange(o.forwardRegex, a, d, m, _);
                if (x) return this._toFoundBracket(r, x);
              }
              b = y;
            }
            if (r && o && b && m !== _) {
              const v = sr.findNextBracketInRange(o.forwardRegex, a, d, m, _);
              if (v) return this._toFoundBracket(r, v);
            }
          }
          return null;
        }
        findEnclosingBrackets(e, t) {
          const i = this.textModel.validatePosition(e);
          if (this.canBuildAST) {
            const _ = z.fromPositions(i), b = this.getBracketPairsInRange(z.fromPositions(i, i)).findLast((v) => v.closingBracketRange !== void 0 && v.range.strictContainsRange(_));
            return b ? [
              b.openingBracketRange,
              b.closingBracketRange
            ] : null;
          }
          const n = tx(t), o = this.textModel.getLineCount(), r = /* @__PURE__ */ new Map();
          let a = [];
          const l = (_, b) => {
            if (!r.has(_)) {
              const v = [];
              for (let y = 0, x = b ? b.brackets.length : 0; y < x; y++) v[y] = 0;
              r.set(_, v);
            }
            a = r.get(_);
          };
          let u = 0;
          const d = (_, b, v, y, x) => {
            for (; ; ) {
              if (n && ++u % 100 === 0 && !n()) return wl.INSTANCE;
              const L = sr.findNextBracketInRange(_.forwardRegex, b, v, y, x);
              if (!L) break;
              const D = v.substring(L.startColumn - 1, L.endColumn - 1).toLowerCase(), k = _.textIsBracket[D];
              if (k && (k.isOpen(D) ? a[k.index]++ : k.isClose(D) && a[k.index]--, a[k.index] === -1)) return this._matchFoundBracket(L, k, false, n);
              y = L.endColumn - 1;
            }
            return null;
          };
          let f = null, m = null;
          for (let _ = i.lineNumber; _ <= o; _++) {
            const b = this.textModel.tokenization.getLineTokens(_), v = b.getCount(), y = this.textModel.getLineContent(_);
            let x = 0, L = 0, D = 0;
            if (_ === i.lineNumber) {
              x = b.findTokenIndexAtOffset(i.column - 1), L = i.column - 1, D = i.column - 1;
              const T = b.getLanguageId(x);
              f !== T && (f = T, m = this.languageConfigurationService.getLanguageConfiguration(f).brackets, l(f, m));
            }
            let k = true;
            for (; x < v; x++) {
              const T = b.getLanguageId(x);
              if (f !== T) {
                if (m && k && L !== D) {
                  const I = d(m, _, y, L, D);
                  if (I) return jb(I);
                  k = false;
                }
                f = T, m = this.languageConfigurationService.getLanguageConfiguration(f).brackets, l(f, m);
              }
              const M = !!m && !pa(b.getStandardTokenType(x));
              if (M) k || (L = b.getStartOffset(x)), D = b.getEndOffset(x);
              else if (m && k && L !== D) {
                const I = d(m, _, y, L, D);
                if (I) return jb(I);
              }
              k = M;
            }
            if (m && k && L !== D) {
              const T = d(m, _, y, L, D);
              if (T) return jb(T);
            }
          }
          return null;
        }
        _toFoundBracket(e, t) {
          if (!t) return null;
          let i = this.textModel.getValueInRange(t);
          i = i.toLowerCase();
          const n = e.getBracketInfo(i);
          return n ? {
            range: t,
            bracketInfo: n
          } : null;
        }
      }
      function pne(s, e) {
        return {
          object: s,
          dispose: () => e == null ? void 0 : e.dispose()
        };
      }
      function tx(s) {
        if (typeof s > "u") return () => true;
        {
          const e = Date.now();
          return () => Date.now() - e <= s;
        }
      }
      const _wl = class _wl {
        constructor() {
          this._searchCanceledBrand = void 0;
        }
      };
      _wl.INSTANCE = new _wl();
      let wl = _wl;
      function jb(s) {
        return s instanceof wl ? null : s;
      }
      class _ne extends he {
        constructor(e) {
          super(), this.textModel = e, this.colorProvider = new wB(), this.onDidChangeEmitter = new G(), this.onDidChange = this.onDidChangeEmitter.event, this.colorizationOptions = e.getOptions().bracketPairColorizationOptions, this._register(e.bracketPairs.onDidChange((t) => {
            this.onDidChangeEmitter.fire();
          }));
        }
        handleDidChangeOptions(e) {
          this.colorizationOptions = this.textModel.getOptions().bracketPairColorizationOptions;
        }
        getDecorationsInRange(e, t, i, n) {
          return n ? [] : t === void 0 ? [] : this.colorizationOptions.enabled ? this.textModel.bracketPairs.getBracketsInRange(e, true).map((r) => ({
            id: `bracket${r.range.toString()}-${r.nestingLevel}`,
            options: {
              description: "BracketPairColorization",
              inlineClassName: this.colorProvider.getInlineClassName(r, this.colorizationOptions.independentColorPoolPerBracketType)
            },
            ownerId: 0,
            range: r.range
          })).toArray() : [];
        }
        getAllDecorations(e, t) {
          return e === void 0 ? [] : this.colorizationOptions.enabled ? this.getDecorationsInRange(new z(1, 1, this.textModel.getLineCount(), 1), e, t) : [];
        }
      }
      class wB {
        constructor() {
          this.unexpectedClosingBracketClassName = "unexpected-closing-bracket";
        }
        getInlineClassName(e, t) {
          return e.isInvalid ? this.unexpectedClosingBracketClassName : this.getInlineClassNameOfLevel(t ? e.nestingLevelOfEqualBracketType : e.nestingLevel);
        }
        getInlineClassNameOfLevel(e) {
          return `bracket-highlighting-${e % 30}`;
        }
      }
      jl((s, e) => {
        const t = [
          cB,
          uB,
          hB,
          dB,
          fB,
          gB
        ], i = new wB();
        e.addRule(`.monaco-editor .${i.unexpectedClosingBracketClassName} { color: ${s.getColor(Die)}; }`);
        const n = t.map((o) => s.getColor(o)).filter((o) => !!o).filter((o) => !o.isTransparent());
        for (let o = 0; o < 30; o++) {
          const r = n[o % n.length];
          e.addRule(`.monaco-editor .${i.getInlineClassNameOfLevel(o)} { color: ${r}; }`);
        }
      });
      function Gb(s) {
        return s.replace(/\n/g, "\\n").replace(/\r/g, "\\r");
      }
      class Mn {
        get oldLength() {
          return this.oldText.length;
        }
        get oldEnd() {
          return this.oldPosition + this.oldText.length;
        }
        get newLength() {
          return this.newText.length;
        }
        get newEnd() {
          return this.newPosition + this.newText.length;
        }
        constructor(e, t, i, n) {
          this.oldPosition = e, this.oldText = t, this.newPosition = i, this.newText = n;
        }
        toString() {
          return this.oldText.length === 0 ? `(insert@${this.oldPosition} "${Gb(this.newText)}")` : this.newText.length === 0 ? `(delete@${this.oldPosition} "${Gb(this.oldText)}")` : `(replace@${this.oldPosition} "${Gb(this.oldText)}" with "${Gb(this.newText)}")`;
        }
        static _writeStringSize(e) {
          return 4 + 2 * e.length;
        }
        static _writeString(e, t, i) {
          const n = t.length;
          Rr(e, n, i), i += 4;
          for (let o = 0; o < n; o++) jj(e, t.charCodeAt(o), i), i += 2;
          return i;
        }
        static _readString(e, t) {
          const i = Ar(e, t);
          return t += 4, Yj(e, t, i);
        }
        writeSize() {
          return 8 + Mn._writeStringSize(this.oldText) + Mn._writeStringSize(this.newText);
        }
        write(e, t) {
          return Rr(e, this.oldPosition, t), t += 4, Rr(e, this.newPosition, t), t += 4, t = Mn._writeString(e, this.oldText, t), t = Mn._writeString(e, this.newText, t), t;
        }
        static read(e, t, i) {
          const n = Ar(e, t);
          t += 4;
          const o = Ar(e, t);
          t += 4;
          const r = Mn._readString(e, t);
          t += Mn._writeStringSize(r);
          const a = Mn._readString(e, t);
          return t += Mn._writeStringSize(a), i.push(new Mn(n, r, o, a)), t;
        }
      }
      function bne(s, e) {
        return s === null || s.length === 0 ? e : new ba(s, e).compress();
      }
      class ba {
        constructor(e, t) {
          this._prevEdits = e, this._currEdits = t, this._result = [], this._resultLen = 0, this._prevLen = this._prevEdits.length, this._prevDeltaOffset = 0, this._currLen = this._currEdits.length, this._currDeltaOffset = 0;
        }
        compress() {
          let e = 0, t = 0, i = this._getPrev(e), n = this._getCurr(t);
          for (; e < this._prevLen || t < this._currLen; ) {
            if (i === null) {
              this._acceptCurr(n), n = this._getCurr(++t);
              continue;
            }
            if (n === null) {
              this._acceptPrev(i), i = this._getPrev(++e);
              continue;
            }
            if (n.oldEnd <= i.newPosition) {
              this._acceptCurr(n), n = this._getCurr(++t);
              continue;
            }
            if (i.newEnd <= n.oldPosition) {
              this._acceptPrev(i), i = this._getPrev(++e);
              continue;
            }
            if (n.oldPosition < i.newPosition) {
              const [u, d] = ba._splitCurr(n, i.newPosition - n.oldPosition);
              this._acceptCurr(u), n = d;
              continue;
            }
            if (i.newPosition < n.oldPosition) {
              const [u, d] = ba._splitPrev(i, n.oldPosition - i.newPosition);
              this._acceptPrev(u), i = d;
              continue;
            }
            let a, l;
            if (n.oldEnd === i.newEnd) a = i, l = n, i = this._getPrev(++e), n = this._getCurr(++t);
            else if (n.oldEnd < i.newEnd) {
              const [u, d] = ba._splitPrev(i, n.oldLength);
              a = u, l = n, i = d, n = this._getCurr(++t);
            } else {
              const [u, d] = ba._splitCurr(n, i.newLength);
              a = i, l = u, i = this._getPrev(++e), n = d;
            }
            this._result[this._resultLen++] = new Mn(a.oldPosition, a.oldText, l.newPosition, l.newText), this._prevDeltaOffset += a.newLength - a.oldLength, this._currDeltaOffset += l.newLength - l.oldLength;
          }
          const o = ba._merge(this._result);
          return ba._removeNoOps(o);
        }
        _acceptCurr(e) {
          this._result[this._resultLen++] = ba._rebaseCurr(this._prevDeltaOffset, e), this._currDeltaOffset += e.newLength - e.oldLength;
        }
        _getCurr(e) {
          return e < this._currLen ? this._currEdits[e] : null;
        }
        _acceptPrev(e) {
          this._result[this._resultLen++] = ba._rebasePrev(this._currDeltaOffset, e), this._prevDeltaOffset += e.newLength - e.oldLength;
        }
        _getPrev(e) {
          return e < this._prevLen ? this._prevEdits[e] : null;
        }
        static _rebaseCurr(e, t) {
          return new Mn(t.oldPosition - e, t.oldText, t.newPosition, t.newText);
        }
        static _rebasePrev(e, t) {
          return new Mn(t.oldPosition, t.oldText, t.newPosition + e, t.newText);
        }
        static _splitPrev(e, t) {
          const i = e.newText.substr(0, t), n = e.newText.substr(t);
          return [
            new Mn(e.oldPosition, e.oldText, e.newPosition, i),
            new Mn(e.oldEnd, "", e.newPosition + t, n)
          ];
        }
        static _splitCurr(e, t) {
          const i = e.oldText.substr(0, t), n = e.oldText.substr(t);
          return [
            new Mn(e.oldPosition, i, e.newPosition, e.newText),
            new Mn(e.oldPosition + t, n, e.newEnd, "")
          ];
        }
        static _merge(e) {
          if (e.length === 0) return e;
          const t = [];
          let i = 0, n = e[0];
          for (let o = 1; o < e.length; o++) {
            const r = e[o];
            n.oldEnd === r.oldPosition ? n = new Mn(n.oldPosition, n.oldText + r.oldText, n.newPosition, n.newText + r.newText) : (t[i++] = n, n = r);
          }
          return t[i++] = n, t;
        }
        static _removeNoOps(e) {
          if (e.length === 0) return e;
          const t = [];
          let i = 0;
          for (let n = 0; n < e.length; n++) {
            const o = e[n];
            o.oldText !== o.newText && (t[i++] = o);
          }
          return t;
        }
      }
      function Jd(s) {
        return s.toString();
      }
      class nn {
        static create(e, t) {
          const i = e.getAlternativeVersionId(), n = o2(e);
          return new nn(i, i, n, n, t, t, []);
        }
        constructor(e, t, i, n, o, r, a) {
          this.beforeVersionId = e, this.afterVersionId = t, this.beforeEOL = i, this.afterEOL = n, this.beforeCursorState = o, this.afterCursorState = r, this.changes = a;
        }
        append(e, t, i, n, o) {
          t.length > 0 && (this.changes = bne(this.changes, t)), this.afterEOL = i, this.afterVersionId = n, this.afterCursorState = o;
        }
        static _writeSelectionsSize(e) {
          return 4 + 4 * 4 * (e ? e.length : 0);
        }
        static _writeSelections(e, t, i) {
          if (Rr(e, t ? t.length : 0, i), i += 4, t) for (const n of t) Rr(e, n.selectionStartLineNumber, i), i += 4, Rr(e, n.selectionStartColumn, i), i += 4, Rr(e, n.positionLineNumber, i), i += 4, Rr(e, n.positionColumn, i), i += 4;
          return i;
        }
        static _readSelections(e, t, i) {
          const n = Ar(e, t);
          t += 4;
          for (let o = 0; o < n; o++) {
            const r = Ar(e, t);
            t += 4;
            const a = Ar(e, t);
            t += 4;
            const l = Ar(e, t);
            t += 4;
            const u = Ar(e, t);
            t += 4, i.push(new mt(r, a, l, u));
          }
          return t;
        }
        serialize() {
          let e = 10 + nn._writeSelectionsSize(this.beforeCursorState) + nn._writeSelectionsSize(this.afterCursorState) + 4;
          for (const n of this.changes) e += n.writeSize();
          const t = new Uint8Array(e);
          let i = 0;
          Rr(t, this.beforeVersionId, i), i += 4, Rr(t, this.afterVersionId, i), i += 4, wO(t, this.beforeEOL, i), i += 1, wO(t, this.afterEOL, i), i += 1, i = nn._writeSelections(t, this.beforeCursorState, i), i = nn._writeSelections(t, this.afterCursorState, i), Rr(t, this.changes.length, i), i += 4;
          for (const n of this.changes) i = n.write(t, i);
          return t.buffer;
        }
        static deserialize(e) {
          const t = new Uint8Array(e);
          let i = 0;
          const n = Ar(t, i);
          i += 4;
          const o = Ar(t, i);
          i += 4;
          const r = CO(t, i);
          i += 1;
          const a = CO(t, i);
          i += 1;
          const l = [];
          i = nn._readSelections(t, i, l);
          const u = [];
          i = nn._readSelections(t, i, u);
          const d = Ar(t, i);
          i += 4;
          const f = [];
          for (let m = 0; m < d; m++) i = Mn.read(t, i, f);
          return new nn(n, o, r, a, l, u, f);
        }
      }
      class yB {
        get type() {
          return 0;
        }
        get resource() {
          return st.isUri(this.model) ? this.model : this.model.uri;
        }
        constructor(e, t, i, n) {
          this.label = e, this.code = t, this.model = i, this._data = nn.create(i, n);
        }
        toString() {
          return (this._data instanceof nn ? this._data : nn.deserialize(this._data)).changes.map((t) => t.toString()).join(", ");
        }
        matchesResource(e) {
          return (st.isUri(this.model) ? this.model : this.model.uri).toString() === e.toString();
        }
        setModel(e) {
          this.model = e;
        }
        canAppend(e) {
          return this.model === e && this._data instanceof nn;
        }
        append(e, t, i, n, o) {
          this._data instanceof nn && this._data.append(e, t, i, n, o);
        }
        close() {
          this._data instanceof nn && (this._data = this._data.serialize());
        }
        open() {
          this._data instanceof nn || (this._data = nn.deserialize(this._data));
        }
        undo() {
          if (st.isUri(this.model)) throw new Error("Invalid SingleModelEditStackElement");
          this._data instanceof nn && (this._data = this._data.serialize());
          const e = nn.deserialize(this._data);
          this.model._applyUndo(e.changes, e.beforeEOL, e.beforeVersionId, e.beforeCursorState);
        }
        redo() {
          if (st.isUri(this.model)) throw new Error("Invalid SingleModelEditStackElement");
          this._data instanceof nn && (this._data = this._data.serialize());
          const e = nn.deserialize(this._data);
          this.model._applyRedo(e.changes, e.afterEOL, e.afterVersionId, e.afterCursorState);
        }
        heapSize() {
          return this._data instanceof nn && (this._data = this._data.serialize()), this._data.byteLength + 168;
        }
      }
      class vne {
        get resources() {
          return this._editStackElementsArr.map((e) => e.resource);
        }
        constructor(e, t, i) {
          this.label = e, this.code = t, this.type = 1, this._isOpen = true, this._editStackElementsArr = i.slice(0), this._editStackElementsMap = /* @__PURE__ */ new Map();
          for (const n of this._editStackElementsArr) {
            const o = Jd(n.resource);
            this._editStackElementsMap.set(o, n);
          }
          this._delegate = null;
        }
        prepareUndoRedo() {
          if (this._delegate) return this._delegate.prepareUndoRedo(this);
        }
        matchesResource(e) {
          const t = Jd(e);
          return this._editStackElementsMap.has(t);
        }
        setModel(e) {
          const t = Jd(st.isUri(e) ? e : e.uri);
          this._editStackElementsMap.has(t) && this._editStackElementsMap.get(t).setModel(e);
        }
        canAppend(e) {
          if (!this._isOpen) return false;
          const t = Jd(e.uri);
          return this._editStackElementsMap.has(t) ? this._editStackElementsMap.get(t).canAppend(e) : false;
        }
        append(e, t, i, n, o) {
          const r = Jd(e.uri);
          this._editStackElementsMap.get(r).append(e, t, i, n, o);
        }
        close() {
          this._isOpen = false;
        }
        open() {
        }
        undo() {
          this._isOpen = false;
          for (const e of this._editStackElementsArr) e.undo();
        }
        redo() {
          for (const e of this._editStackElementsArr) e.redo();
        }
        heapSize(e) {
          const t = Jd(e);
          return this._editStackElementsMap.has(t) ? this._editStackElementsMap.get(t).heapSize() : 0;
        }
        split() {
          return this._editStackElementsArr;
        }
        toString() {
          const e = [];
          for (const t of this._editStackElementsArr) e.push(`${UT(t.resource)}: ${t}`);
          return `{${e.join(", ")}}`;
        }
      }
      function o2(s) {
        return s.getEOL() === `
` ? 0 : 1;
      }
      function yl(s) {
        return s ? s instanceof yB || s instanceof vne : false;
      }
      class dN {
        constructor(e, t) {
          this._model = e, this._undoRedoService = t;
        }
        pushStackElement() {
          const e = this._undoRedoService.getLastElement(this._model.uri);
          yl(e) && e.close();
        }
        popStackElement() {
          const e = this._undoRedoService.getLastElement(this._model.uri);
          yl(e) && e.open();
        }
        clear() {
          this._undoRedoService.removeElements(this._model.uri);
        }
        _getOrCreateEditStackElement(e, t) {
          const i = this._undoRedoService.getLastElement(this._model.uri);
          if (yl(i) && i.canAppend(this._model)) return i;
          const n = new yB(C("edit", "Typing"), "undoredo.textBufferEdit", this._model, e);
          return this._undoRedoService.pushElement(n, t), n;
        }
        pushEOL(e) {
          const t = this._getOrCreateEditStackElement(null, void 0);
          this._model.setEOL(e), t.append(this._model, [], o2(this._model), this._model.getAlternativeVersionId(), null);
        }
        pushEditOperation(e, t, i, n) {
          const o = this._getOrCreateEditStackElement(e, n), r = this._model.applyEdits(t, true), a = dN._computeCursorState(i, r), l = r.map((u, d) => ({
            index: d,
            textChange: u.textChange
          }));
          return l.sort((u, d) => u.textChange.oldPosition === d.textChange.oldPosition ? u.index - d.index : u.textChange.oldPosition - d.textChange.oldPosition), o.append(this._model, l.map((u) => u.textChange), o2(this._model), this._model.getAlternativeVersionId(), a), a;
        }
        static _computeCursorState(e, t) {
          try {
            return e ? e(t) : null;
          } catch (i) {
            return qt(i), null;
          }
        }
      }
      class SB extends he {
        constructor() {
          super(...arguments), this._isDisposed = false;
        }
        dispose() {
          super.dispose(), this._isDisposed = true;
        }
        assertNotDisposed() {
          if (this._isDisposed) throw new Error("TextModelPart is disposed!");
        }
      }
      function Cne(s, e) {
        let t = 0, i = 0;
        const n = s.length;
        for (; i < n; ) {
          const o = s.charCodeAt(i);
          if (o === 32) t++;
          else if (o === 9) t = t - t % e + e;
          else break;
          i++;
        }
        return i === n ? -1 : t;
      }
      var Lh;
      (function(s) {
        s[s.Disabled = 0] = "Disabled", s[s.EnabledForActive = 1] = "EnabledForActive", s[s.Enabled = 2] = "Enabled";
      })(Lh || (Lh = {}));
      class ph {
        constructor(e, t, i, n, o, r) {
          if (this.visibleColumn = e, this.column = t, this.className = i, this.horizontalLine = n, this.forWrappedLinesAfterColumn = o, this.forWrappedLinesBeforeOrAtColumn = r, e !== -1 == (t !== -1)) throw new Error();
        }
      }
      class kp {
        constructor(e, t) {
          this.top = e, this.endColumn = t;
        }
      }
      class wne extends SB {
        constructor(e, t) {
          super(), this.textModel = e, this.languageConfigurationService = t;
        }
        getLanguageConfiguration(e) {
          return this.languageConfigurationService.getLanguageConfiguration(e);
        }
        _computeIndentLevel(e) {
          return Cne(this.textModel.getLineContent(e + 1), this.textModel.getOptions().tabSize);
        }
        getActiveIndentGuide(e, t, i) {
          this.assertNotDisposed();
          const n = this.textModel.getLineCount();
          if (e < 1 || e > n) throw new It("Illegal value for lineNumber");
          const o = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules, r = !!(o && o.offSide);
          let a = -2, l = -1, u = -2, d = -1;
          const f = (I) => {
            if (a !== -1 && (a === -2 || a > I - 1)) {
              a = -1, l = -1;
              for (let R = I - 2; R >= 0; R--) {
                const A = this._computeIndentLevel(R);
                if (A >= 0) {
                  a = R, l = A;
                  break;
                }
              }
            }
            if (u === -2) {
              u = -1, d = -1;
              for (let R = I; R < n; R++) {
                const A = this._computeIndentLevel(R);
                if (A >= 0) {
                  u = R, d = A;
                  break;
                }
              }
            }
          };
          let m = -2, _ = -1, b = -2, v = -1;
          const y = (I) => {
            if (m === -2) {
              m = -1, _ = -1;
              for (let R = I - 2; R >= 0; R--) {
                const A = this._computeIndentLevel(R);
                if (A >= 0) {
                  m = R, _ = A;
                  break;
                }
              }
            }
            if (b !== -1 && (b === -2 || b < I - 1)) {
              b = -1, v = -1;
              for (let R = I; R < n; R++) {
                const A = this._computeIndentLevel(R);
                if (A >= 0) {
                  b = R, v = A;
                  break;
                }
              }
            }
          };
          let x = 0, L = true, D = 0, k = true, T = 0, M = 0;
          for (let I = 0; L || k; I++) {
            const R = e - I, A = e + I;
            I > 1 && (R < 1 || R < t) && (L = false), I > 1 && (A > n || A > i) && (k = false), I > 5e4 && (L = false, k = false);
            let Y = -1;
            if (L && R >= 1) {
              const j = this._computeIndentLevel(R - 1);
              j >= 0 ? (u = R - 1, d = j, Y = Math.ceil(j / this.textModel.getOptions().indentSize)) : (f(R), Y = this._getIndentLevelForWhitespaceLine(r, l, d));
            }
            let U = -1;
            if (k && A <= n) {
              const j = this._computeIndentLevel(A - 1);
              j >= 0 ? (m = A - 1, _ = j, U = Math.ceil(j / this.textModel.getOptions().indentSize)) : (y(A), U = this._getIndentLevelForWhitespaceLine(r, _, v));
            }
            if (I === 0) {
              M = Y;
              continue;
            }
            if (I === 1) {
              if (A <= n && U >= 0 && M + 1 === U) {
                L = false, x = A, D = A, T = U;
                continue;
              }
              if (R >= 1 && Y >= 0 && Y - 1 === M) {
                k = false, x = R, D = R, T = Y;
                continue;
              }
              if (x = e, D = e, T = M, T === 0) return {
                startLineNumber: x,
                endLineNumber: D,
                indent: T
              };
            }
            L && (Y >= T ? x = R : L = false), k && (U >= T ? D = A : k = false);
          }
          return {
            startLineNumber: x,
            endLineNumber: D,
            indent: T
          };
        }
        getLinesBracketGuides(e, t, i, n) {
          var _a3;
          const o = [];
          for (let f = e; f <= t; f++) o.push([]);
          const r = true, a = this.textModel.bracketPairs.getBracketPairsInRangeWithMinIndentation(new z(e, 1, t, this.textModel.getLineMaxColumn(t))).toArray();
          let l;
          if (i && a.length > 0) {
            const f = (e <= i.lineNumber && i.lineNumber <= t ? a : this.textModel.bracketPairs.getBracketPairsInRange(z.fromPositions(i)).toArray()).filter((m) => z.strictContainsPosition(m.range, i));
            l = (_a3 = gv(f, (m) => r)) == null ? void 0 : _a3.range;
          }
          const u = this.textModel.getOptions().bracketPairColorizationOptions.independentColorPoolPerBracketType, d = new LB();
          for (const f of a) {
            if (!f.closingBracketRange) continue;
            const m = l && f.range.equalsRange(l);
            if (!m && !n.includeInactive) continue;
            const _ = d.getInlineClassName(f.nestingLevel, f.nestingLevelOfEqualBracketType, u) + (n.highlightActive && m ? " " + d.activeClassName : ""), b = f.openingBracketRange.getStartPosition(), v = f.closingBracketRange.getStartPosition(), y = n.horizontalGuides === Lh.Enabled || n.horizontalGuides === Lh.EnabledForActive && m;
            if (f.range.startLineNumber === f.range.endLineNumber) {
              y && o[f.range.startLineNumber - e].push(new ph(-1, f.openingBracketRange.getEndPosition().column, _, new kp(false, v.column), -1, -1));
              continue;
            }
            const x = this.getVisibleColumnFromPosition(v), L = this.getVisibleColumnFromPosition(f.openingBracketRange.getStartPosition()), D = Math.min(L, x, f.minVisibleColumnIndentation + 1);
            let k = false;
            qs(this.textModel.getLineContent(f.closingBracketRange.startLineNumber)) < f.closingBracketRange.startColumn - 1 && (k = true);
            const I = Math.max(b.lineNumber, e), R = Math.min(v.lineNumber, t), A = k ? 1 : 0;
            for (let Y = I; Y < R + A; Y++) o[Y - e].push(new ph(D, -1, _, null, Y === b.lineNumber ? b.column : -1, Y === v.lineNumber ? v.column : -1));
            y && (b.lineNumber >= e && L > D && o[b.lineNumber - e].push(new ph(D, -1, _, new kp(false, b.column), -1, -1)), v.lineNumber <= t && x > D && o[v.lineNumber - e].push(new ph(D, -1, _, new kp(!k, v.column), -1, -1)));
          }
          for (const f of o) f.sort((m, _) => m.visibleColumn - _.visibleColumn);
          return o;
        }
        getVisibleColumnFromPosition(e) {
          return Gi.visibleColumnFromColumn(this.textModel.getLineContent(e.lineNumber), e.column, this.textModel.getOptions().tabSize) + 1;
        }
        getLinesIndentGuides(e, t) {
          this.assertNotDisposed();
          const i = this.textModel.getLineCount();
          if (e < 1 || e > i) throw new Error("Illegal value for startLineNumber");
          if (t < 1 || t > i) throw new Error("Illegal value for endLineNumber");
          const n = this.textModel.getOptions(), o = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules, r = !!(o && o.offSide), a = new Array(t - e + 1);
          let l = -2, u = -1, d = -2, f = -1;
          for (let m = e; m <= t; m++) {
            const _ = m - e, b = this._computeIndentLevel(m - 1);
            if (b >= 0) {
              l = m - 1, u = b, a[_] = Math.ceil(b / n.indentSize);
              continue;
            }
            if (l === -2) {
              l = -1, u = -1;
              for (let v = m - 2; v >= 0; v--) {
                const y = this._computeIndentLevel(v);
                if (y >= 0) {
                  l = v, u = y;
                  break;
                }
              }
            }
            if (d !== -1 && (d === -2 || d < m - 1)) {
              d = -1, f = -1;
              for (let v = m; v < i; v++) {
                const y = this._computeIndentLevel(v);
                if (y >= 0) {
                  d = v, f = y;
                  break;
                }
              }
            }
            a[_] = this._getIndentLevelForWhitespaceLine(r, u, f);
          }
          return a;
        }
        _getIndentLevelForWhitespaceLine(e, t, i) {
          const n = this.textModel.getOptions();
          return t === -1 || i === -1 ? 0 : t < i ? 1 + Math.floor(t / n.indentSize) : t === i || e ? Math.ceil(i / n.indentSize) : 1 + Math.floor(i / n.indentSize);
        }
      }
      class LB {
        constructor() {
          this.activeClassName = "indent-active";
        }
        getInlineClassName(e, t, i) {
          return this.getInlineClassNameOfLevel(i ? t : e);
        }
        getInlineClassNameOfLevel(e) {
          return `bracket-indent-guide lvl-${e % 30}`;
        }
      }
      class yne {
        constructor() {
          this.spacesDiff = 0, this.looksLikeAlignment = false;
        }
      }
      function Sne(s, e, t, i, n) {
        n.spacesDiff = 0, n.looksLikeAlignment = false;
        let o;
        for (o = 0; o < e && o < i; o++) {
          const m = s.charCodeAt(o), _ = t.charCodeAt(o);
          if (m !== _) break;
        }
        let r = 0, a = 0;
        for (let m = o; m < e; m++) s.charCodeAt(m) === 32 ? r++ : a++;
        let l = 0, u = 0;
        for (let m = o; m < i; m++) t.charCodeAt(m) === 32 ? l++ : u++;
        if (r > 0 && a > 0 || l > 0 && u > 0) return;
        const d = Math.abs(a - u), f = Math.abs(r - l);
        if (d === 0) {
          n.spacesDiff = f, f > 0 && 0 <= l - 1 && l - 1 < s.length && l < t.length && t.charCodeAt(l) !== 32 && s.charCodeAt(l - 1) === 32 && s.charCodeAt(s.length - 1) === 44 && (n.looksLikeAlignment = true);
          return;
        }
        if (f % d === 0) {
          n.spacesDiff = f / d;
          return;
        }
      }
      function DP(s, e, t) {
        const i = Math.min(s.getLineCount(), 1e4);
        let n = 0, o = 0, r = "", a = 0;
        const l = [
          2,
          4,
          6,
          8,
          3,
          5,
          7
        ], u = 8, d = [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ], f = new yne();
        for (let b = 1; b <= i; b++) {
          const v = s.getLineLength(b), y = s.getLineContent(b), x = v <= 65536;
          let L = false, D = 0, k = 0, T = 0;
          for (let I = 0, R = v; I < R; I++) {
            const A = x ? y.charCodeAt(I) : s.getLineCharCode(b, I);
            if (A === 9) T++;
            else if (A === 32) k++;
            else {
              L = true, D = I;
              break;
            }
          }
          if (!L || (T > 0 ? n++ : k > 1 && o++, Sne(r, a, y, D, f), f.looksLikeAlignment && !(t && e === f.spacesDiff))) continue;
          const M = f.spacesDiff;
          M <= u && d[M]++, r = y, a = D;
        }
        let m = t;
        n !== o && (m = n < o);
        let _ = e;
        if (m) {
          let b = m ? 0 : 0.1 * i;
          l.forEach((v) => {
            const y = d[v];
            y > b && (b = y, _ = v);
          }), _ === 4 && d[4] > 0 && d[2] > 0 && d[2] >= d[4] / 2 && (_ = 2);
        }
        return {
          insertSpaces: m,
          tabSize: _
        };
      }
      function Ss(s) {
        return (s.metadata & 1) >>> 0;
      }
      function ii(s, e) {
        s.metadata = s.metadata & 254 | e << 0;
      }
      function Rn(s) {
        return (s.metadata & 2) >>> 1 === 1;
      }
      function Xt(s, e) {
        s.metadata = s.metadata & 253 | (e ? 1 : 0) << 1;
      }
      function xB(s) {
        return (s.metadata & 4) >>> 2 === 1;
      }
      function EP(s, e) {
        s.metadata = s.metadata & 251 | (e ? 1 : 0) << 2;
      }
      function kB(s) {
        return (s.metadata & 64) >>> 6 === 1;
      }
      function TP(s, e) {
        s.metadata = s.metadata & 191 | (e ? 1 : 0) << 6;
      }
      function Lne(s) {
        return (s.metadata & 24) >>> 3;
      }
      function NP(s, e) {
        s.metadata = s.metadata & 231 | e << 3;
      }
      function xne(s) {
        return (s.metadata & 32) >>> 5 === 1;
      }
      function IP(s, e) {
        s.metadata = s.metadata & 223 | (e ? 1 : 0) << 5;
      }
      class DB {
        constructor(e, t, i) {
          this.metadata = 0, this.parent = this, this.left = this, this.right = this, ii(this, 1), this.start = t, this.end = i, this.delta = 0, this.maxEnd = i, this.id = e, this.ownerId = 0, this.options = null, EP(this, false), TP(this, false), NP(this, 1), IP(this, false), this.cachedVersionId = 0, this.cachedAbsoluteStart = t, this.cachedAbsoluteEnd = i, this.range = null, Xt(this, false);
        }
        reset(e, t, i, n) {
          this.start = t, this.end = i, this.maxEnd = i, this.cachedVersionId = e, this.cachedAbsoluteStart = t, this.cachedAbsoluteEnd = i, this.range = n;
        }
        setOptions(e) {
          this.options = e;
          const t = this.options.className;
          EP(this, t === "squiggly-error" || t === "squiggly-warning" || t === "squiggly-info"), TP(this, this.options.glyphMarginClassName !== null), NP(this, this.options.stickiness), IP(this, this.options.collapseOnReplaceEdit);
        }
        setCachedOffsets(e, t, i) {
          this.cachedVersionId !== i && (this.range = null), this.cachedVersionId = i, this.cachedAbsoluteStart = e, this.cachedAbsoluteEnd = t;
        }
        detach() {
          this.parent = null, this.left = null, this.right = null;
        }
      }
      const Je = new DB(null, 0, 0);
      Je.parent = Je;
      Je.left = Je;
      Je.right = Je;
      ii(Je, 0);
      class ix {
        constructor() {
          this.root = Je, this.requestNormalizeDelta = false;
        }
        intervalSearch(e, t, i, n, o, r) {
          return this.root === Je ? [] : Ane(this, e, t, i, n, o, r);
        }
        search(e, t, i, n) {
          return this.root === Je ? [] : Mne(this, e, t, i, n);
        }
        collectNodesFromOwner(e) {
          return Nne(this, e);
        }
        collectNodesPostOrder() {
          return Ine(this);
        }
        insert(e) {
          MP(this, e), this._normalizeDeltaIfNecessary();
        }
        delete(e) {
          AP(this, e), this._normalizeDeltaIfNecessary();
        }
        resolveNode(e, t) {
          const i = e;
          let n = 0;
          for (; e !== this.root; ) e === e.parent.right && (n += e.parent.delta), e = e.parent;
          const o = i.start + n, r = i.end + n;
          i.setCachedOffsets(o, r, t);
        }
        acceptReplace(e, t, i, n) {
          const o = Ene(this, e, e + t);
          for (let r = 0, a = o.length; r < a; r++) {
            const l = o[r];
            AP(this, l);
          }
          this._normalizeDeltaIfNecessary(), Tne(this, e, e + t, i), this._normalizeDeltaIfNecessary();
          for (let r = 0, a = o.length; r < a; r++) {
            const l = o[r];
            l.start = l.cachedAbsoluteStart, l.end = l.cachedAbsoluteEnd, Dne(l, e, e + t, i, n), l.maxEnd = l.end, MP(this, l);
          }
          this._normalizeDeltaIfNecessary();
        }
        _normalizeDeltaIfNecessary() {
          this.requestNormalizeDelta && (this.requestNormalizeDelta = false, kne(this));
        }
      }
      function kne(s) {
        let e = s.root, t = 0;
        for (; e !== Je; ) {
          if (e.left !== Je && !Rn(e.left)) {
            e = e.left;
            continue;
          }
          if (e.right !== Je && !Rn(e.right)) {
            t += e.delta, e = e.right;
            continue;
          }
          e.start = t + e.start, e.end = t + e.end, e.delta = 0, lu(e), Xt(e, true), Xt(e.left, false), Xt(e.right, false), e === e.parent.right && (t -= e.parent.delta), e = e.parent;
        }
        Xt(s.root, false);
      }
      function ef(s, e, t, i) {
        return s < t ? true : s > t || i === 1 ? false : i === 2 ? true : e;
      }
      function Dne(s, e, t, i, n) {
        const o = Lne(s), r = o === 0 || o === 2, a = o === 1 || o === 2, l = t - e, u = i, d = Math.min(l, u), f = s.start;
        let m = false;
        const _ = s.end;
        let b = false;
        e <= f && _ <= t && xne(s) && (s.start = e, m = true, s.end = e, b = true);
        {
          const y = n ? 1 : l > 0 ? 2 : 0;
          !m && ef(f, r, e, y) && (m = true), !b && ef(_, a, e, y) && (b = true);
        }
        if (d > 0 && !n) {
          const y = l > u ? 2 : 0;
          !m && ef(f, r, e + d, y) && (m = true), !b && ef(_, a, e + d, y) && (b = true);
        }
        {
          const y = n ? 1 : 0;
          !m && ef(f, r, t, y) && (s.start = e + u, m = true), !b && ef(_, a, t, y) && (s.end = e + u, b = true);
        }
        const v = u - l;
        m || (s.start = Math.max(0, f + v)), b || (s.end = Math.max(0, _ + v)), s.start > s.end && (s.end = s.start);
      }
      function Ene(s, e, t) {
        let i = s.root, n = 0, o = 0, r = 0, a = 0;
        const l = [];
        let u = 0;
        for (; i !== Je; ) {
          if (Rn(i)) {
            Xt(i.left, false), Xt(i.right, false), i === i.parent.right && (n -= i.parent.delta), i = i.parent;
            continue;
          }
          if (!Rn(i.left)) {
            if (o = n + i.maxEnd, o < e) {
              Xt(i, true);
              continue;
            }
            if (i.left !== Je) {
              i = i.left;
              continue;
            }
          }
          if (r = n + i.start, r > t) {
            Xt(i, true);
            continue;
          }
          if (a = n + i.end, a >= e && (i.setCachedOffsets(r, a, 0), l[u++] = i), Xt(i, true), i.right !== Je && !Rn(i.right)) {
            n += i.delta, i = i.right;
            continue;
          }
        }
        return Xt(s.root, false), l;
      }
      function Tne(s, e, t, i) {
        let n = s.root, o = 0, r = 0, a = 0;
        const l = i - (t - e);
        for (; n !== Je; ) {
          if (Rn(n)) {
            Xt(n.left, false), Xt(n.right, false), n === n.parent.right && (o -= n.parent.delta), lu(n), n = n.parent;
            continue;
          }
          if (!Rn(n.left)) {
            if (r = o + n.maxEnd, r < e) {
              Xt(n, true);
              continue;
            }
            if (n.left !== Je) {
              n = n.left;
              continue;
            }
          }
          if (a = o + n.start, a > t) {
            n.start += l, n.end += l, n.delta += l, (n.delta < -1073741824 || n.delta > 1073741824) && (s.requestNormalizeDelta = true), Xt(n, true);
            continue;
          }
          if (Xt(n, true), n.right !== Je && !Rn(n.right)) {
            o += n.delta, n = n.right;
            continue;
          }
        }
        Xt(s.root, false);
      }
      function Nne(s, e) {
        let t = s.root;
        const i = [];
        let n = 0;
        for (; t !== Je; ) {
          if (Rn(t)) {
            Xt(t.left, false), Xt(t.right, false), t = t.parent;
            continue;
          }
          if (t.left !== Je && !Rn(t.left)) {
            t = t.left;
            continue;
          }
          if (t.ownerId === e && (i[n++] = t), Xt(t, true), t.right !== Je && !Rn(t.right)) {
            t = t.right;
            continue;
          }
        }
        return Xt(s.root, false), i;
      }
      function Ine(s) {
        let e = s.root;
        const t = [];
        let i = 0;
        for (; e !== Je; ) {
          if (Rn(e)) {
            Xt(e.left, false), Xt(e.right, false), e = e.parent;
            continue;
          }
          if (e.left !== Je && !Rn(e.left)) {
            e = e.left;
            continue;
          }
          if (e.right !== Je && !Rn(e.right)) {
            e = e.right;
            continue;
          }
          t[i++] = e, Xt(e, true);
        }
        return Xt(s.root, false), t;
      }
      function Mne(s, e, t, i, n) {
        let o = s.root, r = 0, a = 0, l = 0;
        const u = [];
        let d = 0;
        for (; o !== Je; ) {
          if (Rn(o)) {
            Xt(o.left, false), Xt(o.right, false), o === o.parent.right && (r -= o.parent.delta), o = o.parent;
            continue;
          }
          if (o.left !== Je && !Rn(o.left)) {
            o = o.left;
            continue;
          }
          a = r + o.start, l = r + o.end, o.setCachedOffsets(a, l, i);
          let f = true;
          if (e && o.ownerId && o.ownerId !== e && (f = false), t && xB(o) && (f = false), n && !kB(o) && (f = false), f && (u[d++] = o), Xt(o, true), o.right !== Je && !Rn(o.right)) {
            r += o.delta, o = o.right;
            continue;
          }
        }
        return Xt(s.root, false), u;
      }
      function Ane(s, e, t, i, n, o, r) {
        let a = s.root, l = 0, u = 0, d = 0, f = 0;
        const m = [];
        let _ = 0;
        for (; a !== Je; ) {
          if (Rn(a)) {
            Xt(a.left, false), Xt(a.right, false), a === a.parent.right && (l -= a.parent.delta), a = a.parent;
            continue;
          }
          if (!Rn(a.left)) {
            if (u = l + a.maxEnd, u < e) {
              Xt(a, true);
              continue;
            }
            if (a.left !== Je) {
              a = a.left;
              continue;
            }
          }
          if (d = l + a.start, d > t) {
            Xt(a, true);
            continue;
          }
          if (f = l + a.end, f >= e) {
            a.setCachedOffsets(d, f, o);
            let b = true;
            i && a.ownerId && a.ownerId !== i && (b = false), n && xB(a) && (b = false), r && !kB(a) && (b = false), b && (m[_++] = a);
          }
          if (Xt(a, true), a.right !== Je && !Rn(a.right)) {
            l += a.delta, a = a.right;
            continue;
          }
        }
        return Xt(s.root, false), m;
      }
      function MP(s, e) {
        if (s.root === Je) return e.parent = Je, e.left = Je, e.right = Je, ii(e, 0), s.root = e, s.root;
        Rne(s, e), xc(e.parent);
        let t = e;
        for (; t !== s.root && Ss(t.parent) === 1; ) if (t.parent === t.parent.parent.left) {
          const i = t.parent.parent.right;
          Ss(i) === 1 ? (ii(t.parent, 0), ii(i, 0), ii(t.parent.parent, 1), t = t.parent.parent) : (t === t.parent.right && (t = t.parent, Dp(s, t)), ii(t.parent, 0), ii(t.parent.parent, 1), Ep(s, t.parent.parent));
        } else {
          const i = t.parent.parent.left;
          Ss(i) === 1 ? (ii(t.parent, 0), ii(i, 0), ii(t.parent.parent, 1), t = t.parent.parent) : (t === t.parent.left && (t = t.parent, Ep(s, t)), ii(t.parent, 0), ii(t.parent.parent, 1), Dp(s, t.parent.parent));
        }
        return ii(s.root, 0), e;
      }
      function Rne(s, e) {
        let t = 0, i = s.root;
        const n = e.start, o = e.end;
        for (; ; ) if (Pne(n, o, i.start + t, i.end + t) < 0) if (i.left === Je) {
          e.start -= t, e.end -= t, e.maxEnd -= t, i.left = e;
          break;
        } else i = i.left;
        else if (i.right === Je) {
          e.start -= t + i.delta, e.end -= t + i.delta, e.maxEnd -= t + i.delta, i.right = e;
          break;
        } else t += i.delta, i = i.right;
        e.parent = i, e.left = Je, e.right = Je, ii(e, 1);
      }
      function AP(s, e) {
        let t, i;
        if (e.left === Je ? (t = e.right, i = e, t.delta += e.delta, (t.delta < -1073741824 || t.delta > 1073741824) && (s.requestNormalizeDelta = true), t.start += e.delta, t.end += e.delta) : e.right === Je ? (t = e.left, i = e) : (i = One(e.right), t = i.right, t.start += i.delta, t.end += i.delta, t.delta += i.delta, (t.delta < -1073741824 || t.delta > 1073741824) && (s.requestNormalizeDelta = true), i.start += e.delta, i.end += e.delta, i.delta = e.delta, (i.delta < -1073741824 || i.delta > 1073741824) && (s.requestNormalizeDelta = true)), i === s.root) {
          s.root = t, ii(t, 0), e.detach(), nx(), lu(t), s.root.parent = Je;
          return;
        }
        const n = Ss(i) === 1;
        if (i === i.parent.left ? i.parent.left = t : i.parent.right = t, i === e ? t.parent = i.parent : (i.parent === e ? t.parent = i : t.parent = i.parent, i.left = e.left, i.right = e.right, i.parent = e.parent, ii(i, Ss(e)), e === s.root ? s.root = i : e === e.parent.left ? e.parent.left = i : e.parent.right = i, i.left !== Je && (i.left.parent = i), i.right !== Je && (i.right.parent = i)), e.detach(), n) {
          xc(t.parent), i !== e && (xc(i), xc(i.parent)), nx();
          return;
        }
        xc(t), xc(t.parent), i !== e && (xc(i), xc(i.parent));
        let o;
        for (; t !== s.root && Ss(t) === 0; ) t === t.parent.left ? (o = t.parent.right, Ss(o) === 1 && (ii(o, 0), ii(t.parent, 1), Dp(s, t.parent), o = t.parent.right), Ss(o.left) === 0 && Ss(o.right) === 0 ? (ii(o, 1), t = t.parent) : (Ss(o.right) === 0 && (ii(o.left, 0), ii(o, 1), Ep(s, o), o = t.parent.right), ii(o, Ss(t.parent)), ii(t.parent, 0), ii(o.right, 0), Dp(s, t.parent), t = s.root)) : (o = t.parent.left, Ss(o) === 1 && (ii(o, 0), ii(t.parent, 1), Ep(s, t.parent), o = t.parent.left), Ss(o.left) === 0 && Ss(o.right) === 0 ? (ii(o, 1), t = t.parent) : (Ss(o.left) === 0 && (ii(o.right, 0), ii(o, 1), Dp(s, o), o = t.parent.left), ii(o, Ss(t.parent)), ii(t.parent, 0), ii(o.left, 0), Ep(s, t.parent), t = s.root));
        ii(t, 0), nx();
      }
      function One(s) {
        for (; s.left !== Je; ) s = s.left;
        return s;
      }
      function nx() {
        Je.parent = Je, Je.delta = 0, Je.start = 0, Je.end = 0;
      }
      function Dp(s, e) {
        const t = e.right;
        t.delta += e.delta, (t.delta < -1073741824 || t.delta > 1073741824) && (s.requestNormalizeDelta = true), t.start += e.delta, t.end += e.delta, e.right = t.left, t.left !== Je && (t.left.parent = e), t.parent = e.parent, e.parent === Je ? s.root = t : e === e.parent.left ? e.parent.left = t : e.parent.right = t, t.left = e, e.parent = t, lu(e), lu(t);
      }
      function Ep(s, e) {
        const t = e.left;
        e.delta -= t.delta, (e.delta < -1073741824 || e.delta > 1073741824) && (s.requestNormalizeDelta = true), e.start -= t.delta, e.end -= t.delta, e.left = t.right, t.right !== Je && (t.right.parent = e), t.parent = e.parent, e.parent === Je ? s.root = t : e === e.parent.right ? e.parent.right = t : e.parent.left = t, t.right = e, e.parent = t, lu(e), lu(t);
      }
      function EB(s) {
        let e = s.end;
        if (s.left !== Je) {
          const t = s.left.maxEnd;
          t > e && (e = t);
        }
        if (s.right !== Je) {
          const t = s.right.maxEnd + s.delta;
          t > e && (e = t);
        }
        return e;
      }
      function lu(s) {
        s.maxEnd = EB(s);
      }
      function xc(s) {
        for (; s !== Je; ) {
          const e = EB(s);
          if (s.maxEnd === e) return;
          s.maxEnd = e, s = s.parent;
        }
      }
      function Pne(s, e, t, i) {
        return s === t ? e - i : s - t;
      }
      class r2 {
        constructor(e, t) {
          this.piece = e, this.color = t, this.size_left = 0, this.lf_left = 0, this.parent = this, this.left = this, this.right = this;
        }
        next() {
          if (this.right !== $e) return fN(this.right);
          let e = this;
          for (; e.parent !== $e && e.parent.left !== e; ) e = e.parent;
          return e.parent === $e ? $e : e.parent;
        }
        prev() {
          if (this.left !== $e) return TB(this.left);
          let e = this;
          for (; e.parent !== $e && e.parent.right !== e; ) e = e.parent;
          return e.parent === $e ? $e : e.parent;
        }
        detach() {
          this.parent = null, this.left = null, this.right = null;
        }
      }
      const $e = new r2(null, 0);
      $e.parent = $e;
      $e.left = $e;
      $e.right = $e;
      $e.color = 0;
      function fN(s) {
        for (; s.left !== $e; ) s = s.left;
        return s;
      }
      function TB(s) {
        for (; s.right !== $e; ) s = s.right;
        return s;
      }
      function gN(s) {
        return s === $e ? 0 : s.size_left + s.piece.length + gN(s.right);
      }
      function mN(s) {
        return s === $e ? 0 : s.lf_left + s.piece.lineFeedCnt + mN(s.right);
      }
      function sx() {
        $e.parent = $e;
      }
      function Tp(s, e) {
        const t = e.right;
        t.size_left += e.size_left + (e.piece ? e.piece.length : 0), t.lf_left += e.lf_left + (e.piece ? e.piece.lineFeedCnt : 0), e.right = t.left, t.left !== $e && (t.left.parent = e), t.parent = e.parent, e.parent === $e ? s.root = t : e.parent.left === e ? e.parent.left = t : e.parent.right = t, t.left = e, e.parent = t;
      }
      function Np(s, e) {
        const t = e.left;
        e.left = t.right, t.right !== $e && (t.right.parent = e), t.parent = e.parent, e.size_left -= t.size_left + (t.piece ? t.piece.length : 0), e.lf_left -= t.lf_left + (t.piece ? t.piece.lineFeedCnt : 0), e.parent === $e ? s.root = t : e === e.parent.right ? e.parent.right = t : e.parent.left = t, t.right = e, e.parent = t;
      }
      function Yb(s, e) {
        let t, i;
        if (e.left === $e ? (i = e, t = i.right) : e.right === $e ? (i = e, t = i.left) : (i = fN(e.right), t = i.right), i === s.root) {
          s.root = t, t.color = 0, e.detach(), sx(), s.root.parent = $e;
          return;
        }
        const n = i.color === 1;
        if (i === i.parent.left ? i.parent.left = t : i.parent.right = t, i === e ? (t.parent = i.parent, lp(s, t)) : (i.parent === e ? t.parent = i : t.parent = i.parent, lp(s, t), i.left = e.left, i.right = e.right, i.parent = e.parent, i.color = e.color, e === s.root ? s.root = i : e === e.parent.left ? e.parent.left = i : e.parent.right = i, i.left !== $e && (i.left.parent = i), i.right !== $e && (i.right.parent = i), i.size_left = e.size_left, i.lf_left = e.lf_left, lp(s, i)), e.detach(), t.parent.left === t) {
          const r = gN(t), a = mN(t);
          if (r !== t.parent.size_left || a !== t.parent.lf_left) {
            const l = r - t.parent.size_left, u = a - t.parent.lf_left;
            t.parent.size_left = r, t.parent.lf_left = a, gl(s, t.parent, l, u);
          }
        }
        if (lp(s, t.parent), n) {
          sx();
          return;
        }
        let o;
        for (; t !== s.root && t.color === 0; ) t === t.parent.left ? (o = t.parent.right, o.color === 1 && (o.color = 0, t.parent.color = 1, Tp(s, t.parent), o = t.parent.right), o.left.color === 0 && o.right.color === 0 ? (o.color = 1, t = t.parent) : (o.right.color === 0 && (o.left.color = 0, o.color = 1, Np(s, o), o = t.parent.right), o.color = t.parent.color, t.parent.color = 0, o.right.color = 0, Tp(s, t.parent), t = s.root)) : (o = t.parent.left, o.color === 1 && (o.color = 0, t.parent.color = 1, Np(s, t.parent), o = t.parent.left), o.left.color === 0 && o.right.color === 0 ? (o.color = 1, t = t.parent) : (o.left.color === 0 && (o.right.color = 0, o.color = 1, Tp(s, o), o = t.parent.left), o.color = t.parent.color, t.parent.color = 0, o.left.color = 0, Np(s, t.parent), t = s.root));
        t.color = 0, sx();
      }
      function RP(s, e) {
        for (lp(s, e); e !== s.root && e.parent.color === 1; ) if (e.parent === e.parent.parent.left) {
          const t = e.parent.parent.right;
          t.color === 1 ? (e.parent.color = 0, t.color = 0, e.parent.parent.color = 1, e = e.parent.parent) : (e === e.parent.right && (e = e.parent, Tp(s, e)), e.parent.color = 0, e.parent.parent.color = 1, Np(s, e.parent.parent));
        } else {
          const t = e.parent.parent.left;
          t.color === 1 ? (e.parent.color = 0, t.color = 0, e.parent.parent.color = 1, e = e.parent.parent) : (e === e.parent.left && (e = e.parent, Np(s, e)), e.parent.color = 0, e.parent.parent.color = 1, Tp(s, e.parent.parent));
        }
        s.root.color = 0;
      }
      function gl(s, e, t, i) {
        for (; e !== s.root && e !== $e; ) e.parent.left === e && (e.parent.size_left += t, e.parent.lf_left += i), e = e.parent;
      }
      function lp(s, e) {
        let t = 0, i = 0;
        if (e !== s.root) {
          for (; e !== s.root && e === e.parent.right; ) e = e.parent;
          if (e !== s.root) for (e = e.parent, t = gN(e.left) - e.size_left, i = mN(e.left) - e.lf_left, e.size_left += t, e.lf_left += i; e !== s.root && (t !== 0 || i !== 0); ) e.parent.left === e && (e.parent.size_left += t, e.parent.lf_left += i), e = e.parent;
        }
      }
      const cl = 65535;
      function NB(s) {
        let e;
        return s[s.length - 1] < 65536 ? e = new Uint16Array(s.length) : e = new Uint32Array(s.length), e.set(s, 0), e;
      }
      class Bne {
        constructor(e, t, i, n, o) {
          this.lineStarts = e, this.cr = t, this.lf = i, this.crlf = n, this.isBasicASCII = o;
        }
      }
      function _l(s, e = true) {
        const t = [
          0
        ];
        let i = 1;
        for (let n = 0, o = s.length; n < o; n++) {
          const r = s.charCodeAt(n);
          r === 13 ? n + 1 < o && s.charCodeAt(n + 1) === 10 ? (t[i++] = n + 2, n++) : t[i++] = n + 1 : r === 10 && (t[i++] = n + 1);
        }
        return e ? NB(t) : t;
      }
      function Fne(s, e) {
        s.length = 0, s[0] = 0;
        let t = 1, i = 0, n = 0, o = 0, r = true;
        for (let l = 0, u = e.length; l < u; l++) {
          const d = e.charCodeAt(l);
          d === 13 ? l + 1 < u && e.charCodeAt(l + 1) === 10 ? (o++, s[t++] = l + 2, l++) : (i++, s[t++] = l + 1) : d === 10 ? (n++, s[t++] = l + 1) : r && d !== 9 && (d < 32 || d > 126) && (r = false);
        }
        const a = new Bne(NB(s), i, n, o, r);
        return s.length = 0, a;
      }
      class Vs {
        constructor(e, t, i, n, o) {
          this.bufferIndex = e, this.start = t, this.end = i, this.lineFeedCnt = n, this.length = o;
        }
      }
      class sh {
        constructor(e, t) {
          this.buffer = e, this.lineStarts = t;
        }
      }
      class Vne {
        constructor(e, t) {
          this._pieces = [], this._tree = e, this._BOM = t, this._index = 0, e.root !== $e && e.iterate(e.root, (i) => (i !== $e && this._pieces.push(i.piece), true));
        }
        read() {
          return this._pieces.length === 0 ? this._index === 0 ? (this._index++, this._BOM) : null : this._index > this._pieces.length - 1 ? null : this._index === 0 ? this._BOM + this._tree.getPieceContent(this._pieces[this._index++]) : this._tree.getPieceContent(this._pieces[this._index++]);
        }
      }
      class Wne {
        constructor(e) {
          this._limit = e, this._cache = [];
        }
        get(e) {
          for (let t = this._cache.length - 1; t >= 0; t--) {
            const i = this._cache[t];
            if (i.nodeStartOffset <= e && i.nodeStartOffset + i.node.piece.length >= e) return i;
          }
          return null;
        }
        get2(e) {
          for (let t = this._cache.length - 1; t >= 0; t--) {
            const i = this._cache[t];
            if (i.nodeStartLineNumber && i.nodeStartLineNumber < e && i.nodeStartLineNumber + i.node.piece.lineFeedCnt >= e) return i;
          }
          return null;
        }
        set(e) {
          this._cache.length >= this._limit && this._cache.shift(), this._cache.push(e);
        }
        validate(e) {
          let t = false;
          const i = this._cache;
          for (let n = 0; n < i.length; n++) {
            const o = i[n];
            if (o.node.parent === null || o.nodeStartOffset >= e) {
              i[n] = null, t = true;
              continue;
            }
          }
          if (t) {
            const n = [];
            for (const o of i) o !== null && n.push(o);
            this._cache = n;
          }
        }
      }
      class Hne {
        constructor(e, t, i) {
          this.create(e, t, i);
        }
        create(e, t, i) {
          this._buffers = [
            new sh("", [
              0
            ])
          ], this._lastChangeBufferPos = {
            line: 0,
            column: 0
          }, this.root = $e, this._lineCnt = 1, this._length = 0, this._EOL = t, this._EOLLength = t.length, this._EOLNormalized = i;
          let n = null;
          for (let o = 0, r = e.length; o < r; o++) if (e[o].buffer.length > 0) {
            e[o].lineStarts || (e[o].lineStarts = _l(e[o].buffer));
            const a = new Vs(o + 1, {
              line: 0,
              column: 0
            }, {
              line: e[o].lineStarts.length - 1,
              column: e[o].buffer.length - e[o].lineStarts[e[o].lineStarts.length - 1]
            }, e[o].lineStarts.length - 1, e[o].buffer.length);
            this._buffers.push(e[o]), n = this.rbInsertRight(n, a);
          }
          this._searchCache = new Wne(1), this._lastVisitedLine = {
            lineNumber: 0,
            value: ""
          }, this.computeBufferMetadata();
        }
        normalizeEOL(e) {
          const t = cl, i = t - Math.floor(t / 3), n = i * 2;
          let o = "", r = 0;
          const a = [];
          if (this.iterate(this.root, (l) => {
            const u = this.getNodeContent(l), d = u.length;
            if (r <= i || r + d < n) return o += u, r += d, true;
            const f = o.replace(/\r\n|\r|\n/g, e);
            return a.push(new sh(f, _l(f))), o = u, r = d, true;
          }), r > 0) {
            const l = o.replace(/\r\n|\r|\n/g, e);
            a.push(new sh(l, _l(l)));
          }
          this.create(a, e, true);
        }
        getEOL() {
          return this._EOL;
        }
        setEOL(e) {
          this._EOL = e, this._EOLLength = this._EOL.length, this.normalizeEOL(e);
        }
        createSnapshot(e) {
          return new Vne(this, e);
        }
        getOffsetAt(e, t) {
          let i = 0, n = this.root;
          for (; n !== $e; ) if (n.left !== $e && n.lf_left + 1 >= e) n = n.left;
          else if (n.lf_left + n.piece.lineFeedCnt + 1 >= e) {
            i += n.size_left;
            const o = this.getAccumulatedValue(n, e - n.lf_left - 2);
            return i += o + t - 1;
          } else e -= n.lf_left + n.piece.lineFeedCnt, i += n.size_left + n.piece.length, n = n.right;
          return i;
        }
        getPositionAt(e) {
          e = Math.floor(e), e = Math.max(0, e);
          let t = this.root, i = 0;
          const n = e;
          for (; t !== $e; ) if (t.size_left !== 0 && t.size_left >= e) t = t.left;
          else if (t.size_left + t.piece.length >= e) {
            const o = this.getIndexOf(t, e - t.size_left);
            if (i += t.lf_left + o.index, o.index === 0) {
              const r = this.getOffsetAt(i + 1, 1), a = n - r;
              return new X(i + 1, a + 1);
            }
            return new X(i + 1, o.remainder + 1);
          } else if (e -= t.size_left + t.piece.length, i += t.lf_left + t.piece.lineFeedCnt, t.right === $e) {
            const o = this.getOffsetAt(i + 1, 1), r = n - e - o;
            return new X(i + 1, r + 1);
          } else t = t.right;
          return new X(1, 1);
        }
        getValueInRange(e, t) {
          if (e.startLineNumber === e.endLineNumber && e.startColumn === e.endColumn) return "";
          const i = this.nodeAt2(e.startLineNumber, e.startColumn), n = this.nodeAt2(e.endLineNumber, e.endColumn), o = this.getValueInRange2(i, n);
          return t ? t !== this._EOL || !this._EOLNormalized ? o.replace(/\r\n|\r|\n/g, t) : t === this.getEOL() && this._EOLNormalized ? o : o.replace(/\r\n|\r|\n/g, t) : o;
        }
        getValueInRange2(e, t) {
          if (e.node === t.node) {
            const a = e.node, l = this._buffers[a.piece.bufferIndex].buffer, u = this.offsetInBuffer(a.piece.bufferIndex, a.piece.start);
            return l.substring(u + e.remainder, u + t.remainder);
          }
          let i = e.node;
          const n = this._buffers[i.piece.bufferIndex].buffer, o = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
          let r = n.substring(o + e.remainder, o + i.piece.length);
          for (i = i.next(); i !== $e; ) {
            const a = this._buffers[i.piece.bufferIndex].buffer, l = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
            if (i === t.node) {
              r += a.substring(l, l + t.remainder);
              break;
            } else r += a.substr(l, i.piece.length);
            i = i.next();
          }
          return r;
        }
        getLinesContent() {
          const e = [];
          let t = 0, i = "", n = false;
          return this.iterate(this.root, (o) => {
            if (o === $e) return true;
            const r = o.piece;
            let a = r.length;
            if (a === 0) return true;
            const l = this._buffers[r.bufferIndex].buffer, u = this._buffers[r.bufferIndex].lineStarts, d = r.start.line, f = r.end.line;
            let m = u[d] + r.start.column;
            if (n && (l.charCodeAt(m) === 10 && (m++, a--), e[t++] = i, i = "", n = false, a === 0)) return true;
            if (d === f) return !this._EOLNormalized && l.charCodeAt(m + a - 1) === 13 ? (n = true, i += l.substr(m, a - 1)) : i += l.substr(m, a), true;
            i += this._EOLNormalized ? l.substring(m, Math.max(m, u[d + 1] - this._EOLLength)) : l.substring(m, u[d + 1]).replace(/(\r\n|\r|\n)$/, ""), e[t++] = i;
            for (let _ = d + 1; _ < f; _++) i = this._EOLNormalized ? l.substring(u[_], u[_ + 1] - this._EOLLength) : l.substring(u[_], u[_ + 1]).replace(/(\r\n|\r|\n)$/, ""), e[t++] = i;
            return !this._EOLNormalized && l.charCodeAt(u[f] + r.end.column - 1) === 13 ? (n = true, r.end.column === 0 ? t-- : i = l.substr(u[f], r.end.column - 1)) : i = l.substr(u[f], r.end.column), true;
          }), n && (e[t++] = i, i = ""), e[t++] = i, e;
        }
        getLength() {
          return this._length;
        }
        getLineCount() {
          return this._lineCnt;
        }
        getLineContent(e) {
          return this._lastVisitedLine.lineNumber === e ? this._lastVisitedLine.value : (this._lastVisitedLine.lineNumber = e, e === this._lineCnt ? this._lastVisitedLine.value = this.getLineRawContent(e) : this._EOLNormalized ? this._lastVisitedLine.value = this.getLineRawContent(e, this._EOLLength) : this._lastVisitedLine.value = this.getLineRawContent(e).replace(/(\r\n|\r|\n)$/, ""), this._lastVisitedLine.value);
        }
        _getCharCode(e) {
          if (e.remainder === e.node.piece.length) {
            const t = e.node.next();
            if (!t) return 0;
            const i = this._buffers[t.piece.bufferIndex], n = this.offsetInBuffer(t.piece.bufferIndex, t.piece.start);
            return i.buffer.charCodeAt(n);
          } else {
            const t = this._buffers[e.node.piece.bufferIndex], n = this.offsetInBuffer(e.node.piece.bufferIndex, e.node.piece.start) + e.remainder;
            return t.buffer.charCodeAt(n);
          }
        }
        getLineCharCode(e, t) {
          const i = this.nodeAt2(e, t + 1);
          return this._getCharCode(i);
        }
        getLineLength(e) {
          if (e === this.getLineCount()) {
            const t = this.getOffsetAt(e, 1);
            return this.getLength() - t;
          }
          return this.getOffsetAt(e + 1, 1) - this.getOffsetAt(e, 1) - this._EOLLength;
        }
        findMatchesInNode(e, t, i, n, o, r, a, l, u, d, f) {
          const m = this._buffers[e.piece.bufferIndex], _ = this.offsetInBuffer(e.piece.bufferIndex, e.piece.start), b = this.offsetInBuffer(e.piece.bufferIndex, o), v = this.offsetInBuffer(e.piece.bufferIndex, r);
          let y;
          const x = {
            line: 0,
            column: 0
          };
          let L, D;
          t._wordSeparators ? (L = m.buffer.substring(b, v), D = (k) => k + b, t.reset(0)) : (L = m.buffer, D = (k) => k, t.reset(b));
          do
            if (y = t.next(L), y) {
              if (D(y.index) >= v) return d;
              this.positionInBuffer(e, D(y.index) - _, x);
              const k = this.getLineFeedCnt(e.piece.bufferIndex, o, x), T = x.line === o.line ? x.column - o.column + n : x.column + 1, M = T + y[0].length;
              if (f[d++] = Xu(new z(i + k, T, i + k, M), y, l), D(y.index) + y[0].length >= v || d >= u) return d;
            }
          while (y);
          return d;
        }
        findMatchesLineByLine(e, t, i, n) {
          const o = [];
          let r = 0;
          const a = new ff(t.wordSeparators, t.regex);
          let l = this.nodeAt2(e.startLineNumber, e.startColumn);
          if (l === null) return [];
          const u = this.nodeAt2(e.endLineNumber, e.endColumn);
          if (u === null) return [];
          let d = this.positionInBuffer(l.node, l.remainder);
          const f = this.positionInBuffer(u.node, u.remainder);
          if (l.node === u.node) return this.findMatchesInNode(l.node, a, e.startLineNumber, e.startColumn, d, f, t, i, n, r, o), o;
          let m = e.startLineNumber, _ = l.node;
          for (; _ !== u.node; ) {
            const v = this.getLineFeedCnt(_.piece.bufferIndex, d, _.piece.end);
            if (v >= 1) {
              const x = this._buffers[_.piece.bufferIndex].lineStarts, L = this.offsetInBuffer(_.piece.bufferIndex, _.piece.start), D = x[d.line + v], k = m === e.startLineNumber ? e.startColumn : 1;
              if (r = this.findMatchesInNode(_, a, m, k, d, this.positionInBuffer(_, D - L), t, i, n, r, o), r >= n) return o;
              m += v;
            }
            const y = m === e.startLineNumber ? e.startColumn - 1 : 0;
            if (m === e.endLineNumber) {
              const x = this.getLineContent(m).substring(y, e.endColumn - 1);
              return r = this._findMatchesInLine(t, a, x, e.endLineNumber, y, r, o, i, n), o;
            }
            if (r = this._findMatchesInLine(t, a, this.getLineContent(m).substr(y), m, y, r, o, i, n), r >= n) return o;
            m++, l = this.nodeAt2(m, 1), _ = l.node, d = this.positionInBuffer(l.node, l.remainder);
          }
          if (m === e.endLineNumber) {
            const v = m === e.startLineNumber ? e.startColumn - 1 : 0, y = this.getLineContent(m).substring(v, e.endColumn - 1);
            return r = this._findMatchesInLine(t, a, y, e.endLineNumber, v, r, o, i, n), o;
          }
          const b = m === e.startLineNumber ? e.startColumn : 1;
          return r = this.findMatchesInNode(u.node, a, m, b, d, f, t, i, n, r, o), o;
        }
        _findMatchesInLine(e, t, i, n, o, r, a, l, u) {
          const d = e.wordSeparators;
          if (!l && e.simpleSearch) {
            const m = e.simpleSearch, _ = m.length, b = i.length;
            let v = -_;
            for (; (v = i.indexOf(m, v + _)) !== -1; ) if ((!d || yT(d, i, b, v, _)) && (a[r++] = new e_(new z(n, v + 1 + o, n, v + 1 + _ + o), null), r >= u)) return r;
            return r;
          }
          let f;
          t.reset(0);
          do
            if (f = t.next(i), f && (a[r++] = Xu(new z(n, f.index + 1 + o, n, f.index + 1 + f[0].length + o), f, l), r >= u)) return r;
          while (f);
          return r;
        }
        insert(e, t, i = false) {
          if (this._EOLNormalized = this._EOLNormalized && i, this._lastVisitedLine.lineNumber = 0, this._lastVisitedLine.value = "", this.root !== $e) {
            const { node: n, remainder: o, nodeStartOffset: r } = this.nodeAt(e), a = n.piece, l = a.bufferIndex, u = this.positionInBuffer(n, o);
            if (n.piece.bufferIndex === 0 && a.end.line === this._lastChangeBufferPos.line && a.end.column === this._lastChangeBufferPos.column && r + a.length === e && t.length < cl) {
              this.appendToNode(n, t), this.computeBufferMetadata();
              return;
            }
            if (r === e) this.insertContentToNodeLeft(t, n), this._searchCache.validate(e);
            else if (r + n.piece.length > e) {
              const d = [];
              let f = new Vs(a.bufferIndex, u, a.end, this.getLineFeedCnt(a.bufferIndex, u, a.end), this.offsetInBuffer(l, a.end) - this.offsetInBuffer(l, u));
              if (this.shouldCheckCRLF() && this.endWithCR(t) && this.nodeCharCodeAt(n, o) === 10) {
                const v = {
                  line: f.start.line + 1,
                  column: 0
                };
                f = new Vs(f.bufferIndex, v, f.end, this.getLineFeedCnt(f.bufferIndex, v, f.end), f.length - 1), t += `
`;
              }
              if (this.shouldCheckCRLF() && this.startWithLF(t)) if (this.nodeCharCodeAt(n, o - 1) === 13) {
                const v = this.positionInBuffer(n, o - 1);
                this.deleteNodeTail(n, v), t = "\r" + t, n.piece.length === 0 && d.push(n);
              } else this.deleteNodeTail(n, u);
              else this.deleteNodeTail(n, u);
              const m = this.createNewPieces(t);
              f.length > 0 && this.rbInsertRight(n, f);
              let _ = n;
              for (let b = 0; b < m.length; b++) _ = this.rbInsertRight(_, m[b]);
              this.deleteNodes(d);
            } else this.insertContentToNodeRight(t, n);
          } else {
            const n = this.createNewPieces(t);
            let o = this.rbInsertLeft(null, n[0]);
            for (let r = 1; r < n.length; r++) o = this.rbInsertRight(o, n[r]);
          }
          this.computeBufferMetadata();
        }
        delete(e, t) {
          if (this._lastVisitedLine.lineNumber = 0, this._lastVisitedLine.value = "", t <= 0 || this.root === $e) return;
          const i = this.nodeAt(e), n = this.nodeAt(e + t), o = i.node, r = n.node;
          if (o === r) {
            const m = this.positionInBuffer(o, i.remainder), _ = this.positionInBuffer(o, n.remainder);
            if (i.nodeStartOffset === e) {
              if (t === o.piece.length) {
                const b = o.next();
                Yb(this, o), this.validateCRLFWithPrevNode(b), this.computeBufferMetadata();
                return;
              }
              this.deleteNodeHead(o, _), this._searchCache.validate(e), this.validateCRLFWithPrevNode(o), this.computeBufferMetadata();
              return;
            }
            if (i.nodeStartOffset + o.piece.length === e + t) {
              this.deleteNodeTail(o, m), this.validateCRLFWithNextNode(o), this.computeBufferMetadata();
              return;
            }
            this.shrinkNode(o, m, _), this.computeBufferMetadata();
            return;
          }
          const a = [], l = this.positionInBuffer(o, i.remainder);
          this.deleteNodeTail(o, l), this._searchCache.validate(e), o.piece.length === 0 && a.push(o);
          const u = this.positionInBuffer(r, n.remainder);
          this.deleteNodeHead(r, u), r.piece.length === 0 && a.push(r);
          const d = o.next();
          for (let m = d; m !== $e && m !== r; m = m.next()) a.push(m);
          const f = o.piece.length === 0 ? o.prev() : o;
          this.deleteNodes(a), this.validateCRLFWithNextNode(f), this.computeBufferMetadata();
        }
        insertContentToNodeLeft(e, t) {
          const i = [];
          if (this.shouldCheckCRLF() && this.endWithCR(e) && this.startWithLF(t)) {
            const r = t.piece, a = {
              line: r.start.line + 1,
              column: 0
            }, l = new Vs(r.bufferIndex, a, r.end, this.getLineFeedCnt(r.bufferIndex, a, r.end), r.length - 1);
            t.piece = l, e += `
`, gl(this, t, -1, -1), t.piece.length === 0 && i.push(t);
          }
          const n = this.createNewPieces(e);
          let o = this.rbInsertLeft(t, n[n.length - 1]);
          for (let r = n.length - 2; r >= 0; r--) o = this.rbInsertLeft(o, n[r]);
          this.validateCRLFWithPrevNode(o), this.deleteNodes(i);
        }
        insertContentToNodeRight(e, t) {
          this.adjustCarriageReturnFromNext(e, t) && (e += `
`);
          const i = this.createNewPieces(e), n = this.rbInsertRight(t, i[0]);
          let o = n;
          for (let r = 1; r < i.length; r++) o = this.rbInsertRight(o, i[r]);
          this.validateCRLFWithPrevNode(n);
        }
        positionInBuffer(e, t, i) {
          const n = e.piece, o = e.piece.bufferIndex, r = this._buffers[o].lineStarts, l = r[n.start.line] + n.start.column + t;
          let u = n.start.line, d = n.end.line, f = 0, m = 0, _ = 0;
          for (; u <= d && (f = u + (d - u) / 2 | 0, _ = r[f], f !== d); ) if (m = r[f + 1], l < _) d = f - 1;
          else if (l >= m) u = f + 1;
          else break;
          return i ? (i.line = f, i.column = l - _, null) : {
            line: f,
            column: l - _
          };
        }
        getLineFeedCnt(e, t, i) {
          if (i.column === 0) return i.line - t.line;
          const n = this._buffers[e].lineStarts;
          if (i.line === n.length - 1) return i.line - t.line;
          const o = n[i.line + 1], r = n[i.line] + i.column;
          if (o > r + 1) return i.line - t.line;
          const a = r - 1;
          return this._buffers[e].buffer.charCodeAt(a) === 13 ? i.line - t.line + 1 : i.line - t.line;
        }
        offsetInBuffer(e, t) {
          return this._buffers[e].lineStarts[t.line] + t.column;
        }
        deleteNodes(e) {
          for (let t = 0; t < e.length; t++) Yb(this, e[t]);
        }
        createNewPieces(e) {
          if (e.length > cl) {
            const d = [];
            for (; e.length > cl; ) {
              const m = e.charCodeAt(cl - 1);
              let _;
              m === 13 || m >= 55296 && m <= 56319 ? (_ = e.substring(0, cl - 1), e = e.substring(cl - 1)) : (_ = e.substring(0, cl), e = e.substring(cl));
              const b = _l(_);
              d.push(new Vs(this._buffers.length, {
                line: 0,
                column: 0
              }, {
                line: b.length - 1,
                column: _.length - b[b.length - 1]
              }, b.length - 1, _.length)), this._buffers.push(new sh(_, b));
            }
            const f = _l(e);
            return d.push(new Vs(this._buffers.length, {
              line: 0,
              column: 0
            }, {
              line: f.length - 1,
              column: e.length - f[f.length - 1]
            }, f.length - 1, e.length)), this._buffers.push(new sh(e, f)), d;
          }
          let t = this._buffers[0].buffer.length;
          const i = _l(e, false);
          let n = this._lastChangeBufferPos;
          if (this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 1] === t && t !== 0 && this.startWithLF(e) && this.endWithCR(this._buffers[0].buffer)) {
            this._lastChangeBufferPos = {
              line: this._lastChangeBufferPos.line,
              column: this._lastChangeBufferPos.column + 1
            }, n = this._lastChangeBufferPos;
            for (let d = 0; d < i.length; d++) i[d] += t + 1;
            this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(i.slice(1)), this._buffers[0].buffer += "_" + e, t += 1;
          } else {
            if (t !== 0) for (let d = 0; d < i.length; d++) i[d] += t;
            this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(i.slice(1)), this._buffers[0].buffer += e;
          }
          const o = this._buffers[0].buffer.length, r = this._buffers[0].lineStarts.length - 1, a = o - this._buffers[0].lineStarts[r], l = {
            line: r,
            column: a
          }, u = new Vs(0, n, l, this.getLineFeedCnt(0, n, l), o - t);
          return this._lastChangeBufferPos = l, [
            u
          ];
        }
        getLineRawContent(e, t = 0) {
          let i = this.root, n = "";
          const o = this._searchCache.get2(e);
          if (o) {
            i = o.node;
            const r = this.getAccumulatedValue(i, e - o.nodeStartLineNumber - 1), a = this._buffers[i.piece.bufferIndex].buffer, l = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
            if (o.nodeStartLineNumber + i.piece.lineFeedCnt === e) n = a.substring(l + r, l + i.piece.length);
            else {
              const u = this.getAccumulatedValue(i, e - o.nodeStartLineNumber);
              return a.substring(l + r, l + u - t);
            }
          } else {
            let r = 0;
            const a = e;
            for (; i !== $e; ) if (i.left !== $e && i.lf_left >= e - 1) i = i.left;
            else if (i.lf_left + i.piece.lineFeedCnt > e - 1) {
              const l = this.getAccumulatedValue(i, e - i.lf_left - 2), u = this.getAccumulatedValue(i, e - i.lf_left - 1), d = this._buffers[i.piece.bufferIndex].buffer, f = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
              return r += i.size_left, this._searchCache.set({
                node: i,
                nodeStartOffset: r,
                nodeStartLineNumber: a - (e - 1 - i.lf_left)
              }), d.substring(f + l, f + u - t);
            } else if (i.lf_left + i.piece.lineFeedCnt === e - 1) {
              const l = this.getAccumulatedValue(i, e - i.lf_left - 2), u = this._buffers[i.piece.bufferIndex].buffer, d = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
              n = u.substring(d + l, d + i.piece.length);
              break;
            } else e -= i.lf_left + i.piece.lineFeedCnt, r += i.size_left + i.piece.length, i = i.right;
          }
          for (i = i.next(); i !== $e; ) {
            const r = this._buffers[i.piece.bufferIndex].buffer;
            if (i.piece.lineFeedCnt > 0) {
              const a = this.getAccumulatedValue(i, 0), l = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
              return n += r.substring(l, l + a - t), n;
            } else {
              const a = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
              n += r.substr(a, i.piece.length);
            }
            i = i.next();
          }
          return n;
        }
        computeBufferMetadata() {
          let e = this.root, t = 1, i = 0;
          for (; e !== $e; ) t += e.lf_left + e.piece.lineFeedCnt, i += e.size_left + e.piece.length, e = e.right;
          this._lineCnt = t, this._length = i, this._searchCache.validate(this._length);
        }
        getIndexOf(e, t) {
          const i = e.piece, n = this.positionInBuffer(e, t), o = n.line - i.start.line;
          if (this.offsetInBuffer(i.bufferIndex, i.end) - this.offsetInBuffer(i.bufferIndex, i.start) === t) {
            const r = this.getLineFeedCnt(e.piece.bufferIndex, i.start, n);
            if (r !== o) return {
              index: r,
              remainder: 0
            };
          }
          return {
            index: o,
            remainder: n.column
          };
        }
        getAccumulatedValue(e, t) {
          if (t < 0) return 0;
          const i = e.piece, n = this._buffers[i.bufferIndex].lineStarts, o = i.start.line + t + 1;
          return o > i.end.line ? n[i.end.line] + i.end.column - n[i.start.line] - i.start.column : n[o] - n[i.start.line] - i.start.column;
        }
        deleteNodeTail(e, t) {
          const i = e.piece, n = i.lineFeedCnt, o = this.offsetInBuffer(i.bufferIndex, i.end), r = t, a = this.offsetInBuffer(i.bufferIndex, r), l = this.getLineFeedCnt(i.bufferIndex, i.start, r), u = l - n, d = a - o, f = i.length + d;
          e.piece = new Vs(i.bufferIndex, i.start, r, l, f), gl(this, e, d, u);
        }
        deleteNodeHead(e, t) {
          const i = e.piece, n = i.lineFeedCnt, o = this.offsetInBuffer(i.bufferIndex, i.start), r = t, a = this.getLineFeedCnt(i.bufferIndex, r, i.end), l = this.offsetInBuffer(i.bufferIndex, r), u = a - n, d = o - l, f = i.length + d;
          e.piece = new Vs(i.bufferIndex, r, i.end, a, f), gl(this, e, d, u);
        }
        shrinkNode(e, t, i) {
          const n = e.piece, o = n.start, r = n.end, a = n.length, l = n.lineFeedCnt, u = t, d = this.getLineFeedCnt(n.bufferIndex, n.start, u), f = this.offsetInBuffer(n.bufferIndex, t) - this.offsetInBuffer(n.bufferIndex, o);
          e.piece = new Vs(n.bufferIndex, n.start, u, d, f), gl(this, e, f - a, d - l);
          const m = new Vs(n.bufferIndex, i, r, this.getLineFeedCnt(n.bufferIndex, i, r), this.offsetInBuffer(n.bufferIndex, r) - this.offsetInBuffer(n.bufferIndex, i)), _ = this.rbInsertRight(e, m);
          this.validateCRLFWithPrevNode(_);
        }
        appendToNode(e, t) {
          this.adjustCarriageReturnFromNext(t, e) && (t += `
`);
          const i = this.shouldCheckCRLF() && this.startWithLF(t) && this.endWithCR(e), n = this._buffers[0].buffer.length;
          this._buffers[0].buffer += t;
          const o = _l(t, false);
          for (let _ = 0; _ < o.length; _++) o[_] += n;
          if (i) {
            const _ = this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 2];
            this._buffers[0].lineStarts.pop(), this._lastChangeBufferPos = {
              line: this._lastChangeBufferPos.line - 1,
              column: n - _
            };
          }
          this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(o.slice(1));
          const r = this._buffers[0].lineStarts.length - 1, a = this._buffers[0].buffer.length - this._buffers[0].lineStarts[r], l = {
            line: r,
            column: a
          }, u = e.piece.length + t.length, d = e.piece.lineFeedCnt, f = this.getLineFeedCnt(0, e.piece.start, l), m = f - d;
          e.piece = new Vs(e.piece.bufferIndex, e.piece.start, l, f, u), this._lastChangeBufferPos = l, gl(this, e, t.length, m);
        }
        nodeAt(e) {
          let t = this.root;
          const i = this._searchCache.get(e);
          if (i) return {
            node: i.node,
            nodeStartOffset: i.nodeStartOffset,
            remainder: e - i.nodeStartOffset
          };
          let n = 0;
          for (; t !== $e; ) if (t.size_left > e) t = t.left;
          else if (t.size_left + t.piece.length >= e) {
            n += t.size_left;
            const o = {
              node: t,
              remainder: e - t.size_left,
              nodeStartOffset: n
            };
            return this._searchCache.set(o), o;
          } else e -= t.size_left + t.piece.length, n += t.size_left + t.piece.length, t = t.right;
          return null;
        }
        nodeAt2(e, t) {
          let i = this.root, n = 0;
          for (; i !== $e; ) if (i.left !== $e && i.lf_left >= e - 1) i = i.left;
          else if (i.lf_left + i.piece.lineFeedCnt > e - 1) {
            const o = this.getAccumulatedValue(i, e - i.lf_left - 2), r = this.getAccumulatedValue(i, e - i.lf_left - 1);
            return n += i.size_left, {
              node: i,
              remainder: Math.min(o + t - 1, r),
              nodeStartOffset: n
            };
          } else if (i.lf_left + i.piece.lineFeedCnt === e - 1) {
            const o = this.getAccumulatedValue(i, e - i.lf_left - 2);
            if (o + t - 1 <= i.piece.length) return {
              node: i,
              remainder: o + t - 1,
              nodeStartOffset: n
            };
            t -= i.piece.length - o;
            break;
          } else e -= i.lf_left + i.piece.lineFeedCnt, n += i.size_left + i.piece.length, i = i.right;
          for (i = i.next(); i !== $e; ) {
            if (i.piece.lineFeedCnt > 0) {
              const o = this.getAccumulatedValue(i, 0), r = this.offsetOfNode(i);
              return {
                node: i,
                remainder: Math.min(t - 1, o),
                nodeStartOffset: r
              };
            } else if (i.piece.length >= t - 1) {
              const o = this.offsetOfNode(i);
              return {
                node: i,
                remainder: t - 1,
                nodeStartOffset: o
              };
            } else t -= i.piece.length;
            i = i.next();
          }
          return null;
        }
        nodeCharCodeAt(e, t) {
          if (e.piece.lineFeedCnt < 1) return -1;
          const i = this._buffers[e.piece.bufferIndex], n = this.offsetInBuffer(e.piece.bufferIndex, e.piece.start) + t;
          return i.buffer.charCodeAt(n);
        }
        offsetOfNode(e) {
          if (!e) return 0;
          let t = e.size_left;
          for (; e !== this.root; ) e.parent.right === e && (t += e.parent.size_left + e.parent.piece.length), e = e.parent;
          return t;
        }
        shouldCheckCRLF() {
          return !(this._EOLNormalized && this._EOL === `
`);
        }
        startWithLF(e) {
          if (typeof e == "string") return e.charCodeAt(0) === 10;
          if (e === $e || e.piece.lineFeedCnt === 0) return false;
          const t = e.piece, i = this._buffers[t.bufferIndex].lineStarts, n = t.start.line, o = i[n] + t.start.column;
          return n === i.length - 1 || i[n + 1] > o + 1 ? false : this._buffers[t.bufferIndex].buffer.charCodeAt(o) === 10;
        }
        endWithCR(e) {
          return typeof e == "string" ? e.charCodeAt(e.length - 1) === 13 : e === $e || e.piece.lineFeedCnt === 0 ? false : this.nodeCharCodeAt(e, e.piece.length - 1) === 13;
        }
        validateCRLFWithPrevNode(e) {
          if (this.shouldCheckCRLF() && this.startWithLF(e)) {
            const t = e.prev();
            this.endWithCR(t) && this.fixCRLF(t, e);
          }
        }
        validateCRLFWithNextNode(e) {
          if (this.shouldCheckCRLF() && this.endWithCR(e)) {
            const t = e.next();
            this.startWithLF(t) && this.fixCRLF(e, t);
          }
        }
        fixCRLF(e, t) {
          const i = [], n = this._buffers[e.piece.bufferIndex].lineStarts;
          let o;
          e.piece.end.column === 0 ? o = {
            line: e.piece.end.line - 1,
            column: n[e.piece.end.line] - n[e.piece.end.line - 1] - 1
          } : o = {
            line: e.piece.end.line,
            column: e.piece.end.column - 1
          };
          const r = e.piece.length - 1, a = e.piece.lineFeedCnt - 1;
          e.piece = new Vs(e.piece.bufferIndex, e.piece.start, o, a, r), gl(this, e, -1, -1), e.piece.length === 0 && i.push(e);
          const l = {
            line: t.piece.start.line + 1,
            column: 0
          }, u = t.piece.length - 1, d = this.getLineFeedCnt(t.piece.bufferIndex, l, t.piece.end);
          t.piece = new Vs(t.piece.bufferIndex, l, t.piece.end, d, u), gl(this, t, -1, -1), t.piece.length === 0 && i.push(t);
          const f = this.createNewPieces(`\r
`);
          this.rbInsertRight(e, f[0]);
          for (let m = 0; m < i.length; m++) Yb(this, i[m]);
        }
        adjustCarriageReturnFromNext(e, t) {
          if (this.shouldCheckCRLF() && this.endWithCR(e)) {
            const i = t.next();
            if (this.startWithLF(i)) {
              if (e += `
`, i.piece.length === 1) Yb(this, i);
              else {
                const n = i.piece, o = {
                  line: n.start.line + 1,
                  column: 0
                }, r = n.length - 1, a = this.getLineFeedCnt(n.bufferIndex, o, n.end);
                i.piece = new Vs(n.bufferIndex, o, n.end, a, r), gl(this, i, -1, -1);
              }
              return true;
            }
          }
          return false;
        }
        iterate(e, t) {
          if (e === $e) return t($e);
          const i = this.iterate(e.left, t);
          return i && t(e) && this.iterate(e.right, t);
        }
        getNodeContent(e) {
          if (e === $e) return "";
          const t = this._buffers[e.piece.bufferIndex], i = e.piece, n = this.offsetInBuffer(i.bufferIndex, i.start), o = this.offsetInBuffer(i.bufferIndex, i.end);
          return t.buffer.substring(n, o);
        }
        getPieceContent(e) {
          const t = this._buffers[e.bufferIndex], i = this.offsetInBuffer(e.bufferIndex, e.start), n = this.offsetInBuffer(e.bufferIndex, e.end);
          return t.buffer.substring(i, n);
        }
        rbInsertRight(e, t) {
          const i = new r2(t, 1);
          if (i.left = $e, i.right = $e, i.parent = $e, i.size_left = 0, i.lf_left = 0, this.root === $e) this.root = i, i.color = 0;
          else if (e.right === $e) e.right = i, i.parent = e;
          else {
            const o = fN(e.right);
            o.left = i, i.parent = o;
          }
          return RP(this, i), i;
        }
        rbInsertLeft(e, t) {
          const i = new r2(t, 1);
          if (i.left = $e, i.right = $e, i.parent = $e, i.size_left = 0, i.lf_left = 0, this.root === $e) this.root = i, i.color = 0;
          else if (e.left === $e) e.left = i, i.parent = e;
          else {
            const n = TB(e.left);
            n.right = i, i.parent = n;
          }
          return RP(this, i), i;
        }
      }
      class qf extends he {
        constructor(e, t, i, n, o, r, a) {
          super(), this._onDidChangeContent = this._register(new G()), this._BOM = t, this._mightContainNonBasicASCII = !r, this._mightContainRTL = n, this._mightContainUnusualLineTerminators = o, this._pieceTree = new Hne(e, i, a);
        }
        mightContainRTL() {
          return this._mightContainRTL;
        }
        mightContainUnusualLineTerminators() {
          return this._mightContainUnusualLineTerminators;
        }
        resetMightContainUnusualLineTerminators() {
          this._mightContainUnusualLineTerminators = false;
        }
        mightContainNonBasicASCII() {
          return this._mightContainNonBasicASCII;
        }
        getBOM() {
          return this._BOM;
        }
        getEOL() {
          return this._pieceTree.getEOL();
        }
        createSnapshot(e) {
          return this._pieceTree.createSnapshot(e ? this._BOM : "");
        }
        getOffsetAt(e, t) {
          return this._pieceTree.getOffsetAt(e, t);
        }
        getPositionAt(e) {
          return this._pieceTree.getPositionAt(e);
        }
        getRangeAt(e, t) {
          const i = e + t, n = this.getPositionAt(e), o = this.getPositionAt(i);
          return new z(n.lineNumber, n.column, o.lineNumber, o.column);
        }
        getValueInRange(e, t = 0) {
          if (e.isEmpty()) return "";
          const i = this._getEndOfLine(t);
          return this._pieceTree.getValueInRange(e, i);
        }
        getValueLengthInRange(e, t = 0) {
          if (e.isEmpty()) return 0;
          if (e.startLineNumber === e.endLineNumber) return e.endColumn - e.startColumn;
          const i = this.getOffsetAt(e.startLineNumber, e.startColumn), n = this.getOffsetAt(e.endLineNumber, e.endColumn);
          let o = 0;
          const r = this._getEndOfLine(t), a = this.getEOL();
          if (r.length !== a.length) {
            const l = r.length - a.length, u = e.endLineNumber - e.startLineNumber;
            o = l * u;
          }
          return n - i + o;
        }
        getCharacterCountInRange(e, t = 0) {
          if (this._mightContainNonBasicASCII) {
            let i = 0;
            const n = e.startLineNumber, o = e.endLineNumber;
            for (let r = n; r <= o; r++) {
              const a = this.getLineContent(r), l = r === n ? e.startColumn - 1 : 0, u = r === o ? e.endColumn - 1 : a.length;
              for (let d = l; d < u; d++) on(a.charCodeAt(d)) ? (i = i + 1, d = d + 1) : i = i + 1;
            }
            return i += this._getEndOfLine(t).length * (o - n), i;
          }
          return this.getValueLengthInRange(e, t);
        }
        getLength() {
          return this._pieceTree.getLength();
        }
        getLineCount() {
          return this._pieceTree.getLineCount();
        }
        getLinesContent() {
          return this._pieceTree.getLinesContent();
        }
        getLineContent(e) {
          return this._pieceTree.getLineContent(e);
        }
        getLineCharCode(e, t) {
          return this._pieceTree.getLineCharCode(e, t);
        }
        getLineLength(e) {
          return this._pieceTree.getLineLength(e);
        }
        getLineFirstNonWhitespaceColumn(e) {
          const t = qs(this.getLineContent(e));
          return t === -1 ? 0 : t + 1;
        }
        getLineLastNonWhitespaceColumn(e) {
          const t = qh(this.getLineContent(e));
          return t === -1 ? 0 : t + 2;
        }
        _getEndOfLine(e) {
          switch (e) {
            case 1:
              return `
`;
            case 2:
              return `\r
`;
            case 0:
              return this.getEOL();
            default:
              throw new Error("Unknown EOL preference");
          }
        }
        setEOL(e) {
          this._pieceTree.setEOL(e);
        }
        applyEdits(e, t, i) {
          let n = this._mightContainRTL, o = this._mightContainUnusualLineTerminators, r = this._mightContainNonBasicASCII, a = true, l = [];
          for (let v = 0; v < e.length; v++) {
            const y = e[v];
            a && y._isTracked && (a = false);
            const x = y.range;
            if (y.text) {
              let M = true;
              r || (M = !ZE(y.text), r = M), !n && M && (n = Yp(y.text)), !o && M && (o = D9(y.text));
            }
            let L = "", D = 0, k = 0, T = 0;
            if (y.text) {
              let M;
              [D, k, T, M] = cg(y.text);
              const I = this.getEOL();
              M === 0 || M === (I === `\r
` ? 2 : 1) ? L = y.text : L = y.text.replace(/\r\n|\r|\n/g, I);
            }
            l[v] = {
              sortIndex: v,
              identifier: y.identifier || null,
              range: x,
              rangeOffset: this.getOffsetAt(x.startLineNumber, x.startColumn),
              rangeLength: this.getValueLengthInRange(x),
              text: L,
              eolCount: D,
              firstLineLength: k,
              lastLineLength: T,
              forceMoveMarkers: !!y.forceMoveMarkers,
              isAutoWhitespaceEdit: y.isAutoWhitespaceEdit || false
            };
          }
          l.sort(qf._sortOpsAscending);
          let u = false;
          for (let v = 0, y = l.length - 1; v < y; v++) {
            const x = l[v].range.getEndPosition(), L = l[v + 1].range.getStartPosition();
            if (L.isBeforeOrEqual(x)) {
              if (L.isBefore(x)) throw new Error("Overlapping ranges are not allowed!");
              u = true;
            }
          }
          a && (l = this._reduceOperations(l));
          const d = i || t ? qf._getInverseEditRanges(l) : [], f = [];
          if (t) for (let v = 0; v < l.length; v++) {
            const y = l[v], x = d[v];
            if (y.isAutoWhitespaceEdit && y.range.isEmpty()) for (let L = x.startLineNumber; L <= x.endLineNumber; L++) {
              let D = "";
              L === x.startLineNumber && (D = this.getLineContent(y.range.startLineNumber), qs(D) !== -1) || f.push({
                lineNumber: L,
                oldContent: D
              });
            }
          }
          let m = null;
          if (i) {
            let v = 0;
            m = [];
            for (let y = 0; y < l.length; y++) {
              const x = l[y], L = d[y], D = this.getValueInRange(x.range), k = x.rangeOffset + v;
              v += x.text.length - D.length, m[y] = {
                sortIndex: x.sortIndex,
                identifier: x.identifier,
                range: L,
                text: D,
                textChange: new Mn(x.rangeOffset, D, k, x.text)
              };
            }
            u || m.sort((y, x) => y.sortIndex - x.sortIndex);
          }
          this._mightContainRTL = n, this._mightContainUnusualLineTerminators = o, this._mightContainNonBasicASCII = r;
          const _ = this._doApplyEdits(l);
          let b = null;
          if (t && f.length > 0) {
            f.sort((v, y) => y.lineNumber - v.lineNumber), b = [];
            for (let v = 0, y = f.length; v < y; v++) {
              const x = f[v].lineNumber;
              if (v > 0 && f[v - 1].lineNumber === x) continue;
              const L = f[v].oldContent, D = this.getLineContent(x);
              D.length === 0 || D === L || qs(D) !== -1 || b.push(x);
            }
          }
          return this._onDidChangeContent.fire(), new WG(m, _, b);
        }
        _reduceOperations(e) {
          return e.length < 1e3 ? e : [
            this._toSingleEditOperation(e)
          ];
        }
        _toSingleEditOperation(e) {
          let t = false;
          const i = e[0].range, n = e[e.length - 1].range, o = new z(i.startLineNumber, i.startColumn, n.endLineNumber, n.endColumn);
          let r = i.startLineNumber, a = i.startColumn;
          const l = [];
          for (let _ = 0, b = e.length; _ < b; _++) {
            const v = e[_], y = v.range;
            t = t || v.forceMoveMarkers, l.push(this.getValueInRange(new z(r, a, y.startLineNumber, y.startColumn))), v.text.length > 0 && l.push(v.text), r = y.endLineNumber, a = y.endColumn;
          }
          const u = l.join(""), [d, f, m] = cg(u);
          return {
            sortIndex: 0,
            identifier: e[0].identifier,
            range: o,
            rangeOffset: this.getOffsetAt(o.startLineNumber, o.startColumn),
            rangeLength: this.getValueLengthInRange(o, 0),
            text: u,
            eolCount: d,
            firstLineLength: f,
            lastLineLength: m,
            forceMoveMarkers: t,
            isAutoWhitespaceEdit: false
          };
        }
        _doApplyEdits(e) {
          e.sort(qf._sortOpsDescending);
          const t = [];
          for (let i = 0; i < e.length; i++) {
            const n = e[i], o = n.range.startLineNumber, r = n.range.startColumn, a = n.range.endLineNumber, l = n.range.endColumn;
            if (o === a && r === l && n.text.length === 0) continue;
            n.text ? (this._pieceTree.delete(n.rangeOffset, n.rangeLength), this._pieceTree.insert(n.rangeOffset, n.text, true)) : this._pieceTree.delete(n.rangeOffset, n.rangeLength);
            const u = new z(o, r, a, l);
            t.push({
              range: u,
              rangeLength: n.rangeLength,
              text: n.text,
              rangeOffset: n.rangeOffset,
              forceMoveMarkers: n.forceMoveMarkers
            });
          }
          return t;
        }
        findMatchesLineByLine(e, t, i, n) {
          return this._pieceTree.findMatchesLineByLine(e, t, i, n);
        }
        static _getInverseEditRanges(e) {
          const t = [];
          let i = 0, n = 0, o = null;
          for (let r = 0, a = e.length; r < a; r++) {
            const l = e[r];
            let u, d;
            o ? o.range.endLineNumber === l.range.startLineNumber ? (u = i, d = n + (l.range.startColumn - o.range.endColumn)) : (u = i + (l.range.startLineNumber - o.range.endLineNumber), d = l.range.startColumn) : (u = l.range.startLineNumber, d = l.range.startColumn);
            let f;
            if (l.text.length > 0) {
              const m = l.eolCount + 1;
              m === 1 ? f = new z(u, d, u, d + l.firstLineLength) : f = new z(u, d, u + m - 1, l.lastLineLength + 1);
            } else f = new z(u, d, u, d);
            i = f.endLineNumber, n = f.endColumn, t.push(f), o = l;
          }
          return t;
        }
        static _sortOpsAscending(e, t) {
          const i = z.compareRangesUsingEnds(e.range, t.range);
          return i === 0 ? e.sortIndex - t.sortIndex : i;
        }
        static _sortOpsDescending(e, t) {
          const i = z.compareRangesUsingEnds(e.range, t.range);
          return i === 0 ? t.sortIndex - e.sortIndex : -i;
        }
      }
      class zne {
        constructor(e, t, i, n, o, r, a, l, u) {
          this._chunks = e, this._bom = t, this._cr = i, this._lf = n, this._crlf = o, this._containsRTL = r, this._containsUnusualLineTerminators = a, this._isBasicASCII = l, this._normalizeEOL = u;
        }
        _getEOL(e) {
          const t = this._cr + this._lf + this._crlf, i = this._cr + this._crlf;
          return t === 0 ? e === 1 ? `
` : `\r
` : i > t / 2 ? `\r
` : `
`;
        }
        create(e) {
          const t = this._getEOL(e), i = this._chunks;
          if (this._normalizeEOL && (t === `\r
` && (this._cr > 0 || this._lf > 0) || t === `
` && (this._cr > 0 || this._crlf > 0))) for (let o = 0, r = i.length; o < r; o++) {
            const a = i[o].buffer.replace(/\r\n|\r|\n/g, t), l = _l(a);
            i[o] = new sh(a, l);
          }
          const n = new qf(i, this._bom, t, this._containsRTL, this._containsUnusualLineTerminators, this._isBasicASCII, this._normalizeEOL);
          return {
            textBuffer: n,
            disposable: n
          };
        }
      }
      class IB {
        constructor() {
          this.chunks = [], this.BOM = "", this._hasPreviousChar = false, this._previousChar = 0, this._tmpLineStarts = [], this.cr = 0, this.lf = 0, this.crlf = 0, this.containsRTL = false, this.containsUnusualLineTerminators = false, this.isBasicASCII = true;
        }
        acceptChunk(e) {
          if (e.length === 0) return;
          this.chunks.length === 0 && XE(e) && (this.BOM = Oq, e = e.substr(1));
          const t = e.charCodeAt(e.length - 1);
          t === 13 || t >= 55296 && t <= 56319 ? (this._acceptChunk1(e.substr(0, e.length - 1), false), this._hasPreviousChar = true, this._previousChar = t) : (this._acceptChunk1(e, false), this._hasPreviousChar = false, this._previousChar = t);
        }
        _acceptChunk1(e, t) {
          !t && e.length === 0 || (this._hasPreviousChar ? this._acceptChunk2(String.fromCharCode(this._previousChar) + e) : this._acceptChunk2(e));
        }
        _acceptChunk2(e) {
          const t = Fne(this._tmpLineStarts, e);
          this.chunks.push(new sh(e, t.lineStarts)), this.cr += t.cr, this.lf += t.lf, this.crlf += t.crlf, t.isBasicASCII || (this.isBasicASCII = false, this.containsRTL || (this.containsRTL = Yp(e)), this.containsUnusualLineTerminators || (this.containsUnusualLineTerminators = D9(e)));
        }
        finish(e = true) {
          return this._finish(), new zne(this.chunks, this.BOM, this.cr, this.lf, this.crlf, this.containsRTL, this.containsUnusualLineTerminators, this.isBasicASCII, e);
        }
        _finish() {
          if (this.chunks.length === 0 && this._acceptChunk1("", true), this._hasPreviousChar) {
            this._hasPreviousChar = false;
            const e = this.chunks[this.chunks.length - 1];
            e.buffer += String.fromCharCode(this._previousChar);
            const t = _l(e.buffer);
            e.lineStarts = t, this._previousChar === 13 && this.cr++;
          }
        }
      }
      class Une {
        constructor(e) {
          this._default = e, this._store = [];
        }
        get(e) {
          return e < this._store.length ? this._store[e] : this._default;
        }
        set(e, t) {
          for (; e >= this._store.length; ) this._store[this._store.length] = this._default;
          this._store[e] = t;
        }
        replace(e, t, i) {
          if (e >= this._store.length) return;
          if (t === 0) {
            this.insert(e, i);
            return;
          } else if (i === 0) {
            this.delete(e, t);
            return;
          }
          const n = this._store.slice(0, e), o = this._store.slice(e + t), r = $ne(i, this._default);
          this._store = n.concat(r, o);
        }
        delete(e, t) {
          t === 0 || e >= this._store.length || this._store.splice(e, t);
        }
        insert(e, t) {
          if (t === 0 || e >= this._store.length) return;
          const i = [];
          for (let n = 0; n < t; n++) i[n] = this._default;
          this._store = PC(this._store, e, i);
        }
      }
      function $ne(s, e) {
        const t = [];
        for (let i = 0; i < s; i++) t[i] = e;
        return t;
      }
      class qne {
        get startLineNumber() {
          return this._startLineNumber;
        }
        get endLineNumber() {
          return this._startLineNumber + this._tokens.length - 1;
        }
        constructor(e, t) {
          this._startLineNumber = e, this._tokens = t;
        }
        getLineTokens(e) {
          return this._tokens[e - this._startLineNumber];
        }
        appendLineTokens(e) {
          this._tokens.push(e);
        }
      }
      class a2 {
        constructor() {
          this._tokens = [];
        }
        add(e, t) {
          if (this._tokens.length > 0) {
            const i = this._tokens[this._tokens.length - 1];
            if (i.endLineNumber + 1 === e) {
              i.appendLineTokens(t);
              return;
            }
          }
          this._tokens.push(new qne(e, [
            t
          ]));
        }
        finalize() {
          return this._tokens;
        }
      }
      class Kne {
        constructor(e, t) {
          this.tokenizationSupport = t, this.initialState = this.tokenizationSupport.getInitialState(), this.store = new l2(e);
        }
        getStartState(e) {
          return this.store.getStartState(e, this.initialState);
        }
        getFirstInvalidLine() {
          return this.store.getFirstInvalidLine(this.initialState);
        }
      }
      class jne extends Kne {
        constructor(e, t, i, n) {
          super(e, t), this._textModel = i, this._languageIdCodec = n;
        }
        updateTokensUntilLine(e, t) {
          const i = this._textModel.getLanguageId();
          for (; ; ) {
            const n = this.getFirstInvalidLine();
            if (!n || n.lineNumber > t) break;
            const o = this._textModel.getLineContent(n.lineNumber), r = Um(this._languageIdCodec, i, this.tokenizationSupport, o, true, n.startState);
            e.add(n.lineNumber, r.tokens), this.store.setEndState(n.lineNumber, r.endState);
          }
        }
        getTokenTypeIfInsertingCharacter(e, t) {
          const i = this.getStartState(e.lineNumber);
          if (!i) return 0;
          const n = this._textModel.getLanguageId(), o = this._textModel.getLineContent(e.lineNumber), r = o.substring(0, e.column - 1) + t + o.substring(e.column - 1), a = Um(this._languageIdCodec, n, this.tokenizationSupport, r, true, i), l = new Fi(a.tokens, r, this._languageIdCodec);
          if (l.getCount() === 0) return 0;
          const u = l.findTokenIndexAtOffset(e.column - 1);
          return l.getStandardTokenType(u);
        }
        tokenizeLineWithEdit(e, t, i) {
          const n = e.lineNumber, o = e.column, r = this.getStartState(n);
          if (!r) return null;
          const a = this._textModel.getLineContent(n), l = a.substring(0, o - 1) + i + a.substring(o - 1 + t), u = this._textModel.getLanguageIdAtPosition(n, 0), d = Um(this._languageIdCodec, u, this.tokenizationSupport, l, true, r);
          return new Fi(d.tokens, l, this._languageIdCodec);
        }
        hasAccurateTokensForLine(e) {
          const t = this.store.getFirstInvalidEndStateLineNumberOrMax();
          return e < t;
        }
        isCheapToTokenize(e) {
          const t = this.store.getFirstInvalidEndStateLineNumberOrMax();
          return e < t || e === t && this._textModel.getLineLength(e) < 2048;
        }
        tokenizeHeuristically(e, t, i) {
          if (i <= this.store.getFirstInvalidEndStateLineNumberOrMax()) return {
            heuristicTokens: false
          };
          if (t <= this.store.getFirstInvalidEndStateLineNumberOrMax()) return this.updateTokensUntilLine(e, i), {
            heuristicTokens: false
          };
          let n = this.guessStartState(t);
          const o = this._textModel.getLanguageId();
          for (let r = t; r <= i; r++) {
            const a = this._textModel.getLineContent(r), l = Um(this._languageIdCodec, o, this.tokenizationSupport, a, true, n);
            e.add(r, l.tokens), n = l.endState;
          }
          return {
            heuristicTokens: true
          };
        }
        guessStartState(e) {
          let t = this._textModel.getLineFirstNonWhitespaceColumn(e);
          const i = [];
          let n = null;
          for (let a = e - 1; t > 1 && a >= 1; a--) {
            const l = this._textModel.getLineFirstNonWhitespaceColumn(a);
            if (l !== 0 && l < t && (i.push(this._textModel.getLineContent(a)), t = l, n = this.getStartState(a), n)) break;
          }
          n || (n = this.tokenizationSupport.getInitialState()), i.reverse();
          const o = this._textModel.getLanguageId();
          let r = n;
          for (const a of i) r = Um(this._languageIdCodec, o, this.tokenizationSupport, a, false, r).endState;
          return r;
        }
      }
      class l2 {
        constructor(e) {
          this.lineCount = e, this._tokenizationStateStore = new Gne(), this._invalidEndStatesLineNumbers = new Yne(), this._invalidEndStatesLineNumbers.addRange(new Qe(1, e + 1));
        }
        getEndState(e) {
          return this._tokenizationStateStore.getEndState(e);
        }
        setEndState(e, t) {
          if (!t) throw new It("Cannot set null/undefined state");
          this._invalidEndStatesLineNumbers.delete(e);
          const i = this._tokenizationStateStore.setEndState(e, t);
          return i && e < this.lineCount && this._invalidEndStatesLineNumbers.addRange(new Qe(e + 1, e + 2)), i;
        }
        acceptChange(e, t) {
          this.lineCount += t - e.length, this._tokenizationStateStore.acceptChange(e, t), this._invalidEndStatesLineNumbers.addRangeAndResize(new Qe(e.startLineNumber, e.endLineNumberExclusive), t);
        }
        acceptChanges(e) {
          for (const t of e) {
            const [i] = cg(t.text);
            this.acceptChange(new qe(t.range.startLineNumber, t.range.endLineNumber + 1), i + 1);
          }
        }
        invalidateEndStateRange(e) {
          this._invalidEndStatesLineNumbers.addRange(new Qe(e.startLineNumber, e.endLineNumberExclusive));
        }
        getFirstInvalidEndStateLineNumber() {
          return this._invalidEndStatesLineNumbers.min;
        }
        getFirstInvalidEndStateLineNumberOrMax() {
          return this.getFirstInvalidEndStateLineNumber() || Number.MAX_SAFE_INTEGER;
        }
        allStatesValid() {
          return this._invalidEndStatesLineNumbers.min === null;
        }
        getStartState(e, t) {
          return e === 1 ? t : this.getEndState(e - 1);
        }
        getFirstInvalidLine(e) {
          const t = this.getFirstInvalidEndStateLineNumber();
          if (t === null) return null;
          const i = this.getStartState(t, e);
          if (!i) throw new It("Start state must be defined");
          return {
            lineNumber: t,
            startState: i
          };
        }
      }
      class Gne {
        constructor() {
          this._lineEndStates = new Une(null);
        }
        getEndState(e) {
          return this._lineEndStates.get(e);
        }
        setEndState(e, t) {
          const i = this._lineEndStates.get(e);
          return i && i.equals(t) ? false : (this._lineEndStates.set(e, t), true);
        }
        acceptChange(e, t) {
          let i = e.length;
          t > 0 && i > 0 && (i--, t--), this._lineEndStates.replace(e.startLineNumber, i, t);
        }
      }
      class Yne {
        constructor() {
          this._ranges = [];
        }
        get min() {
          return this._ranges.length === 0 ? null : this._ranges[0].start;
        }
        delete(e) {
          const t = this._ranges.findIndex((i) => i.contains(e));
          if (t !== -1) {
            const i = this._ranges[t];
            i.start === e ? i.endExclusive === e + 1 ? this._ranges.splice(t, 1) : this._ranges[t] = new Qe(e + 1, i.endExclusive) : i.endExclusive === e + 1 ? this._ranges[t] = new Qe(i.start, e) : this._ranges.splice(t, 1, new Qe(i.start, e), new Qe(e + 1, i.endExclusive));
          }
        }
        addRange(e) {
          Qe.addRange(e, this._ranges);
        }
        addRangeAndResize(e, t) {
          let i = 0;
          for (; !(i >= this._ranges.length || e.start <= this._ranges[i].endExclusive); ) i++;
          let n = i;
          for (; !(n >= this._ranges.length || e.endExclusive < this._ranges[n].start); ) n++;
          const o = t - e.length;
          for (let r = n; r < this._ranges.length; r++) this._ranges[r] = this._ranges[r].delta(o);
          if (i === n) {
            const r = new Qe(e.start, e.start + t);
            r.isEmpty || this._ranges.splice(i, 0, r);
          } else {
            const r = Math.min(e.start, this._ranges[i].start), a = Math.max(e.endExclusive, this._ranges[n - 1].endExclusive), l = new Qe(r, a + o);
            l.isEmpty ? this._ranges.splice(i, n - i) : this._ranges.splice(i, n - i, l);
          }
        }
        toString() {
          return this._ranges.map((e) => e.toString()).join(" + ");
        }
      }
      function Um(s, e, t, i, n, o) {
        let r = null;
        if (t) try {
          r = t.tokenizeEncoded(i, n, o.clone());
        } catch (a) {
          qt(a);
        }
        return r || (r = KT(s.encodeLanguageId(e), o)), Fi.convertToEndOffset(r.tokens, i.length), r;
      }
      class Zne {
        constructor(e, t) {
          this._tokenizerWithStateStore = e, this._backgroundTokenStore = t, this._isDisposed = false, this._isScheduled = false;
        }
        dispose() {
          this._isDisposed = true;
        }
        handleChanges() {
          this._beginBackgroundTokenization();
        }
        _beginBackgroundTokenization() {
          this._isScheduled || !this._tokenizerWithStateStore._textModel.isAttachedToEditor() || !this._hasLinesToTokenize() || (this._isScheduled = true, O9((e) => {
            this._isScheduled = false, this._backgroundTokenizeWithDeadline(e);
          }));
        }
        _backgroundTokenizeWithDeadline(e) {
          const t = Date.now() + e.timeRemaining(), i = () => {
            this._isDisposed || !this._tokenizerWithStateStore._textModel.isAttachedToEditor() || !this._hasLinesToTokenize() || (this._backgroundTokenizeForAtLeast1ms(), Date.now() < t ? t9(i) : this._beginBackgroundTokenization());
          };
          i();
        }
        _backgroundTokenizeForAtLeast1ms() {
          const e = this._tokenizerWithStateStore._textModel.getLineCount(), t = new a2(), i = $h.create(false);
          do
            if (i.elapsed() > 1 || this._tokenizeOneInvalidLine(t) >= e) break;
          while (this._hasLinesToTokenize());
          this._backgroundTokenStore.setTokens(t.finalize()), this.checkFinished();
        }
        _hasLinesToTokenize() {
          return this._tokenizerWithStateStore ? !this._tokenizerWithStateStore.store.allStatesValid() : false;
        }
        _tokenizeOneInvalidLine(e) {
          var _a3;
          const t = (_a3 = this._tokenizerWithStateStore) == null ? void 0 : _a3.getFirstInvalidLine();
          return t ? (this._tokenizerWithStateStore.updateTokensUntilLine(e, t.lineNumber), t.lineNumber) : this._tokenizerWithStateStore._textModel.getLineCount() + 1;
        }
        checkFinished() {
          this._isDisposed || this._tokenizerWithStateStore.store.allStatesValid() && this._backgroundTokenStore.backgroundTokenizationFinished();
        }
        requestTokens(e, t) {
          this._tokenizerWithStateStore.store.invalidateEndStateRange(new qe(e, t));
        }
      }
      class Qne {
        constructor() {
          this._onDidChangeVisibleRanges = new G(), this.onDidChangeVisibleRanges = this._onDidChangeVisibleRanges.event, this._views = /* @__PURE__ */ new Set();
        }
        attachView() {
          const e = new Xne((t) => {
            this._onDidChangeVisibleRanges.fire({
              view: e,
              state: t
            });
          });
          return this._views.add(e), e;
        }
        detachView(e) {
          this._views.delete(e), this._onDidChangeVisibleRanges.fire({
            view: e,
            state: void 0
          });
        }
      }
      class Xne {
        constructor(e) {
          this.handleStateChange = e;
        }
        setVisibleLines(e, t) {
          const i = e.map((n) => new qe(n.startLineNumber, n.endLineNumber + 1));
          this.handleStateChange({
            visibleLineRanges: i,
            stabilized: t
          });
        }
      }
      class Jne extends he {
        get lineRanges() {
          return this._lineRanges;
        }
        constructor(e) {
          super(), this._refreshTokens = e, this.runner = this._register(new ns(() => this.update(), 50)), this._computedLineRanges = [], this._lineRanges = [];
        }
        update() {
          Qi(this._computedLineRanges, this._lineRanges, (e, t) => e.equals(t)) || (this._computedLineRanges = this._lineRanges, this._refreshTokens());
        }
        handleStateChange(e) {
          this._lineRanges = e.visibleLineRanges, e.stabilized ? (this.runner.cancel(), this.update()) : this.runner.schedule();
        }
      }
      class MB extends he {
        get backgroundTokenizationState() {
          return this._backgroundTokenizationState;
        }
        constructor(e, t, i) {
          super(), this._languageIdCodec = e, this._textModel = t, this.getLanguageId = i, this._backgroundTokenizationState = 1, this._onDidChangeBackgroundTokenizationState = this._register(new G()), this.onDidChangeBackgroundTokenizationState = this._onDidChangeBackgroundTokenizationState.event, this._onDidChangeTokens = this._register(new G()), this.onDidChangeTokens = this._onDidChangeTokens.event;
        }
        tokenizeIfCheap(e) {
          this.isCheapToTokenize(e) && this.forceTokenization(e);
        }
      }
      class OP extends MB {
        constructor(e, t, i, n) {
          super(t, i, n), this._treeSitterService = e, this._tokenizationSupport = null, this._initialize();
        }
        _initialize() {
          const e = this.getLanguageId();
          (!this._tokenizationSupport || this._lastLanguageId !== e) && (this._lastLanguageId = e, this._tokenizationSupport = Wx.get(e));
        }
        getLineTokens(e) {
          const t = this._textModel.getLineContent(e);
          if (this._tokenizationSupport) {
            const i = this._tokenizationSupport.tokenizeEncoded(e, this._textModel);
            if (i) return new Fi(i, t, this._languageIdCodec);
          }
          return Fi.createEmpty(t, this._languageIdCodec);
        }
        resetTokenization(e = true) {
          e && this._onDidChangeTokens.fire({
            semanticTokensApplied: false,
            ranges: [
              {
                fromLineNumber: 1,
                toLineNumber: this._textModel.getLineCount()
              }
            ]
          }), this._initialize();
        }
        handleDidChangeAttached() {
        }
        handleDidChangeContent(e) {
          e.isFlush && this.resetTokenization(false);
        }
        forceTokenization(e) {
        }
        hasAccurateTokensForLine(e) {
          return true;
        }
        isCheapToTokenize(e) {
          return true;
        }
        getTokenTypeIfInsertingCharacter(e, t, i) {
          return 0;
        }
        tokenizeLineWithEdit(e, t, i) {
          return null;
        }
        get hasTokens() {
          return this._treeSitterService.getParseResult(this._textModel) !== void 0;
        }
      }
      const AB = pt("treeSitterParserService"), bl = new Uint32Array(0).buffer;
      class va {
        static deleteBeginning(e, t) {
          return e === null || e === bl ? e : va.delete(e, 0, t);
        }
        static deleteEnding(e, t) {
          if (e === null || e === bl) return e;
          const i = El(e), n = i[i.length - 2];
          return va.delete(e, t, n);
        }
        static delete(e, t, i) {
          if (e === null || e === bl || t === i) return e;
          const n = El(e), o = n.length >>> 1;
          if (t === 0 && n[n.length - 2] === i) return bl;
          const r = Fi.findIndexInTokensArray(n, t), a = r > 0 ? n[r - 1 << 1] : 0, l = n[r << 1];
          if (i < l) {
            const _ = i - t;
            for (let b = r; b < o; b++) n[b << 1] -= _;
            return e;
          }
          let u, d;
          a !== t ? (n[r << 1] = t, u = r + 1 << 1, d = t) : (u = r << 1, d = a);
          const f = i - t;
          for (let _ = r + 1; _ < o; _++) {
            const b = n[_ << 1] - f;
            b > d && (n[u++] = b, n[u++] = n[(_ << 1) + 1], d = b);
          }
          if (u === n.length) return e;
          const m = new Uint32Array(u);
          return m.set(n.subarray(0, u), 0), m.buffer;
        }
        static append(e, t) {
          if (t === bl) return e;
          if (e === bl) return t;
          if (e === null) return e;
          if (t === null) return null;
          const i = El(e), n = El(t), o = n.length >>> 1, r = new Uint32Array(i.length + n.length);
          r.set(i, 0);
          let a = i.length;
          const l = i[i.length - 2];
          for (let u = 0; u < o; u++) r[a++] = n[u << 1] + l, r[a++] = n[(u << 1) + 1];
          return r.buffer;
        }
        static insert(e, t, i) {
          if (e === null || e === bl) return e;
          const n = El(e), o = n.length >>> 1;
          let r = Fi.findIndexInTokensArray(n, t);
          r > 0 && n[r - 1 << 1] === t && r--;
          for (let a = r; a < o; a++) n[a << 1] += i;
          return e;
        }
      }
      function El(s) {
        return s instanceof Uint32Array ? s : new Uint32Array(s);
      }
      class m_ {
        constructor(e) {
          this._lineTokens = [], this._len = 0, this._languageIdCodec = e;
        }
        flush() {
          this._lineTokens = [], this._len = 0;
        }
        get hasTokens() {
          return this._lineTokens.length > 0;
        }
        getTokens(e, t, i) {
          let n = null;
          if (t < this._len && (n = this._lineTokens[t]), n !== null && n !== bl) return new Fi(El(n), i, this._languageIdCodec);
          const o = new Uint32Array(2);
          return o[0] = i.length, o[1] = PP(this._languageIdCodec.encodeLanguageId(e)), new Fi(o, i, this._languageIdCodec);
        }
        static _massageTokens(e, t, i) {
          const n = i ? El(i) : null;
          if (t === 0) {
            let o = false;
            if (n && n.length > 1 && (o = Pr.getLanguageId(n[1]) !== e), !o) return bl;
          }
          if (!n || n.length === 0) {
            const o = new Uint32Array(2);
            return o[0] = t, o[1] = PP(e), o.buffer;
          }
          return n[n.length - 2] = t, n.byteOffset === 0 && n.byteLength === n.buffer.byteLength ? n.buffer : n;
        }
        _ensureLine(e) {
          for (; e >= this._len; ) this._lineTokens[this._len] = null, this._len++;
        }
        _deleteLines(e, t) {
          t !== 0 && (e + t > this._len && (t = this._len - e), this._lineTokens.splice(e, t), this._len -= t);
        }
        _insertLines(e, t) {
          if (t === 0) return;
          const i = [];
          for (let n = 0; n < t; n++) i[n] = null;
          this._lineTokens = PC(this._lineTokens, e, i), this._len += t;
        }
        setTokens(e, t, i, n, o) {
          const r = m_._massageTokens(this._languageIdCodec.encodeLanguageId(e), i, n);
          this._ensureLine(t);
          const a = this._lineTokens[t];
          return this._lineTokens[t] = r, o ? !m_._equals(a, r) : false;
        }
        static _equals(e, t) {
          if (!e || !t) return !e && !t;
          const i = El(e), n = El(t);
          if (i.length !== n.length) return false;
          for (let o = 0, r = i.length; o < r; o++) if (i[o] !== n[o]) return false;
          return true;
        }
        acceptEdit(e, t, i) {
          this._acceptDeleteRange(e), this._acceptInsertText(new X(e.startLineNumber, e.startColumn), t, i);
        }
        _acceptDeleteRange(e) {
          const t = e.startLineNumber - 1;
          if (t >= this._len) return;
          if (e.startLineNumber === e.endLineNumber) {
            if (e.startColumn === e.endColumn) return;
            this._lineTokens[t] = va.delete(this._lineTokens[t], e.startColumn - 1, e.endColumn - 1);
            return;
          }
          this._lineTokens[t] = va.deleteEnding(this._lineTokens[t], e.startColumn - 1);
          const i = e.endLineNumber - 1;
          let n = null;
          i < this._len && (n = va.deleteBeginning(this._lineTokens[i], e.endColumn - 1)), this._lineTokens[t] = va.append(this._lineTokens[t], n), this._deleteLines(e.startLineNumber, e.endLineNumber - e.startLineNumber);
        }
        _acceptInsertText(e, t, i) {
          if (t === 0 && i === 0) return;
          const n = e.lineNumber - 1;
          if (!(n >= this._len)) {
            if (t === 0) {
              this._lineTokens[n] = va.insert(this._lineTokens[n], e.column - 1, i);
              return;
            }
            this._lineTokens[n] = va.deleteEnding(this._lineTokens[n], e.column - 1), this._lineTokens[n] = va.insert(this._lineTokens[n], e.column - 1, i), this._insertLines(e.lineNumber, t);
          }
        }
        setMultilineTokens(e, t) {
          if (e.length === 0) return {
            changes: []
          };
          const i = [];
          for (let n = 0, o = e.length; n < o; n++) {
            const r = e[n];
            let a = 0, l = 0, u = false;
            for (let d = r.startLineNumber; d <= r.endLineNumber; d++) u ? (this.setTokens(t.getLanguageId(), d - 1, t.getLineLength(d), r.getLineTokens(d), false), l = d) : this.setTokens(t.getLanguageId(), d - 1, t.getLineLength(d), r.getLineTokens(d), true) && (u = true, a = d, l = d);
            u && i.push({
              fromLineNumber: a,
              toLineNumber: l
            });
          }
          return {
            changes: i
          };
        }
      }
      function PP(s) {
        return (s << 0 | 0 | 0 | 32768 | 2 << 24 | 1024) >>> 0;
      }
      class pN {
        constructor(e) {
          this._pieces = [], this._isComplete = false, this._languageIdCodec = e;
        }
        flush() {
          this._pieces = [], this._isComplete = false;
        }
        isEmpty() {
          return this._pieces.length === 0;
        }
        set(e, t) {
          this._pieces = e || [], this._isComplete = t;
        }
        setPartial(e, t) {
          let i = e;
          if (t.length > 0) {
            const o = t[0].getRange(), r = t[t.length - 1].getRange();
            if (!o || !r) return e;
            i = e.plusRange(o).plusRange(r);
          }
          let n = null;
          for (let o = 0, r = this._pieces.length; o < r; o++) {
            const a = this._pieces[o];
            if (a.endLineNumber < i.startLineNumber) continue;
            if (a.startLineNumber > i.endLineNumber) {
              n = n || {
                index: o
              };
              break;
            }
            if (a.removeTokens(i), a.isEmpty()) {
              this._pieces.splice(o, 1), o--, r--;
              continue;
            }
            if (a.endLineNumber < i.startLineNumber) continue;
            if (a.startLineNumber > i.endLineNumber) {
              n = n || {
                index: o
              };
              continue;
            }
            const [l, u] = a.split(i);
            if (l.isEmpty()) {
              n = n || {
                index: o
              };
              continue;
            }
            u.isEmpty() || (this._pieces.splice(o, 1, l, u), o++, r++, n = n || {
              index: o
            });
          }
          return n = n || {
            index: this._pieces.length
          }, t.length > 0 && (this._pieces = PC(this._pieces, n.index, t)), i;
        }
        isComplete() {
          return this._isComplete;
        }
        addSparseTokens(e, t) {
          if (t.getLineContent().length === 0) return t;
          const i = this._pieces;
          if (i.length === 0) return t;
          const n = pN._findFirstPieceWithLine(i, e), o = i[n].getLineTokens(e);
          if (!o) return t;
          const r = t.getCount(), a = o.getCount();
          let l = 0;
          const u = [];
          let d = 0, f = 0;
          const m = (_, b) => {
            _ !== f && (f = _, u[d++] = _, u[d++] = b);
          };
          for (let _ = 0; _ < a; _++) {
            const b = o.getStartCharacter(_), v = o.getEndCharacter(_), y = o.getMetadata(_), x = ((y & 1 ? 2048 : 0) | (y & 2 ? 4096 : 0) | (y & 4 ? 8192 : 0) | (y & 8 ? 16384 : 0) | (y & 16 ? 16744448 : 0) | (y & 32 ? 4278190080 : 0)) >>> 0, L = ~x >>> 0;
            for (; l < r && t.getEndOffset(l) <= b; ) m(t.getEndOffset(l), t.getMetadata(l)), l++;
            for (l < r && t.getStartOffset(l) < b && m(b, t.getMetadata(l)); l < r && t.getEndOffset(l) < v; ) m(t.getEndOffset(l), t.getMetadata(l) & L | y & x), l++;
            if (l < r) m(v, t.getMetadata(l) & L | y & x), t.getEndOffset(l) === v && l++;
            else {
              const D = Math.min(Math.max(0, l - 1), r - 1);
              m(v, t.getMetadata(D) & L | y & x);
            }
          }
          for (; l < r; ) m(t.getEndOffset(l), t.getMetadata(l)), l++;
          return new Fi(new Uint32Array(u), t.getLineContent(), this._languageIdCodec);
        }
        static _findFirstPieceWithLine(e, t) {
          let i = 0, n = e.length - 1;
          for (; i < n; ) {
            let o = i + Math.floor((n - i) / 2);
            if (e[o].endLineNumber < t) i = o + 1;
            else if (e[o].startLineNumber > t) n = o - 1;
            else {
              for (; o > i && e[o - 1].startLineNumber <= t && t <= e[o - 1].endLineNumber; ) o--;
              return o;
            }
          }
          return i;
        }
        acceptEdit(e, t, i, n, o) {
          for (const r of this._pieces) r.acceptEdit(e, t, i, n, o);
        }
      }
      var ese = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      }, ox = function(s, e) {
        return function(t, i) {
          e(t, i, s);
        };
      }, N0;
      let c2 = N0 = class extends SB {
        constructor(e, t, i, n, o, r, a) {
          super(), this._textModel = e, this._bracketPairsTextModelPart = t, this._languageId = i, this._attachedViews = n, this._languageService = o, this._languageConfigurationService = r, this._treeSitterService = a, this._semanticTokens = new pN(this._languageService.languageIdCodec), this._onDidChangeLanguage = this._register(new G()), this.onDidChangeLanguage = this._onDidChangeLanguage.event, this._onDidChangeLanguageConfiguration = this._register(new G()), this.onDidChangeLanguageConfiguration = this._onDidChangeLanguageConfiguration.event, this._onDidChangeTokens = this._register(new G()), this.onDidChangeTokens = this._onDidChangeTokens.event, this._tokensDisposables = this._register(new Me()), this._register(this._languageConfigurationService.onDidChange((l) => {
            l.affects(this._languageId) && this._onDidChangeLanguageConfiguration.fire({});
          })), this._register(be.filter(Wx.onDidChange, (l) => l.changedLanguages.includes(this._languageId))(() => {
            this.createPreferredTokenProvider();
          })), this.createPreferredTokenProvider();
        }
        createGrammarTokens() {
          return this._register(new BP(this._languageService.languageIdCodec, this._textModel, () => this._languageId, this._attachedViews));
        }
        createTreeSitterTokens() {
          return this._register(new OP(this._treeSitterService, this._languageService.languageIdCodec, this._textModel, () => this._languageId));
        }
        createTokens(e) {
          var _a3;
          const t = this._tokens !== void 0;
          (_a3 = this._tokens) == null ? void 0 : _a3.dispose(), this._tokens = e ? this.createTreeSitterTokens() : this.createGrammarTokens(), this._tokensDisposables.clear(), this._tokensDisposables.add(this._tokens.onDidChangeTokens((i) => {
            this._emitModelTokensChangedEvent(i);
          })), this._tokensDisposables.add(this._tokens.onDidChangeBackgroundTokenizationState((i) => {
            this._bracketPairsTextModelPart.handleDidChangeBackgroundTokenizationState();
          })), t && this._tokens.resetTokenization();
        }
        createPreferredTokenProvider() {
          Wx.get(this._languageId) ? this._tokens instanceof OP || this.createTokens(true) : this._tokens instanceof BP || this.createTokens(false);
        }
        handleLanguageConfigurationServiceChange(e) {
          e.affects(this._languageId) && this._onDidChangeLanguageConfiguration.fire({});
        }
        handleDidChangeContent(e) {
          if (e.isFlush) this._semanticTokens.flush();
          else if (!e.isEolChange) for (const t of e.changes) {
            const [i, n, o] = cg(t.text);
            this._semanticTokens.acceptEdit(t.range, i, n, o, t.text.length > 0 ? t.text.charCodeAt(0) : 0);
          }
          this._tokens.handleDidChangeContent(e);
        }
        handleDidChangeAttached() {
          this._tokens.handleDidChangeAttached();
        }
        getLineTokens(e) {
          this.validateLineNumber(e);
          const t = this._tokens.getLineTokens(e);
          return this._semanticTokens.addSparseTokens(e, t);
        }
        _emitModelTokensChangedEvent(e) {
          this._textModel._isDisposing() || (this._bracketPairsTextModelPart.handleDidChangeTokens(e), this._onDidChangeTokens.fire(e));
        }
        validateLineNumber(e) {
          if (e < 1 || e > this._textModel.getLineCount()) throw new It("Illegal value for lineNumber");
        }
        get hasTokens() {
          return this._tokens.hasTokens;
        }
        resetTokenization() {
          this._tokens.resetTokenization();
        }
        get backgroundTokenizationState() {
          return this._tokens.backgroundTokenizationState;
        }
        forceTokenization(e) {
          this.validateLineNumber(e), this._tokens.forceTokenization(e);
        }
        hasAccurateTokensForLine(e) {
          return this.validateLineNumber(e), this._tokens.hasAccurateTokensForLine(e);
        }
        isCheapToTokenize(e) {
          return this.validateLineNumber(e), this._tokens.isCheapToTokenize(e);
        }
        tokenizeIfCheap(e) {
          this.validateLineNumber(e), this._tokens.tokenizeIfCheap(e);
        }
        getTokenTypeIfInsertingCharacter(e, t, i) {
          return this._tokens.getTokenTypeIfInsertingCharacter(e, t, i);
        }
        tokenizeLineWithEdit(e, t, i) {
          return this._tokens.tokenizeLineWithEdit(e, t, i);
        }
        setSemanticTokens(e, t) {
          this._semanticTokens.set(e, t), this._emitModelTokensChangedEvent({
            semanticTokensApplied: e !== null,
            ranges: [
              {
                fromLineNumber: 1,
                toLineNumber: this._textModel.getLineCount()
              }
            ]
          });
        }
        hasCompleteSemanticTokens() {
          return this._semanticTokens.isComplete();
        }
        hasSomeSemanticTokens() {
          return !this._semanticTokens.isEmpty();
        }
        setPartialSemanticTokens(e, t) {
          if (this.hasCompleteSemanticTokens()) return;
          const i = this._textModel.validateRange(this._semanticTokens.setPartial(e, t));
          this._emitModelTokensChangedEvent({
            semanticTokensApplied: true,
            ranges: [
              {
                fromLineNumber: i.startLineNumber,
                toLineNumber: i.endLineNumber
              }
            ]
          });
        }
        getWordAtPosition(e) {
          this.assertNotDisposed();
          const t = this._textModel.validatePosition(e), i = this._textModel.getLineContent(t.lineNumber), n = this.getLineTokens(t.lineNumber), o = n.findTokenIndexAtOffset(t.column - 1), [r, a] = N0._findLanguageBoundaries(n, o), l = Kp(t.column, this.getLanguageConfiguration(n.getLanguageId(o)).getWordDefinition(), i.substring(r, a), r);
          if (l && l.startColumn <= e.column && e.column <= l.endColumn) return l;
          if (o > 0 && r === t.column - 1) {
            const [u, d] = N0._findLanguageBoundaries(n, o - 1), f = Kp(t.column, this.getLanguageConfiguration(n.getLanguageId(o - 1)).getWordDefinition(), i.substring(u, d), u);
            if (f && f.startColumn <= e.column && e.column <= f.endColumn) return f;
          }
          return null;
        }
        getLanguageConfiguration(e) {
          return this._languageConfigurationService.getLanguageConfiguration(e);
        }
        static _findLanguageBoundaries(e, t) {
          const i = e.getLanguageId(t);
          let n = 0;
          for (let r = t; r >= 0 && e.getLanguageId(r) === i; r--) n = e.getStartOffset(r);
          let o = e.getLineContent().length;
          for (let r = t, a = e.getCount(); r < a && e.getLanguageId(r) === i; r++) o = e.getEndOffset(r);
          return [
            n,
            o
          ];
        }
        getWordUntilPosition(e) {
          const t = this.getWordAtPosition(e);
          return t ? {
            word: t.word.substr(0, e.column - t.startColumn),
            startColumn: t.startColumn,
            endColumn: e.column
          } : {
            word: "",
            startColumn: e.column,
            endColumn: e.column
          };
        }
        getLanguageId() {
          return this._languageId;
        }
        getLanguageIdAtPosition(e, t) {
          const i = this._textModel.validatePosition(new X(e, t)), n = this.getLineTokens(i.lineNumber);
          return n.getLanguageId(n.findTokenIndexAtOffset(i.column - 1));
        }
        setLanguageId(e, t = "api") {
          if (this._languageId === e) return;
          const i = {
            oldLanguage: this._languageId,
            newLanguage: e,
            source: t
          };
          this._languageId = e, this._bracketPairsTextModelPart.handleDidChangeLanguage(i), this._tokens.resetTokenization(), this.createPreferredTokenProvider(), this._onDidChangeLanguage.fire(i), this._onDidChangeLanguageConfiguration.fire({});
        }
      };
      c2 = N0 = ese([
        ox(4, un),
        ox(5, Pa),
        ox(6, AB)
      ], c2);
      class BP extends MB {
        constructor(e, t, i, n) {
          super(e, t, i), this._tokenizer = null, this._defaultBackgroundTokenizer = null, this._backgroundTokenizer = this._register(new Ul()), this._tokens = new m_(this._languageIdCodec), this._debugBackgroundTokenizer = this._register(new Ul()), this._attachedViewStates = this._register(new VE()), this._register(Bi.onDidChange((o) => {
            const r = this.getLanguageId();
            o.changedLanguages.indexOf(r) !== -1 && this.resetTokenization();
          })), this.resetTokenization(), this._register(n.onDidChangeVisibleRanges(({ view: o, state: r }) => {
            if (r) {
              let a = this._attachedViewStates.get(o);
              a || (a = new Jne(() => this.refreshRanges(a.lineRanges)), this._attachedViewStates.set(o, a)), a.handleStateChange(r);
            } else this._attachedViewStates.deleteAndDispose(o);
          }));
        }
        resetTokenization(e = true) {
          var _a3;
          this._tokens.flush(), (_a3 = this._debugBackgroundTokens) == null ? void 0 : _a3.flush(), this._debugBackgroundStates && (this._debugBackgroundStates = new l2(this._textModel.getLineCount())), e && this._onDidChangeTokens.fire({
            semanticTokensApplied: false,
            ranges: [
              {
                fromLineNumber: 1,
                toLineNumber: this._textModel.getLineCount()
              }
            ]
          });
          const t = () => {
            if (this._textModel.isTooLargeForTokenization()) return [
              null,
              null
            ];
            const o = Bi.get(this.getLanguageId());
            if (!o) return [
              null,
              null
            ];
            let r;
            try {
              r = o.getInitialState();
            } catch (a) {
              return qt(a), [
                null,
                null
              ];
            }
            return [
              o,
              r
            ];
          }, [i, n] = t();
          if (i && n ? this._tokenizer = new jne(this._textModel.getLineCount(), i, this._textModel, this._languageIdCodec) : this._tokenizer = null, this._backgroundTokenizer.clear(), this._defaultBackgroundTokenizer = null, this._tokenizer) {
            const o = {
              setTokens: (r) => {
                this.setTokens(r);
              },
              backgroundTokenizationFinished: () => {
                if (this._backgroundTokenizationState === 2) return;
                const r = 2;
                this._backgroundTokenizationState = r, this._onDidChangeBackgroundTokenizationState.fire();
              },
              setEndState: (r, a) => {
                var _a4;
                if (!this._tokenizer) return;
                const l = this._tokenizer.store.getFirstInvalidEndStateLineNumber();
                l !== null && r >= l && ((_a4 = this._tokenizer) == null ? void 0 : _a4.store.setEndState(r, a));
              }
            };
            i && i.createBackgroundTokenizer && !i.backgroundTokenizerShouldOnlyVerifyTokens && (this._backgroundTokenizer.value = i.createBackgroundTokenizer(this._textModel, o)), !this._backgroundTokenizer.value && !this._textModel.isTooLargeForTokenization() && (this._backgroundTokenizer.value = this._defaultBackgroundTokenizer = new Zne(this._tokenizer, o), this._defaultBackgroundTokenizer.handleChanges()), (i == null ? void 0 : i.backgroundTokenizerShouldOnlyVerifyTokens) && i.createBackgroundTokenizer ? (this._debugBackgroundTokens = new m_(this._languageIdCodec), this._debugBackgroundStates = new l2(this._textModel.getLineCount()), this._debugBackgroundTokenizer.clear(), this._debugBackgroundTokenizer.value = i.createBackgroundTokenizer(this._textModel, {
              setTokens: (r) => {
                var _a4;
                (_a4 = this._debugBackgroundTokens) == null ? void 0 : _a4.setMultilineTokens(r, this._textModel);
              },
              backgroundTokenizationFinished() {
              },
              setEndState: (r, a) => {
                var _a4;
                (_a4 = this._debugBackgroundStates) == null ? void 0 : _a4.setEndState(r, a);
              }
            })) : (this._debugBackgroundTokens = void 0, this._debugBackgroundStates = void 0, this._debugBackgroundTokenizer.value = void 0);
          }
          this.refreshAllVisibleLineTokens();
        }
        handleDidChangeAttached() {
          var _a3;
          (_a3 = this._defaultBackgroundTokenizer) == null ? void 0 : _a3.handleChanges();
        }
        handleDidChangeContent(e) {
          var _a3, _b3, _c2;
          if (e.isFlush) this.resetTokenization(false);
          else if (!e.isEolChange) {
            for (const t of e.changes) {
              const [i, n] = cg(t.text);
              this._tokens.acceptEdit(t.range, i, n), (_a3 = this._debugBackgroundTokens) == null ? void 0 : _a3.acceptEdit(t.range, i, n);
            }
            (_b3 = this._debugBackgroundStates) == null ? void 0 : _b3.acceptChanges(e.changes), this._tokenizer && this._tokenizer.store.acceptChanges(e.changes), (_c2 = this._defaultBackgroundTokenizer) == null ? void 0 : _c2.handleChanges();
          }
        }
        setTokens(e) {
          const { changes: t } = this._tokens.setMultilineTokens(e, this._textModel);
          return t.length > 0 && this._onDidChangeTokens.fire({
            semanticTokensApplied: false,
            ranges: t
          }), {
            changes: t
          };
        }
        refreshAllVisibleLineTokens() {
          const e = qe.joinMany([
            ...this._attachedViewStates
          ].map(([t, i]) => i.lineRanges));
          this.refreshRanges(e);
        }
        refreshRanges(e) {
          for (const t of e) this.refreshRange(t.startLineNumber, t.endLineNumberExclusive - 1);
        }
        refreshRange(e, t) {
          var _a3, _b3;
          if (!this._tokenizer) return;
          e = Math.max(1, Math.min(this._textModel.getLineCount(), e)), t = Math.min(this._textModel.getLineCount(), t);
          const i = new a2(), { heuristicTokens: n } = this._tokenizer.tokenizeHeuristically(i, e, t), o = this.setTokens(i.finalize());
          if (n) for (const r of o.changes) (_a3 = this._backgroundTokenizer.value) == null ? void 0 : _a3.requestTokens(r.fromLineNumber, r.toLineNumber + 1);
          (_b3 = this._defaultBackgroundTokenizer) == null ? void 0 : _b3.checkFinished();
        }
        forceTokenization(e) {
          var _a3, _b3;
          const t = new a2();
          (_a3 = this._tokenizer) == null ? void 0 : _a3.updateTokensUntilLine(t, e), this.setTokens(t.finalize()), (_b3 = this._defaultBackgroundTokenizer) == null ? void 0 : _b3.checkFinished();
        }
        hasAccurateTokensForLine(e) {
          return this._tokenizer ? this._tokenizer.hasAccurateTokensForLine(e) : true;
        }
        isCheapToTokenize(e) {
          return this._tokenizer ? this._tokenizer.isCheapToTokenize(e) : true;
        }
        getLineTokens(e) {
          var _a3;
          const t = this._textModel.getLineContent(e), i = this._tokens.getTokens(this._textModel.getLanguageId(), e - 1, t);
          if (this._debugBackgroundTokens && this._debugBackgroundStates && this._tokenizer && this._debugBackgroundStates.getFirstInvalidEndStateLineNumberOrMax() > e && this._tokenizer.store.getFirstInvalidEndStateLineNumberOrMax() > e) {
            const n = this._debugBackgroundTokens.getTokens(this._textModel.getLanguageId(), e - 1, t);
            !i.equals(n) && ((_a3 = this._debugBackgroundTokenizer.value) == null ? void 0 : _a3.reportMismatchingTokens) && this._debugBackgroundTokenizer.value.reportMismatchingTokens(e);
          }
          return i;
        }
        getTokenTypeIfInsertingCharacter(e, t, i) {
          if (!this._tokenizer) return 0;
          const n = this._textModel.validatePosition(new X(e, t));
          return this.forceTokenization(n.lineNumber), this._tokenizer.getTokenTypeIfInsertingCharacter(n, i);
        }
        tokenizeLineWithEdit(e, t, i) {
          if (!this._tokenizer) return null;
          const n = this._textModel.validatePosition(e);
          return this.forceTokenization(n.lineNumber), this._tokenizer.tokenizeLineWithEdit(n, t, i);
        }
        get hasTokens() {
          return this._tokens.hasTokens;
        }
      }
      class tse {
        constructor() {
          this.changeType = 1;
        }
      }
      class Kr {
        static applyInjectedText(e, t) {
          if (!t || t.length === 0) return e;
          let i = "", n = 0;
          for (const o of t) i += e.substring(n, o.column - 1), n = o.column - 1, i += o.options.content;
          return i += e.substring(n), i;
        }
        static fromDecorations(e) {
          const t = [];
          for (const i of e) i.options.before && i.options.before.content.length > 0 && t.push(new Kr(i.ownerId, i.range.startLineNumber, i.range.startColumn, i.options.before, 0)), i.options.after && i.options.after.content.length > 0 && t.push(new Kr(i.ownerId, i.range.endLineNumber, i.range.endColumn, i.options.after, 1));
          return t.sort((i, n) => i.lineNumber === n.lineNumber ? i.column === n.column ? i.order - n.order : i.column - n.column : i.lineNumber - n.lineNumber), t;
        }
        constructor(e, t, i, n, o) {
          this.ownerId = e, this.lineNumber = t, this.column = i, this.options = n, this.order = o;
        }
      }
      class FP {
        constructor(e, t, i) {
          this.changeType = 2, this.lineNumber = e, this.detail = t, this.injectedText = i;
        }
      }
      class ise {
        constructor(e, t) {
          this.changeType = 3, this.fromLineNumber = e, this.toLineNumber = t;
        }
      }
      class nse {
        constructor(e, t, i, n) {
          this.changeType = 4, this.injectedTexts = n, this.fromLineNumber = e, this.toLineNumber = t, this.detail = i;
        }
      }
      class sse {
        constructor() {
          this.changeType = 5;
        }
      }
      class Kf {
        constructor(e, t, i, n) {
          this.changes = e, this.versionId = t, this.isUndoing = i, this.isRedoing = n, this.resultingSelection = null;
        }
        containsEvent(e) {
          for (let t = 0, i = this.changes.length; t < i; t++) if (this.changes[t].changeType === e) return true;
          return false;
        }
        static merge(e, t) {
          const i = [].concat(e.changes).concat(t.changes), n = t.versionId, o = e.isUndoing || t.isUndoing, r = e.isRedoing || t.isRedoing;
          return new Kf(i, n, o, r);
        }
      }
      class RB {
        constructor(e) {
          this.changes = e;
        }
      }
      class xh {
        constructor(e, t) {
          this.rawContentChangedEvent = e, this.contentChangedEvent = t;
        }
        merge(e) {
          const t = Kf.merge(this.rawContentChangedEvent, e.rawContentChangedEvent), i = xh._mergeChangeEvents(this.contentChangedEvent, e.contentChangedEvent);
          return new xh(t, i);
        }
        static _mergeChangeEvents(e, t) {
          const i = [].concat(e.changes).concat(t.changes), n = t.eol, o = t.versionId, r = e.isUndoing || t.isUndoing, a = e.isRedoing || t.isRedoing, l = e.isFlush || t.isFlush, u = e.isEolChange && t.isEolChange;
          return {
            changes: i,
            eol: n,
            isEolChange: u,
            versionId: o,
            isUndoing: r,
            isRedoing: a,
            isFlush: l
          };
        }
      }
      var ose = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      }, Zb = function(s, e) {
        return function(t, i) {
          e(t, i, s);
        };
      }, Ku;
      function rse(s) {
        const e = new IB();
        return e.acceptChunk(s), e.finish();
      }
      function ase(s) {
        const e = new IB();
        let t;
        for (; typeof (t = s.read()) == "string"; ) e.acceptChunk(t);
        return e.finish();
      }
      function VP(s, e) {
        let t;
        return typeof s == "string" ? t = rse(s) : FG(s) ? t = ase(s) : t = s, t.create(e);
      }
      let Qb = 0;
      const lse = 999, cse = 1e4;
      class use {
        constructor(e) {
          this._source = e, this._eos = false;
        }
        read() {
          if (this._eos) return null;
          const e = [];
          let t = 0, i = 0;
          do {
            const n = this._source.read();
            if (n === null) return this._eos = true, t === 0 ? null : e.join("");
            if (n.length > 0 && (e[t++] = n, i += n.length), i >= 64 * 1024) return e.join("");
          } while (true);
        }
      }
      const $m = () => {
        throw new Error("Invalid change accessor");
      };
      let u2 = (_h2 = class extends he {
        static resolveOptions(e, t) {
          if (t.detectIndentation) {
            const i = DP(e, t.tabSize, t.insertSpaces);
            return new C0({
              tabSize: i.tabSize,
              indentSize: "tabSize",
              insertSpaces: i.insertSpaces,
              trimAutoWhitespace: t.trimAutoWhitespace,
              defaultEOL: t.defaultEOL,
              bracketPairColorizationOptions: t.bracketPairColorizationOptions
            });
          }
          return new C0(t);
        }
        get onDidChangeLanguage() {
          return this._tokenizationTextModelPart.onDidChangeLanguage;
        }
        get onDidChangeLanguageConfiguration() {
          return this._tokenizationTextModelPart.onDidChangeLanguageConfiguration;
        }
        get onDidChangeTokens() {
          return this._tokenizationTextModelPart.onDidChangeTokens;
        }
        onDidChangeContent(e) {
          return this._eventEmitter.slowEvent((t) => e(t.contentChangedEvent));
        }
        onDidChangeContentOrInjectedText(e) {
          return ka(this._eventEmitter.fastEvent((t) => e(t)), this._onDidChangeInjectedText.event((t) => e(t)));
        }
        _isDisposing() {
          return this.__isDisposing;
        }
        get tokenization() {
          return this._tokenizationTextModelPart;
        }
        get bracketPairs() {
          return this._bracketPairs;
        }
        get guides() {
          return this._guidesTextModelPart;
        }
        constructor(e, t, i, n = null, o, r, a, l) {
          super(), this._undoRedoService = o, this._languageService = r, this._languageConfigurationService = a, this.instantiationService = l, this._onWillDispose = this._register(new G()), this.onWillDispose = this._onWillDispose.event, this._onDidChangeDecorations = this._register(new pse((b) => this.handleBeforeFireDecorationsChangedEvent(b))), this.onDidChangeDecorations = this._onDidChangeDecorations.event, this._onDidChangeOptions = this._register(new G()), this.onDidChangeOptions = this._onDidChangeOptions.event, this._onDidChangeAttached = this._register(new G()), this.onDidChangeAttached = this._onDidChangeAttached.event, this._onDidChangeInjectedText = this._register(new G()), this._eventEmitter = this._register(new _se()), this._languageSelectionListener = this._register(new Ul()), this._deltaDecorationCallCnt = 0, this._attachedViews = new Qne(), Qb++, this.id = "$model" + Qb, this.isForSimpleWidget = i.isForSimpleWidget, typeof n > "u" || n === null ? this._associatedResource = st.parse("inmemory://model/" + Qb) : this._associatedResource = n, this._attachedEditorCount = 0;
          const { textBuffer: u, disposable: d } = VP(e, i.defaultEOL);
          this._buffer = u, this._bufferDisposable = d, this._options = Ku.resolveOptions(this._buffer, i);
          const f = typeof t == "string" ? t : t.languageId;
          typeof t != "string" && (this._languageSelectionListener.value = t.onDidChange(() => this._setLanguage(t.languageId))), this._bracketPairs = this._register(new mne(this, this._languageConfigurationService)), this._guidesTextModelPart = this._register(new wne(this, this._languageConfigurationService)), this._decorationProvider = this._register(new _ne(this)), this._tokenizationTextModelPart = this.instantiationService.createInstance(c2, this, this._bracketPairs, f, this._attachedViews);
          const m = this._buffer.getLineCount(), _ = this._buffer.getValueLengthInRange(new z(1, 1, m, this._buffer.getLineLength(m) + 1), 0);
          i.largeFileOptimizations ? (this._isTooLargeForTokenization = _ > Ku.LARGE_FILE_SIZE_THRESHOLD || m > Ku.LARGE_FILE_LINE_COUNT_THRESHOLD, this._isTooLargeForHeapOperation = _ > Ku.LARGE_FILE_HEAP_OPERATION_THRESHOLD) : (this._isTooLargeForTokenization = false, this._isTooLargeForHeapOperation = false), this._isTooLargeForSyncing = _ > Ku._MODEL_SYNC_LIMIT, this._versionId = 1, this._alternativeVersionId = 1, this._initialUndoRedoSnapshot = null, this._isDisposed = false, this.__isDisposing = false, this._instanceId = E9(Qb), this._lastDecorationId = 0, this._decorations = /* @__PURE__ */ Object.create(null), this._decorationsTree = new WP(), this._commandManager = new dN(this, this._undoRedoService), this._isUndoing = false, this._isRedoing = false, this._trimAutoWhitespaceLines = null, this._register(this._decorationProvider.onDidChange(() => {
            this._onDidChangeDecorations.beginDeferredEmit(), this._onDidChangeDecorations.fire(), this._onDidChangeDecorations.endDeferredEmit();
          })), this._languageService.requestRichLanguageFeatures(f), this._register(this._languageConfigurationService.onDidChange((b) => {
            this._bracketPairs.handleLanguageConfigurationServiceChange(b), this._tokenizationTextModelPart.handleLanguageConfigurationServiceChange(b);
          }));
        }
        dispose() {
          this.__isDisposing = true, this._onWillDispose.fire(), this._tokenizationTextModelPart.dispose(), this._isDisposed = true, super.dispose(), this._bufferDisposable.dispose(), this.__isDisposing = false;
          const e = new qf([], "", `
`, false, false, true, true);
          e.dispose(), this._buffer = e, this._bufferDisposable = he.None;
        }
        _assertNotDisposed() {
          if (this._isDisposed) throw new It("Model is disposed!");
        }
        _emitContentChangedEvent(e, t) {
          this.__isDisposing || (this._tokenizationTextModelPart.handleDidChangeContent(t), this._bracketPairs.handleDidChangeContent(t), this._eventEmitter.fire(new xh(e, t)));
        }
        setValue(e) {
          if (this._assertNotDisposed(), e == null) throw FC();
          const { textBuffer: t, disposable: i } = VP(e, this._options.defaultEOL);
          this._setValueFromTextBuffer(t, i);
        }
        _createContentChanged2(e, t, i, n, o, r, a, l) {
          return {
            changes: [
              {
                range: e,
                rangeOffset: t,
                rangeLength: i,
                text: n
              }
            ],
            eol: this._buffer.getEOL(),
            isEolChange: l,
            versionId: this.getVersionId(),
            isUndoing: o,
            isRedoing: r,
            isFlush: a
          };
        }
        _setValueFromTextBuffer(e, t) {
          this._assertNotDisposed();
          const i = this.getFullModelRange(), n = this.getValueLengthInRange(i), o = this.getLineCount(), r = this.getLineMaxColumn(o);
          this._buffer = e, this._bufferDisposable.dispose(), this._bufferDisposable = t, this._increaseVersionId(), this._decorations = /* @__PURE__ */ Object.create(null), this._decorationsTree = new WP(), this._commandManager.clear(), this._trimAutoWhitespaceLines = null, this._emitContentChangedEvent(new Kf([
            new tse()
          ], this._versionId, false, false), this._createContentChanged2(new z(1, 1, o, r), 0, n, this.getValue(), false, false, true, false));
        }
        setEOL(e) {
          this._assertNotDisposed();
          const t = e === 1 ? `\r
` : `
`;
          if (this._buffer.getEOL() === t) return;
          const i = this.getFullModelRange(), n = this.getValueLengthInRange(i), o = this.getLineCount(), r = this.getLineMaxColumn(o);
          this._onBeforeEOLChange(), this._buffer.setEOL(t), this._increaseVersionId(), this._onAfterEOLChange(), this._emitContentChangedEvent(new Kf([
            new sse()
          ], this._versionId, false, false), this._createContentChanged2(new z(1, 1, o, r), 0, n, this.getValue(), false, false, false, true));
        }
        _onBeforeEOLChange() {
          this._decorationsTree.ensureAllNodesHaveRanges(this);
        }
        _onAfterEOLChange() {
          const e = this.getVersionId(), t = this._decorationsTree.collectNodesPostOrder();
          for (let i = 0, n = t.length; i < n; i++) {
            const o = t[i], r = o.range, a = o.cachedAbsoluteStart - o.start, l = this._buffer.getOffsetAt(r.startLineNumber, r.startColumn), u = this._buffer.getOffsetAt(r.endLineNumber, r.endColumn);
            o.cachedAbsoluteStart = l, o.cachedAbsoluteEnd = u, o.cachedVersionId = e, o.start = l - a, o.end = u - a, lu(o);
          }
        }
        onBeforeAttached() {
          return this._attachedEditorCount++, this._attachedEditorCount === 1 && (this._tokenizationTextModelPart.handleDidChangeAttached(), this._onDidChangeAttached.fire(void 0)), this._attachedViews.attachView();
        }
        onBeforeDetached(e) {
          this._attachedEditorCount--, this._attachedEditorCount === 0 && (this._tokenizationTextModelPart.handleDidChangeAttached(), this._onDidChangeAttached.fire(void 0)), this._attachedViews.detachView(e);
        }
        isAttachedToEditor() {
          return this._attachedEditorCount > 0;
        }
        getAttachedEditorCount() {
          return this._attachedEditorCount;
        }
        isTooLargeForSyncing() {
          return this._isTooLargeForSyncing;
        }
        isTooLargeForTokenization() {
          return this._isTooLargeForTokenization;
        }
        isTooLargeForHeapOperation() {
          return this._isTooLargeForHeapOperation;
        }
        isDisposed() {
          return this._isDisposed;
        }
        isDominatedByLongLines() {
          if (this._assertNotDisposed(), this.isTooLargeForTokenization()) return false;
          let e = 0, t = 0;
          const i = this._buffer.getLineCount();
          for (let n = 1; n <= i; n++) {
            const o = this._buffer.getLineLength(n);
            o >= cse ? t += o : e += o;
          }
          return t > e;
        }
        get uri() {
          return this._associatedResource;
        }
        getOptions() {
          return this._assertNotDisposed(), this._options;
        }
        getFormattingOptions() {
          return {
            tabSize: this._options.indentSize,
            insertSpaces: this._options.insertSpaces
          };
        }
        updateOptions(e) {
          this._assertNotDisposed();
          const t = typeof e.tabSize < "u" ? e.tabSize : this._options.tabSize, i = typeof e.indentSize < "u" ? e.indentSize : this._options.originalIndentSize, n = typeof e.insertSpaces < "u" ? e.insertSpaces : this._options.insertSpaces, o = typeof e.trimAutoWhitespace < "u" ? e.trimAutoWhitespace : this._options.trimAutoWhitespace, r = typeof e.bracketColorizationOptions < "u" ? e.bracketColorizationOptions : this._options.bracketPairColorizationOptions, a = new C0({
            tabSize: t,
            indentSize: i,
            insertSpaces: n,
            defaultEOL: this._options.defaultEOL,
            trimAutoWhitespace: o,
            bracketPairColorizationOptions: r
          });
          if (this._options.equals(a)) return;
          const l = this._options.createChangeEvent(a);
          this._options = a, this._bracketPairs.handleDidChangeOptions(l), this._decorationProvider.handleDidChangeOptions(l), this._onDidChangeOptions.fire(l);
        }
        detectIndentation(e, t) {
          this._assertNotDisposed();
          const i = DP(this._buffer, t, e);
          this.updateOptions({
            insertSpaces: i.insertSpaces,
            tabSize: i.tabSize,
            indentSize: i.tabSize
          });
        }
        normalizeIndentation(e) {
          return this._assertNotDisposed(), pB(e, this._options.indentSize, this._options.insertSpaces);
        }
        getVersionId() {
          return this._assertNotDisposed(), this._versionId;
        }
        mightContainRTL() {
          return this._buffer.mightContainRTL();
        }
        mightContainUnusualLineTerminators() {
          return this._buffer.mightContainUnusualLineTerminators();
        }
        removeUnusualLineTerminators(e = null) {
          const t = this.findMatches(k9.source, false, true, false, null, false, 1073741824);
          this._buffer.resetMightContainUnusualLineTerminators(), this.pushEditOperations(e, t.map((i) => ({
            range: i.range,
            text: null
          })), () => null);
        }
        mightContainNonBasicASCII() {
          return this._buffer.mightContainNonBasicASCII();
        }
        getAlternativeVersionId() {
          return this._assertNotDisposed(), this._alternativeVersionId;
        }
        getInitialUndoRedoSnapshot() {
          return this._assertNotDisposed(), this._initialUndoRedoSnapshot;
        }
        getOffsetAt(e) {
          this._assertNotDisposed();
          const t = this._validatePosition(e.lineNumber, e.column, 0);
          return this._buffer.getOffsetAt(t.lineNumber, t.column);
        }
        getPositionAt(e) {
          this._assertNotDisposed();
          const t = Math.min(this._buffer.getLength(), Math.max(0, e));
          return this._buffer.getPositionAt(t);
        }
        _increaseVersionId() {
          this._versionId = this._versionId + 1, this._alternativeVersionId = this._versionId;
        }
        _overwriteVersionId(e) {
          this._versionId = e;
        }
        _overwriteAlternativeVersionId(e) {
          this._alternativeVersionId = e;
        }
        _overwriteInitialUndoRedoSnapshot(e) {
          this._initialUndoRedoSnapshot = e;
        }
        getValue(e, t = false) {
          if (this._assertNotDisposed(), this.isTooLargeForHeapOperation()) throw new It("Operation would exceed heap memory limits");
          const i = this.getFullModelRange(), n = this.getValueInRange(i, e);
          return t ? this._buffer.getBOM() + n : n;
        }
        createSnapshot(e = false) {
          return new use(this._buffer.createSnapshot(e));
        }
        getValueLength(e, t = false) {
          this._assertNotDisposed();
          const i = this.getFullModelRange(), n = this.getValueLengthInRange(i, e);
          return t ? this._buffer.getBOM().length + n : n;
        }
        getValueInRange(e, t = 0) {
          return this._assertNotDisposed(), this._buffer.getValueInRange(this.validateRange(e), t);
        }
        getValueLengthInRange(e, t = 0) {
          return this._assertNotDisposed(), this._buffer.getValueLengthInRange(this.validateRange(e), t);
        }
        getCharacterCountInRange(e, t = 0) {
          return this._assertNotDisposed(), this._buffer.getCharacterCountInRange(this.validateRange(e), t);
        }
        getLineCount() {
          return this._assertNotDisposed(), this._buffer.getLineCount();
        }
        getLineContent(e) {
          if (this._assertNotDisposed(), e < 1 || e > this.getLineCount()) throw new It("Illegal value for lineNumber");
          return this._buffer.getLineContent(e);
        }
        getLineLength(e) {
          if (this._assertNotDisposed(), e < 1 || e > this.getLineCount()) throw new It("Illegal value for lineNumber");
          return this._buffer.getLineLength(e);
        }
        getLinesContent() {
          if (this._assertNotDisposed(), this.isTooLargeForHeapOperation()) throw new It("Operation would exceed heap memory limits");
          return this._buffer.getLinesContent();
        }
        getEOL() {
          return this._assertNotDisposed(), this._buffer.getEOL();
        }
        getEndOfLineSequence() {
          return this._assertNotDisposed(), this._buffer.getEOL() === `
` ? 0 : 1;
        }
        getLineMinColumn(e) {
          return this._assertNotDisposed(), 1;
        }
        getLineMaxColumn(e) {
          if (this._assertNotDisposed(), e < 1 || e > this.getLineCount()) throw new It("Illegal value for lineNumber");
          return this._buffer.getLineLength(e) + 1;
        }
        getLineFirstNonWhitespaceColumn(e) {
          if (this._assertNotDisposed(), e < 1 || e > this.getLineCount()) throw new It("Illegal value for lineNumber");
          return this._buffer.getLineFirstNonWhitespaceColumn(e);
        }
        getLineLastNonWhitespaceColumn(e) {
          if (this._assertNotDisposed(), e < 1 || e > this.getLineCount()) throw new It("Illegal value for lineNumber");
          return this._buffer.getLineLastNonWhitespaceColumn(e);
        }
        _validateRangeRelaxedNoAllocations(e) {
          const t = this._buffer.getLineCount(), i = e.startLineNumber, n = e.startColumn;
          let o = Math.floor(typeof i == "number" && !isNaN(i) ? i : 1), r = Math.floor(typeof n == "number" && !isNaN(n) ? n : 1);
          if (o < 1) o = 1, r = 1;
          else if (o > t) o = t, r = this.getLineMaxColumn(o);
          else if (r <= 1) r = 1;
          else {
            const f = this.getLineMaxColumn(o);
            r >= f && (r = f);
          }
          const a = e.endLineNumber, l = e.endColumn;
          let u = Math.floor(typeof a == "number" && !isNaN(a) ? a : 1), d = Math.floor(typeof l == "number" && !isNaN(l) ? l : 1);
          if (u < 1) u = 1, d = 1;
          else if (u > t) u = t, d = this.getLineMaxColumn(u);
          else if (d <= 1) d = 1;
          else {
            const f = this.getLineMaxColumn(u);
            d >= f && (d = f);
          }
          return i === o && n === r && a === u && l === d && e instanceof z && !(e instanceof mt) ? e : new z(o, r, u, d);
        }
        _isValidPosition(e, t, i) {
          if (typeof e != "number" || typeof t != "number" || isNaN(e) || isNaN(t) || e < 1 || t < 1 || (e | 0) !== e || (t | 0) !== t) return false;
          const n = this._buffer.getLineCount();
          if (e > n) return false;
          if (t === 1) return true;
          const o = this.getLineMaxColumn(e);
          if (t > o) return false;
          if (i === 1) {
            const r = this._buffer.getLineCharCode(e, t - 2);
            if (on(r)) return false;
          }
          return true;
        }
        _validatePosition(e, t, i) {
          const n = Math.floor(typeof e == "number" && !isNaN(e) ? e : 1), o = Math.floor(typeof t == "number" && !isNaN(t) ? t : 1), r = this._buffer.getLineCount();
          if (n < 1) return new X(1, 1);
          if (n > r) return new X(r, this.getLineMaxColumn(r));
          if (o <= 1) return new X(n, 1);
          const a = this.getLineMaxColumn(n);
          if (o >= a) return new X(n, a);
          if (i === 1) {
            const l = this._buffer.getLineCharCode(n, o - 2);
            if (on(l)) return new X(n, o - 1);
          }
          return new X(n, o);
        }
        validatePosition(e) {
          return this._assertNotDisposed(), e instanceof X && this._isValidPosition(e.lineNumber, e.column, 1) ? e : this._validatePosition(e.lineNumber, e.column, 1);
        }
        _isValidRange(e, t) {
          const i = e.startLineNumber, n = e.startColumn, o = e.endLineNumber, r = e.endColumn;
          if (!this._isValidPosition(i, n, 0) || !this._isValidPosition(o, r, 0)) return false;
          if (t === 1) {
            const a = n > 1 ? this._buffer.getLineCharCode(i, n - 2) : 0, l = r > 1 && r <= this._buffer.getLineLength(o) ? this._buffer.getLineCharCode(o, r - 2) : 0, u = on(a), d = on(l);
            return !u && !d;
          }
          return true;
        }
        validateRange(e) {
          if (this._assertNotDisposed(), e instanceof z && !(e instanceof mt) && this._isValidRange(e, 1)) return e;
          const i = this._validatePosition(e.startLineNumber, e.startColumn, 0), n = this._validatePosition(e.endLineNumber, e.endColumn, 0), o = i.lineNumber, r = i.column, a = n.lineNumber, l = n.column;
          {
            const u = r > 1 ? this._buffer.getLineCharCode(o, r - 2) : 0, d = l > 1 && l <= this._buffer.getLineLength(a) ? this._buffer.getLineCharCode(a, l - 2) : 0, f = on(u), m = on(d);
            return !f && !m ? new z(o, r, a, l) : o === a && r === l ? new z(o, r - 1, a, l - 1) : f && m ? new z(o, r - 1, a, l + 1) : f ? new z(o, r - 1, a, l) : new z(o, r, a, l + 1);
          }
        }
        modifyPosition(e, t) {
          this._assertNotDisposed();
          const i = this.getOffsetAt(e) + t;
          return this.getPositionAt(Math.min(this._buffer.getLength(), Math.max(0, i)));
        }
        getFullModelRange() {
          this._assertNotDisposed();
          const e = this.getLineCount();
          return new z(1, 1, e, this.getLineMaxColumn(e));
        }
        findMatchesLineByLine(e, t, i, n) {
          return this._buffer.findMatchesLineByLine(e, t, i, n);
        }
        findMatches(e, t, i, n, o, r, a = lse) {
          this._assertNotDisposed();
          let l = null;
          t !== null && (Array.isArray(t) || (t = [
            t
          ]), t.every((f) => z.isIRange(f)) && (l = t.map((f) => this.validateRange(f)))), l === null && (l = [
            this.getFullModelRange()
          ]), l = l.sort((f, m) => f.startLineNumber - m.startLineNumber || f.startColumn - m.startColumn);
          const u = [];
          u.push(l.reduce((f, m) => z.areIntersecting(f, m) ? f.plusRange(m) : (u.push(f), m)));
          let d;
          if (!i && e.indexOf(`
`) < 0) {
            const m = new Yd(e, i, n, o).parseSearchRequest();
            if (!m) return [];
            d = (_) => this.findMatchesLineByLine(_, m, r, a);
          } else d = (f) => Nb.findMatches(this, new Yd(e, i, n, o), f, r, a);
          return u.map(d).reduce((f, m) => f.concat(m), []);
        }
        findNextMatch(e, t, i, n, o, r) {
          this._assertNotDisposed();
          const a = this.validatePosition(t);
          if (!i && e.indexOf(`
`) < 0) {
            const u = new Yd(e, i, n, o).parseSearchRequest();
            if (!u) return null;
            const d = this.getLineCount();
            let f = new z(a.lineNumber, a.column, d, this.getLineMaxColumn(d)), m = this.findMatchesLineByLine(f, u, r, 1);
            return Nb.findNextMatch(this, new Yd(e, i, n, o), a, r), m.length > 0 || (f = new z(1, 1, a.lineNumber, this.getLineMaxColumn(a.lineNumber)), m = this.findMatchesLineByLine(f, u, r, 1), m.length > 0) ? m[0] : null;
          }
          return Nb.findNextMatch(this, new Yd(e, i, n, o), a, r);
        }
        findPreviousMatch(e, t, i, n, o, r) {
          this._assertNotDisposed();
          const a = this.validatePosition(t);
          return Nb.findPreviousMatch(this, new Yd(e, i, n, o), a, r);
        }
        pushStackElement() {
          this._commandManager.pushStackElement();
        }
        popStackElement() {
          this._commandManager.popStackElement();
        }
        pushEOL(e) {
          if ((this.getEOL() === `
` ? 0 : 1) !== e) try {
            this._onDidChangeDecorations.beginDeferredEmit(), this._eventEmitter.beginDeferredEmit(), this._initialUndoRedoSnapshot === null && (this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri)), this._commandManager.pushEOL(e);
          } finally {
            this._eventEmitter.endDeferredEmit(), this._onDidChangeDecorations.endDeferredEmit();
          }
        }
        _validateEditOperation(e) {
          return e instanceof BL ? e : new BL(e.identifier || null, this.validateRange(e.range), e.text, e.forceMoveMarkers || false, e.isAutoWhitespaceEdit || false, e._isTracked || false);
        }
        _validateEditOperations(e) {
          const t = [];
          for (let i = 0, n = e.length; i < n; i++) t[i] = this._validateEditOperation(e[i]);
          return t;
        }
        pushEditOperations(e, t, i, n) {
          try {
            return this._onDidChangeDecorations.beginDeferredEmit(), this._eventEmitter.beginDeferredEmit(), this._pushEditOperations(e, this._validateEditOperations(t), i, n);
          } finally {
            this._eventEmitter.endDeferredEmit(), this._onDidChangeDecorations.endDeferredEmit();
          }
        }
        _pushEditOperations(e, t, i, n) {
          if (this._options.trimAutoWhitespace && this._trimAutoWhitespaceLines) {
            const o = t.map((a) => ({
              range: this.validateRange(a.range),
              text: a.text
            }));
            let r = true;
            if (e) for (let a = 0, l = e.length; a < l; a++) {
              const u = e[a];
              let d = false;
              for (let f = 0, m = o.length; f < m; f++) {
                const _ = o[f].range, b = _.startLineNumber > u.endLineNumber, v = u.startLineNumber > _.endLineNumber;
                if (!b && !v) {
                  d = true;
                  break;
                }
              }
              if (!d) {
                r = false;
                break;
              }
            }
            if (r) for (let a = 0, l = this._trimAutoWhitespaceLines.length; a < l; a++) {
              const u = this._trimAutoWhitespaceLines[a], d = this.getLineMaxColumn(u);
              let f = true;
              for (let m = 0, _ = o.length; m < _; m++) {
                const b = o[m].range, v = o[m].text;
                if (!(u < b.startLineNumber || u > b.endLineNumber) && !(u === b.startLineNumber && b.startColumn === d && b.isEmpty() && v && v.length > 0 && v.charAt(0) === `
`) && !(u === b.startLineNumber && b.startColumn === 1 && b.isEmpty() && v && v.length > 0 && v.charAt(v.length - 1) === `
`)) {
                  f = false;
                  break;
                }
              }
              if (f) {
                const m = new z(u, 1, u, d);
                t.push(new BL(null, m, null, false, false, false));
              }
            }
            this._trimAutoWhitespaceLines = null;
          }
          return this._initialUndoRedoSnapshot === null && (this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri)), this._commandManager.pushEditOperation(e, t, i, n);
        }
        _applyUndo(e, t, i, n) {
          const o = e.map((r) => {
            const a = this.getPositionAt(r.newPosition), l = this.getPositionAt(r.newEnd);
            return {
              range: new z(a.lineNumber, a.column, l.lineNumber, l.column),
              text: r.oldText
            };
          });
          this._applyUndoRedoEdits(o, t, true, false, i, n);
        }
        _applyRedo(e, t, i, n) {
          const o = e.map((r) => {
            const a = this.getPositionAt(r.oldPosition), l = this.getPositionAt(r.oldEnd);
            return {
              range: new z(a.lineNumber, a.column, l.lineNumber, l.column),
              text: r.newText
            };
          });
          this._applyUndoRedoEdits(o, t, false, true, i, n);
        }
        _applyUndoRedoEdits(e, t, i, n, o, r) {
          try {
            this._onDidChangeDecorations.beginDeferredEmit(), this._eventEmitter.beginDeferredEmit(), this._isUndoing = i, this._isRedoing = n, this.applyEdits(e, false), this.setEOL(t), this._overwriteAlternativeVersionId(o);
          } finally {
            this._isUndoing = false, this._isRedoing = false, this._eventEmitter.endDeferredEmit(r), this._onDidChangeDecorations.endDeferredEmit();
          }
        }
        applyEdits(e, t = false) {
          try {
            this._onDidChangeDecorations.beginDeferredEmit(), this._eventEmitter.beginDeferredEmit();
            const i = this._validateEditOperations(e);
            return this._doApplyEdits(i, t);
          } finally {
            this._eventEmitter.endDeferredEmit(), this._onDidChangeDecorations.endDeferredEmit();
          }
        }
        _doApplyEdits(e, t) {
          const i = this._buffer.getLineCount(), n = this._buffer.applyEdits(e, this._options.trimAutoWhitespace, t), o = this._buffer.getLineCount(), r = n.changes;
          if (this._trimAutoWhitespaceLines = n.trimAutoWhitespaceLineNumbers, r.length !== 0) {
            for (let u = 0, d = r.length; u < d; u++) {
              const f = r[u];
              this._decorationsTree.acceptReplace(f.rangeOffset, f.rangeLength, f.text.length, f.forceMoveMarkers);
            }
            const a = [];
            this._increaseVersionId();
            let l = i;
            for (let u = 0, d = r.length; u < d; u++) {
              const f = r[u], [m] = cg(f.text);
              this._onDidChangeDecorations.fire();
              const _ = f.range.startLineNumber, b = f.range.endLineNumber, v = b - _, y = m, x = Math.min(v, y), L = y - v, D = o - l - L + _, k = D, T = D + y, M = this._decorationsTree.getInjectedTextInInterval(this, this.getOffsetAt(new X(k, 1)), this.getOffsetAt(new X(T, this.getLineMaxColumn(T))), 0), I = Kr.fromDecorations(M), R = new zl(I);
              for (let A = x; A >= 0; A--) {
                const Y = _ + A, U = D + A;
                R.takeFromEndWhile((ee) => ee.lineNumber > U);
                const j = R.takeFromEndWhile((ee) => ee.lineNumber === U);
                a.push(new FP(Y, this.getLineContent(U), j));
              }
              if (x < v) {
                const A = _ + x;
                a.push(new ise(A + 1, b));
              }
              if (x < y) {
                const A = new zl(I), Y = _ + x, U = y - x, j = o - l - U + Y + 1, ee = [], K = [];
                for (let te = 0; te < U; te++) {
                  const H = j + te;
                  K[te] = this.getLineContent(H), A.takeWhile((se) => se.lineNumber < H), ee[te] = A.takeWhile((se) => se.lineNumber === H);
                }
                a.push(new nse(Y + 1, _ + y, K, ee));
              }
              l += L;
            }
            this._emitContentChangedEvent(new Kf(a, this.getVersionId(), this._isUndoing, this._isRedoing), {
              changes: r,
              eol: this._buffer.getEOL(),
              isEolChange: false,
              versionId: this.getVersionId(),
              isUndoing: this._isUndoing,
              isRedoing: this._isRedoing,
              isFlush: false
            });
          }
          return n.reverseEdits === null ? void 0 : n.reverseEdits;
        }
        undo() {
          return this._undoRedoService.undo(this.uri);
        }
        canUndo() {
          return this._undoRedoService.canUndo(this.uri);
        }
        redo() {
          return this._undoRedoService.redo(this.uri);
        }
        canRedo() {
          return this._undoRedoService.canRedo(this.uri);
        }
        handleBeforeFireDecorationsChangedEvent(e) {
          if (e === null || e.size === 0) return;
          const i = Array.from(e).map((n) => new FP(n, this.getLineContent(n), this._getInjectedTextInLine(n)));
          this._onDidChangeInjectedText.fire(new RB(i));
        }
        changeDecorations(e, t = 0) {
          this._assertNotDisposed();
          try {
            return this._onDidChangeDecorations.beginDeferredEmit(), this._changeDecorations(t, e);
          } finally {
            this._onDidChangeDecorations.endDeferredEmit();
          }
        }
        _changeDecorations(e, t) {
          const i = {
            addDecoration: (o, r) => this._deltaDecorationsImpl(e, [], [
              {
                range: o,
                options: r
              }
            ])[0],
            changeDecoration: (o, r) => {
              this._changeDecorationImpl(o, r);
            },
            changeDecorationOptions: (o, r) => {
              this._changeDecorationOptionsImpl(o, zP(r));
            },
            removeDecoration: (o) => {
              this._deltaDecorationsImpl(e, [
                o
              ], []);
            },
            deltaDecorations: (o, r) => o.length === 0 && r.length === 0 ? [] : this._deltaDecorationsImpl(e, o, r)
          };
          let n = null;
          try {
            n = t(i);
          } catch (o) {
            qt(o);
          }
          return i.addDecoration = $m, i.changeDecoration = $m, i.changeDecorationOptions = $m, i.removeDecoration = $m, i.deltaDecorations = $m, n;
        }
        deltaDecorations(e, t, i = 0) {
          if (this._assertNotDisposed(), e || (e = []), e.length === 0 && t.length === 0) return [];
          try {
            return this._deltaDecorationCallCnt++, this._deltaDecorationCallCnt > 1 && (console.warn("Invoking deltaDecorations recursively could lead to leaking decorations."), qt(new Error("Invoking deltaDecorations recursively could lead to leaking decorations."))), this._onDidChangeDecorations.beginDeferredEmit(), this._deltaDecorationsImpl(i, e, t);
          } finally {
            this._onDidChangeDecorations.endDeferredEmit(), this._deltaDecorationCallCnt--;
          }
        }
        _getTrackedRange(e) {
          return this.getDecorationRange(e);
        }
        _setTrackedRange(e, t, i) {
          const n = e ? this._decorations[e] : null;
          if (!n) return t ? this._deltaDecorationsImpl(0, [], [
            {
              range: t,
              options: HP[i]
            }
          ], true)[0] : null;
          if (!t) return this._decorationsTree.delete(n), delete this._decorations[n.id], null;
          const o = this._validateRangeRelaxedNoAllocations(t), r = this._buffer.getOffsetAt(o.startLineNumber, o.startColumn), a = this._buffer.getOffsetAt(o.endLineNumber, o.endColumn);
          return this._decorationsTree.delete(n), n.reset(this.getVersionId(), r, a, o), n.setOptions(HP[i]), this._decorationsTree.insert(n), n.id;
        }
        removeAllDecorationsWithOwnerId(e) {
          if (this._isDisposed) return;
          const t = this._decorationsTree.collectNodesFromOwner(e);
          for (let i = 0, n = t.length; i < n; i++) {
            const o = t[i];
            this._decorationsTree.delete(o), delete this._decorations[o.id];
          }
        }
        getDecorationOptions(e) {
          const t = this._decorations[e];
          return t ? t.options : null;
        }
        getDecorationRange(e) {
          const t = this._decorations[e];
          return t ? this._decorationsTree.getNodeRange(this, t) : null;
        }
        getLineDecorations(e, t = 0, i = false) {
          return e < 1 || e > this.getLineCount() ? [] : this.getLinesDecorations(e, e, t, i);
        }
        getLinesDecorations(e, t, i = 0, n = false, o = false) {
          const r = this.getLineCount(), a = Math.min(r, Math.max(1, e)), l = Math.min(r, Math.max(1, t)), u = this.getLineMaxColumn(l), d = new z(a, 1, l, u), f = this._getDecorationsInRange(d, i, n, o);
          return Nx(f, this._decorationProvider.getDecorationsInRange(d, i, n)), f;
        }
        getDecorationsInRange(e, t = 0, i = false, n = false, o = false) {
          const r = this.validateRange(e), a = this._getDecorationsInRange(r, t, i, o);
          return Nx(a, this._decorationProvider.getDecorationsInRange(r, t, i, n)), a;
        }
        getOverviewRulerDecorations(e = 0, t = false) {
          return this._decorationsTree.getAll(this, e, t, true, false);
        }
        getInjectedTextDecorations(e = 0) {
          return this._decorationsTree.getAllInjectedText(this, e);
        }
        _getInjectedTextInLine(e) {
          const t = this._buffer.getOffsetAt(e, 1), i = t + this._buffer.getLineLength(e), n = this._decorationsTree.getInjectedTextInInterval(this, t, i, 0);
          return Kr.fromDecorations(n).filter((o) => o.lineNumber === e);
        }
        getAllDecorations(e = 0, t = false) {
          let i = this._decorationsTree.getAll(this, e, t, false, false);
          return i = i.concat(this._decorationProvider.getAllDecorations(e, t)), i;
        }
        getAllMarginDecorations(e = 0) {
          return this._decorationsTree.getAll(this, e, false, false, true);
        }
        _getDecorationsInRange(e, t, i, n) {
          const o = this._buffer.getOffsetAt(e.startLineNumber, e.startColumn), r = this._buffer.getOffsetAt(e.endLineNumber, e.endColumn);
          return this._decorationsTree.getAllInInterval(this, o, r, t, i, n);
        }
        getRangeAt(e, t) {
          return this._buffer.getRangeAt(e, t - e);
        }
        _changeDecorationImpl(e, t) {
          const i = this._decorations[e];
          if (!i) return;
          if (i.options.after) {
            const a = this.getDecorationRange(e);
            this._onDidChangeDecorations.recordLineAffectedByInjectedText(a.endLineNumber);
          }
          if (i.options.before) {
            const a = this.getDecorationRange(e);
            this._onDidChangeDecorations.recordLineAffectedByInjectedText(a.startLineNumber);
          }
          const n = this._validateRangeRelaxedNoAllocations(t), o = this._buffer.getOffsetAt(n.startLineNumber, n.startColumn), r = this._buffer.getOffsetAt(n.endLineNumber, n.endColumn);
          this._decorationsTree.delete(i), i.reset(this.getVersionId(), o, r, n), this._decorationsTree.insert(i), this._onDidChangeDecorations.checkAffectedAndFire(i.options), i.options.after && this._onDidChangeDecorations.recordLineAffectedByInjectedText(n.endLineNumber), i.options.before && this._onDidChangeDecorations.recordLineAffectedByInjectedText(n.startLineNumber);
        }
        _changeDecorationOptionsImpl(e, t) {
          const i = this._decorations[e];
          if (!i) return;
          const n = !!(i.options.overviewRuler && i.options.overviewRuler.color), o = !!(t.overviewRuler && t.overviewRuler.color);
          if (this._onDidChangeDecorations.checkAffectedAndFire(i.options), this._onDidChangeDecorations.checkAffectedAndFire(t), i.options.after || t.after) {
            const l = this._decorationsTree.getNodeRange(this, i);
            this._onDidChangeDecorations.recordLineAffectedByInjectedText(l.endLineNumber);
          }
          if (i.options.before || t.before) {
            const l = this._decorationsTree.getNodeRange(this, i);
            this._onDidChangeDecorations.recordLineAffectedByInjectedText(l.startLineNumber);
          }
          const r = n !== o, a = dse(t) !== I0(i);
          r || a ? (this._decorationsTree.delete(i), i.setOptions(t), this._decorationsTree.insert(i)) : i.setOptions(t);
        }
        _deltaDecorationsImpl(e, t, i, n = false) {
          const o = this.getVersionId(), r = t.length;
          let a = 0;
          const l = i.length;
          let u = 0;
          this._onDidChangeDecorations.beginDeferredEmit();
          try {
            const d = new Array(l);
            for (; a < r || u < l; ) {
              let f = null;
              if (a < r) {
                do
                  f = this._decorations[t[a++]];
                while (!f && a < r);
                if (f) {
                  if (f.options.after) {
                    const m = this._decorationsTree.getNodeRange(this, f);
                    this._onDidChangeDecorations.recordLineAffectedByInjectedText(m.endLineNumber);
                  }
                  if (f.options.before) {
                    const m = this._decorationsTree.getNodeRange(this, f);
                    this._onDidChangeDecorations.recordLineAffectedByInjectedText(m.startLineNumber);
                  }
                  this._decorationsTree.delete(f), n || this._onDidChangeDecorations.checkAffectedAndFire(f.options);
                }
              }
              if (u < l) {
                if (!f) {
                  const x = ++this._lastDecorationId, L = `${this._instanceId};${x}`;
                  f = new DB(L, 0, 0), this._decorations[L] = f;
                }
                const m = i[u], _ = this._validateRangeRelaxedNoAllocations(m.range), b = zP(m.options), v = this._buffer.getOffsetAt(_.startLineNumber, _.startColumn), y = this._buffer.getOffsetAt(_.endLineNumber, _.endColumn);
                f.ownerId = e, f.reset(o, v, y, _), f.setOptions(b), f.options.after && this._onDidChangeDecorations.recordLineAffectedByInjectedText(_.endLineNumber), f.options.before && this._onDidChangeDecorations.recordLineAffectedByInjectedText(_.startLineNumber), n || this._onDidChangeDecorations.checkAffectedAndFire(b), this._decorationsTree.insert(f), d[u] = f.id, u++;
              } else f && delete this._decorations[f.id];
            }
            return d;
          } finally {
            this._onDidChangeDecorations.endDeferredEmit();
          }
        }
        getLanguageId() {
          return this.tokenization.getLanguageId();
        }
        setLanguage(e, t) {
          typeof e == "string" ? (this._languageSelectionListener.clear(), this._setLanguage(e, t)) : (this._languageSelectionListener.value = e.onDidChange(() => this._setLanguage(e.languageId, t)), this._setLanguage(e.languageId, t));
        }
        _setLanguage(e, t) {
          this.tokenization.setLanguageId(e, t), this._languageService.requestRichLanguageFeatures(e);
        }
        getLanguageIdAtPosition(e, t) {
          return this.tokenization.getLanguageIdAtPosition(e, t);
        }
        getWordAtPosition(e) {
          return this._tokenizationTextModelPart.getWordAtPosition(e);
        }
        getWordUntilPosition(e) {
          return this._tokenizationTextModelPart.getWordUntilPosition(e);
        }
        normalizePosition(e, t) {
          return e;
        }
        getLineIndentColumn(e) {
          return hse(this.getLineContent(e)) + 1;
        }
      }, Ku = _h2, _h2._MODEL_SYNC_LIMIT = 50 * 1024 * 1024, _h2.LARGE_FILE_SIZE_THRESHOLD = 20 * 1024 * 1024, _h2.LARGE_FILE_LINE_COUNT_THRESHOLD = 300 * 1e3, _h2.LARGE_FILE_HEAP_OPERATION_THRESHOLD = 256 * 1024 * 1024, _h2.DEFAULT_CREATION_OPTIONS = {
        isForSimpleWidget: false,
        tabSize: zn.tabSize,
        indentSize: zn.indentSize,
        insertSpaces: zn.insertSpaces,
        detectIndentation: false,
        defaultEOL: 1,
        trimAutoWhitespace: zn.trimAutoWhitespace,
        largeFileOptimizations: zn.largeFileOptimizations,
        bracketPairColorizationOptions: zn.bracketPairColorizationOptions
      }, _h2);
      u2 = Ku = ose([
        Zb(4, DT),
        Zb(5, un),
        Zb(6, Pa),
        Zb(7, Ft)
      ], u2);
      function hse(s) {
        let e = 0;
        for (const t of s) if (t === " " || t === "	") e++;
        else break;
        return e;
      }
      function rx(s) {
        return !!(s.options.overviewRuler && s.options.overviewRuler.color);
      }
      function dse(s) {
        return !!s.after || !!s.before;
      }
      function I0(s) {
        return !!s.options.after || !!s.options.before;
      }
      class WP {
        constructor() {
          this._decorationsTree0 = new ix(), this._decorationsTree1 = new ix(), this._injectedTextDecorationsTree = new ix();
        }
        ensureAllNodesHaveRanges(e) {
          this.getAll(e, 0, false, false, false);
        }
        _ensureNodesHaveRanges(e, t) {
          for (const i of t) i.range === null && (i.range = e.getRangeAt(i.cachedAbsoluteStart, i.cachedAbsoluteEnd));
          return t;
        }
        getAllInInterval(e, t, i, n, o, r) {
          const a = e.getVersionId(), l = this._intervalSearch(t, i, n, o, a, r);
          return this._ensureNodesHaveRanges(e, l);
        }
        _intervalSearch(e, t, i, n, o, r) {
          const a = this._decorationsTree0.intervalSearch(e, t, i, n, o, r), l = this._decorationsTree1.intervalSearch(e, t, i, n, o, r), u = this._injectedTextDecorationsTree.intervalSearch(e, t, i, n, o, r);
          return a.concat(l).concat(u);
        }
        getInjectedTextInInterval(e, t, i, n) {
          const o = e.getVersionId(), r = this._injectedTextDecorationsTree.intervalSearch(t, i, n, false, o, false);
          return this._ensureNodesHaveRanges(e, r).filter((a) => a.options.showIfCollapsed || !a.range.isEmpty());
        }
        getAllInjectedText(e, t) {
          const i = e.getVersionId(), n = this._injectedTextDecorationsTree.search(t, false, i, false);
          return this._ensureNodesHaveRanges(e, n).filter((o) => o.options.showIfCollapsed || !o.range.isEmpty());
        }
        getAll(e, t, i, n, o) {
          const r = e.getVersionId(), a = this._search(t, i, n, r, o);
          return this._ensureNodesHaveRanges(e, a);
        }
        _search(e, t, i, n, o) {
          if (i) return this._decorationsTree1.search(e, t, n, o);
          {
            const r = this._decorationsTree0.search(e, t, n, o), a = this._decorationsTree1.search(e, t, n, o), l = this._injectedTextDecorationsTree.search(e, t, n, o);
            return r.concat(a).concat(l);
          }
        }
        collectNodesFromOwner(e) {
          const t = this._decorationsTree0.collectNodesFromOwner(e), i = this._decorationsTree1.collectNodesFromOwner(e), n = this._injectedTextDecorationsTree.collectNodesFromOwner(e);
          return t.concat(i).concat(n);
        }
        collectNodesPostOrder() {
          const e = this._decorationsTree0.collectNodesPostOrder(), t = this._decorationsTree1.collectNodesPostOrder(), i = this._injectedTextDecorationsTree.collectNodesPostOrder();
          return e.concat(t).concat(i);
        }
        insert(e) {
          I0(e) ? this._injectedTextDecorationsTree.insert(e) : rx(e) ? this._decorationsTree1.insert(e) : this._decorationsTree0.insert(e);
        }
        delete(e) {
          I0(e) ? this._injectedTextDecorationsTree.delete(e) : rx(e) ? this._decorationsTree1.delete(e) : this._decorationsTree0.delete(e);
        }
        getNodeRange(e, t) {
          const i = e.getVersionId();
          return t.cachedVersionId !== i && this._resolveNode(t, i), t.range === null && (t.range = e.getRangeAt(t.cachedAbsoluteStart, t.cachedAbsoluteEnd)), t.range;
        }
        _resolveNode(e, t) {
          I0(e) ? this._injectedTextDecorationsTree.resolveNode(e, t) : rx(e) ? this._decorationsTree1.resolveNode(e, t) : this._decorationsTree0.resolveNode(e, t);
        }
        acceptReplace(e, t, i, n) {
          this._decorationsTree0.acceptReplace(e, t, i, n), this._decorationsTree1.acceptReplace(e, t, i, n), this._injectedTextDecorationsTree.acceptReplace(e, t, i, n);
        }
      }
      function ga(s) {
        return s.replace(/[^a-z0-9\-_]/gi, " ");
      }
      class OB {
        constructor(e) {
          this.color = e.color || "", this.darkColor = e.darkColor || "";
        }
      }
      class fse extends OB {
        constructor(e) {
          super(e), this._resolvedColor = null, this.position = typeof e.position == "number" ? e.position : fv.Center;
        }
        getColor(e) {
          return this._resolvedColor || (e.type !== "light" && this.darkColor ? this._resolvedColor = this._resolveColor(this.darkColor, e) : this._resolvedColor = this._resolveColor(this.color, e)), this._resolvedColor;
        }
        invalidateCachedColor() {
          this._resolvedColor = null;
        }
        _resolveColor(e, t) {
          if (typeof e == "string") return e;
          const i = e ? t.getColor(e.id) : null;
          return i ? i.toString() : "";
        }
      }
      class gse {
        constructor(e) {
          this.position = (e == null ? void 0 : e.position) ?? ru.Center, this.persistLane = e == null ? void 0 : e.persistLane;
        }
      }
      class mse extends OB {
        constructor(e) {
          super(e), this.position = e.position, this.sectionHeaderStyle = e.sectionHeaderStyle ?? null, this.sectionHeaderText = e.sectionHeaderText ?? null;
        }
        getColor(e) {
          return this._resolvedColor || (e.type !== "light" && this.darkColor ? this._resolvedColor = this._resolveColor(this.darkColor, e) : this._resolvedColor = this._resolveColor(this.color, e)), this._resolvedColor;
        }
        invalidateCachedColor() {
          this._resolvedColor = void 0;
        }
        _resolveColor(e, t) {
          return typeof e == "string" ? le.fromHex(e) : t.getColor(e.id);
        }
      }
      class p_ {
        static from(e) {
          return e instanceof p_ ? e : new p_(e);
        }
        constructor(e) {
          this.content = e.content || "", this.inlineClassName = e.inlineClassName || null, this.inlineClassNameAffectsLetterSpacing = e.inlineClassNameAffectsLetterSpacing || false, this.attachedData = e.attachedData || null, this.cursorStops = e.cursorStops || null;
        }
      }
      class Zi {
        static register(e) {
          return new Zi(e);
        }
        static createDynamic(e) {
          return new Zi(e);
        }
        constructor(e) {
          this.description = e.description, this.blockClassName = e.blockClassName ? ga(e.blockClassName) : null, this.blockDoesNotCollapse = e.blockDoesNotCollapse ?? null, this.blockIsAfterEnd = e.blockIsAfterEnd ?? null, this.blockPadding = e.blockPadding ?? null, this.stickiness = e.stickiness || 0, this.zIndex = e.zIndex || 0, this.className = e.className ? ga(e.className) : null, this.shouldFillLineOnLineBreak = e.shouldFillLineOnLineBreak ?? null, this.hoverMessage = e.hoverMessage || null, this.glyphMarginHoverMessage = e.glyphMarginHoverMessage || null, this.lineNumberHoverMessage = e.lineNumberHoverMessage || null, this.isWholeLine = e.isWholeLine || false, this.showIfCollapsed = e.showIfCollapsed || false, this.collapseOnReplaceEdit = e.collapseOnReplaceEdit || false, this.overviewRuler = e.overviewRuler ? new fse(e.overviewRuler) : null, this.minimap = e.minimap ? new mse(e.minimap) : null, this.glyphMargin = e.glyphMarginClassName ? new gse(e.glyphMargin) : null, this.glyphMarginClassName = e.glyphMarginClassName ? ga(e.glyphMarginClassName) : null, this.linesDecorationsClassName = e.linesDecorationsClassName ? ga(e.linesDecorationsClassName) : null, this.lineNumberClassName = e.lineNumberClassName ? ga(e.lineNumberClassName) : null, this.linesDecorationsTooltip = e.linesDecorationsTooltip ? Dq(e.linesDecorationsTooltip) : null, this.firstLineDecorationClassName = e.firstLineDecorationClassName ? ga(e.firstLineDecorationClassName) : null, this.marginClassName = e.marginClassName ? ga(e.marginClassName) : null, this.inlineClassName = e.inlineClassName ? ga(e.inlineClassName) : null, this.inlineClassNameAffectsLetterSpacing = e.inlineClassNameAffectsLetterSpacing || false, this.beforeContentClassName = e.beforeContentClassName ? ga(e.beforeContentClassName) : null, this.afterContentClassName = e.afterContentClassName ? ga(e.afterContentClassName) : null, this.after = e.after ? p_.from(e.after) : null, this.before = e.before ? p_.from(e.before) : null, this.hideInCommentTokens = e.hideInCommentTokens ?? false, this.hideInStringTokens = e.hideInStringTokens ?? false;
        }
      }
      Zi.EMPTY = Zi.register({
        description: "empty"
      });
      const HP = [
        Zi.register({
          description: "tracked-range-always-grows-when-typing-at-edges",
          stickiness: 0
        }),
        Zi.register({
          description: "tracked-range-never-grows-when-typing-at-edges",
          stickiness: 1
        }),
        Zi.register({
          description: "tracked-range-grows-only-when-typing-before",
          stickiness: 2
        }),
        Zi.register({
          description: "tracked-range-grows-only-when-typing-after",
          stickiness: 3
        })
      ];
      function zP(s) {
        return s instanceof Zi ? s : Zi.createDynamic(s);
      }
      class pse extends he {
        constructor(e) {
          super(), this.handleBeforeFire = e, this._actual = this._register(new G()), this.event = this._actual.event, this._affectedInjectedTextLines = null, this._deferredCnt = 0, this._shouldFireDeferred = false, this._affectsMinimap = false, this._affectsOverviewRuler = false, this._affectsGlyphMargin = false, this._affectsLineNumber = false;
        }
        beginDeferredEmit() {
          this._deferredCnt++;
        }
        endDeferredEmit() {
          var _a3;
          this._deferredCnt--, this._deferredCnt === 0 && (this._shouldFireDeferred && this.doFire(), (_a3 = this._affectedInjectedTextLines) == null ? void 0 : _a3.clear(), this._affectedInjectedTextLines = null);
        }
        recordLineAffectedByInjectedText(e) {
          this._affectedInjectedTextLines || (this._affectedInjectedTextLines = /* @__PURE__ */ new Set()), this._affectedInjectedTextLines.add(e);
        }
        checkAffectedAndFire(e) {
          var _a3, _b3;
          this._affectsMinimap || (this._affectsMinimap = !!((_a3 = e.minimap) == null ? void 0 : _a3.position)), this._affectsOverviewRuler || (this._affectsOverviewRuler = !!((_b3 = e.overviewRuler) == null ? void 0 : _b3.color)), this._affectsGlyphMargin || (this._affectsGlyphMargin = !!e.glyphMarginClassName), this._affectsLineNumber || (this._affectsLineNumber = !!e.lineNumberClassName), this.tryFire();
        }
        fire() {
          this._affectsMinimap = true, this._affectsOverviewRuler = true, this._affectsGlyphMargin = true, this.tryFire();
        }
        tryFire() {
          this._deferredCnt === 0 ? this.doFire() : this._shouldFireDeferred = true;
        }
        doFire() {
          this.handleBeforeFire(this._affectedInjectedTextLines);
          const e = {
            affectsMinimap: this._affectsMinimap,
            affectsOverviewRuler: this._affectsOverviewRuler,
            affectsGlyphMargin: this._affectsGlyphMargin,
            affectsLineNumber: this._affectsLineNumber
          };
          this._shouldFireDeferred = false, this._affectsMinimap = false, this._affectsOverviewRuler = false, this._affectsGlyphMargin = false, this._actual.fire(e);
        }
      }
      class _se extends he {
        constructor() {
          super(), this._fastEmitter = this._register(new G()), this.fastEvent = this._fastEmitter.event, this._slowEmitter = this._register(new G()), this.slowEvent = this._slowEmitter.event, this._deferredCnt = 0, this._deferredEvent = null;
        }
        beginDeferredEmit() {
          this._deferredCnt++;
        }
        endDeferredEmit(e = null) {
          if (this._deferredCnt--, this._deferredCnt === 0 && this._deferredEvent !== null) {
            this._deferredEvent.rawContentChangedEvent.resultingSelection = e;
            const t = this._deferredEvent;
            this._deferredEvent = null, this._fastEmitter.fire(t), this._slowEmitter.fire(t);
          }
        }
        fire(e) {
          if (this._deferredCnt > 0) {
            this._deferredEvent ? this._deferredEvent = this._deferredEvent.merge(e) : this._deferredEvent = e;
            return;
          }
          this._fastEmitter.fire(e), this._slowEmitter.fire(e);
        }
      }
      var bse = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      }, Xb = function(s, e) {
        return function(t, i) {
          e(t, i, s);
        };
      }, sf;
      function Wu(s) {
        return s.toString();
      }
      let vse = class {
        constructor(e, t, i) {
          this.model = e, this._modelEventListeners = new Me(), this.model = e, this._modelEventListeners.add(e.onWillDispose(() => t(e))), this._modelEventListeners.add(e.onDidChangeLanguage((n) => i(e, n)));
        }
        dispose() {
          this._modelEventListeners.dispose();
        }
      };
      const Cse = Is || _t ? 1 : 2;
      class wse {
        constructor(e, t, i, n, o, r, a, l) {
          this.uri = e, this.initialUndoRedoSnapshot = t, this.time = i, this.sharesUndoRedoStack = n, this.heapSize = o, this.sha1 = r, this.versionId = a, this.alternativeVersionId = l;
        }
      }
      let h2 = (_i = class extends he {
        constructor(e, t, i, n) {
          super(), this._configurationService = e, this._resourcePropertiesService = t, this._undoRedoService = i, this._instantiationService = n, this._onModelAdded = this._register(new G()), this.onModelAdded = this._onModelAdded.event, this._onModelRemoved = this._register(new G()), this.onModelRemoved = this._onModelRemoved.event, this._onModelModeChanged = this._register(new G()), this.onModelLanguageChanged = this._onModelModeChanged.event, this._modelCreationOptionsByLanguageAndResource = /* @__PURE__ */ Object.create(null), this._models = {}, this._disposedModels = /* @__PURE__ */ new Map(), this._disposedModelsHeapSize = 0, this._register(this._configurationService.onDidChangeConfiguration((o) => this._updateModelOptions(o))), this._updateModelOptions(void 0);
        }
        static _readModelOptions(e, t) {
          var _a3;
          let i = zn.tabSize;
          if (e.editor && typeof e.editor.tabSize < "u") {
            const m = parseInt(e.editor.tabSize, 10);
            isNaN(m) || (i = m), i < 1 && (i = 1);
          }
          let n = "tabSize";
          if (e.editor && typeof e.editor.indentSize < "u" && e.editor.indentSize !== "tabSize") {
            const m = parseInt(e.editor.indentSize, 10);
            isNaN(m) || (n = Math.max(m, 1));
          }
          let o = zn.insertSpaces;
          e.editor && typeof e.editor.insertSpaces < "u" && (o = e.editor.insertSpaces === "false" ? false : !!e.editor.insertSpaces);
          let r = Cse;
          const a = e.eol;
          a === `\r
` ? r = 2 : a === `
` && (r = 1);
          let l = zn.trimAutoWhitespace;
          e.editor && typeof e.editor.trimAutoWhitespace < "u" && (l = e.editor.trimAutoWhitespace === "false" ? false : !!e.editor.trimAutoWhitespace);
          let u = zn.detectIndentation;
          e.editor && typeof e.editor.detectIndentation < "u" && (u = e.editor.detectIndentation === "false" ? false : !!e.editor.detectIndentation);
          let d = zn.largeFileOptimizations;
          e.editor && typeof e.editor.largeFileOptimizations < "u" && (d = e.editor.largeFileOptimizations === "false" ? false : !!e.editor.largeFileOptimizations);
          let f = zn.bracketPairColorizationOptions;
          return ((_a3 = e.editor) == null ? void 0 : _a3.bracketPairColorization) && typeof e.editor.bracketPairColorization == "object" && (f = {
            enabled: !!e.editor.bracketPairColorization.enabled,
            independentColorPoolPerBracketType: !!e.editor.bracketPairColorization.independentColorPoolPerBracketType
          }), {
            isForSimpleWidget: t,
            tabSize: i,
            indentSize: n,
            insertSpaces: o,
            detectIndentation: u,
            defaultEOL: r,
            trimAutoWhitespace: l,
            largeFileOptimizations: d,
            bracketPairColorizationOptions: f
          };
        }
        _getEOL(e, t) {
          if (e) return this._resourcePropertiesService.getEOL(e, t);
          const i = this._configurationService.getValue("files.eol", {
            overrideIdentifier: t
          });
          return i && typeof i == "string" && i !== "auto" ? i : ur === 3 || ur === 2 ? `
` : `\r
`;
        }
        _shouldRestoreUndoStack() {
          const e = this._configurationService.getValue("files.restoreUndoStack");
          return typeof e == "boolean" ? e : true;
        }
        getCreationOptions(e, t, i) {
          const n = typeof e == "string" ? e : e.languageId;
          let o = this._modelCreationOptionsByLanguageAndResource[n + t];
          if (!o) {
            const r = this._configurationService.getValue("editor", {
              overrideIdentifier: n,
              resource: t
            }), a = this._getEOL(t, n);
            o = sf._readModelOptions({
              editor: r,
              eol: a
            }, i), this._modelCreationOptionsByLanguageAndResource[n + t] = o;
          }
          return o;
        }
        _updateModelOptions(e) {
          const t = this._modelCreationOptionsByLanguageAndResource;
          this._modelCreationOptionsByLanguageAndResource = /* @__PURE__ */ Object.create(null);
          const i = Object.keys(this._models);
          for (let n = 0, o = i.length; n < o; n++) {
            const r = i[n], a = this._models[r], l = a.model.getLanguageId(), u = a.model.uri;
            if (e && !e.affectsConfiguration("editor", {
              overrideIdentifier: l,
              resource: u
            }) && !e.affectsConfiguration("files.eol", {
              overrideIdentifier: l,
              resource: u
            })) continue;
            const d = t[l + u], f = this.getCreationOptions(l, u, a.model.isForSimpleWidget);
            sf._setModelOptionsForModel(a.model, f, d);
          }
        }
        static _setModelOptionsForModel(e, t, i) {
          i && i.defaultEOL !== t.defaultEOL && e.getLineCount() === 1 && e.setEOL(t.defaultEOL === 1 ? 0 : 1), !(i && i.detectIndentation === t.detectIndentation && i.insertSpaces === t.insertSpaces && i.tabSize === t.tabSize && i.indentSize === t.indentSize && i.trimAutoWhitespace === t.trimAutoWhitespace && $s(i.bracketPairColorizationOptions, t.bracketPairColorizationOptions)) && (t.detectIndentation ? (e.detectIndentation(t.insertSpaces, t.tabSize), e.updateOptions({
            trimAutoWhitespace: t.trimAutoWhitespace,
            bracketColorizationOptions: t.bracketPairColorizationOptions
          })) : e.updateOptions({
            insertSpaces: t.insertSpaces,
            tabSize: t.tabSize,
            indentSize: t.indentSize,
            trimAutoWhitespace: t.trimAutoWhitespace,
            bracketColorizationOptions: t.bracketPairColorizationOptions
          }));
        }
        _insertDisposedModel(e) {
          this._disposedModels.set(Wu(e.uri), e), this._disposedModelsHeapSize += e.heapSize;
        }
        _removeDisposedModel(e) {
          const t = this._disposedModels.get(Wu(e));
          return t && (this._disposedModelsHeapSize -= t.heapSize), this._disposedModels.delete(Wu(e)), t;
        }
        _ensureDisposedModelsHeapSize(e) {
          if (this._disposedModelsHeapSize > e) {
            const t = [];
            for (this._disposedModels.forEach((i) => {
              i.sharesUndoRedoStack || t.push(i);
            }), t.sort((i, n) => i.time - n.time); t.length > 0 && this._disposedModelsHeapSize > e; ) {
              const i = t.shift();
              this._removeDisposedModel(i.uri), i.initialUndoRedoSnapshot !== null && this._undoRedoService.restoreSnapshot(i.initialUndoRedoSnapshot);
            }
          }
        }
        _createModelData(e, t, i, n) {
          const o = this.getCreationOptions(t, i, n), r = this._instantiationService.createInstance(u2, e, t, o, i);
          if (i && this._disposedModels.has(Wu(i))) {
            const u = this._removeDisposedModel(i), d = this._undoRedoService.getElements(i), f = this._getSHA1Computer(), m = f.canComputeSHA1(r) ? f.computeSHA1(r) === u.sha1 : false;
            if (m || u.sharesUndoRedoStack) {
              for (const _ of d.past) yl(_) && _.matchesResource(i) && _.setModel(r);
              for (const _ of d.future) yl(_) && _.matchesResource(i) && _.setModel(r);
              this._undoRedoService.setElementsValidFlag(i, true, (_) => yl(_) && _.matchesResource(i)), m && (r._overwriteVersionId(u.versionId), r._overwriteAlternativeVersionId(u.alternativeVersionId), r._overwriteInitialUndoRedoSnapshot(u.initialUndoRedoSnapshot));
            } else u.initialUndoRedoSnapshot !== null && this._undoRedoService.restoreSnapshot(u.initialUndoRedoSnapshot);
          }
          const a = Wu(r.uri);
          if (this._models[a]) throw new Error("ModelService: Cannot add model because it already exists!");
          const l = new vse(r, (u) => this._onWillDispose(u), (u, d) => this._onDidChangeLanguage(u, d));
          return this._models[a] = l, l;
        }
        createModel(e, t, i, n = false) {
          let o;
          return t ? o = this._createModelData(e, t, i, n) : o = this._createModelData(e, gr, i, n), this._onModelAdded.fire(o.model), o.model;
        }
        getModels() {
          const e = [], t = Object.keys(this._models);
          for (let i = 0, n = t.length; i < n; i++) {
            const o = t[i];
            e.push(this._models[o].model);
          }
          return e;
        }
        getModel(e) {
          const t = Wu(e), i = this._models[t];
          return i ? i.model : null;
        }
        _schemaShouldMaintainUndoRedoElements(e) {
          return e.scheme === it.file || e.scheme === it.vscodeRemote || e.scheme === it.vscodeUserData || e.scheme === it.vscodeNotebookCell || e.scheme === "fake-fs";
        }
        _onWillDispose(e) {
          const t = Wu(e.uri), i = this._models[t], n = this._undoRedoService.getUriComparisonKey(e.uri) !== e.uri.toString();
          let o = false, r = 0;
          if (n || this._shouldRestoreUndoStack() && this._schemaShouldMaintainUndoRedoElements(e.uri)) {
            const u = this._undoRedoService.getElements(e.uri);
            if (u.past.length > 0 || u.future.length > 0) {
              for (const d of u.past) yl(d) && d.matchesResource(e.uri) && (o = true, r += d.heapSize(e.uri), d.setModel(e.uri));
              for (const d of u.future) yl(d) && d.matchesResource(e.uri) && (o = true, r += d.heapSize(e.uri), d.setModel(e.uri));
            }
          }
          const a = sf.MAX_MEMORY_FOR_CLOSED_FILES_UNDO_STACK, l = this._getSHA1Computer();
          if (o) if (!n && (r > a || !l.canComputeSHA1(e))) {
            const u = i.model.getInitialUndoRedoSnapshot();
            u !== null && this._undoRedoService.restoreSnapshot(u);
          } else this._ensureDisposedModelsHeapSize(a - r), this._undoRedoService.setElementsValidFlag(e.uri, false, (u) => yl(u) && u.matchesResource(e.uri)), this._insertDisposedModel(new wse(e.uri, i.model.getInitialUndoRedoSnapshot(), Date.now(), n, r, l.computeSHA1(e), e.getVersionId(), e.getAlternativeVersionId()));
          else if (!n) {
            const u = i.model.getInitialUndoRedoSnapshot();
            u !== null && this._undoRedoService.restoreSnapshot(u);
          }
          delete this._models[t], i.dispose(), delete this._modelCreationOptionsByLanguageAndResource[e.getLanguageId() + e.uri], this._onModelRemoved.fire(e);
        }
        _onDidChangeLanguage(e, t) {
          const i = t.oldLanguage, n = e.getLanguageId(), o = this.getCreationOptions(i, e.uri, e.isForSimpleWidget), r = this.getCreationOptions(n, e.uri, e.isForSimpleWidget);
          sf._setModelOptionsForModel(e, r, o), this._onModelModeChanged.fire({
            model: e,
            oldLanguageId: i
          });
        }
        _getSHA1Computer() {
          return new _N();
        }
      }, sf = _i, _i.MAX_MEMORY_FOR_CLOSED_FILES_UNDO_STACK = 20 * 1024 * 1024, _i);
      h2 = sf = bse([
        Xb(0, Si),
        Xb(1, R8),
        Xb(2, DT),
        Xb(3, Ft)
      ], h2);
      const __N = class __N {
        canComputeSHA1(e) {
          return e.getValueLength() <= __N.MAX_MODEL_SIZE;
        }
        computeSHA1(e) {
          const t = new nT(), i = e.createSnapshot();
          let n;
          for (; n = i.read(); ) t.update(n);
          return t.digest();
        }
      };
      __N.MAX_MODEL_SIZE = 10 * 1024 * 1024;
      let _N = __N;
      var d2;
      (function(s) {
        s[s.PRESERVE = 0] = "PRESERVE", s[s.LAST = 1] = "LAST";
      })(d2 || (d2 = {}));
      const PB = {
        Quickaccess: "workbench.contributions.quickaccess"
      };
      class yse {
        constructor() {
          this.providers = [], this.defaultProvider = void 0;
        }
        registerQuickAccessProvider(e) {
          return e.prefix.length === 0 ? this.defaultProvider = e : this.providers.push(e), this.providers.sort((t, i) => i.prefix.length - t.prefix.length), Ze(() => {
            this.providers.splice(this.providers.indexOf(e), 1), this.defaultProvider === e && (this.defaultProvider = void 0);
          });
        }
        getQuickAccessProviders() {
          return NE([
            this.defaultProvider,
            ...this.providers
          ]);
        }
        getQuickAccessProvider(e) {
          return e && this.providers.find((i) => e.startsWith(i.prefix)) || void 0 || this.defaultProvider;
        }
      }
      yn.add(PB.Quickaccess, new yse());
      const Sse = {
        ctrlCmd: false,
        alt: false
      };
      var pg;
      (function(s) {
        s[s.Blur = 1] = "Blur", s[s.Gesture = 2] = "Gesture", s[s.Other = 3] = "Other";
      })(pg || (pg = {}));
      var Ca;
      (function(s) {
        s[s.NONE = 0] = "NONE", s[s.FIRST = 1] = "FIRST", s[s.SECOND = 2] = "SECOND", s[s.LAST = 3] = "LAST";
      })(Ca || (Ca = {}));
      var Zt;
      (function(s) {
        s[s.First = 1] = "First", s[s.Second = 2] = "Second", s[s.Last = 3] = "Last", s[s.Next = 4] = "Next", s[s.Previous = 5] = "Previous", s[s.NextPage = 6] = "NextPage", s[s.PreviousPage = 7] = "PreviousPage", s[s.NextSeparator = 8] = "NextSeparator", s[s.PreviousSeparator = 9] = "PreviousSeparator";
      })(Zt || (Zt = {}));
      var Kv;
      (function(s) {
        s[s.Title = 1] = "Title", s[s.Inline = 2] = "Inline";
      })(Kv || (Kv = {}));
      const kw = pt("quickInputService");
      var Lse = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      }, UP = function(s, e) {
        return function(t, i) {
          e(t, i, s);
        };
      };
      let f2 = class extends he {
        constructor(e, t) {
          super(), this.quickInputService = e, this.instantiationService = t, this.registry = yn.as(PB.Quickaccess), this.mapProviderToDescriptor = /* @__PURE__ */ new Map(), this.lastAcceptedPickerValues = /* @__PURE__ */ new Map(), this.visibleQuickAccess = void 0;
        }
        show(e = "", t) {
          this.doShowOrPick(e, false, t);
        }
        doShowOrPick(e, t, i) {
          var _a3, _b3;
          const [n, o] = this.getOrInstantiateProvider(e, i == null ? void 0 : i.enabledProviderPrefixes), r = this.visibleQuickAccess, a = r == null ? void 0 : r.descriptor;
          if (r && o && a === o) {
            e !== o.prefix && !(i == null ? void 0 : i.preserveValue) && (r.picker.value = e), this.adjustValueSelection(r.picker, o, i);
            return;
          }
          if (o && !(i == null ? void 0 : i.preserveValue)) {
            let b;
            if (r && a && a !== o) {
              const v = r.value.substr(a.prefix.length);
              v && (b = `${o.prefix}${v}`);
            }
            if (!b) {
              const v = n == null ? void 0 : n.defaultFilterValue;
              v === d2.LAST ? b = this.lastAcceptedPickerValues.get(o) : typeof v == "string" && (b = `${o.prefix}${v}`);
            }
            typeof b == "string" && (e = b);
          }
          const l = (_a3 = r == null ? void 0 : r.picker) == null ? void 0 : _a3.valueSelection, u = (_b3 = r == null ? void 0 : r.picker) == null ? void 0 : _b3.value, d = new Me(), f = d.add(this.quickInputService.createQuickPick({
            useSeparators: true
          }));
          f.value = e, this.adjustValueSelection(f, o, i), f.placeholder = (i == null ? void 0 : i.placeholder) ?? (o == null ? void 0 : o.placeholder), f.quickNavigate = i == null ? void 0 : i.quickNavigateConfiguration, f.hideInput = !!f.quickNavigate && !r, (typeof (i == null ? void 0 : i.itemActivation) == "number" || (i == null ? void 0 : i.quickNavigateConfiguration)) && (f.itemActivation = (i == null ? void 0 : i.itemActivation) ?? Ca.SECOND), f.contextKey = o == null ? void 0 : o.contextKey, f.filterValue = (b) => b.substring(o ? o.prefix.length : 0);
          let m;
          t && (m = new P9(), d.add(be.once(f.onWillAccept)((b) => {
            b.veto(), f.hide();
          }))), d.add(this.registerPickerListeners(f, n, o, e, i));
          const _ = d.add(new Lg());
          if (n && d.add(n.provide(f, _.token, i == null ? void 0 : i.providerOptions)), be.once(f.onDidHide)(() => {
            f.selectedItems.length === 0 && _.cancel(), d.dispose(), m == null ? void 0 : m.complete(f.selectedItems.slice(0));
          }), f.show(), l && u === e && (f.valueSelection = l), t) return m == null ? void 0 : m.p;
        }
        adjustValueSelection(e, t, i) {
          let n;
          (i == null ? void 0 : i.preserveValue) ? n = [
            e.value.length,
            e.value.length
          ] : n = [
            (t == null ? void 0 : t.prefix.length) ?? 0,
            e.value.length
          ], e.valueSelection = n;
        }
        registerPickerListeners(e, t, i, n, o) {
          const r = new Me(), a = this.visibleQuickAccess = {
            picker: e,
            descriptor: i,
            value: n
          };
          return r.add(Ze(() => {
            a === this.visibleQuickAccess && (this.visibleQuickAccess = void 0);
          })), r.add(e.onDidChangeValue((l) => {
            const [u] = this.getOrInstantiateProvider(l, o == null ? void 0 : o.enabledProviderPrefixes);
            u !== t ? this.show(l, {
              enabledProviderPrefixes: o == null ? void 0 : o.enabledProviderPrefixes,
              preserveValue: true,
              providerOptions: o == null ? void 0 : o.providerOptions
            }) : a.value = l;
          })), i && r.add(e.onDidAccept(() => {
            this.lastAcceptedPickerValues.set(i, e.value);
          })), r;
        }
        getOrInstantiateProvider(e, t) {
          const i = this.registry.getQuickAccessProvider(e);
          if (!i || t && !(t == null ? void 0 : t.includes(i.prefix))) return [
            void 0,
            void 0
          ];
          let n = this.mapProviderToDescriptor.get(i);
          return n || (n = this.instantiationService.createInstance(i.ctor), this.mapProviderToDescriptor.set(i, n)), [
            n,
            i
          ];
        }
      };
      f2 = Lse([
        UP(0, kw),
        UP(1, Ft)
      ], f2);
      class Dw extends Yl {
        constructor(e) {
          super(), this._onChange = this._register(new G()), this.onChange = this._onChange.event, this._onKeyDown = this._register(new G()), this.onKeyDown = this._onKeyDown.event, this._opts = e, this._checked = this._opts.isChecked;
          const t = [
            "monaco-custom-toggle"
          ];
          this._opts.icon && (this._icon = this._opts.icon, t.push(...wt.asClassNameArray(this._icon))), this._opts.actionClassName && t.push(...this._opts.actionClassName.split(" ")), this._checked && t.push("checked"), this.domNode = document.createElement("div"), this._hover = this._register(Ba().setupManagedHover(e.hoverDelegate ?? $o("mouse"), this.domNode, this._opts.title)), this.domNode.classList.add(...t), this._opts.notFocusable || (this.domNode.tabIndex = 0), this.domNode.setAttribute("role", "checkbox"), this.domNode.setAttribute("aria-checked", String(this._checked)), this.domNode.setAttribute("aria-label", this._opts.title), this.applyStyles(), this.onclick(this.domNode, (i) => {
            this.enabled && (this.checked = !this._checked, this._onChange.fire(false), i.preventDefault());
          }), this._register(this.ignoreGesture(this.domNode)), this.onkeydown(this.domNode, (i) => {
            if (i.keyCode === 10 || i.keyCode === 3) {
              this.checked = !this._checked, this._onChange.fire(true), i.preventDefault(), i.stopPropagation();
              return;
            }
            this._onKeyDown.fire(i);
          });
        }
        get enabled() {
          return this.domNode.getAttribute("aria-disabled") !== "true";
        }
        focus() {
          this.domNode.focus();
        }
        get checked() {
          return this._checked;
        }
        set checked(e) {
          this._checked = e, this.domNode.setAttribute("aria-checked", String(this._checked)), this.domNode.classList.toggle("checked", this._checked), this.applyStyles();
        }
        width() {
          return 22;
        }
        applyStyles() {
          this.domNode && (this.domNode.style.borderColor = this._checked && this._opts.inputActiveOptionBorder || "", this.domNode.style.color = this._checked && this._opts.inputActiveOptionForeground || "inherit", this.domNode.style.backgroundColor = this._checked && this._opts.inputActiveOptionBackground || "");
        }
        enable() {
          this.domNode.setAttribute("aria-disabled", String(false));
        }
        disable() {
          this.domNode.setAttribute("aria-disabled", String(true));
        }
      }
      var xse = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      };
      class BB {
        constructor(e) {
          this.nodes = e;
        }
        toString() {
          return this.nodes.map((e) => typeof e == "string" ? e : e.label).join("");
        }
      }
      xse([
        Li
      ], BB.prototype, "toString", null);
      const kse = /\[([^\]]+)\]\(((?:https?:\/\/|command:|file:)[^\)\s]+)(?: (["'])(.+?)(\3))?\)/gi;
      function Dse(s) {
        const e = [];
        let t = 0, i;
        for (; i = kse.exec(s); ) {
          i.index - t > 0 && e.push(s.substring(t, i.index));
          const [, n, o, , r] = i;
          r ? e.push({
            label: n,
            href: o,
            title: r
          }) : e.push({
            label: n,
            href: o
          }), t = i.index + i[0].length;
        }
        return t < s.length && e.push(s.substring(t)), new BB(e);
      }
      const ax = {}, Ese = new A6("quick-input-button-icon-");
      function Tse(s) {
        if (!s) return;
        let e;
        const t = s.dark.toString();
        return ax[t] ? e = ax[t] : (e = Ese.nextId(), Kk(`.${e}, .hc-light .${e}`, `background-image: ${ql(s.light || s.dark)}`), Kk(`.vs-dark .${e}, .hc-black .${e}`, `background-image: ${ql(s.dark)}`), ax[t] = e), e;
      }
      function Ip(s, e, t) {
        let i = s.iconClass || Tse(s.iconPath);
        return s.alwaysVisible && (i = i ? `${i} always-visible` : "always-visible"), {
          id: e,
          label: "",
          tooltip: s.tooltip || "",
          class: i,
          enabled: true,
          run: t
        };
      }
      function Nse(s, e, t) {
        gs(e);
        const i = Dse(s);
        let n = 0;
        for (const o of i.nodes) if (typeof o == "string") e.append(...wh(o));
        else {
          let r = o.title;
          !r && o.href.startsWith("command:") ? r = C("executeCommand", "Click to execute command '{0}'", o.href.substring(8)) : r || (r = o.href);
          const a = He("a", {
            href: o.href,
            title: r,
            tabIndex: n++
          }, o.label);
          a.style.textDecoration = "underline";
          const l = (_) => {
            HK(_) && dt.stop(_, true), t.callback(o.href);
          }, u = t.disposables.add(new ot(a, Ce.CLICK)).event, d = t.disposables.add(new ot(a, Ce.KEY_DOWN)).event, f = be.chain(d, (_) => _.filter((b) => {
            const v = new si(b);
            return v.equals(10) || v.equals(3);
          }));
          t.disposables.add(ui.addTarget(a));
          const m = t.disposables.add(new ot(a, Qt.Tap)).event;
          be.any(u, m, f)(l, null, t.disposables), e.appendChild(a);
        }
      }
      var Ise = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      }, $P = function(s, e) {
        return function(t, i) {
          e(t, i, s);
        };
      };
      const FB = "inQuickInput", Mse = new Ie(FB, false, C("inQuickInput", "Whether keyboard focus is inside the quick input control")), Ase = Ot.has(FB), VB = "quickInputType", Rse = new Ie(VB, void 0, C("quickInputType", "The type of the currently visible quick input")), WB = "cursorAtEndOfQuickInputBox", Ose = new Ie(WB, false, C("cursorAtEndOfQuickInputBox", "Whether the cursor in the quick input is at the end of the input box")), Pse = Ot.has(WB), g2 = {
        iconClass: wt.asClassName(Te.quickInputBack),
        tooltip: C("quickInput.back", "Back")
      };
      const _Ew = class _Ew extends he {
        constructor(e) {
          super(), this.ui = e, this._widgetUpdated = false, this.visible = false, this._enabled = true, this._busy = false, this._ignoreFocusOut = false, this._leftButtons = [], this._rightButtons = [], this._inlineButtons = [], this.buttonsUpdated = false, this._toggles = [], this.togglesUpdated = false, this.noValidationMessage = _Ew.noPromptMessage, this._severity = Ui.Ignore, this.onDidTriggerButtonEmitter = this._register(new G()), this.onDidHideEmitter = this._register(new G()), this.onWillHideEmitter = this._register(new G()), this.onDisposeEmitter = this._register(new G()), this.visibleDisposables = this._register(new Me()), this.onDidHide = this.onDidHideEmitter.event;
        }
        get title() {
          return this._title;
        }
        set title(e) {
          this._title = e, this.update();
        }
        get description() {
          return this._description;
        }
        set description(e) {
          this._description = e, this.update();
        }
        get step() {
          return this._steps;
        }
        set step(e) {
          this._steps = e, this.update();
        }
        get totalSteps() {
          return this._totalSteps;
        }
        set totalSteps(e) {
          this._totalSteps = e, this.update();
        }
        get enabled() {
          return this._enabled;
        }
        set enabled(e) {
          this._enabled = e, this.update();
        }
        get contextKey() {
          return this._contextKey;
        }
        set contextKey(e) {
          this._contextKey = e, this.update();
        }
        get busy() {
          return this._busy;
        }
        set busy(e) {
          this._busy = e, this.update();
        }
        get ignoreFocusOut() {
          return this._ignoreFocusOut;
        }
        set ignoreFocusOut(e) {
          const t = this._ignoreFocusOut !== e && !Ih;
          this._ignoreFocusOut = e && !Ih, t && this.update();
        }
        get titleButtons() {
          return this._leftButtons.length ? [
            ...this._leftButtons,
            this._rightButtons
          ] : this._rightButtons;
        }
        get buttons() {
          return [
            ...this._leftButtons,
            ...this._rightButtons,
            ...this._inlineButtons
          ];
        }
        set buttons(e) {
          this._leftButtons = e.filter((t) => t === g2), this._rightButtons = e.filter((t) => t !== g2 && t.location !== Kv.Inline), this._inlineButtons = e.filter((t) => t.location === Kv.Inline), this.buttonsUpdated = true, this.update();
        }
        get toggles() {
          return this._toggles;
        }
        set toggles(e) {
          this._toggles = e ?? [], this.togglesUpdated = true, this.update();
        }
        get validationMessage() {
          return this._validationMessage;
        }
        set validationMessage(e) {
          this._validationMessage = e, this.update();
        }
        get severity() {
          return this._severity;
        }
        set severity(e) {
          this._severity = e, this.update();
        }
        show() {
          this.visible || (this.visibleDisposables.add(this.ui.onDidTriggerButton((e) => {
            this.buttons.indexOf(e) !== -1 && this.onDidTriggerButtonEmitter.fire(e);
          })), this.ui.show(this), this.visible = true, this._lastValidationMessage = void 0, this._lastSeverity = void 0, this.buttons.length && (this.buttonsUpdated = true), this.toggles.length && (this.togglesUpdated = true), this.update());
        }
        hide() {
          this.visible && this.ui.hide();
        }
        didHide(e = pg.Other) {
          this.visible = false, this.visibleDisposables.clear(), this.onDidHideEmitter.fire({
            reason: e
          });
        }
        willHide(e = pg.Other) {
          this.onWillHideEmitter.fire({
            reason: e
          });
        }
        update() {
          var _a3;
          if (!this.visible) return;
          const e = this.getTitle();
          e && this.ui.title.textContent !== e ? this.ui.title.textContent = e : !e && this.ui.title.innerHTML !== "&nbsp;" && (this.ui.title.innerText = "\xA0");
          const t = this.getDescription();
          if (this.ui.description1.textContent !== t && (this.ui.description1.textContent = t), this.ui.description2.textContent !== t && (this.ui.description2.textContent = t), this._widgetUpdated && (this._widgetUpdated = false, this._widget ? gs(this.ui.widget, this._widget) : gs(this.ui.widget)), this.busy && !this.busyDelay && (this.busyDelay = new Kh(), this.busyDelay.setIfNotSet(() => {
            this.visible && this.ui.progressBar.infinite();
          }, 800)), !this.busy && this.busyDelay && (this.ui.progressBar.stop(), this.busyDelay.cancel(), this.busyDelay = void 0), this.buttonsUpdated) {
            this.buttonsUpdated = false, this.ui.leftActionBar.clear();
            const n = this._leftButtons.map((a, l) => Ip(a, `id-${l}`, async () => this.onDidTriggerButtonEmitter.fire(a)));
            this.ui.leftActionBar.push(n, {
              icon: true,
              label: false
            }), this.ui.rightActionBar.clear();
            const o = this._rightButtons.map((a, l) => Ip(a, `id-${l}`, async () => this.onDidTriggerButtonEmitter.fire(a)));
            this.ui.rightActionBar.push(o, {
              icon: true,
              label: false
            }), this.ui.inlineActionBar.clear();
            const r = this._inlineButtons.map((a, l) => Ip(a, `id-${l}`, async () => this.onDidTriggerButtonEmitter.fire(a)));
            this.ui.inlineActionBar.push(r, {
              icon: true,
              label: false
            });
          }
          if (this.togglesUpdated) {
            this.togglesUpdated = false;
            const n = ((_a3 = this.toggles) == null ? void 0 : _a3.filter((o) => o instanceof Dw)) ?? [];
            this.ui.inputBox.toggles = n;
          }
          this.ui.ignoreFocusOut = this.ignoreFocusOut, this.ui.setEnabled(this.enabled), this.ui.setContextKey(this.contextKey);
          const i = this.validationMessage || this.noValidationMessage;
          this._lastValidationMessage !== i && (this._lastValidationMessage = i, gs(this.ui.message), Nse(i, this.ui.message, {
            callback: (n) => {
              this.ui.linkOpenerDelegate(n);
            },
            disposables: this.visibleDisposables
          })), this._lastSeverity !== this.severity && (this._lastSeverity = this.severity, this.showMessageDecoration(this.severity));
        }
        getTitle() {
          return this.title && this.step ? `${this.title} (${this.getSteps()})` : this.title ? this.title : this.step ? this.getSteps() : "";
        }
        getDescription() {
          return this.description || "";
        }
        getSteps() {
          return this.step && this.totalSteps ? C("quickInput.steps", "{0}/{1}", this.step, this.totalSteps) : this.step ? String(this.step) : "";
        }
        showMessageDecoration(e) {
          if (this.ui.inputBox.showDecoration(e), e !== Ui.Ignore) {
            const t = this.ui.inputBox.stylesForType(e);
            this.ui.message.style.color = t.foreground ? `${t.foreground}` : "", this.ui.message.style.backgroundColor = t.background ? `${t.background}` : "", this.ui.message.style.border = t.border ? `1px solid ${t.border}` : "", this.ui.message.style.marginBottom = "-2px";
          } else this.ui.message.style.color = "", this.ui.message.style.backgroundColor = "", this.ui.message.style.border = "", this.ui.message.style.marginBottom = "";
        }
        dispose() {
          this.hide(), this.onDisposeEmitter.fire(), super.dispose();
        }
      };
      _Ew.noPromptMessage = C("inputModeEntry", "Press 'Enter' to confirm your input or 'Escape' to cancel");
      let Ew = _Ew;
      const _jv = class _jv extends Ew {
        constructor() {
          super(...arguments), this._value = "", this.onDidChangeValueEmitter = this._register(new G()), this.onWillAcceptEmitter = this._register(new G()), this.onDidAcceptEmitter = this._register(new G()), this.onDidCustomEmitter = this._register(new G()), this._items = [], this.itemsUpdated = false, this._canSelectMany = false, this._canAcceptInBackground = false, this._matchOnDescription = false, this._matchOnDetail = false, this._matchOnLabel = true, this._matchOnLabelMode = "fuzzy", this._sortByLabel = true, this._keepScrollPosition = false, this._itemActivation = Ca.FIRST, this._activeItems = [], this.activeItemsUpdated = false, this.activeItemsToConfirm = [], this.onDidChangeActiveEmitter = this._register(new G()), this._selectedItems = [], this.selectedItemsUpdated = false, this.selectedItemsToConfirm = [], this.onDidChangeSelectionEmitter = this._register(new G()), this.onDidTriggerItemButtonEmitter = this._register(new G()), this.onDidTriggerSeparatorButtonEmitter = this._register(new G()), this.valueSelectionUpdated = true, this._ok = "default", this._customButton = false, this._focusEventBufferer = new B_(), this.type = "quickPick", this.filterValue = (e) => e, this.onDidChangeValue = this.onDidChangeValueEmitter.event, this.onWillAccept = this.onWillAcceptEmitter.event, this.onDidAccept = this.onDidAcceptEmitter.event, this.onDidChangeActive = this.onDidChangeActiveEmitter.event, this.onDidChangeSelection = this.onDidChangeSelectionEmitter.event, this.onDidTriggerItemButton = this.onDidTriggerItemButtonEmitter.event, this.onDidTriggerSeparatorButton = this.onDidTriggerSeparatorButtonEmitter.event;
        }
        get quickNavigate() {
          return this._quickNavigate;
        }
        set quickNavigate(e) {
          this._quickNavigate = e, this.update();
        }
        get value() {
          return this._value;
        }
        set value(e) {
          this.doSetValue(e);
        }
        doSetValue(e, t) {
          this._value !== e && (this._value = e, t || this.update(), this.visible && this.ui.list.filter(this.filterValue(this._value)) && this.trySelectFirst(), this.onDidChangeValueEmitter.fire(this._value));
        }
        set ariaLabel(e) {
          this._ariaLabel = e, this.update();
        }
        get ariaLabel() {
          return this._ariaLabel;
        }
        get placeholder() {
          return this._placeholder;
        }
        set placeholder(e) {
          this._placeholder = e, this.update();
        }
        get items() {
          return this._items;
        }
        get scrollTop() {
          return this.ui.list.scrollTop;
        }
        set scrollTop(e) {
          this.ui.list.scrollTop = e;
        }
        set items(e) {
          this._items = e, this.itemsUpdated = true, this.update();
        }
        get canSelectMany() {
          return this._canSelectMany;
        }
        set canSelectMany(e) {
          this._canSelectMany = e, this.update();
        }
        get canAcceptInBackground() {
          return this._canAcceptInBackground;
        }
        set canAcceptInBackground(e) {
          this._canAcceptInBackground = e;
        }
        get matchOnDescription() {
          return this._matchOnDescription;
        }
        set matchOnDescription(e) {
          this._matchOnDescription = e, this.update();
        }
        get matchOnDetail() {
          return this._matchOnDetail;
        }
        set matchOnDetail(e) {
          this._matchOnDetail = e, this.update();
        }
        get matchOnLabel() {
          return this._matchOnLabel;
        }
        set matchOnLabel(e) {
          this._matchOnLabel = e, this.update();
        }
        get matchOnLabelMode() {
          return this._matchOnLabelMode;
        }
        set matchOnLabelMode(e) {
          this._matchOnLabelMode = e, this.update();
        }
        get sortByLabel() {
          return this._sortByLabel;
        }
        set sortByLabel(e) {
          this._sortByLabel = e, this.update();
        }
        get keepScrollPosition() {
          return this._keepScrollPosition;
        }
        set keepScrollPosition(e) {
          this._keepScrollPosition = e;
        }
        get itemActivation() {
          return this._itemActivation;
        }
        set itemActivation(e) {
          this._itemActivation = e;
        }
        get activeItems() {
          return this._activeItems;
        }
        set activeItems(e) {
          this._activeItems = e, this.activeItemsUpdated = true, this.update();
        }
        get selectedItems() {
          return this._selectedItems;
        }
        set selectedItems(e) {
          this._selectedItems = e, this.selectedItemsUpdated = true, this.update();
        }
        get keyMods() {
          return this._quickNavigate ? Sse : this.ui.keyMods;
        }
        get valueSelection() {
          const e = this.ui.inputBox.getSelection();
          if (e) return [
            e.start,
            e.end
          ];
        }
        set valueSelection(e) {
          this._valueSelection = e, this.valueSelectionUpdated = true, this.update();
        }
        get customButton() {
          return this._customButton;
        }
        set customButton(e) {
          this._customButton = e, this.update();
        }
        get customLabel() {
          return this._customButtonLabel;
        }
        set customLabel(e) {
          this._customButtonLabel = e, this.update();
        }
        get customHover() {
          return this._customButtonHover;
        }
        set customHover(e) {
          this._customButtonHover = e, this.update();
        }
        get ok() {
          return this._ok;
        }
        set ok(e) {
          this._ok = e, this.update();
        }
        get hideInput() {
          return !!this._hideInput;
        }
        set hideInput(e) {
          this._hideInput = e, this.update();
        }
        trySelectFirst() {
          this.canSelectMany || this.ui.list.focus(Zt.First);
        }
        show() {
          this.visible || (this.visibleDisposables.add(this.ui.inputBox.onDidChange((e) => {
            this.doSetValue(e, true);
          })), this.visibleDisposables.add(this.ui.onDidAccept(() => {
            this.canSelectMany ? this.ui.list.getCheckedElements().length || (this._selectedItems = [], this.onDidChangeSelectionEmitter.fire(this.selectedItems)) : this.activeItems[0] && (this._selectedItems = [
              this.activeItems[0]
            ], this.onDidChangeSelectionEmitter.fire(this.selectedItems)), this.handleAccept(false);
          })), this.visibleDisposables.add(this.ui.onDidCustom(() => {
            this.onDidCustomEmitter.fire();
          })), this.visibleDisposables.add(this._focusEventBufferer.wrapEvent(this.ui.list.onDidChangeFocus, (e, t) => t)((e) => {
            this.activeItemsUpdated || this.activeItemsToConfirm !== this._activeItems && Qi(e, this._activeItems, (t, i) => t === i) || (this._activeItems = e, this.onDidChangeActiveEmitter.fire(e));
          })), this.visibleDisposables.add(this.ui.list.onDidChangeSelection(({ items: e, event: t }) => {
            if (this.canSelectMany) {
              e.length && this.ui.list.setSelectedElements([]);
              return;
            }
            this.selectedItemsToConfirm !== this._selectedItems && Qi(e, this._selectedItems, (i, n) => i === n) || (this._selectedItems = e, this.onDidChangeSelectionEmitter.fire(e), e.length && this.handleAccept(cT(t) && t.button === 1));
          })), this.visibleDisposables.add(this.ui.list.onChangedCheckedElements((e) => {
            !this.canSelectMany || !this.visible || this.selectedItemsToConfirm !== this._selectedItems && Qi(e, this._selectedItems, (t, i) => t === i) || (this._selectedItems = e, this.onDidChangeSelectionEmitter.fire(e));
          })), this.visibleDisposables.add(this.ui.list.onButtonTriggered((e) => this.onDidTriggerItemButtonEmitter.fire(e))), this.visibleDisposables.add(this.ui.list.onSeparatorButtonTriggered((e) => this.onDidTriggerSeparatorButtonEmitter.fire(e))), this.visibleDisposables.add(this.registerQuickNavigation()), this.valueSelectionUpdated = true), super.show();
        }
        handleAccept(e) {
          let t = false;
          this.onWillAcceptEmitter.fire({
            veto: () => t = true
          }), t || this.onDidAcceptEmitter.fire({
            inBackground: e
          });
        }
        registerQuickNavigation() {
          return re(this.ui.container, Ce.KEY_UP, (e) => {
            if (this.canSelectMany || !this._quickNavigate) return;
            const t = new si(e), i = t.keyCode;
            this._quickNavigate.keybindings.some((r) => {
              const a = r.getChords();
              return a.length > 1 ? false : a[0].shiftKey && i === 4 ? !(t.ctrlKey || t.altKey || t.metaKey) : !!(a[0].altKey && i === 6 || a[0].ctrlKey && i === 5 || a[0].metaKey && i === 57);
            }) && (this.activeItems[0] && (this._selectedItems = [
              this.activeItems[0]
            ], this.onDidChangeSelectionEmitter.fire(this.selectedItems), this.handleAccept(false)), this._quickNavigate = void 0);
          });
        }
        update() {
          if (!this.visible) return;
          const e = this.keepScrollPosition ? this.scrollTop : 0, t = !!this.description, i = {
            title: !!this.title || !!this.step || !!this.titleButtons.length,
            description: t,
            checkAll: this.canSelectMany && !this._hideCheckAll,
            checkBox: this.canSelectMany,
            inputBox: !this._hideInput,
            progressBar: !this._hideInput || t,
            visibleCount: true,
            count: this.canSelectMany && !this._hideCountBadge,
            ok: this.ok === "default" ? this.canSelectMany : this.ok,
            list: true,
            message: !!this.validationMessage,
            customButton: this.customButton
          };
          this.ui.setVisibilities(i), super.update(), this.ui.inputBox.value !== this.value && (this.ui.inputBox.value = this.value), this.valueSelectionUpdated && (this.valueSelectionUpdated = false, this.ui.inputBox.select(this._valueSelection && {
            start: this._valueSelection[0],
            end: this._valueSelection[1]
          })), this.ui.inputBox.placeholder !== (this.placeholder || "") && (this.ui.inputBox.placeholder = this.placeholder || "");
          let n = this.ariaLabel;
          !n && i.inputBox && (n = this.placeholder || _jv.DEFAULT_ARIA_LABEL, this.title && (n += ` - ${this.title}`)), this.ui.list.ariaLabel !== n && (this.ui.list.ariaLabel = n ?? null), this.ui.list.matchOnDescription = this.matchOnDescription, this.ui.list.matchOnDetail = this.matchOnDetail, this.ui.list.matchOnLabel = this.matchOnLabel, this.ui.list.matchOnLabelMode = this.matchOnLabelMode, this.ui.list.sortByLabel = this.sortByLabel, this.itemsUpdated && (this.itemsUpdated = false, this._focusEventBufferer.bufferEvents(() => {
            switch (this.ui.list.setElements(this.items), this.ui.list.shouldLoop = !this.canSelectMany, this.ui.list.filter(this.filterValue(this.ui.inputBox.value)), this._itemActivation) {
              case Ca.NONE:
                this._itemActivation = Ca.FIRST;
                break;
              case Ca.SECOND:
                this.ui.list.focus(Zt.Second), this._itemActivation = Ca.FIRST;
                break;
              case Ca.LAST:
                this.ui.list.focus(Zt.Last), this._itemActivation = Ca.FIRST;
                break;
              default:
                this.trySelectFirst();
                break;
            }
          })), this.ui.container.classList.contains("show-checkboxes") !== !!this.canSelectMany && (this.canSelectMany ? this.ui.list.clearFocus() : this.trySelectFirst()), this.activeItemsUpdated && (this.activeItemsUpdated = false, this.activeItemsToConfirm = this._activeItems, this.ui.list.setFocusedElements(this.activeItems), this.activeItemsToConfirm === this._activeItems && (this.activeItemsToConfirm = null)), this.selectedItemsUpdated && (this.selectedItemsUpdated = false, this.selectedItemsToConfirm = this._selectedItems, this.canSelectMany ? this.ui.list.setCheckedElements(this.selectedItems) : this.ui.list.setSelectedElements(this.selectedItems), this.selectedItemsToConfirm === this._selectedItems && (this.selectedItemsToConfirm = null)), this.ui.customButton.label = this.customLabel || "", this.ui.customButton.element.title = this.customHover || "", i.inputBox || (this.ui.list.domFocus(), this.canSelectMany && this.ui.list.focus(Zt.First)), this.keepScrollPosition && (this.scrollTop = e);
        }
        focus(e) {
          this.ui.list.focus(e), this.canSelectMany && this.ui.list.domFocus();
        }
        accept(e) {
          e && !this._canAcceptInBackground || this.activeItems[0] && (this._selectedItems = [
            this.activeItems[0]
          ], this.onDidChangeSelectionEmitter.fire(this.selectedItems), this.handleAccept(e ?? false));
        }
      };
      _jv.DEFAULT_ARIA_LABEL = C("quickInputBox.ariaLabel", "Type to narrow down results.");
      let jv = _jv;
      let Bse = class extends Ew {
        constructor() {
          super(...arguments), this._value = "", this.valueSelectionUpdated = true, this._password = false, this.onDidValueChangeEmitter = this._register(new G()), this.onDidAcceptEmitter = this._register(new G()), this.type = "inputBox", this.onDidChangeValue = this.onDidValueChangeEmitter.event, this.onDidAccept = this.onDidAcceptEmitter.event;
        }
        get value() {
          return this._value;
        }
        set value(e) {
          this._value = e || "", this.update();
        }
        get placeholder() {
          return this._placeholder;
        }
        set placeholder(e) {
          this._placeholder = e, this.update();
        }
        get password() {
          return this._password;
        }
        set password(e) {
          this._password = e, this.update();
        }
        show() {
          this.visible || (this.visibleDisposables.add(this.ui.inputBox.onDidChange((e) => {
            e !== this.value && (this._value = e, this.onDidValueChangeEmitter.fire(e));
          })), this.visibleDisposables.add(this.ui.onDidAccept(() => this.onDidAcceptEmitter.fire())), this.valueSelectionUpdated = true), super.show();
        }
        update() {
          if (!this.visible) return;
          this.ui.container.classList.remove("hidden-input");
          const e = {
            title: !!this.title || !!this.step || !!this.titleButtons.length,
            description: !!this.description || !!this.step,
            inputBox: true,
            message: true,
            progressBar: true
          };
          this.ui.setVisibilities(e), super.update(), this.ui.inputBox.value !== this.value && (this.ui.inputBox.value = this.value), this.valueSelectionUpdated && (this.valueSelectionUpdated = false, this.ui.inputBox.select(this._valueSelection && {
            start: this._valueSelection[0],
            end: this._valueSelection[1]
          })), this.ui.inputBox.placeholder !== (this.placeholder || "") && (this.ui.inputBox.placeholder = this.placeholder || ""), this.ui.inputBox.password !== this.password && (this.ui.inputBox.password = this.password);
        }
      }, m2 = class extends o_ {
        constructor(e, t) {
          super("element", false, (i) => this.getOverrideOptions(i), e, t);
        }
        getOverrideOptions(e) {
          const t = (wn(e.content) ? e.content.textContent ?? "" : typeof e.content == "string" ? e.content : e.content.value).includes(`
`);
          return {
            persistence: {
              hideOnKeyDown: false
            },
            appearance: {
              showHoverHint: t,
              skipFadeInAnimation: true
            }
          };
        }
      };
      m2 = Ise([
        $P(0, Si),
        $P(1, Z_)
      ], m2);
      le.white.toString(), le.white.toString();
      class p2 extends he {
        get onDidClick() {
          return this._onDidClick.event;
        }
        constructor(e, t) {
          super(), this._label = "", this._onDidClick = this._register(new G()), this._onDidEscape = this._register(new G()), this.options = t, this._element = document.createElement("a"), this._element.classList.add("monaco-button"), this._element.tabIndex = 0, this._element.setAttribute("role", "button"), this._element.classList.toggle("secondary", !!t.secondary);
          const i = t.secondary ? t.buttonSecondaryBackground : t.buttonBackground, n = t.secondary ? t.buttonSecondaryForeground : t.buttonForeground;
          this._element.style.color = n || "", this._element.style.backgroundColor = i || "", t.supportShortLabel && (this._labelShortElement = document.createElement("div"), this._labelShortElement.classList.add("monaco-button-label-short"), this._element.appendChild(this._labelShortElement), this._labelElement = document.createElement("div"), this._labelElement.classList.add("monaco-button-label"), this._element.appendChild(this._labelElement), this._element.classList.add("monaco-text-button-with-short-label")), typeof t.title == "string" && this.setTitle(t.title), typeof t.ariaLabel == "string" && this._element.setAttribute("aria-label", t.ariaLabel), e.appendChild(this._element), this._register(ui.addTarget(this._element)), [
            Ce.CLICK,
            Qt.Tap
          ].forEach((o) => {
            this._register(re(this._element, o, (r) => {
              if (!this.enabled) {
                dt.stop(r);
                return;
              }
              this._onDidClick.fire(r);
            }));
          }), this._register(re(this._element, Ce.KEY_DOWN, (o) => {
            const r = new si(o);
            let a = false;
            this.enabled && (r.equals(3) || r.equals(10)) ? (this._onDidClick.fire(o), a = true) : r.equals(9) && (this._onDidEscape.fire(o), this._element.blur(), a = true), a && dt.stop(r, true);
          })), this._register(re(this._element, Ce.MOUSE_OVER, (o) => {
            this._element.classList.contains("disabled") || this.updateBackground(true);
          })), this._register(re(this._element, Ce.MOUSE_OUT, (o) => {
            this.updateBackground(false);
          })), this.focusTracker = this._register(Qp(this._element)), this._register(this.focusTracker.onDidFocus(() => {
            this.enabled && this.updateBackground(true);
          })), this._register(this.focusTracker.onDidBlur(() => {
            this.enabled && this.updateBackground(false);
          }));
        }
        dispose() {
          super.dispose(), this._element.remove();
        }
        getContentElements(e) {
          const t = [];
          for (let i of wh(e)) if (typeof i == "string") {
            if (i = i.trim(), i === "") continue;
            const n = document.createElement("span");
            n.textContent = i, t.push(n);
          } else t.push(i);
          return t;
        }
        updateBackground(e) {
          let t;
          this.options.secondary ? t = e ? this.options.buttonSecondaryHoverBackground : this.options.buttonSecondaryBackground : t = e ? this.options.buttonHoverBackground : this.options.buttonBackground, t && (this._element.style.backgroundColor = t);
        }
        get element() {
          return this._element;
        }
        set label(e) {
          var _a3;
          if (this._label === e || Vf(this._label) && Vf(e) && lJ(this._label, e)) return;
          this._element.classList.add("monaco-text-button");
          const t = this.options.supportShortLabel ? this._labelElement : this._element;
          if (Vf(e)) {
            const n = $T(e, {
              inline: true
            });
            n.dispose();
            const o = (_a3 = n.element.querySelector("p")) == null ? void 0 : _a3.innerHTML;
            if (o) {
              const r = z9(o, {
                ADD_TAGS: [
                  "b",
                  "i",
                  "u",
                  "code",
                  "span"
                ],
                ALLOWED_ATTR: [
                  "class"
                ],
                RETURN_TRUSTED_TYPE: true
              });
              t.innerHTML = r;
            } else gs(t);
          } else this.options.supportIcons ? gs(t, ...this.getContentElements(e)) : t.textContent = e;
          let i = "";
          typeof this.options.title == "string" ? i = this.options.title : this.options.title && (i = vJ(e)), this.setTitle(i), typeof this.options.ariaLabel == "string" ? this._element.setAttribute("aria-label", this.options.ariaLabel) : this.options.ariaLabel && this._element.setAttribute("aria-label", i), this._label = e;
        }
        get label() {
          return this._label;
        }
        set icon(e) {
          this._element.classList.add(...wt.asClassNameArray(e));
        }
        set enabled(e) {
          e ? (this._element.classList.remove("disabled"), this._element.setAttribute("aria-disabled", String(false)), this._element.tabIndex = 0) : (this._element.classList.add("disabled"), this._element.setAttribute("aria-disabled", String(true)));
        }
        get enabled() {
          return !this._element.classList.contains("disabled");
        }
        setTitle(e) {
          !this._hover && e !== "" ? this._hover = this._register(Ba().setupManagedHover(this.options.hoverDelegate ?? $o("mouse"), this._element, e)) : this._hover && this._hover.update(e);
        }
      }
      class qP {
        constructor(e, t, i) {
          this.options = t, this.styles = i, this.count = 0, this.element = Ne(e, He(".monaco-count-badge")), this.countFormat = this.options.countFormat || "{0}", this.titleFormat = this.options.titleFormat || "", this.setCount(this.options.count || 0);
        }
        setCount(e) {
          this.count = e, this.render();
        }
        setTitleFormat(e) {
          this.titleFormat = e, this.render();
        }
        render() {
          this.element.textContent = Ak(this.countFormat, this.count), this.element.title = Ak(this.titleFormat, this.count), this.element.style.backgroundColor = this.styles.badgeBackground ?? "", this.element.style.color = this.styles.badgeForeground ?? "", this.styles.badgeBorder && (this.element.style.border = `1px solid ${this.styles.badgeBorder}`);
        }
      }
      const KP = "done", jP = "active", lx = "infinite", cx = "infinite-long-running", GP = "discrete";
      const _bN = class _bN extends he {
        constructor(e, t) {
          super(), this.progressSignal = this._register(new Ul()), this.workedVal = 0, this.showDelayedScheduler = this._register(new ns(() => e8(this.element), 0)), this.longRunningScheduler = this._register(new ns(() => this.infiniteLongRunning(), _bN.LONG_RUNNING_INFINITE_THRESHOLD)), this.create(e, t);
        }
        create(e, t) {
          this.element = document.createElement("div"), this.element.classList.add("monaco-progress-container"), this.element.setAttribute("role", "progressbar"), this.element.setAttribute("aria-valuemin", "0"), e.appendChild(this.element), this.bit = document.createElement("div"), this.bit.classList.add("progress-bit"), this.bit.style.backgroundColor = (t == null ? void 0 : t.progressBarBackground) || "#0E70C0", this.element.appendChild(this.bit);
        }
        off() {
          this.bit.style.width = "inherit", this.bit.style.opacity = "1", this.element.classList.remove(jP, lx, cx, GP), this.workedVal = 0, this.totalWork = void 0, this.longRunningScheduler.cancel(), this.progressSignal.clear();
        }
        stop() {
          return this.doDone(false);
        }
        doDone(e) {
          return this.element.classList.add(KP), this.element.classList.contains(lx) ? (this.bit.style.opacity = "0", e ? setTimeout(() => this.off(), 200) : this.off()) : (this.bit.style.width = "inherit", e ? setTimeout(() => this.off(), 200) : this.off()), this;
        }
        infinite() {
          return this.bit.style.width = "2%", this.bit.style.opacity = "1", this.element.classList.remove(GP, KP, cx), this.element.classList.add(jP, lx), this.longRunningScheduler.schedule(), this;
        }
        infiniteLongRunning() {
          this.element.classList.add(cx);
        }
        getContainer() {
          return this.element;
        }
      };
      _bN.LONG_RUNNING_INFINITE_THRESHOLD = 1e4;
      let bN = _bN;
      const Fse = C("caseDescription", "Match Case"), Vse = C("wordsDescription", "Match Whole Word"), Wse = C("regexDescription", "Use Regular Expression");
      class Hse extends Dw {
        constructor(e) {
          super({
            icon: Te.caseSensitive,
            title: Fse + e.appendTitle,
            isChecked: e.isChecked,
            hoverDelegate: e.hoverDelegate ?? $o("element"),
            inputActiveOptionBorder: e.inputActiveOptionBorder,
            inputActiveOptionForeground: e.inputActiveOptionForeground,
            inputActiveOptionBackground: e.inputActiveOptionBackground
          });
        }
      }
      class zse extends Dw {
        constructor(e) {
          super({
            icon: Te.wholeWord,
            title: Vse + e.appendTitle,
            isChecked: e.isChecked,
            hoverDelegate: e.hoverDelegate ?? $o("element"),
            inputActiveOptionBorder: e.inputActiveOptionBorder,
            inputActiveOptionForeground: e.inputActiveOptionForeground,
            inputActiveOptionBackground: e.inputActiveOptionBackground
          });
        }
      }
      class Use extends Dw {
        constructor(e) {
          super({
            icon: Te.regex,
            title: Wse + e.appendTitle,
            isChecked: e.isChecked,
            hoverDelegate: e.hoverDelegate ?? $o("element"),
            inputActiveOptionBorder: e.inputActiveOptionBorder,
            inputActiveOptionForeground: e.inputActiveOptionForeground,
            inputActiveOptionBackground: e.inputActiveOptionBackground
          });
        }
      }
      class $se {
        constructor(e, t = 0, i = e.length, n = t - 1) {
          this.items = e, this.start = t, this.end = i, this.index = n;
        }
        current() {
          return this.index === this.start - 1 || this.index === this.end ? null : this.items[this.index];
        }
        next() {
          return this.index = Math.min(this.index + 1, this.end), this.current();
        }
        previous() {
          return this.index = Math.max(this.index - 1, this.start - 1), this.current();
        }
        first() {
          return this.index = this.start, this.current();
        }
        last() {
          return this.index = this.end - 1, this.current();
        }
      }
      class qse {
        constructor(e = [], t = 10) {
          this._initialize(e), this._limit = t, this._onChange();
        }
        getHistory() {
          return this._elements;
        }
        add(e) {
          this._history.delete(e), this._history.add(e), this._onChange();
        }
        next() {
          return this._navigator.next();
        }
        previous() {
          return this._currentPosition() !== 0 ? this._navigator.previous() : null;
        }
        current() {
          return this._navigator.current();
        }
        first() {
          return this._navigator.first();
        }
        last() {
          return this._navigator.last();
        }
        isLast() {
          return this._currentPosition() >= this._elements.length - 1;
        }
        isNowhere() {
          return this._navigator.current() === null;
        }
        has(e) {
          return this._history.has(e);
        }
        _onChange() {
          this._reduceToLimit();
          const e = this._elements;
          this._navigator = new $se(e, 0, e.length, e.length);
        }
        _reduceToLimit() {
          const e = this._elements;
          e.length > this._limit && this._initialize(e.slice(e.length - this._limit));
        }
        _currentPosition() {
          const e = this._navigator.current();
          return e ? this._elements.indexOf(e) : -1;
        }
        _initialize(e) {
          this._history = /* @__PURE__ */ new Set();
          for (const t of e) this._history.add(t);
        }
        get _elements() {
          const e = [];
          return this._history.forEach((t) => e.push(t)), e;
        }
      }
      const qm = He;
      class Kse extends Yl {
        constructor(e, t, i) {
          super(), this.state = "idle", this.maxHeight = Number.POSITIVE_INFINITY, this._onDidChange = this._register(new G()), this.onDidChange = this._onDidChange.event, this._onDidHeightChange = this._register(new G()), this.onDidHeightChange = this._onDidHeightChange.event, this.contextViewProvider = t, this.options = i, this.message = null, this.placeholder = this.options.placeholder || "", this.tooltip = this.options.tooltip ?? (this.placeholder || ""), this.ariaLabel = this.options.ariaLabel || "", this.options.validationOptions && (this.validation = this.options.validationOptions.validation), this.element = Ne(e, qm(".monaco-inputbox.idle"));
          const n = this.options.flexibleHeight ? "textarea" : "input", o = Ne(this.element, qm(".ibwrapper"));
          if (this.input = Ne(o, qm(n + ".input.empty")), this.input.setAttribute("autocorrect", "off"), this.input.setAttribute("autocapitalize", "off"), this.input.setAttribute("spellcheck", "false"), this.onfocus(this.input, () => this.element.classList.add("synthetic-focus")), this.onblur(this.input, () => this.element.classList.remove("synthetic-focus")), this.options.flexibleHeight) {
            this.maxHeight = typeof this.options.flexibleMaxHeight == "number" ? this.options.flexibleMaxHeight : Number.POSITIVE_INFINITY, this.mirror = Ne(o, qm("div.mirror")), this.mirror.innerText = "\xA0", this.scrollableElement = new yX(this.element, {
              vertical: 1
            }), this.options.flexibleWidth && (this.input.setAttribute("wrap", "off"), this.mirror.style.whiteSpace = "pre", this.mirror.style.wordWrap = "initial"), Ne(e, this.scrollableElement.getDomNode()), this._register(this.scrollableElement), this._register(this.scrollableElement.onScroll((l) => this.input.scrollTop = l.scrollTop));
            const r = this._register(new ot(e.ownerDocument, "selectionchange")), a = be.filter(r.event, () => {
              var _a3;
              return ((_a3 = e.ownerDocument.getSelection()) == null ? void 0 : _a3.anchorNode) === o;
            });
            this._register(a(this.updateScrollDimensions, this)), this._register(this.onDidHeightChange(this.updateScrollDimensions, this));
          } else this.input.type = this.options.type || "text", this.input.setAttribute("wrap", "off");
          this.ariaLabel && this.input.setAttribute("aria-label", this.ariaLabel), this.placeholder && !this.options.showPlaceholderOnFocus && this.setPlaceHolder(this.placeholder), this.tooltip && this.setTooltip(this.tooltip), this.oninput(this.input, () => this.onValueChange()), this.onblur(this.input, () => this.onBlur()), this.onfocus(this.input, () => this.onFocus()), this._register(this.ignoreGesture(this.input)), setTimeout(() => this.updateMirror(), 0), this.options.actions && (this.actionbar = this._register(new Wl(this.element)), this.actionbar.push(this.options.actions, {
            icon: true,
            label: false
          })), this.applyStyles();
        }
        onBlur() {
          this._hideMessage(), this.options.showPlaceholderOnFocus && this.input.setAttribute("placeholder", "");
        }
        onFocus() {
          this._showMessage(), this.options.showPlaceholderOnFocus && this.input.setAttribute("placeholder", this.placeholder || "");
        }
        setPlaceHolder(e) {
          this.placeholder = e, this.input.setAttribute("placeholder", e);
        }
        setTooltip(e) {
          this.tooltip = e, this.hover ? this.hover.update(e) : this.hover = this._register(Ba().setupManagedHover($o("mouse"), this.input, e));
        }
        get inputElement() {
          return this.input;
        }
        get value() {
          return this.input.value;
        }
        set value(e) {
          this.input.value !== e && (this.input.value = e, this.onValueChange());
        }
        get height() {
          return typeof this.cachedHeight == "number" ? this.cachedHeight : qk(this.element);
        }
        focus() {
          this.input.focus();
        }
        blur() {
          this.input.blur();
        }
        hasFocus() {
          return aT(this.input);
        }
        select(e = null) {
          this.input.select(), e && (this.input.setSelectionRange(e.start, e.end), e.end === this.input.value.length && (this.input.scrollLeft = this.input.scrollWidth));
        }
        isSelectionAtEnd() {
          return this.input.selectionEnd === this.input.value.length && this.input.selectionStart === this.input.selectionEnd;
        }
        getSelection() {
          const e = this.input.selectionStart;
          if (e === null) return null;
          const t = this.input.selectionEnd ?? e;
          return {
            start: e,
            end: t
          };
        }
        enable() {
          this.input.removeAttribute("disabled");
        }
        disable() {
          this.blur(), this.input.disabled = true, this._hideMessage();
        }
        set paddingRight(e) {
          this.input.style.width = `calc(100% - ${e}px)`, this.mirror && (this.mirror.style.paddingRight = e + "px");
        }
        updateScrollDimensions() {
          if (typeof this.cachedContentHeight != "number" || typeof this.cachedHeight != "number" || !this.scrollableElement) return;
          const e = this.cachedContentHeight, t = this.cachedHeight, i = this.input.scrollTop;
          this.scrollableElement.setScrollDimensions({
            scrollHeight: e,
            height: t
          }), this.scrollableElement.setScrollPosition({
            scrollTop: i
          });
        }
        showMessage(e, t) {
          if (this.state === "open" && $s(this.message, e)) return;
          this.message = e, this.element.classList.remove("idle"), this.element.classList.remove("info"), this.element.classList.remove("warning"), this.element.classList.remove("error"), this.element.classList.add(this.classForType(e.type));
          const i = this.stylesForType(this.message.type);
          this.element.style.border = `1px solid ${Pl(i.border, "transparent")}`, this.message.content && (this.hasFocus() || t) && this._showMessage();
        }
        hideMessage() {
          this.message = null, this.element.classList.remove("info"), this.element.classList.remove("warning"), this.element.classList.remove("error"), this.element.classList.add("idle"), this._hideMessage(), this.applyStyles();
        }
        validate() {
          let e = null;
          return this.validation && (e = this.validation(this.value), e ? (this.inputElement.setAttribute("aria-invalid", "true"), this.showMessage(e)) : this.inputElement.hasAttribute("aria-invalid") && (this.inputElement.removeAttribute("aria-invalid"), this.hideMessage())), e == null ? void 0 : e.type;
        }
        stylesForType(e) {
          const t = this.options.inputBoxStyles;
          switch (e) {
            case 1:
              return {
                border: t.inputValidationInfoBorder,
                background: t.inputValidationInfoBackground,
                foreground: t.inputValidationInfoForeground
              };
            case 2:
              return {
                border: t.inputValidationWarningBorder,
                background: t.inputValidationWarningBackground,
                foreground: t.inputValidationWarningForeground
              };
            default:
              return {
                border: t.inputValidationErrorBorder,
                background: t.inputValidationErrorBackground,
                foreground: t.inputValidationErrorForeground
              };
          }
        }
        classForType(e) {
          switch (e) {
            case 1:
              return "info";
            case 2:
              return "warning";
            default:
              return "error";
          }
        }
        _showMessage() {
          if (!this.contextViewProvider || !this.message) return;
          let e;
          const t = () => e.style.width = rT(this.element) + "px";
          this.contextViewProvider.showContextView({
            getAnchor: () => this.element,
            anchorAlignment: 1,
            render: (n) => {
              if (!this.message) return null;
              e = Ne(n, qm(".monaco-inputbox-container")), t();
              const o = {
                inline: true,
                className: "monaco-inputbox-message"
              }, r = this.message.formatContent ? NX(this.message.content, o) : TX(this.message.content, o);
              r.classList.add(this.classForType(this.message.type));
              const a = this.stylesForType(this.message.type);
              return r.style.backgroundColor = a.background ?? "", r.style.color = a.foreground ?? "", r.style.border = a.border ? `1px solid ${a.border}` : "", Ne(e, r), null;
            },
            onHide: () => {
              this.state = "closed";
            },
            layout: t
          });
          let i;
          this.message.type === 3 ? i = C("alertErrorMessage", "Error: {0}", this.message.content) : this.message.type === 2 ? i = C("alertWarningMessage", "Warning: {0}", this.message.content) : i = C("alertInfoMessage", "Info: {0}", this.message.content), l_(i), this.state = "open";
        }
        _hideMessage() {
          this.contextViewProvider && (this.state === "open" && this.contextViewProvider.hideContextView(), this.state = "idle");
        }
        onValueChange() {
          this._onDidChange.fire(this.value), this.validate(), this.updateMirror(), this.input.classList.toggle("empty", !this.value), this.state === "open" && this.contextViewProvider && this.contextViewProvider.layout();
        }
        updateMirror() {
          if (!this.mirror) return;
          const e = this.value, i = e.charCodeAt(e.length - 1) === 10 ? " " : "";
          (e + i).replace(/\u000c/g, "") ? this.mirror.textContent = e + i : this.mirror.innerText = "\xA0", this.layout();
        }
        applyStyles() {
          const e = this.options.inputBoxStyles, t = e.inputBackground ?? "", i = e.inputForeground ?? "", n = e.inputBorder ?? "";
          this.element.style.backgroundColor = t, this.element.style.color = i, this.input.style.backgroundColor = "inherit", this.input.style.color = i, this.element.style.border = `1px solid ${Pl(n, "transparent")}`;
        }
        layout() {
          if (!this.mirror) return;
          const e = this.cachedContentHeight;
          this.cachedContentHeight = qk(this.mirror), e !== this.cachedContentHeight && (this.cachedHeight = Math.min(this.cachedContentHeight, this.maxHeight), this.input.style.height = this.cachedHeight + "px", this._onDidHeightChange.fire(this.cachedContentHeight));
        }
        insertAtCursor(e) {
          const t = this.inputElement, i = t.selectionStart, n = t.selectionEnd, o = t.value;
          i !== null && n !== null && (this.value = o.substr(0, i) + e + o.substr(n), t.setSelectionRange(i + 1, i + 1), this.layout());
        }
        dispose() {
          var _a3;
          this._hideMessage(), this.message = null, (_a3 = this.actionbar) == null ? void 0 : _a3.dispose(), super.dispose();
        }
      }
      class jse extends Kse {
        constructor(e, t, i) {
          const n = C({
            key: "history.inputbox.hint.suffix.noparens",
            comment: [
              'Text is the suffix of an input field placeholder coming after the action the input field performs, this will be used when the input field ends in a closing parenthesis ")", for example "Filter (e.g. text, !exclude)". The character inserted into the final string is \u21C5 to represent the up and down arrow keys.'
            ]
          }, " or {0} for history", "\u21C5"), o = C({
            key: "history.inputbox.hint.suffix.inparens",
            comment: [
              'Text is the suffix of an input field placeholder coming after the action the input field performs, this will be used when the input field does NOT end in a closing parenthesis (eg. "Find"). The character inserted into the final string is \u21C5 to represent the up and down arrow keys.'
            ]
          }, " ({0} for history)", "\u21C5");
          super(e, t, i), this._onDidFocus = this._register(new G()), this.onDidFocus = this._onDidFocus.event, this._onDidBlur = this._register(new G()), this.onDidBlur = this._onDidBlur.event, this.history = new qse(i.history, 100);
          const r = () => {
            if (i.showHistoryHint && i.showHistoryHint() && !this.placeholder.endsWith(n) && !this.placeholder.endsWith(o) && this.history.getHistory().length) {
              const a = this.placeholder.endsWith(")") ? n : o, l = this.placeholder + a;
              i.showPlaceholderOnFocus && !aT(this.input) ? this.placeholder = l : this.setPlaceHolder(l);
            }
          };
          this.observer = new MutationObserver((a, l) => {
            a.forEach((u) => {
              u.target.textContent || r();
            });
          }), this.observer.observe(this.input, {
            attributeFilter: [
              "class"
            ]
          }), this.onfocus(this.input, () => r()), this.onblur(this.input, () => {
            const a = (l) => {
              if (this.placeholder.endsWith(l)) {
                const u = this.placeholder.slice(0, this.placeholder.length - l.length);
                return i.showPlaceholderOnFocus ? this.placeholder = u : this.setPlaceHolder(u), true;
              } else return false;
            };
            a(o) || a(n);
          });
        }
        dispose() {
          super.dispose(), this.observer && (this.observer.disconnect(), this.observer = void 0);
        }
        addToHistory(e) {
          this.value && (e || this.value !== this.getCurrentValue()) && this.history.add(this.value);
        }
        isAtLastInHistory() {
          return this.history.isLast();
        }
        isNowhereInHistory() {
          return this.history.isNowhere();
        }
        showNextValue() {
          this.history.has(this.value) || this.addToHistory();
          let e = this.getNextValue();
          e && (e = e === this.value ? this.getNextValue() : e), this.value = e ?? "", Ev(this.value ? this.value : C("clearedInput", "Cleared Input"));
        }
        showPreviousValue() {
          this.history.has(this.value) || this.addToHistory();
          let e = this.getPreviousValue();
          e && (e = e === this.value ? this.getPreviousValue() : e), e && (this.value = e, Ev(this.value));
        }
        setPlaceHolder(e) {
          super.setPlaceHolder(e), this.setTooltip(e);
        }
        onBlur() {
          super.onBlur(), this._onDidBlur.fire();
        }
        onFocus() {
          super.onFocus(), this._onDidFocus.fire();
        }
        getCurrentValue() {
          let e = this.history.current();
          return e || (e = this.history.last(), this.history.next()), e;
        }
        getPreviousValue() {
          return this.history.previous() || this.history.first();
        }
        getNextValue() {
          return this.history.next();
        }
      }
      const Gse = C("defaultLabel", "input");
      class Yse extends Yl {
        constructor(e, t, i) {
          super(), this.fixFocusOnOptionClickEnabled = true, this.imeSessionInProgress = false, this.additionalTogglesDisposables = this._register(new Ul()), this.additionalToggles = [], this._onDidOptionChange = this._register(new G()), this.onDidOptionChange = this._onDidOptionChange.event, this._onKeyDown = this._register(new G()), this.onKeyDown = this._onKeyDown.event, this._onMouseDown = this._register(new G()), this.onMouseDown = this._onMouseDown.event, this._onInput = this._register(new G()), this._onKeyUp = this._register(new G()), this._onCaseSensitiveKeyDown = this._register(new G()), this.onCaseSensitiveKeyDown = this._onCaseSensitiveKeyDown.event, this._onRegexKeyDown = this._register(new G()), this.onRegexKeyDown = this._onRegexKeyDown.event, this._lastHighlightFindOptions = 0, this.placeholder = i.placeholder || "", this.validation = i.validation, this.label = i.label || Gse, this.showCommonFindToggles = !!i.showCommonFindToggles;
          const n = i.appendCaseSensitiveLabel || "", o = i.appendWholeWordsLabel || "", r = i.appendRegexLabel || "", a = i.history || [], l = !!i.flexibleHeight, u = !!i.flexibleWidth, d = i.flexibleMaxHeight;
          this.domNode = document.createElement("div"), this.domNode.classList.add("monaco-findInput"), this.inputBox = this._register(new jse(this.domNode, t, {
            placeholder: this.placeholder || "",
            ariaLabel: this.label || "",
            validationOptions: {
              validation: this.validation
            },
            history: a,
            showHistoryHint: i.showHistoryHint,
            flexibleHeight: l,
            flexibleWidth: u,
            flexibleMaxHeight: d,
            inputBoxStyles: i.inputBoxStyles
          }));
          const f = this._register(iN());
          if (this.showCommonFindToggles) {
            this.regex = this._register(new Use({
              appendTitle: r,
              isChecked: false,
              hoverDelegate: f,
              ...i.toggleStyles
            })), this._register(this.regex.onChange((_) => {
              this._onDidOptionChange.fire(_), !_ && this.fixFocusOnOptionClickEnabled && this.inputBox.focus(), this.validate();
            })), this._register(this.regex.onKeyDown((_) => {
              this._onRegexKeyDown.fire(_);
            })), this.wholeWords = this._register(new zse({
              appendTitle: o,
              isChecked: false,
              hoverDelegate: f,
              ...i.toggleStyles
            })), this._register(this.wholeWords.onChange((_) => {
              this._onDidOptionChange.fire(_), !_ && this.fixFocusOnOptionClickEnabled && this.inputBox.focus(), this.validate();
            })), this.caseSensitive = this._register(new Hse({
              appendTitle: n,
              isChecked: false,
              hoverDelegate: f,
              ...i.toggleStyles
            })), this._register(this.caseSensitive.onChange((_) => {
              this._onDidOptionChange.fire(_), !_ && this.fixFocusOnOptionClickEnabled && this.inputBox.focus(), this.validate();
            })), this._register(this.caseSensitive.onKeyDown((_) => {
              this._onCaseSensitiveKeyDown.fire(_);
            }));
            const m = [
              this.caseSensitive.domNode,
              this.wholeWords.domNode,
              this.regex.domNode
            ];
            this.onkeydown(this.domNode, (_) => {
              if (_.equals(15) || _.equals(17) || _.equals(9)) {
                const b = m.indexOf(this.domNode.ownerDocument.activeElement);
                if (b >= 0) {
                  let v = -1;
                  _.equals(17) ? v = (b + 1) % m.length : _.equals(15) && (b === 0 ? v = m.length - 1 : v = b - 1), _.equals(9) ? (m[b].blur(), this.inputBox.focus()) : v >= 0 && m[v].focus(), dt.stop(_, true);
                }
              }
            });
          }
          this.controls = document.createElement("div"), this.controls.className = "controls", this.controls.style.display = this.showCommonFindToggles ? "" : "none", this.caseSensitive && this.controls.append(this.caseSensitive.domNode), this.wholeWords && this.controls.appendChild(this.wholeWords.domNode), this.regex && this.controls.appendChild(this.regex.domNode), this.setAdditionalToggles(i == null ? void 0 : i.additionalToggles), this.controls && this.domNode.appendChild(this.controls), e == null ? void 0 : e.appendChild(this.domNode), this._register(re(this.inputBox.inputElement, "compositionstart", (m) => {
            this.imeSessionInProgress = true;
          })), this._register(re(this.inputBox.inputElement, "compositionend", (m) => {
            this.imeSessionInProgress = false, this._onInput.fire();
          })), this.onkeydown(this.inputBox.inputElement, (m) => this._onKeyDown.fire(m)), this.onkeyup(this.inputBox.inputElement, (m) => this._onKeyUp.fire(m)), this.oninput(this.inputBox.inputElement, (m) => this._onInput.fire()), this.onmousedown(this.inputBox.inputElement, (m) => this._onMouseDown.fire(m));
        }
        get onDidChange() {
          return this.inputBox.onDidChange;
        }
        layout(e) {
          this.inputBox.layout(), this.updateInputBoxPadding(e.collapsedFindWidget);
        }
        enable() {
          var _a3, _b3, _c2;
          this.domNode.classList.remove("disabled"), this.inputBox.enable(), (_a3 = this.regex) == null ? void 0 : _a3.enable(), (_b3 = this.wholeWords) == null ? void 0 : _b3.enable(), (_c2 = this.caseSensitive) == null ? void 0 : _c2.enable();
          for (const e of this.additionalToggles) e.enable();
        }
        disable() {
          var _a3, _b3, _c2;
          this.domNode.classList.add("disabled"), this.inputBox.disable(), (_a3 = this.regex) == null ? void 0 : _a3.disable(), (_b3 = this.wholeWords) == null ? void 0 : _b3.disable(), (_c2 = this.caseSensitive) == null ? void 0 : _c2.disable();
          for (const e of this.additionalToggles) e.disable();
        }
        setFocusInputOnOptionClick(e) {
          this.fixFocusOnOptionClickEnabled = e;
        }
        setEnabled(e) {
          e ? this.enable() : this.disable();
        }
        setAdditionalToggles(e) {
          for (const t of this.additionalToggles) t.domNode.remove();
          this.additionalToggles = [], this.additionalTogglesDisposables.value = new Me();
          for (const t of e ?? []) this.additionalTogglesDisposables.value.add(t), this.controls.appendChild(t.domNode), this.additionalTogglesDisposables.value.add(t.onChange((i) => {
            this._onDidOptionChange.fire(i), !i && this.fixFocusOnOptionClickEnabled && this.inputBox.focus();
          })), this.additionalToggles.push(t);
          this.additionalToggles.length > 0 && (this.controls.style.display = ""), this.updateInputBoxPadding();
        }
        updateInputBoxPadding(e = false) {
          var _a3, _b3, _c2;
          e ? this.inputBox.paddingRight = 0 : this.inputBox.paddingRight = (((_a3 = this.caseSensitive) == null ? void 0 : _a3.width()) ?? 0) + (((_b3 = this.wholeWords) == null ? void 0 : _b3.width()) ?? 0) + (((_c2 = this.regex) == null ? void 0 : _c2.width()) ?? 0) + this.additionalToggles.reduce((t, i) => t + i.width(), 0);
        }
        getValue() {
          return this.inputBox.value;
        }
        setValue(e) {
          this.inputBox.value !== e && (this.inputBox.value = e);
        }
        select() {
          this.inputBox.select();
        }
        focus() {
          this.inputBox.focus();
        }
        getCaseSensitive() {
          var _a3;
          return ((_a3 = this.caseSensitive) == null ? void 0 : _a3.checked) ?? false;
        }
        setCaseSensitive(e) {
          this.caseSensitive && (this.caseSensitive.checked = e);
        }
        getWholeWords() {
          var _a3;
          return ((_a3 = this.wholeWords) == null ? void 0 : _a3.checked) ?? false;
        }
        setWholeWords(e) {
          this.wholeWords && (this.wholeWords.checked = e);
        }
        getRegex() {
          var _a3;
          return ((_a3 = this.regex) == null ? void 0 : _a3.checked) ?? false;
        }
        setRegex(e) {
          this.regex && (this.regex.checked = e, this.validate());
        }
        focusOnCaseSensitive() {
          var _a3;
          (_a3 = this.caseSensitive) == null ? void 0 : _a3.focus();
        }
        highlightFindOptions() {
          this.domNode.classList.remove("highlight-" + this._lastHighlightFindOptions), this._lastHighlightFindOptions = 1 - this._lastHighlightFindOptions, this.domNode.classList.add("highlight-" + this._lastHighlightFindOptions);
        }
        validate() {
          this.inputBox.validate();
        }
        showMessage(e) {
          this.inputBox.showMessage(e);
        }
        clearMessage() {
          this.inputBox.hideMessage();
        }
      }
      const Zse = He;
      class Qse extends he {
        constructor(e, t, i) {
          super(), this.parent = e, this.onKeyDown = (o) => ln(this.findInput.inputBox.inputElement, Ce.KEY_DOWN, o), this.onDidChange = (o) => this.findInput.onDidChange(o), this.container = Ne(this.parent, Zse(".quick-input-box")), this.findInput = this._register(new Yse(this.container, void 0, {
            label: "",
            inputBoxStyles: t,
            toggleStyles: i
          }));
          const n = this.findInput.inputBox.inputElement;
          n.role = "combobox", n.ariaHasPopup = "menu", n.ariaAutoComplete = "list", n.ariaExpanded = "true";
        }
        get value() {
          return this.findInput.getValue();
        }
        set value(e) {
          this.findInput.setValue(e);
        }
        select(e = null) {
          this.findInput.inputBox.select(e);
        }
        getSelection() {
          return this.findInput.inputBox.getSelection();
        }
        isSelectionAtEnd() {
          return this.findInput.inputBox.isSelectionAtEnd();
        }
        get placeholder() {
          return this.findInput.inputBox.inputElement.getAttribute("placeholder") || "";
        }
        set placeholder(e) {
          this.findInput.inputBox.setPlaceHolder(e);
        }
        get password() {
          return this.findInput.inputBox.inputElement.type === "password";
        }
        set password(e) {
          this.findInput.inputBox.inputElement.type = e ? "password" : "text";
        }
        set enabled(e) {
          this.findInput.inputBox.inputElement.toggleAttribute("readonly", !e);
        }
        set toggles(e) {
          this.findInput.setAdditionalToggles(e);
        }
        setAttribute(e, t) {
          this.findInput.inputBox.inputElement.setAttribute(e, t);
        }
        showDecoration(e) {
          e === Ui.Ignore ? this.findInput.clearMessage() : this.findInput.showMessage({
            type: e === Ui.Info ? 1 : e === Ui.Warning ? 2 : 3,
            content: ""
          });
        }
        stylesForType(e) {
          return this.findInput.inputBox.stylesForType(e === Ui.Info ? 1 : e === Ui.Warning ? 2 : 3);
        }
        setFocus() {
          this.findInput.focus();
        }
        layout() {
          this.findInput.inputBox.layout();
        }
      }
      class Xse {
        get templateId() {
          return this.renderer.templateId;
        }
        constructor(e, t) {
          this.renderer = e, this.modelProvider = t;
        }
        renderTemplate(e) {
          return {
            data: this.renderer.renderTemplate(e),
            disposable: he.None
          };
        }
        renderElement(e, t, i, n) {
          var _a3;
          if ((_a3 = i.disposable) == null ? void 0 : _a3.dispose(), !i.data) return;
          const o = this.modelProvider();
          if (o.isResolved(e)) return this.renderer.renderElement(o.get(e), e, i.data, n);
          const r = new Lg(), a = o.resolve(e, r.token);
          i.disposable = {
            dispose: () => r.cancel()
          }, this.renderer.renderPlaceholder(e, i.data), a.then((l) => this.renderer.renderElement(l, e, i.data, n));
        }
        disposeTemplate(e) {
          e.disposable && (e.disposable.dispose(), e.disposable = void 0), e.data && (this.renderer.disposeTemplate(e.data), e.data = void 0);
        }
      }
      class Jse {
        constructor(e, t) {
          this.modelProvider = e, this.accessibilityProvider = t;
        }
        getWidgetAriaLabel() {
          return this.accessibilityProvider.getWidgetAriaLabel();
        }
        getAriaLabel(e) {
          const t = this.modelProvider();
          return t.isResolved(e) ? this.accessibilityProvider.getAriaLabel(t.get(e)) : null;
        }
      }
      function eoe(s, e) {
        return {
          ...e,
          accessibilityProvider: e.accessibilityProvider && new Jse(s, e.accessibilityProvider)
        };
      }
      class toe {
        constructor(e, t, i, n, o = {}) {
          const r = () => this.model, a = n.map((l) => new Xse(l, r));
          this.list = new ta(e, t, i, a, eoe(r, o));
        }
        updateOptions(e) {
          this.list.updateOptions(e);
        }
        getHTMLElement() {
          return this.list.getHTMLElement();
        }
        get onDidFocus() {
          return this.list.onDidFocus;
        }
        get widget() {
          return this.list;
        }
        get onDidDispose() {
          return this.list.onDidDispose;
        }
        get onMouseDblClick() {
          return be.map(this.list.onMouseDblClick, ({ element: e, index: t, browserEvent: i }) => ({
            element: e === void 0 ? void 0 : this._model.get(e),
            index: t,
            browserEvent: i
          }));
        }
        get onPointer() {
          return be.map(this.list.onPointer, ({ element: e, index: t, browserEvent: i }) => ({
            element: e === void 0 ? void 0 : this._model.get(e),
            index: t,
            browserEvent: i
          }));
        }
        get onDidChangeSelection() {
          return be.map(this.list.onDidChangeSelection, ({ elements: e, indexes: t, browserEvent: i }) => ({
            elements: e.map((n) => this._model.get(n)),
            indexes: t,
            browserEvent: i
          }));
        }
        get model() {
          return this._model;
        }
        set model(e) {
          this._model = e, this.list.splice(0, this.list.length, Ls(e.length));
        }
        getFocus() {
          return this.list.getFocus();
        }
        getSelection() {
          return this.list.getSelection();
        }
        getSelectedElements() {
          return this.getSelection().map((e) => this.model.get(e));
        }
        style(e) {
          this.list.style(e);
        }
        dispose() {
          this.list.dispose();
        }
      }
      var Ig = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      };
      const ioe = false;
      var YP;
      (function(s) {
        s.North = "north", s.South = "south", s.East = "east", s.West = "west";
      })(YP || (YP = {}));
      let noe = 4;
      const soe = new G();
      let ooe = 300;
      const roe = new G();
      class vN {
        constructor(e) {
          this.el = e, this.disposables = new Me();
        }
        get onPointerMove() {
          return this.disposables.add(new ot(Oe(this.el), "mousemove")).event;
        }
        get onPointerUp() {
          return this.disposables.add(new ot(Oe(this.el), "mouseup")).event;
        }
        dispose() {
          this.disposables.dispose();
        }
      }
      Ig([
        Li
      ], vN.prototype, "onPointerMove", null);
      Ig([
        Li
      ], vN.prototype, "onPointerUp", null);
      class CN {
        get onPointerMove() {
          return this.disposables.add(new ot(this.el, Qt.Change)).event;
        }
        get onPointerUp() {
          return this.disposables.add(new ot(this.el, Qt.End)).event;
        }
        constructor(e) {
          this.el = e, this.disposables = new Me();
        }
        dispose() {
          this.disposables.dispose();
        }
      }
      Ig([
        Li
      ], CN.prototype, "onPointerMove", null);
      Ig([
        Li
      ], CN.prototype, "onPointerUp", null);
      class Gv {
        get onPointerMove() {
          return this.factory.onPointerMove;
        }
        get onPointerUp() {
          return this.factory.onPointerUp;
        }
        constructor(e) {
          this.factory = e;
        }
        dispose() {
        }
      }
      Ig([
        Li
      ], Gv.prototype, "onPointerMove", null);
      Ig([
        Li
      ], Gv.prototype, "onPointerUp", null);
      const ZP = "pointer-events-disabled";
      class To extends he {
        get state() {
          return this._state;
        }
        get orthogonalStartSash() {
          return this._orthogonalStartSash;
        }
        get orthogonalEndSash() {
          return this._orthogonalEndSash;
        }
        set state(e) {
          this._state !== e && (this.el.classList.toggle("disabled", e === 0), this.el.classList.toggle("minimum", e === 1), this.el.classList.toggle("maximum", e === 2), this._state = e, this.onDidEnablementChange.fire(e));
        }
        set orthogonalStartSash(e) {
          if (this._orthogonalStartSash !== e) {
            if (this.orthogonalStartDragHandleDisposables.clear(), this.orthogonalStartSashDisposables.clear(), e) {
              const t = (i) => {
                this.orthogonalStartDragHandleDisposables.clear(), i !== 0 && (this._orthogonalStartDragHandle = Ne(this.el, He(".orthogonal-drag-handle.start")), this.orthogonalStartDragHandleDisposables.add(Ze(() => this._orthogonalStartDragHandle.remove())), this.orthogonalStartDragHandleDisposables.add(new ot(this._orthogonalStartDragHandle, "mouseenter")).event(() => To.onMouseEnter(e), void 0, this.orthogonalStartDragHandleDisposables), this.orthogonalStartDragHandleDisposables.add(new ot(this._orthogonalStartDragHandle, "mouseleave")).event(() => To.onMouseLeave(e), void 0, this.orthogonalStartDragHandleDisposables));
              };
              this.orthogonalStartSashDisposables.add(e.onDidEnablementChange.event(t, this)), t(e.state);
            }
            this._orthogonalStartSash = e;
          }
        }
        set orthogonalEndSash(e) {
          if (this._orthogonalEndSash !== e) {
            if (this.orthogonalEndDragHandleDisposables.clear(), this.orthogonalEndSashDisposables.clear(), e) {
              const t = (i) => {
                this.orthogonalEndDragHandleDisposables.clear(), i !== 0 && (this._orthogonalEndDragHandle = Ne(this.el, He(".orthogonal-drag-handle.end")), this.orthogonalEndDragHandleDisposables.add(Ze(() => this._orthogonalEndDragHandle.remove())), this.orthogonalEndDragHandleDisposables.add(new ot(this._orthogonalEndDragHandle, "mouseenter")).event(() => To.onMouseEnter(e), void 0, this.orthogonalEndDragHandleDisposables), this.orthogonalEndDragHandleDisposables.add(new ot(this._orthogonalEndDragHandle, "mouseleave")).event(() => To.onMouseLeave(e), void 0, this.orthogonalEndDragHandleDisposables));
              };
              this.orthogonalEndSashDisposables.add(e.onDidEnablementChange.event(t, this)), t(e.state);
            }
            this._orthogonalEndSash = e;
          }
        }
        constructor(e, t, i) {
          super(), this.hoverDelay = ooe, this.hoverDelayer = this._register(new W_(this.hoverDelay)), this._state = 3, this.onDidEnablementChange = this._register(new G()), this._onDidStart = this._register(new G()), this._onDidChange = this._register(new G()), this._onDidReset = this._register(new G()), this._onDidEnd = this._register(new G()), this.orthogonalStartSashDisposables = this._register(new Me()), this.orthogonalStartDragHandleDisposables = this._register(new Me()), this.orthogonalEndSashDisposables = this._register(new Me()), this.orthogonalEndDragHandleDisposables = this._register(new Me()), this.onDidStart = this._onDidStart.event, this.onDidChange = this._onDidChange.event, this.onDidReset = this._onDidReset.event, this.onDidEnd = this._onDidEnd.event, this.linkedSash = void 0, this.el = Ne(e, He(".monaco-sash")), i.orthogonalEdge && this.el.classList.add(`orthogonal-edge-${i.orthogonalEdge}`), _t && this.el.classList.add("mac");
          const n = this._register(new ot(this.el, "mousedown")).event;
          this._register(n((f) => this.onPointerStart(f, new vN(e)), this));
          const o = this._register(new ot(this.el, "dblclick")).event;
          this._register(o(this.onPointerDoublePress, this));
          const r = this._register(new ot(this.el, "mouseenter")).event;
          this._register(r(() => To.onMouseEnter(this)));
          const a = this._register(new ot(this.el, "mouseleave")).event;
          this._register(a(() => To.onMouseLeave(this))), this._register(ui.addTarget(this.el));
          const l = this._register(new ot(this.el, Qt.Start)).event;
          this._register(l((f) => this.onPointerStart(f, new CN(this.el)), this));
          const u = this._register(new ot(this.el, Qt.Tap)).event;
          let d;
          this._register(u((f) => {
            if (d) {
              clearTimeout(d), d = void 0, this.onPointerDoublePress(f);
              return;
            }
            clearTimeout(d), d = setTimeout(() => d = void 0, 250);
          }, this)), typeof i.size == "number" ? (this.size = i.size, i.orientation === 0 ? this.el.style.width = `${this.size}px` : this.el.style.height = `${this.size}px`) : (this.size = noe, this._register(soe.event((f) => {
            this.size = f, this.layout();
          }))), this._register(roe.event((f) => this.hoverDelay = f)), this.layoutProvider = t, this.orthogonalStartSash = i.orthogonalStartSash, this.orthogonalEndSash = i.orthogonalEndSash, this.orientation = i.orientation || 0, this.orientation === 1 ? (this.el.classList.add("horizontal"), this.el.classList.remove("vertical")) : (this.el.classList.remove("horizontal"), this.el.classList.add("vertical")), this.el.classList.toggle("debug", ioe), this.layout();
        }
        onPointerStart(e, t) {
          dt.stop(e);
          let i = false;
          if (!e.__orthogonalSashEvent) {
            const b = this.getOrthogonalSash(e);
            b && (i = true, e.__orthogonalSashEvent = true, b.onPointerStart(e, new Gv(t)));
          }
          if (this.linkedSash && !e.__linkedSashEvent && (e.__linkedSashEvent = true, this.linkedSash.onPointerStart(e, new Gv(t))), !this.state) return;
          const n = this.el.ownerDocument.getElementsByTagName("iframe");
          for (const b of n) b.classList.add(ZP);
          const o = e.pageX, r = e.pageY, a = e.altKey, l = {
            startX: o,
            currentX: o,
            startY: r,
            currentY: r,
            altKey: a
          };
          this.el.classList.add("active"), this._onDidStart.fire(l);
          const u = Uo(this.el), d = () => {
            let b = "";
            i ? b = "all-scroll" : this.orientation === 1 ? this.state === 1 ? b = "s-resize" : this.state === 2 ? b = "n-resize" : b = _t ? "row-resize" : "ns-resize" : this.state === 1 ? b = "e-resize" : this.state === 2 ? b = "w-resize" : b = _t ? "col-resize" : "ew-resize", u.textContent = `* { cursor: ${b} !important; }`;
          }, f = new Me();
          d(), i || this.onDidEnablementChange.event(d, null, f);
          const m = (b) => {
            dt.stop(b, false);
            const v = {
              startX: o,
              currentX: b.pageX,
              startY: r,
              currentY: b.pageY,
              altKey: a
            };
            this._onDidChange.fire(v);
          }, _ = (b) => {
            dt.stop(b, false), u.remove(), this.el.classList.remove("active"), this._onDidEnd.fire(), f.dispose();
            for (const v of n) v.classList.remove(ZP);
          };
          t.onPointerMove(m, null, f), t.onPointerUp(_, null, f), f.add(t);
        }
        onPointerDoublePress(e) {
          const t = this.getOrthogonalSash(e);
          t && t._onDidReset.fire(), this.linkedSash && this.linkedSash._onDidReset.fire(), this._onDidReset.fire();
        }
        static onMouseEnter(e, t = false) {
          e.el.classList.contains("active") ? (e.hoverDelayer.cancel(), e.el.classList.add("hover")) : e.hoverDelayer.trigger(() => e.el.classList.add("hover"), e.hoverDelay).then(void 0, () => {
          }), !t && e.linkedSash && To.onMouseEnter(e.linkedSash, true);
        }
        static onMouseLeave(e, t = false) {
          e.hoverDelayer.cancel(), e.el.classList.remove("hover"), !t && e.linkedSash && To.onMouseLeave(e.linkedSash, true);
        }
        clearSashHoverState() {
          To.onMouseLeave(this);
        }
        layout() {
          if (this.orientation === 0) {
            const e = this.layoutProvider;
            this.el.style.left = e.getVerticalSashLeft(this) - this.size / 2 + "px", e.getVerticalSashTop && (this.el.style.top = e.getVerticalSashTop(this) + "px"), e.getVerticalSashHeight && (this.el.style.height = e.getVerticalSashHeight(this) + "px");
          } else {
            const e = this.layoutProvider;
            this.el.style.top = e.getHorizontalSashTop(this) - this.size / 2 + "px", e.getHorizontalSashLeft && (this.el.style.left = e.getHorizontalSashLeft(this) + "px"), e.getHorizontalSashWidth && (this.el.style.width = e.getHorizontalSashWidth(this) + "px");
          }
        }
        getOrthogonalSash(e) {
          const t = e.initialTarget ?? e.target;
          if (!(!t || !wn(t)) && t.classList.contains("orthogonal-drag-handle")) return t.classList.contains("start") ? this.orthogonalStartSash : this.orthogonalEndSash;
        }
        dispose() {
          super.dispose(), this.el.remove();
        }
      }
      const aoe = {
        separatorBorder: le.transparent
      };
      class HB {
        set size(e) {
          this._size = e;
        }
        get size() {
          return this._size;
        }
        get visible() {
          return typeof this._cachedVisibleSize > "u";
        }
        setVisible(e, t) {
          var _a3, _b3;
          if (e !== this.visible) {
            e ? (this.size = xs(this._cachedVisibleSize, this.viewMinimumSize, this.viewMaximumSize), this._cachedVisibleSize = void 0) : (this._cachedVisibleSize = typeof t == "number" ? t : this.size, this.size = 0), this.container.classList.toggle("visible", e);
            try {
              (_b3 = (_a3 = this.view).setVisible) == null ? void 0 : _b3.call(_a3, e);
            } catch (i) {
              console.error("Splitview: Failed to set visible view"), console.error(i);
            }
          }
        }
        get minimumSize() {
          return this.visible ? this.view.minimumSize : 0;
        }
        get viewMinimumSize() {
          return this.view.minimumSize;
        }
        get maximumSize() {
          return this.visible ? this.view.maximumSize : 0;
        }
        get viewMaximumSize() {
          return this.view.maximumSize;
        }
        get priority() {
          return this.view.priority;
        }
        get proportionalLayout() {
          return this.view.proportionalLayout ?? true;
        }
        get snap() {
          return !!this.view.snap;
        }
        set enabled(e) {
          this.container.style.pointerEvents = e ? "" : "none";
        }
        constructor(e, t, i, n) {
          this.container = e, this.view = t, this.disposable = n, this._cachedVisibleSize = void 0, typeof i == "number" ? (this._size = i, this._cachedVisibleSize = void 0, e.classList.add("visible")) : (this._size = 0, this._cachedVisibleSize = i.cachedVisibleSize);
        }
        layout(e, t) {
          this.layoutContainer(e);
          try {
            this.view.layout(this.size, e, t);
          } catch (i) {
            console.error("Splitview: Failed to layout view"), console.error(i);
          }
        }
        dispose() {
          this.disposable.dispose();
        }
      }
      class loe extends HB {
        layoutContainer(e) {
          this.container.style.top = `${e}px`, this.container.style.height = `${this.size}px`;
        }
      }
      class coe extends HB {
        layoutContainer(e) {
          this.container.style.left = `${e}px`, this.container.style.width = `${this.size}px`;
        }
      }
      var vl;
      (function(s) {
        s[s.Idle = 0] = "Idle", s[s.Busy = 1] = "Busy";
      })(vl || (vl = {}));
      var QP;
      (function(s) {
        s.Distribute = {
          type: "distribute"
        };
        function e(n) {
          return {
            type: "split",
            index: n
          };
        }
        s.Split = e;
        function t(n) {
          return {
            type: "auto",
            index: n
          };
        }
        s.Auto = t;
        function i(n) {
          return {
            type: "invisible",
            cachedVisibleSize: n
          };
        }
        s.Invisible = i;
      })(QP || (QP = {}));
      class uoe extends he {
        get orthogonalStartSash() {
          return this._orthogonalStartSash;
        }
        get orthogonalEndSash() {
          return this._orthogonalEndSash;
        }
        get startSnappingEnabled() {
          return this._startSnappingEnabled;
        }
        get endSnappingEnabled() {
          return this._endSnappingEnabled;
        }
        set orthogonalStartSash(e) {
          for (const t of this.sashItems) t.sash.orthogonalStartSash = e;
          this._orthogonalStartSash = e;
        }
        set orthogonalEndSash(e) {
          for (const t of this.sashItems) t.sash.orthogonalEndSash = e;
          this._orthogonalEndSash = e;
        }
        set startSnappingEnabled(e) {
          this._startSnappingEnabled !== e && (this._startSnappingEnabled = e, this.updateSashEnablement());
        }
        set endSnappingEnabled(e) {
          this._endSnappingEnabled !== e && (this._endSnappingEnabled = e, this.updateSashEnablement());
        }
        constructor(e, t = {}) {
          super(), this.size = 0, this._contentSize = 0, this.proportions = void 0, this.viewItems = [], this.sashItems = [], this.state = vl.Idle, this._onDidSashChange = this._register(new G()), this._onDidSashReset = this._register(new G()), this._startSnappingEnabled = true, this._endSnappingEnabled = true, this.onDidSashChange = this._onDidSashChange.event, this.onDidSashReset = this._onDidSashReset.event, this.orientation = t.orientation ?? 0, this.inverseAltBehavior = t.inverseAltBehavior ?? false, this.proportionalLayout = t.proportionalLayout ?? true, this.getSashOrthogonalSize = t.getSashOrthogonalSize, this.el = document.createElement("div"), this.el.classList.add("monaco-split-view2"), this.el.classList.add(this.orientation === 0 ? "vertical" : "horizontal"), e.appendChild(this.el), this.sashContainer = Ne(this.el, He(".sash-container")), this.viewContainer = He(".split-view-container"), this.scrollable = this._register(new Dg({
            forceIntegerValues: true,
            smoothScrollDuration: 125,
            scheduleAtNextAnimationFrame: (n) => Gs(Oe(this.el), n)
          })), this.scrollableElement = this._register(new dw(this.viewContainer, {
            vertical: this.orientation === 0 ? t.scrollbarVisibility ?? 1 : 2,
            horizontal: this.orientation === 1 ? t.scrollbarVisibility ?? 1 : 2
          }, this.scrollable));
          const i = this._register(new ot(this.viewContainer, "scroll")).event;
          this._register(i((n) => {
            const o = this.scrollableElement.getScrollPosition(), r = Math.abs(this.viewContainer.scrollLeft - o.scrollLeft) <= 1 ? void 0 : this.viewContainer.scrollLeft, a = Math.abs(this.viewContainer.scrollTop - o.scrollTop) <= 1 ? void 0 : this.viewContainer.scrollTop;
            (r !== void 0 || a !== void 0) && this.scrollableElement.setScrollPosition({
              scrollLeft: r,
              scrollTop: a
            });
          })), this.onDidScroll = this.scrollableElement.onScroll, this._register(this.onDidScroll((n) => {
            n.scrollTopChanged && (this.viewContainer.scrollTop = n.scrollTop), n.scrollLeftChanged && (this.viewContainer.scrollLeft = n.scrollLeft);
          })), Ne(this.el, this.scrollableElement.getDomNode()), this.style(t.styles || aoe), t.descriptor && (this.size = t.descriptor.size, t.descriptor.views.forEach((n, o) => {
            const r = Po(n.visible) || n.visible ? n.size : {
              type: "invisible",
              cachedVisibleSize: n.size
            }, a = n.view;
            this.doAddView(a, r, o, true);
          }), this._contentSize = this.viewItems.reduce((n, o) => n + o.size, 0), this.saveProportions());
        }
        style(e) {
          e.separatorBorder.isTransparent() ? (this.el.classList.remove("separator-border"), this.el.style.removeProperty("--separator-border")) : (this.el.classList.add("separator-border"), this.el.style.setProperty("--separator-border", e.separatorBorder.toString()));
        }
        addView(e, t, i = this.viewItems.length, n) {
          this.doAddView(e, t, i, n);
        }
        layout(e, t) {
          const i = Math.max(this.size, this._contentSize);
          if (this.size = e, this.layoutContext = t, this.proportions) {
            let n = 0;
            for (let o = 0; o < this.viewItems.length; o++) {
              const r = this.viewItems[o], a = this.proportions[o];
              typeof a == "number" ? n += a : e -= r.size;
            }
            for (let o = 0; o < this.viewItems.length; o++) {
              const r = this.viewItems[o], a = this.proportions[o];
              typeof a == "number" && n > 0 && (r.size = xs(Math.round(a * e / n), r.minimumSize, r.maximumSize));
            }
          } else {
            const n = Ls(this.viewItems.length), o = n.filter((a) => this.viewItems[a].priority === 1), r = n.filter((a) => this.viewItems[a].priority === 2);
            this.resize(this.viewItems.length - 1, e - i, void 0, o, r);
          }
          this.distributeEmptySpace(), this.layoutViews();
        }
        saveProportions() {
          this.proportionalLayout && this._contentSize > 0 && (this.proportions = this.viewItems.map((e) => e.proportionalLayout && e.visible ? e.size / this._contentSize : void 0));
        }
        onSashStart({ sash: e, start: t, alt: i }) {
          for (const a of this.viewItems) a.enabled = false;
          const n = this.sashItems.findIndex((a) => a.sash === e), o = ka(re(this.el.ownerDocument.body, "keydown", (a) => r(this.sashDragState.current, a.altKey)), re(this.el.ownerDocument.body, "keyup", () => r(this.sashDragState.current, false))), r = (a, l) => {
            const u = this.viewItems.map((b) => b.size);
            let d = Number.NEGATIVE_INFINITY, f = Number.POSITIVE_INFINITY;
            if (this.inverseAltBehavior && (l = !l), l) if (n === this.sashItems.length - 1) {
              const v = this.viewItems[n];
              d = (v.minimumSize - v.size) / 2, f = (v.maximumSize - v.size) / 2;
            } else {
              const v = this.viewItems[n + 1];
              d = (v.size - v.maximumSize) / 2, f = (v.size - v.minimumSize) / 2;
            }
            let m, _;
            if (!l) {
              const b = Ls(n, -1), v = Ls(n + 1, this.viewItems.length), y = b.reduce((R, A) => R + (this.viewItems[A].minimumSize - u[A]), 0), x = b.reduce((R, A) => R + (this.viewItems[A].viewMaximumSize - u[A]), 0), L = v.length === 0 ? Number.POSITIVE_INFINITY : v.reduce((R, A) => R + (u[A] - this.viewItems[A].minimumSize), 0), D = v.length === 0 ? Number.NEGATIVE_INFINITY : v.reduce((R, A) => R + (u[A] - this.viewItems[A].viewMaximumSize), 0), k = Math.max(y, D), T = Math.min(L, x), M = this.findFirstSnapIndex(b), I = this.findFirstSnapIndex(v);
              if (typeof M == "number") {
                const R = this.viewItems[M], A = Math.floor(R.viewMinimumSize / 2);
                m = {
                  index: M,
                  limitDelta: R.visible ? k - A : k + A,
                  size: R.size
                };
              }
              if (typeof I == "number") {
                const R = this.viewItems[I], A = Math.floor(R.viewMinimumSize / 2);
                _ = {
                  index: I,
                  limitDelta: R.visible ? T + A : T - A,
                  size: R.size
                };
              }
            }
            this.sashDragState = {
              start: a,
              current: a,
              index: n,
              sizes: u,
              minDelta: d,
              maxDelta: f,
              alt: l,
              snapBefore: m,
              snapAfter: _,
              disposable: o
            };
          };
          r(t, i);
        }
        onSashChange({ current: e }) {
          const { index: t, start: i, sizes: n, alt: o, minDelta: r, maxDelta: a, snapBefore: l, snapAfter: u } = this.sashDragState;
          this.sashDragState.current = e;
          const d = e - i, f = this.resize(t, d, n, void 0, void 0, r, a, l, u);
          if (o) {
            const m = t === this.sashItems.length - 1, _ = this.viewItems.map((D) => D.size), b = m ? t : t + 1, v = this.viewItems[b], y = v.size - v.maximumSize, x = v.size - v.minimumSize, L = m ? t - 1 : t + 1;
            this.resize(L, -f, _, void 0, void 0, y, x);
          }
          this.distributeEmptySpace(), this.layoutViews();
        }
        onSashEnd(e) {
          this._onDidSashChange.fire(e), this.sashDragState.disposable.dispose(), this.saveProportions();
          for (const t of this.viewItems) t.enabled = true;
        }
        onViewChange(e, t) {
          const i = this.viewItems.indexOf(e);
          i < 0 || i >= this.viewItems.length || (t = typeof t == "number" ? t : e.size, t = xs(t, e.minimumSize, e.maximumSize), this.inverseAltBehavior && i > 0 ? (this.resize(i - 1, Math.floor((e.size - t) / 2)), this.distributeEmptySpace(), this.layoutViews()) : (e.size = t, this.relayout([
            i
          ], void 0)));
        }
        resizeView(e, t) {
          if (!(e < 0 || e >= this.viewItems.length)) {
            if (this.state !== vl.Idle) throw new Error("Cant modify splitview");
            this.state = vl.Busy;
            try {
              const i = Ls(this.viewItems.length).filter((a) => a !== e), n = [
                ...i.filter((a) => this.viewItems[a].priority === 1),
                e
              ], o = i.filter((a) => this.viewItems[a].priority === 2), r = this.viewItems[e];
              t = Math.round(t), t = xs(t, r.minimumSize, Math.min(r.maximumSize, this.size)), r.size = t, this.relayout(n, o);
            } finally {
              this.state = vl.Idle;
            }
          }
        }
        distributeViewSizes() {
          const e = [];
          let t = 0;
          for (const a of this.viewItems) a.maximumSize - a.minimumSize > 0 && (e.push(a), t += a.size);
          const i = Math.floor(t / e.length);
          for (const a of e) a.size = xs(i, a.minimumSize, a.maximumSize);
          const n = Ls(this.viewItems.length), o = n.filter((a) => this.viewItems[a].priority === 1), r = n.filter((a) => this.viewItems[a].priority === 2);
          this.relayout(o, r);
        }
        getViewSize(e) {
          return e < 0 || e >= this.viewItems.length ? -1 : this.viewItems[e].size;
        }
        doAddView(e, t, i = this.viewItems.length, n) {
          if (this.state !== vl.Idle) throw new Error("Cant modify splitview");
          this.state = vl.Busy;
          try {
            const o = He(".split-view-view");
            i === this.viewItems.length ? this.viewContainer.appendChild(o) : this.viewContainer.insertBefore(o, this.viewContainer.children.item(i));
            const r = e.onDidChange((m) => this.onViewChange(d, m)), a = Ze(() => o.remove()), l = ka(r, a);
            let u;
            typeof t == "number" ? u = t : (t.type === "auto" && (this.areViewsDistributed() ? t = {
              type: "distribute"
            } : t = {
              type: "split",
              index: t.index
            }), t.type === "split" ? u = this.getViewSize(t.index) / 2 : t.type === "invisible" ? u = {
              cachedVisibleSize: t.cachedVisibleSize
            } : u = e.minimumSize);
            const d = this.orientation === 0 ? new loe(o, e, u, l) : new coe(o, e, u, l);
            if (this.viewItems.splice(i, 0, d), this.viewItems.length > 1) {
              const m = {
                orthogonalStartSash: this.orthogonalStartSash,
                orthogonalEndSash: this.orthogonalEndSash
              }, _ = this.orientation === 0 ? new To(this.sashContainer, {
                getHorizontalSashTop: (R) => this.getSashPosition(R),
                getHorizontalSashWidth: this.getSashOrthogonalSize
              }, {
                ...m,
                orientation: 1
              }) : new To(this.sashContainer, {
                getVerticalSashLeft: (R) => this.getSashPosition(R),
                getVerticalSashHeight: this.getSashOrthogonalSize
              }, {
                ...m,
                orientation: 0
              }), b = this.orientation === 0 ? (R) => ({
                sash: _,
                start: R.startY,
                current: R.currentY,
                alt: R.altKey
              }) : (R) => ({
                sash: _,
                start: R.startX,
                current: R.currentX,
                alt: R.altKey
              }), y = be.map(_.onDidStart, b)(this.onSashStart, this), L = be.map(_.onDidChange, b)(this.onSashChange, this), k = be.map(_.onDidEnd, () => this.sashItems.findIndex((R) => R.sash === _))(this.onSashEnd, this), T = _.onDidReset(() => {
                const R = this.sashItems.findIndex((ee) => ee.sash === _), A = Ls(R, -1), Y = Ls(R + 1, this.viewItems.length), U = this.findFirstSnapIndex(A), j = this.findFirstSnapIndex(Y);
                typeof U == "number" && !this.viewItems[U].visible || typeof j == "number" && !this.viewItems[j].visible || this._onDidSashReset.fire(R);
              }), M = ka(y, L, k, T, _), I = {
                sash: _,
                disposable: M
              };
              this.sashItems.splice(i - 1, 0, I);
            }
            o.appendChild(e.element);
            let f;
            typeof t != "number" && t.type === "split" && (f = [
              t.index
            ]), n || this.relayout([
              i
            ], f), !n && typeof t != "number" && t.type === "distribute" && this.distributeViewSizes();
          } finally {
            this.state = vl.Idle;
          }
        }
        relayout(e, t) {
          const i = this.viewItems.reduce((n, o) => n + o.size, 0);
          this.resize(this.viewItems.length - 1, this.size - i, void 0, e, t), this.distributeEmptySpace(), this.layoutViews(), this.saveProportions();
        }
        resize(e, t, i = this.viewItems.map((d) => d.size), n, o, r = Number.NEGATIVE_INFINITY, a = Number.POSITIVE_INFINITY, l, u) {
          if (e < 0 || e >= this.viewItems.length) return 0;
          const d = Ls(e, -1), f = Ls(e + 1, this.viewItems.length);
          if (o) for (const I of o) cL(d, I), cL(f, I);
          if (n) for (const I of n) vb(d, I), vb(f, I);
          const m = d.map((I) => this.viewItems[I]), _ = d.map((I) => i[I]), b = f.map((I) => this.viewItems[I]), v = f.map((I) => i[I]), y = d.reduce((I, R) => I + (this.viewItems[R].minimumSize - i[R]), 0), x = d.reduce((I, R) => I + (this.viewItems[R].maximumSize - i[R]), 0), L = f.length === 0 ? Number.POSITIVE_INFINITY : f.reduce((I, R) => I + (i[R] - this.viewItems[R].minimumSize), 0), D = f.length === 0 ? Number.NEGATIVE_INFINITY : f.reduce((I, R) => I + (i[R] - this.viewItems[R].maximumSize), 0), k = Math.max(y, D, r), T = Math.min(L, x, a);
          let M = false;
          if (l) {
            const I = this.viewItems[l.index], R = t >= l.limitDelta;
            M = R !== I.visible, I.setVisible(R, l.size);
          }
          if (!M && u) {
            const I = this.viewItems[u.index], R = t < u.limitDelta;
            M = R !== I.visible, I.setVisible(R, u.size);
          }
          if (M) return this.resize(e, t, i, n, o, r, a);
          t = xs(t, k, T);
          for (let I = 0, R = t; I < m.length; I++) {
            const A = m[I], Y = xs(_[I] + R, A.minimumSize, A.maximumSize), U = Y - _[I];
            R -= U, A.size = Y;
          }
          for (let I = 0, R = t; I < b.length; I++) {
            const A = b[I], Y = xs(v[I] - R, A.minimumSize, A.maximumSize), U = Y - v[I];
            R += U, A.size = Y;
          }
          return t;
        }
        distributeEmptySpace(e) {
          const t = this.viewItems.reduce((a, l) => a + l.size, 0);
          let i = this.size - t;
          const n = Ls(this.viewItems.length - 1, -1), o = n.filter((a) => this.viewItems[a].priority === 1), r = n.filter((a) => this.viewItems[a].priority === 2);
          for (const a of r) cL(n, a);
          for (const a of o) vb(n, a);
          typeof e == "number" && vb(n, e);
          for (let a = 0; i !== 0 && a < n.length; a++) {
            const l = this.viewItems[n[a]], u = xs(l.size + i, l.minimumSize, l.maximumSize), d = u - l.size;
            i -= d, l.size = u;
          }
        }
        layoutViews() {
          this._contentSize = this.viewItems.reduce((t, i) => t + i.size, 0);
          let e = 0;
          for (const t of this.viewItems) t.layout(e, this.layoutContext), e += t.size;
          this.sashItems.forEach((t) => t.sash.layout()), this.updateSashEnablement(), this.updateScrollableElement();
        }
        updateScrollableElement() {
          this.orientation === 0 ? this.scrollableElement.setScrollDimensions({
            height: this.size,
            scrollHeight: this._contentSize
          }) : this.scrollableElement.setScrollDimensions({
            width: this.size,
            scrollWidth: this._contentSize
          });
        }
        updateSashEnablement() {
          let e = false;
          const t = this.viewItems.map((l) => e = l.size - l.minimumSize > 0 || e);
          e = false;
          const i = this.viewItems.map((l) => e = l.maximumSize - l.size > 0 || e), n = [
            ...this.viewItems
          ].reverse();
          e = false;
          const o = n.map((l) => e = l.size - l.minimumSize > 0 || e).reverse();
          e = false;
          const r = n.map((l) => e = l.maximumSize - l.size > 0 || e).reverse();
          let a = 0;
          for (let l = 0; l < this.sashItems.length; l++) {
            const { sash: u } = this.sashItems[l], d = this.viewItems[l];
            a += d.size;
            const f = !(t[l] && r[l + 1]), m = !(i[l] && o[l + 1]);
            if (f && m) {
              const _ = Ls(l, -1), b = Ls(l + 1, this.viewItems.length), v = this.findFirstSnapIndex(_), y = this.findFirstSnapIndex(b), x = typeof v == "number" && !this.viewItems[v].visible, L = typeof y == "number" && !this.viewItems[y].visible;
              x && o[l] && (a > 0 || this.startSnappingEnabled) ? u.state = 1 : L && t[l] && (a < this._contentSize || this.endSnappingEnabled) ? u.state = 2 : u.state = 0;
            } else f && !m ? u.state = 1 : !f && m ? u.state = 2 : u.state = 3;
          }
        }
        getSashPosition(e) {
          let t = 0;
          for (let i = 0; i < this.sashItems.length; i++) if (t += this.viewItems[i].size, this.sashItems[i].sash === e) return t;
          return 0;
        }
        findFirstSnapIndex(e) {
          for (const t of e) {
            const i = this.viewItems[t];
            if (i.visible && i.snap) return t;
          }
          for (const t of e) {
            const i = this.viewItems[t];
            if (i.visible && i.maximumSize - i.minimumSize > 0) return;
            if (!i.visible && i.snap) return t;
          }
        }
        areViewsDistributed() {
          let e, t;
          for (const i of this.viewItems) if (e = e === void 0 ? i.size : Math.min(e, i.size), t = t === void 0 ? i.size : Math.max(t, i.size), t - e > 2) return false;
          return true;
        }
        dispose() {
          var _a3;
          (_a3 = this.sashDragState) == null ? void 0 : _a3.disposable.dispose(), On(this.viewItems), this.viewItems = [], this.sashItems.forEach((e) => e.disposable.dispose()), this.sashItems = [], super.dispose();
        }
      }
      const _Tw = class _Tw {
        constructor(e, t, i) {
          this.columns = e, this.getColumnSize = i, this.templateId = _Tw.TemplateId, this.renderedTemplates = /* @__PURE__ */ new Set();
          const n = new Map(t.map((o) => [
            o.templateId,
            o
          ]));
          this.renderers = [];
          for (const o of e) {
            const r = n.get(o.templateId);
            if (!r) throw new Error(`Table cell renderer for template id ${o.templateId} not found.`);
            this.renderers.push(r);
          }
        }
        renderTemplate(e) {
          const t = Ne(e, He(".monaco-table-tr")), i = [], n = [];
          for (let r = 0; r < this.columns.length; r++) {
            const a = this.renderers[r], l = Ne(t, He(".monaco-table-td", {
              "data-col-index": r
            }));
            l.style.width = `${this.getColumnSize(r)}px`, i.push(l), n.push(a.renderTemplate(l));
          }
          const o = {
            container: e,
            cellContainers: i,
            cellTemplateData: n
          };
          return this.renderedTemplates.add(o), o;
        }
        renderElement(e, t, i, n) {
          for (let o = 0; o < this.columns.length; o++) {
            const a = this.columns[o].project(e);
            this.renderers[o].renderElement(a, t, i.cellTemplateData[o], n);
          }
        }
        disposeElement(e, t, i, n) {
          for (let o = 0; o < this.columns.length; o++) {
            const r = this.renderers[o];
            if (r.disposeElement) {
              const l = this.columns[o].project(e);
              r.disposeElement(l, t, i.cellTemplateData[o], n);
            }
          }
        }
        disposeTemplate(e) {
          for (let t = 0; t < this.columns.length; t++) this.renderers[t].disposeTemplate(e.cellTemplateData[t]);
          $r(e.container), this.renderedTemplates.delete(e);
        }
        layoutColumn(e, t) {
          for (const { cellContainers: i } of this.renderedTemplates) i[e].style.width = `${t}px`;
        }
      };
      _Tw.TemplateId = "row";
      let Tw = _Tw;
      function hoe(s) {
        return {
          getHeight(e) {
            return s.getHeight(e);
          },
          getTemplateId() {
            return Tw.TemplateId;
          }
        };
      }
      class doe extends he {
        get minimumSize() {
          return this.column.minimumWidth ?? 120;
        }
        get maximumSize() {
          return this.column.maximumWidth ?? Number.POSITIVE_INFINITY;
        }
        get onDidChange() {
          return this.column.onDidChangeWidthConstraints ?? be.None;
        }
        constructor(e, t) {
          super(), this.column = e, this.index = t, this._onDidLayout = new G(), this.onDidLayout = this._onDidLayout.event, this.element = He(".monaco-table-th", {
            "data-col-index": t
          }, e.label), e.tooltip && this._register(Ba().setupManagedHover($o("mouse"), this.element, e.tooltip));
        }
        layout(e) {
          this._onDidLayout.fire([
            this.index,
            e
          ]);
        }
      }
      const _wN = class _wN {
        get onDidChangeFocus() {
          return this.list.onDidChangeFocus;
        }
        get onDidChangeSelection() {
          return this.list.onDidChangeSelection;
        }
        get onDidScroll() {
          return this.list.onDidScroll;
        }
        get onMouseDblClick() {
          return this.list.onMouseDblClick;
        }
        get onPointer() {
          return this.list.onPointer;
        }
        get onDidFocus() {
          return this.list.onDidFocus;
        }
        get scrollTop() {
          return this.list.scrollTop;
        }
        set scrollTop(e) {
          this.list.scrollTop = e;
        }
        get scrollHeight() {
          return this.list.scrollHeight;
        }
        get renderHeight() {
          return this.list.renderHeight;
        }
        get onDidDispose() {
          return this.list.onDidDispose;
        }
        constructor(e, t, i, n, o, r) {
          this.virtualDelegate = i, this.columns = n, this.domId = `table_id_${++_wN.InstanceCount}`, this.disposables = new Me(), this.cachedWidth = 0, this.cachedHeight = 0, this.domNode = Ne(t, He(`.monaco-table.${this.domId}`));
          const a = n.map((d, f) => this.disposables.add(new doe(d, f))), l = {
            size: a.reduce((d, f) => d + f.column.weight, 0),
            views: a.map((d) => ({
              size: d.column.weight,
              view: d
            }))
          };
          this.splitview = this.disposables.add(new uoe(this.domNode, {
            orientation: 1,
            scrollbarVisibility: 2,
            getSashOrthogonalSize: () => this.cachedHeight,
            descriptor: l
          })), this.splitview.el.style.height = `${i.headerRowHeight}px`, this.splitview.el.style.lineHeight = `${i.headerRowHeight}px`;
          const u = new Tw(n, o, (d) => this.splitview.getViewSize(d));
          this.list = this.disposables.add(new ta(e, this.domNode, hoe(i), [
            u
          ], r)), be.any(...a.map((d) => d.onDidLayout))(([d, f]) => u.layoutColumn(d, f), null, this.disposables), this.splitview.onDidSashReset((d) => {
            const f = n.reduce((_, b) => _ + b.weight, 0), m = n[d].weight / f * this.cachedWidth;
            this.splitview.resizeView(d, m);
          }, null, this.disposables), this.styleElement = Uo(this.domNode), this.style(kte);
        }
        updateOptions(e) {
          this.list.updateOptions(e);
        }
        splice(e, t, i = []) {
          this.list.splice(e, t, i);
        }
        getHTMLElement() {
          return this.domNode;
        }
        style(e) {
          const t = [];
          t.push(`.monaco-table.${this.domId} > .monaco-split-view2 .monaco-sash.vertical::before {
			top: ${this.virtualDelegate.headerRowHeight + 1}px;
			height: calc(100% - ${this.virtualDelegate.headerRowHeight}px);
		}`), this.styleElement.textContent = t.join(`
`), this.list.style(e);
        }
        getSelectedElements() {
          return this.list.getSelectedElements();
        }
        getSelection() {
          return this.list.getSelection();
        }
        getFocus() {
          return this.list.getFocus();
        }
        dispose() {
          this.disposables.dispose();
        }
      };
      _wN.InstanceCount = 0;
      let wN = _wN;
      var so;
      (function(s) {
        s[s.Expanded = 0] = "Expanded", s[s.Collapsed = 1] = "Collapsed", s[s.PreserveOrExpanded = 2] = "PreserveOrExpanded", s[s.PreserveOrCollapsed = 3] = "PreserveOrCollapsed";
      })(so || (so = {}));
      var _h;
      (function(s) {
        s[s.Unknown = 0] = "Unknown", s[s.Twistie = 1] = "Twistie", s[s.Element = 2] = "Element", s[s.Filter = 3] = "Filter";
      })(_h || (_h = {}));
      class lo extends Error {
        constructor(e, t) {
          super(`TreeError [${e}] ${t}`);
        }
      }
      class yN {
        constructor(e) {
          this.fn = e, this._map = /* @__PURE__ */ new WeakMap();
        }
        map(e) {
          let t = this._map.get(e);
          return t || (t = this.fn(e), this._map.set(e, t)), t;
        }
      }
      function SN(s) {
        return typeof s == "object" && "visibility" in s && "data" in s;
      }
      function __(s) {
        switch (s) {
          case true:
            return 1;
          case false:
            return 0;
          default:
            return s;
        }
      }
      function ux(s) {
        return typeof s.collapsible == "boolean";
      }
      class foe {
        constructor(e, t, i, n = {}) {
          this.user = e, this.list = t, this.rootRef = [], this.eventBufferer = new B_(), this._onDidChangeCollapseState = new G(), this.onDidChangeCollapseState = this.eventBufferer.wrapEvent(this._onDidChangeCollapseState.event), this._onDidChangeRenderNodeCount = new G(), this.onDidChangeRenderNodeCount = this.eventBufferer.wrapEvent(this._onDidChangeRenderNodeCount.event), this._onDidSplice = new G(), this.onDidSplice = this._onDidSplice.event, this.refilterDelayer = new W_(M9), this.collapseByDefault = typeof n.collapseByDefault > "u" ? false : n.collapseByDefault, this.allowNonCollapsibleParents = n.allowNonCollapsibleParents ?? false, this.filter = n.filter, this.autoExpandSingleChildren = typeof n.autoExpandSingleChildren > "u" ? false : n.autoExpandSingleChildren, this.root = {
            parent: void 0,
            element: i,
            children: [],
            depth: 0,
            visibleChildrenCount: 0,
            visibleChildIndex: -1,
            collapsible: false,
            collapsed: false,
            renderNodeCount: 0,
            visibility: 1,
            visible: true,
            filterData: void 0
          };
        }
        splice(e, t, i = kt.empty(), n = {}) {
          if (e.length === 0) throw new lo(this.user, "Invalid tree location");
          n.diffIdentityProvider ? this.spliceSmart(n.diffIdentityProvider, e, t, i, n) : this.spliceSimple(e, t, i, n);
        }
        spliceSmart(e, t, i, n = kt.empty(), o, r = o.diffDepth ?? 0) {
          const { parentNode: a } = this.getParentNodeWithListIndex(t);
          if (!a.lastDiffIds) return this.spliceSimple(t, i, n, o);
          const l = [
            ...n
          ], u = t[t.length - 1], d = new Dl({
            getElements: () => a.lastDiffIds
          }, {
            getElements: () => [
              ...a.children.slice(0, u),
              ...l,
              ...a.children.slice(u + i)
            ].map((v) => e.getId(v.element).toString())
          }).ComputeDiff(false);
          if (d.quitEarly) return a.lastDiffIds = void 0, this.spliceSimple(t, i, l, o);
          const f = t.slice(0, -1), m = (v, y, x) => {
            if (r > 0) for (let L = 0; L < x; L++) v--, y--, this.spliceSmart(e, [
              ...f,
              v,
              0
            ], Number.MAX_SAFE_INTEGER, l[y].children, o, r - 1);
          };
          let _ = Math.min(a.children.length, u + i), b = l.length;
          for (const v of d.changes.sort((y, x) => x.originalStart - y.originalStart)) m(_, b, _ - (v.originalStart + v.originalLength)), _ = v.originalStart, b = v.modifiedStart - u, this.spliceSimple([
            ...f,
            _
          ], v.originalLength, kt.slice(l, b, b + v.modifiedLength), o);
          m(_, b, _);
        }
        spliceSimple(e, t, i = kt.empty(), { onDidCreateNode: n, onDidDeleteNode: o, diffIdentityProvider: r }) {
          const { parentNode: a, listIndex: l, revealed: u, visible: d } = this.getParentNodeWithListIndex(e), f = [], m = kt.map(i, (T) => this.createTreeNode(T, a, a.visible ? 1 : 0, u, f, n)), _ = e[e.length - 1];
          let b = 0;
          for (let T = _; T >= 0 && T < a.children.length; T--) {
            const M = a.children[T];
            if (M.visible) {
              b = M.visibleChildIndex;
              break;
            }
          }
          const v = [];
          let y = 0, x = 0;
          for (const T of m) v.push(T), x += T.renderNodeCount, T.visible && (T.visibleChildIndex = b + y++);
          const L = y4(a.children, _, t, v);
          r ? a.lastDiffIds ? y4(a.lastDiffIds, _, t, v.map((T) => r.getId(T.element).toString())) : a.lastDiffIds = a.children.map((T) => r.getId(T.element).toString()) : a.lastDiffIds = void 0;
          let D = 0;
          for (const T of L) T.visible && D++;
          if (D !== 0) for (let T = _ + v.length; T < a.children.length; T++) {
            const M = a.children[T];
            M.visible && (M.visibleChildIndex -= D);
          }
          if (a.visibleChildrenCount += y - D, u && d) {
            const T = L.reduce((M, I) => M + (I.visible ? I.renderNodeCount : 0), 0);
            this._updateAncestorsRenderNodeCount(a, x - T), this.list.splice(l, T, f);
          }
          if (L.length > 0 && o) {
            const T = (M) => {
              o(M), M.children.forEach(T);
            };
            L.forEach(T);
          }
          this._onDidSplice.fire({
            insertedNodes: v,
            deletedNodes: L
          });
          let k = a;
          for (; k; ) {
            if (k.visibility === 2) {
              this.refilterDelayer.trigger(() => this.refilter());
              break;
            }
            k = k.parent;
          }
        }
        rerender(e) {
          if (e.length === 0) throw new lo(this.user, "Invalid tree location");
          const { node: t, listIndex: i, revealed: n } = this.getTreeNodeWithListIndex(e);
          t.visible && n && this.list.splice(i, 1, [
            t
          ]);
        }
        has(e) {
          return this.hasTreeNode(e);
        }
        getListIndex(e) {
          const { listIndex: t, visible: i, revealed: n } = this.getTreeNodeWithListIndex(e);
          return i && n ? t : -1;
        }
        getListRenderCount(e) {
          return this.getTreeNode(e).renderNodeCount;
        }
        isCollapsible(e) {
          return this.getTreeNode(e).collapsible;
        }
        setCollapsible(e, t) {
          const i = this.getTreeNode(e);
          typeof t > "u" && (t = !i.collapsible);
          const n = {
            collapsible: t
          };
          return this.eventBufferer.bufferEvents(() => this._setCollapseState(e, n));
        }
        isCollapsed(e) {
          return this.getTreeNode(e).collapsed;
        }
        setCollapsed(e, t, i) {
          const n = this.getTreeNode(e);
          typeof t > "u" && (t = !n.collapsed);
          const o = {
            collapsed: t,
            recursive: i || false
          };
          return this.eventBufferer.bufferEvents(() => this._setCollapseState(e, o));
        }
        _setCollapseState(e, t) {
          const { node: i, listIndex: n, revealed: o } = this.getTreeNodeWithListIndex(e), r = this._setListNodeCollapseState(i, n, o, t);
          if (i !== this.root && this.autoExpandSingleChildren && r && !ux(t) && i.collapsible && !i.collapsed && !t.recursive) {
            let a = -1;
            for (let l = 0; l < i.children.length; l++) if (i.children[l].visible) if (a > -1) {
              a = -1;
              break;
            } else a = l;
            a > -1 && this._setCollapseState([
              ...e,
              a
            ], t);
          }
          return r;
        }
        _setListNodeCollapseState(e, t, i, n) {
          const o = this._setNodeCollapseState(e, n, false);
          if (!i || !e.visible || !o) return o;
          const r = e.renderNodeCount, a = this.updateNodeAfterCollapseChange(e), l = r - (t === -1 ? 0 : 1);
          return this.list.splice(t + 1, l, a.slice(1)), o;
        }
        _setNodeCollapseState(e, t, i) {
          let n;
          if (e === this.root ? n = false : (ux(t) ? (n = e.collapsible !== t.collapsible, e.collapsible = t.collapsible) : e.collapsible ? (n = e.collapsed !== t.collapsed, e.collapsed = t.collapsed) : n = false, n && this._onDidChangeCollapseState.fire({
            node: e,
            deep: i
          })), !ux(t) && t.recursive) for (const o of e.children) n = this._setNodeCollapseState(o, t, true) || n;
          return n;
        }
        expandTo(e) {
          this.eventBufferer.bufferEvents(() => {
            let t = this.getTreeNode(e);
            for (; t.parent; ) t = t.parent, e = e.slice(0, e.length - 1), t.collapsed && this._setCollapseState(e, {
              collapsed: false,
              recursive: false
            });
          });
        }
        refilter() {
          const e = this.root.renderNodeCount, t = this.updateNodeAfterFilterChange(this.root);
          this.list.splice(0, e, t), this.refilterDelayer.cancel();
        }
        createTreeNode(e, t, i, n, o, r) {
          const a = {
            parent: t,
            element: e.element,
            children: [],
            depth: t.depth + 1,
            visibleChildrenCount: 0,
            visibleChildIndex: -1,
            collapsible: typeof e.collapsible == "boolean" ? e.collapsible : typeof e.collapsed < "u",
            collapsed: typeof e.collapsed > "u" ? this.collapseByDefault : e.collapsed,
            renderNodeCount: 1,
            visibility: 1,
            visible: true,
            filterData: void 0
          }, l = this._filterNode(a, i);
          a.visibility = l, n && o.push(a);
          const u = e.children || kt.empty(), d = n && l !== 0 && !a.collapsed;
          let f = 0, m = 1;
          for (const _ of u) {
            const b = this.createTreeNode(_, a, l, d, o, r);
            a.children.push(b), m += b.renderNodeCount, b.visible && (b.visibleChildIndex = f++);
          }
          return this.allowNonCollapsibleParents || (a.collapsible = a.collapsible || a.children.length > 0), a.visibleChildrenCount = f, a.visible = l === 2 ? f > 0 : l === 1, a.visible ? a.collapsed || (a.renderNodeCount = m) : (a.renderNodeCount = 0, n && o.pop()), r == null ? void 0 : r(a), a;
        }
        updateNodeAfterCollapseChange(e) {
          const t = e.renderNodeCount, i = [];
          return this._updateNodeAfterCollapseChange(e, i), this._updateAncestorsRenderNodeCount(e.parent, i.length - t), i;
        }
        _updateNodeAfterCollapseChange(e, t) {
          if (e.visible === false) return 0;
          if (t.push(e), e.renderNodeCount = 1, !e.collapsed) for (const i of e.children) e.renderNodeCount += this._updateNodeAfterCollapseChange(i, t);
          return this._onDidChangeRenderNodeCount.fire(e), e.renderNodeCount;
        }
        updateNodeAfterFilterChange(e) {
          const t = e.renderNodeCount, i = [];
          return this._updateNodeAfterFilterChange(e, e.visible ? 1 : 0, i), this._updateAncestorsRenderNodeCount(e.parent, i.length - t), i;
        }
        _updateNodeAfterFilterChange(e, t, i, n = true) {
          let o;
          if (e !== this.root) {
            if (o = this._filterNode(e, t), o === 0) return e.visible = false, e.renderNodeCount = 0, false;
            n && i.push(e);
          }
          const r = i.length;
          e.renderNodeCount = e === this.root ? 0 : 1;
          let a = false;
          if (!e.collapsed || o !== 0) {
            let l = 0;
            for (const u of e.children) a = this._updateNodeAfterFilterChange(u, o, i, n && !e.collapsed) || a, u.visible && (u.visibleChildIndex = l++);
            e.visibleChildrenCount = l;
          } else e.visibleChildrenCount = 0;
          return e !== this.root && (e.visible = o === 2 ? a : o === 1, e.visibility = o), e.visible ? e.collapsed || (e.renderNodeCount += i.length - r) : (e.renderNodeCount = 0, n && i.pop()), this._onDidChangeRenderNodeCount.fire(e), e.visible;
        }
        _updateAncestorsRenderNodeCount(e, t) {
          if (t !== 0) for (; e; ) e.renderNodeCount += t, this._onDidChangeRenderNodeCount.fire(e), e = e.parent;
        }
        _filterNode(e, t) {
          const i = this.filter ? this.filter.filter(e.element, t) : 1;
          return typeof i == "boolean" ? (e.filterData = void 0, i ? 1 : 0) : SN(i) ? (e.filterData = i.data, __(i.visibility)) : (e.filterData = void 0, __(i));
        }
        hasTreeNode(e, t = this.root) {
          if (!e || e.length === 0) return true;
          const [i, ...n] = e;
          return i < 0 || i > t.children.length ? false : this.hasTreeNode(n, t.children[i]);
        }
        getTreeNode(e, t = this.root) {
          if (!e || e.length === 0) return t;
          const [i, ...n] = e;
          if (i < 0 || i > t.children.length) throw new lo(this.user, "Invalid tree location");
          return this.getTreeNode(n, t.children[i]);
        }
        getTreeNodeWithListIndex(e) {
          if (e.length === 0) return {
            node: this.root,
            listIndex: -1,
            revealed: true,
            visible: false
          };
          const { parentNode: t, listIndex: i, revealed: n, visible: o } = this.getParentNodeWithListIndex(e), r = e[e.length - 1];
          if (r < 0 || r > t.children.length) throw new lo(this.user, "Invalid tree location");
          const a = t.children[r];
          return {
            node: a,
            listIndex: i,
            revealed: n,
            visible: o && a.visible
          };
        }
        getParentNodeWithListIndex(e, t = this.root, i = 0, n = true, o = true) {
          const [r, ...a] = e;
          if (r < 0 || r > t.children.length) throw new lo(this.user, "Invalid tree location");
          for (let l = 0; l < r; l++) i += t.children[l].renderNodeCount;
          return n = n && !t.collapsed, o = o && t.visible, a.length === 0 ? {
            parentNode: t,
            listIndex: i,
            revealed: n,
            visible: o
          } : this.getParentNodeWithListIndex(a, t.children[r], i + 1, n, o);
        }
        getNode(e = []) {
          return this.getTreeNode(e);
        }
        getNodeLocation(e) {
          const t = [];
          let i = e;
          for (; i.parent; ) t.push(i.parent.children.indexOf(i)), i = i.parent;
          return t.reverse();
        }
        getParentNodeLocation(e) {
          if (e.length !== 0) return e.length === 1 ? [] : dU(e)[0];
        }
        getFirstElementChild(e) {
          const t = this.getTreeNode(e);
          if (t.children.length !== 0) return t.children[0].element;
        }
      }
      class goe extends e1 {
        constructor(e) {
          super(e.elements.map((t) => t.element)), this.data = e;
        }
      }
      function hx(s) {
        return s instanceof e1 ? new goe(s) : s;
      }
      class moe {
        constructor(e, t) {
          this.modelProvider = e, this.dnd = t, this.autoExpandDisposable = he.None, this.disposables = new Me();
        }
        getDragURI(e) {
          return this.dnd.getDragURI(e.element);
        }
        getDragLabel(e, t) {
          if (this.dnd.getDragLabel) return this.dnd.getDragLabel(e.map((i) => i.element), t);
        }
        onDragStart(e, t) {
          var _a3, _b3;
          (_b3 = (_a3 = this.dnd).onDragStart) == null ? void 0 : _b3.call(_a3, hx(e), t);
        }
        onDragOver(e, t, i, n, o, r = true) {
          const a = this.dnd.onDragOver(hx(e), t && t.element, i, n, o), l = this.autoExpandNode !== t;
          if (l && (this.autoExpandDisposable.dispose(), this.autoExpandNode = t), typeof t > "u") return a;
          if (l && typeof a != "boolean" && a.autoExpand && (this.autoExpandDisposable = Vk(() => {
            const _ = this.modelProvider(), b = _.getNodeLocation(t);
            _.isCollapsed(b) && _.setCollapsed(b, false), this.autoExpandNode = void 0;
          }, 500, this.disposables)), typeof a == "boolean" || !a.accept || typeof a.bubble > "u" || a.feedback) {
            if (!r) {
              const _ = typeof a == "boolean" ? a : a.accept, b = typeof a == "boolean" ? void 0 : a.effect;
              return {
                accept: _,
                effect: b,
                feedback: [
                  i
                ]
              };
            }
            return a;
          }
          if (a.bubble === 1) {
            const _ = this.modelProvider(), b = _.getNodeLocation(t), v = _.getParentNodeLocation(b), y = _.getNode(v), x = v && _.getListIndex(v);
            return this.onDragOver(e, y, x, n, o, false);
          }
          const u = this.modelProvider(), d = u.getNodeLocation(t), f = u.getListIndex(d), m = u.getListRenderCount(d);
          return {
            ...a,
            feedback: Ls(f, f + m)
          };
        }
        drop(e, t, i, n, o) {
          this.autoExpandDisposable.dispose(), this.autoExpandNode = void 0, this.dnd.drop(hx(e), t && t.element, i, n, o);
        }
        onDragEnd(e) {
          var _a3, _b3;
          (_b3 = (_a3 = this.dnd).onDragEnd) == null ? void 0 : _b3.call(_a3, e);
        }
        dispose() {
          this.disposables.dispose(), this.dnd.dispose();
        }
      }
      function poe(s, e) {
        return e && {
          ...e,
          identityProvider: e.identityProvider && {
            getId(t) {
              return e.identityProvider.getId(t.element);
            }
          },
          dnd: e.dnd && new moe(s, e.dnd),
          multipleSelectionController: e.multipleSelectionController && {
            isSelectionSingleChangeEvent(t) {
              return e.multipleSelectionController.isSelectionSingleChangeEvent({
                ...t,
                element: t.element
              });
            },
            isSelectionRangeChangeEvent(t) {
              return e.multipleSelectionController.isSelectionRangeChangeEvent({
                ...t,
                element: t.element
              });
            }
          },
          accessibilityProvider: e.accessibilityProvider && {
            ...e.accessibilityProvider,
            getSetSize(t) {
              const i = s(), n = i.getNodeLocation(t), o = i.getParentNodeLocation(n);
              return i.getNode(o).visibleChildrenCount;
            },
            getPosInSet(t) {
              return t.visibleChildIndex + 1;
            },
            isChecked: e.accessibilityProvider && e.accessibilityProvider.isChecked ? (t) => e.accessibilityProvider.isChecked(t.element) : void 0,
            getRole: e.accessibilityProvider && e.accessibilityProvider.getRole ? (t) => e.accessibilityProvider.getRole(t.element) : () => "treeitem",
            getAriaLabel(t) {
              return e.accessibilityProvider.getAriaLabel(t.element);
            },
            getWidgetAriaLabel() {
              return e.accessibilityProvider.getWidgetAriaLabel();
            },
            getWidgetRole: e.accessibilityProvider && e.accessibilityProvider.getWidgetRole ? () => e.accessibilityProvider.getWidgetRole() : () => "tree",
            getAriaLevel: e.accessibilityProvider && e.accessibilityProvider.getAriaLevel ? (t) => e.accessibilityProvider.getAriaLevel(t.element) : (t) => t.depth,
            getActiveDescendantId: e.accessibilityProvider.getActiveDescendantId && ((t) => e.accessibilityProvider.getActiveDescendantId(t.element))
          },
          keyboardNavigationLabelProvider: e.keyboardNavigationLabelProvider && {
            ...e.keyboardNavigationLabelProvider,
            getKeyboardNavigationLabel(t) {
              return e.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(t.element);
            }
          }
        };
      }
      class LN {
        constructor(e) {
          this.delegate = e;
        }
        getHeight(e) {
          return this.delegate.getHeight(e.element);
        }
        getTemplateId(e) {
          return this.delegate.getTemplateId(e.element);
        }
        hasDynamicHeight(e) {
          return !!this.delegate.hasDynamicHeight && this.delegate.hasDynamicHeight(e.element);
        }
        setDynamicHeight(e, t) {
          var _a3, _b3;
          (_b3 = (_a3 = this.delegate).setDynamicHeight) == null ? void 0 : _b3.call(_a3, e.element, t);
        }
      }
      var _g;
      (function(s) {
        s.None = "none", s.OnHover = "onHover", s.Always = "always";
      })(_g || (_g = {}));
      class _oe {
        get elements() {
          return this._elements;
        }
        constructor(e, t = []) {
          this._elements = t, this.disposables = new Me(), this.onDidChange = be.forEach(e, (i) => this._elements = i, this.disposables);
        }
        dispose() {
          this.disposables.dispose();
        }
      }
      const _Yv = class _Yv {
        constructor(e, t, i, n, o, r = {}) {
          var _a3;
          this.renderer = e, this.modelProvider = t, this.activeNodes = n, this.renderedIndentGuides = o, this.renderedElements = /* @__PURE__ */ new Map(), this.renderedNodes = /* @__PURE__ */ new Map(), this.indent = _Yv.DefaultIndent, this.hideTwistiesOfChildlessElements = false, this.shouldRenderIndentGuides = false, this.activeIndentNodes = /* @__PURE__ */ new Set(), this.indentGuidesDisposable = he.None, this.disposables = new Me(), this.templateId = e.templateId, this.updateOptions(r), be.map(i, (a) => a.node)(this.onDidChangeNodeTwistieState, this, this.disposables), (_a3 = e.onDidChangeTwistieState) == null ? void 0 : _a3.call(e, this.onDidChangeTwistieState, this, this.disposables);
        }
        updateOptions(e = {}) {
          if (typeof e.indent < "u") {
            const t = xs(e.indent, 0, 40);
            if (t !== this.indent) {
              this.indent = t;
              for (const [i, n] of this.renderedNodes) this.renderTreeElement(i, n);
            }
          }
          if (typeof e.renderIndentGuides < "u") {
            const t = e.renderIndentGuides !== _g.None;
            if (t !== this.shouldRenderIndentGuides) {
              this.shouldRenderIndentGuides = t;
              for (const [i, n] of this.renderedNodes) this._renderIndentGuides(i, n);
              if (this.indentGuidesDisposable.dispose(), t) {
                const i = new Me();
                this.activeNodes.onDidChange(this._onDidChangeActiveNodes, this, i), this.indentGuidesDisposable = i, this._onDidChangeActiveNodes(this.activeNodes.elements);
              }
            }
          }
          typeof e.hideTwistiesOfChildlessElements < "u" && (this.hideTwistiesOfChildlessElements = e.hideTwistiesOfChildlessElements);
        }
        renderTemplate(e) {
          const t = Ne(e, He(".monaco-tl-row")), i = Ne(t, He(".monaco-tl-indent")), n = Ne(t, He(".monaco-tl-twistie")), o = Ne(t, He(".monaco-tl-contents")), r = this.renderer.renderTemplate(o);
          return {
            container: e,
            indent: i,
            twistie: n,
            indentGuidesDisposable: he.None,
            templateData: r
          };
        }
        renderElement(e, t, i, n) {
          this.renderedNodes.set(e, i), this.renderedElements.set(e.element, e), this.renderTreeElement(e, i), this.renderer.renderElement(e, t, i.templateData, n);
        }
        disposeElement(e, t, i, n) {
          var _a3, _b3;
          i.indentGuidesDisposable.dispose(), (_b3 = (_a3 = this.renderer).disposeElement) == null ? void 0 : _b3.call(_a3, e, t, i.templateData, n), typeof n == "number" && (this.renderedNodes.delete(e), this.renderedElements.delete(e.element));
        }
        disposeTemplate(e) {
          this.renderer.disposeTemplate(e.templateData);
        }
        onDidChangeTwistieState(e) {
          const t = this.renderedElements.get(e);
          t && this.onDidChangeNodeTwistieState(t);
        }
        onDidChangeNodeTwistieState(e) {
          const t = this.renderedNodes.get(e);
          t && (this._onDidChangeActiveNodes(this.activeNodes.elements), this.renderTreeElement(e, t));
        }
        renderTreeElement(e, t) {
          const i = _Yv.DefaultIndent + (e.depth - 1) * this.indent;
          t.twistie.style.paddingLeft = `${i}px`, t.indent.style.width = `${i + this.indent - 16}px`, e.collapsible ? t.container.setAttribute("aria-expanded", String(!e.collapsed)) : t.container.removeAttribute("aria-expanded"), t.twistie.classList.remove(...wt.asClassNameArray(Te.treeItemExpanded));
          let n = false;
          this.renderer.renderTwistie && (n = this.renderer.renderTwistie(e.element, t.twistie)), e.collapsible && (!this.hideTwistiesOfChildlessElements || e.visibleChildrenCount > 0) ? (n || t.twistie.classList.add(...wt.asClassNameArray(Te.treeItemExpanded)), t.twistie.classList.add("collapsible"), t.twistie.classList.toggle("collapsed", e.collapsed)) : t.twistie.classList.remove("collapsible", "collapsed"), this._renderIndentGuides(e, t);
        }
        _renderIndentGuides(e, t) {
          if ($r(t.indent), t.indentGuidesDisposable.dispose(), !this.shouldRenderIndentGuides) return;
          const i = new Me(), n = this.modelProvider();
          for (; ; ) {
            const o = n.getNodeLocation(e), r = n.getParentNodeLocation(o);
            if (!r) break;
            const a = n.getNode(r), l = He(".indent-guide", {
              style: `width: ${this.indent}px`
            });
            this.activeIndentNodes.has(a) && l.classList.add("active"), t.indent.childElementCount === 0 ? t.indent.appendChild(l) : t.indent.insertBefore(l, t.indent.firstElementChild), this.renderedIndentGuides.add(a, l), i.add(Ze(() => this.renderedIndentGuides.delete(a, l))), e = a;
          }
          t.indentGuidesDisposable = i;
        }
        _onDidChangeActiveNodes(e) {
          if (!this.shouldRenderIndentGuides) return;
          const t = /* @__PURE__ */ new Set(), i = this.modelProvider();
          e.forEach((n) => {
            const o = i.getNodeLocation(n);
            try {
              const r = i.getParentNodeLocation(o);
              n.collapsible && n.children.length > 0 && !n.collapsed ? t.add(n) : r && t.add(i.getNode(r));
            } catch {
            }
          }), this.activeIndentNodes.forEach((n) => {
            t.has(n) || this.renderedIndentGuides.forEach(n, (o) => o.classList.remove("active"));
          }), t.forEach((n) => {
            this.activeIndentNodes.has(n) || this.renderedIndentGuides.forEach(n, (o) => o.classList.add("active"));
          }), this.activeIndentNodes = t;
        }
        dispose() {
          this.renderedNodes.clear(), this.renderedElements.clear(), this.indentGuidesDisposable.dispose(), On(this.disposables);
        }
      };
      _Yv.DefaultIndent = 8;
      let Yv = _Yv;
      class boe {
        get totalCount() {
          return this._totalCount;
        }
        get matchCount() {
          return this._matchCount;
        }
        constructor(e, t, i) {
          this.tree = e, this.keyboardNavigationLabelProvider = t, this._filter = i, this._totalCount = 0, this._matchCount = 0, this._pattern = "", this._lowercasePattern = "", this.disposables = new Me(), e.onWillRefilter(this.reset, this, this.disposables);
        }
        filter(e, t) {
          let i = 1;
          if (this._filter) {
            const r = this._filter.filter(e, t);
            if (typeof r == "boolean" ? i = r ? 1 : 0 : SN(r) ? i = __(r.visibility) : i = r, i === 0) return false;
          }
          if (this._totalCount++, !this._pattern) return this._matchCount++, {
            data: Ff.Default,
            visibility: i
          };
          const n = this.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(e), o = Array.isArray(n) ? n : [
            n
          ];
          for (const r of o) {
            const a = r && r.toString();
            if (typeof a > "u") return {
              data: Ff.Default,
              visibility: i
            };
            let l;
            if (this.tree.findMatchType === Vh.Contiguous) {
              const u = a.toLowerCase().indexOf(this._lowercasePattern);
              if (u > -1) {
                l = [
                  Number.MAX_SAFE_INTEGER,
                  0
                ];
                for (let d = this._lowercasePattern.length; d > 0; d--) l.push(u + d - 1);
              }
            } else l = N6(this._pattern, this._lowercasePattern, 0, a, a.toLowerCase(), 0, {
              firstMatchCanBeWeak: true,
              boostFullMatch: true
            });
            if (l) return this._matchCount++, o.length === 1 ? {
              data: l,
              visibility: i
            } : {
              data: {
                label: a,
                score: l
              },
              visibility: i
            };
          }
          return this.tree.findMode === Ml.Filter ? typeof this.tree.options.defaultFindVisibility == "number" ? this.tree.options.defaultFindVisibility : this.tree.options.defaultFindVisibility ? this.tree.options.defaultFindVisibility(e) : 2 : {
            data: Ff.Default,
            visibility: i
          };
        }
        reset() {
          this._totalCount = 0, this._matchCount = 0;
        }
        dispose() {
          On(this.disposables);
        }
      }
      var Ml;
      (function(s) {
        s[s.Highlight = 0] = "Highlight", s[s.Filter = 1] = "Filter";
      })(Ml || (Ml = {}));
      var Vh;
      (function(s) {
        s[s.Fuzzy = 0] = "Fuzzy", s[s.Contiguous = 1] = "Contiguous";
      })(Vh || (Vh = {}));
      class voe {
        get pattern() {
          return this._pattern;
        }
        get mode() {
          return this._mode;
        }
        set mode(e) {
          e !== this._mode && (this._mode = e, this.widget && (this.widget.mode = this._mode), this.tree.refilter(), this.render(), this._onDidChangeMode.fire(e));
        }
        get matchType() {
          return this._matchType;
        }
        set matchType(e) {
          e !== this._matchType && (this._matchType = e, this.widget && (this.widget.matchType = this._matchType), this.tree.refilter(), this.render(), this._onDidChangeMatchType.fire(e));
        }
        constructor(e, t, i, n, o, r = {}) {
          this.tree = e, this.view = i, this.filter = n, this.contextViewProvider = o, this.options = r, this._pattern = "", this.width = 0, this._onDidChangeMode = new G(), this.onDidChangeMode = this._onDidChangeMode.event, this._onDidChangeMatchType = new G(), this.onDidChangeMatchType = this._onDidChangeMatchType.event, this._onDidChangePattern = new G(), this._onDidChangeOpenState = new G(), this.onDidChangeOpenState = this._onDidChangeOpenState.event, this.enabledDisposables = new Me(), this.disposables = new Me(), this._mode = e.options.defaultFindMode ?? Ml.Highlight, this._matchType = e.options.defaultFindMatchType ?? Vh.Fuzzy, t.onDidSplice(this.onDidSpliceModel, this, this.disposables);
        }
        updateOptions(e = {}) {
          e.defaultFindMode !== void 0 && (this.mode = e.defaultFindMode), e.defaultFindMatchType !== void 0 && (this.matchType = e.defaultFindMatchType);
        }
        onDidSpliceModel() {
          !this.widget || this.pattern.length === 0 || (this.tree.refilter(), this.render());
        }
        render() {
          var _a3, _b3, _c2;
          const e = this.filter.totalCount > 0 && this.filter.matchCount === 0;
          this.pattern && e ? (l_(C("replFindNoResults", "No results")), this.tree.options.showNotFoundMessage ?? true ? (_a3 = this.widget) == null ? void 0 : _a3.showMessage({
            type: 2,
            content: C("not found", "No elements found.")
          }) : (_b3 = this.widget) == null ? void 0 : _b3.showMessage({
            type: 2
          })) : ((_c2 = this.widget) == null ? void 0 : _c2.clearMessage(), this.pattern && l_(C("replFindResults", "{0} results", this.filter.matchCount)));
        }
        shouldAllowFocus(e) {
          return !this.widget || !this.pattern || this.filter.totalCount > 0 && this.filter.matchCount <= 1 ? true : !Ff.isDefault(e.filterData);
        }
        layout(e) {
          var _a3;
          this.width = e, (_a3 = this.widget) == null ? void 0 : _a3.layout(e);
        }
        dispose() {
          this._history = void 0, this._onDidChangePattern.dispose(), this.enabledDisposables.dispose(), this.disposables.dispose();
        }
      }
      function Coe(s, e) {
        return s.position === e.position && zB(s, e);
      }
      function zB(s, e) {
        return s.node.element === e.node.element && s.startIndex === e.startIndex && s.height === e.height && s.endIndex === e.endIndex;
      }
      class woe {
        constructor(e = []) {
          this.stickyNodes = e;
        }
        get count() {
          return this.stickyNodes.length;
        }
        equal(e) {
          return Qi(this.stickyNodes, e.stickyNodes, Coe);
        }
        lastNodePartiallyVisible() {
          if (this.count === 0) return false;
          const e = this.stickyNodes[this.count - 1];
          if (this.count === 1) return e.position !== 0;
          const t = this.stickyNodes[this.count - 2];
          return t.position + t.height !== e.position;
        }
        animationStateChanged(e) {
          if (!Qi(this.stickyNodes, e.stickyNodes, zB) || this.count === 0) return false;
          const t = this.stickyNodes[this.count - 1], i = e.stickyNodes[e.count - 1];
          return t.position !== i.position;
        }
      }
      class yoe {
        constrainStickyScrollNodes(e, t, i) {
          for (let n = 0; n < e.length; n++) {
            const o = e[n];
            if (o.position + o.height > i || n >= t) return e.slice(0, n);
          }
          return e;
        }
      }
      class XP extends he {
        constructor(e, t, i, n, o, r = {}) {
          super(), this.tree = e, this.model = t, this.view = i, this.treeDelegate = o, this.maxWidgetViewRatio = 0.4;
          const a = this.validateStickySettings(r);
          this.stickyScrollMaxItemCount = a.stickyScrollMaxItemCount, this.stickyScrollDelegate = r.stickyScrollDelegate ?? new yoe(), this._widget = this._register(new Soe(i.getScrollableElement(), i, e, n, o, r.accessibilityProvider)), this.onDidChangeHasFocus = this._widget.onDidChangeHasFocus, this.onContextMenu = this._widget.onContextMenu, this._register(i.onDidScroll(() => this.update())), this._register(i.onDidChangeContentHeight(() => this.update())), this._register(e.onDidChangeCollapseState(() => this.update())), this.update();
        }
        get height() {
          return this._widget.height;
        }
        getNodeAtHeight(e) {
          let t;
          if (e === 0 ? t = this.view.firstVisibleIndex : t = this.view.indexAt(e + this.view.scrollTop), !(t < 0 || t >= this.view.length)) return this.view.element(t);
        }
        update() {
          const e = this.getNodeAtHeight(0);
          if (!e || this.tree.scrollTop === 0) {
            this._widget.setState(void 0);
            return;
          }
          const t = this.findStickyState(e);
          this._widget.setState(t);
        }
        findStickyState(e) {
          const t = [];
          let i = e, n = 0, o = this.getNextStickyNode(i, void 0, n);
          for (; o && (t.push(o), n += o.height, !(t.length <= this.stickyScrollMaxItemCount && (i = this.getNextVisibleNode(o), !i))); ) o = this.getNextStickyNode(i, o.node, n);
          const r = this.constrainStickyNodes(t);
          return r.length ? new woe(r) : void 0;
        }
        getNextVisibleNode(e) {
          return this.getNodeAtHeight(e.position + e.height);
        }
        getNextStickyNode(e, t, i) {
          const n = this.getAncestorUnderPrevious(e, t);
          if (n && !(n === e && (!this.nodeIsUncollapsedParent(e) || this.nodeTopAlignsWithStickyNodesBottom(e, i)))) return this.createStickyScrollNode(n, i);
        }
        nodeTopAlignsWithStickyNodesBottom(e, t) {
          const i = this.getNodeIndex(e), n = this.view.getElementTop(i), o = t;
          return this.view.scrollTop === n - o;
        }
        createStickyScrollNode(e, t) {
          const i = this.treeDelegate.getHeight(e), { startIndex: n, endIndex: o } = this.getNodeRange(e), r = this.calculateStickyNodePosition(o, t, i);
          return {
            node: e,
            position: r,
            height: i,
            startIndex: n,
            endIndex: o
          };
        }
        getAncestorUnderPrevious(e, t = void 0) {
          let i = e, n = this.getParentNode(i);
          for (; n; ) {
            if (n === t) return i;
            i = n, n = this.getParentNode(i);
          }
          if (t === void 0) return i;
        }
        calculateStickyNodePosition(e, t, i) {
          let n = this.view.getRelativeTop(e);
          if (n === null && this.view.firstVisibleIndex === e && e + 1 < this.view.length) {
            const u = this.treeDelegate.getHeight(this.view.element(e)), d = this.view.getRelativeTop(e + 1);
            n = d ? d - u / this.view.renderHeight : null;
          }
          if (n === null) return t;
          const o = this.view.element(e), r = this.treeDelegate.getHeight(o), l = n * this.view.renderHeight + r;
          return t + i > l && t <= l ? l - i : t;
        }
        constrainStickyNodes(e) {
          if (e.length === 0) return [];
          const t = this.view.renderHeight * this.maxWidgetViewRatio, i = e[e.length - 1];
          if (e.length <= this.stickyScrollMaxItemCount && i.position + i.height <= t) return e;
          const n = this.stickyScrollDelegate.constrainStickyScrollNodes(e, this.stickyScrollMaxItemCount, t);
          if (!n.length) return [];
          const o = n[n.length - 1];
          if (n.length > this.stickyScrollMaxItemCount || o.position + o.height > t) throw new Error("stickyScrollDelegate violates constraints");
          return n;
        }
        getParentNode(e) {
          const t = this.model.getNodeLocation(e), i = this.model.getParentNodeLocation(t);
          return i ? this.model.getNode(i) : void 0;
        }
        nodeIsUncollapsedParent(e) {
          const t = this.model.getNodeLocation(e);
          return this.model.getListRenderCount(t) > 1;
        }
        getNodeIndex(e) {
          const t = this.model.getNodeLocation(e);
          return this.model.getListIndex(t);
        }
        getNodeRange(e) {
          const t = this.model.getNodeLocation(e), i = this.model.getListIndex(t);
          if (i < 0) throw new Error("Node not found in tree");
          const n = this.model.getListRenderCount(t), o = i + n - 1;
          return {
            startIndex: i,
            endIndex: o
          };
        }
        nodePositionTopBelowWidget(e) {
          const t = [];
          let i = this.getParentNode(e);
          for (; i; ) t.push(i), i = this.getParentNode(i);
          let n = 0;
          for (let o = 0; o < t.length && o < this.stickyScrollMaxItemCount; o++) n += this.treeDelegate.getHeight(t[o]);
          return n;
        }
        domFocus() {
          this._widget.domFocus();
        }
        focusedLast() {
          return this._widget.focusedLast();
        }
        updateOptions(e = {}) {
          if (!e.stickyScrollMaxItemCount) return;
          const t = this.validateStickySettings(e);
          this.stickyScrollMaxItemCount !== t.stickyScrollMaxItemCount && (this.stickyScrollMaxItemCount = t.stickyScrollMaxItemCount, this.update());
        }
        validateStickySettings(e) {
          let t = 7;
          return typeof e.stickyScrollMaxItemCount == "number" && (t = Math.max(e.stickyScrollMaxItemCount, 1)), {
            stickyScrollMaxItemCount: t
          };
        }
      }
      class Soe {
        constructor(e, t, i, n, o, r) {
          this.view = t, this.tree = i, this.treeRenderers = n, this.treeDelegate = o, this.accessibilityProvider = r, this._previousElements = [], this._previousStateDisposables = new Me(), this._rootDomNode = He(".monaco-tree-sticky-container.empty"), e.appendChild(this._rootDomNode);
          const a = He(".monaco-tree-sticky-container-shadow");
          this._rootDomNode.appendChild(a), this.stickyScrollFocus = new Loe(this._rootDomNode, t), this.onDidChangeHasFocus = this.stickyScrollFocus.onDidChangeHasFocus, this.onContextMenu = this.stickyScrollFocus.onContextMenu;
        }
        get height() {
          if (!this._previousState) return 0;
          const e = this._previousState.stickyNodes[this._previousState.count - 1];
          return e.position + e.height;
        }
        setState(e) {
          const t = !!this._previousState && this._previousState.count > 0, i = !!e && e.count > 0;
          if (!t && !i || t && i && this._previousState.equal(e)) return;
          if (t !== i && this.setVisible(i), !i) {
            this._previousState = void 0, this._previousElements = [], this._previousStateDisposables.clear();
            return;
          }
          const n = e.stickyNodes[e.count - 1];
          if (this._previousState && e.animationStateChanged(this._previousState)) this._previousElements[this._previousState.count - 1].style.top = `${n.position}px`;
          else {
            this._previousStateDisposables.clear();
            const o = Array(e.count);
            for (let r = e.count - 1; r >= 0; r--) {
              const a = e.stickyNodes[r], { element: l, disposable: u } = this.createElement(a, r, e.count);
              o[r] = l, this._rootDomNode.appendChild(l), this._previousStateDisposables.add(u);
            }
            this.stickyScrollFocus.updateElements(o, e), this._previousElements = o;
          }
          this._previousState = e, this._rootDomNode.style.height = `${n.position + n.height}px`;
        }
        createElement(e, t, i) {
          const n = e.startIndex, o = document.createElement("div");
          o.style.top = `${e.position}px`, this.tree.options.setRowHeight !== false && (o.style.height = `${e.height}px`), this.tree.options.setRowLineHeight !== false && (o.style.lineHeight = `${e.height}px`), o.classList.add("monaco-tree-sticky-row"), o.classList.add("monaco-list-row"), o.setAttribute("data-index", `${n}`), o.setAttribute("data-parity", n % 2 === 0 ? "even" : "odd"), o.setAttribute("id", this.view.getElementID(n));
          const r = this.setAccessibilityAttributes(o, e.node.element, t, i), a = this.treeDelegate.getTemplateId(e.node), l = this.treeRenderers.find((m) => m.templateId === a);
          if (!l) throw new Error(`No renderer found for template id ${a}`);
          let u = e.node;
          u === this.tree.getNode(this.tree.getNodeLocation(e.node)) && (u = new Proxy(e.node, {}));
          const d = l.renderTemplate(o);
          l.renderElement(u, e.startIndex, d, e.height);
          const f = Ze(() => {
            r.dispose(), l.disposeElement(u, e.startIndex, d, e.height), l.disposeTemplate(d), o.remove();
          });
          return {
            element: o,
            disposable: f
          };
        }
        setAccessibilityAttributes(e, t, i, n) {
          if (!this.accessibilityProvider) return he.None;
          this.accessibilityProvider.getSetSize && e.setAttribute("aria-setsize", String(this.accessibilityProvider.getSetSize(t, i, n))), this.accessibilityProvider.getPosInSet && e.setAttribute("aria-posinset", String(this.accessibilityProvider.getPosInSet(t, i))), this.accessibilityProvider.getRole && e.setAttribute("role", this.accessibilityProvider.getRole(t) ?? "treeitem");
          const o = this.accessibilityProvider.getAriaLabel(t), r = o && typeof o != "string" ? o : Ov(o), a = Dt((u) => {
            const d = u.readObservable(r);
            d ? e.setAttribute("aria-label", d) : e.removeAttribute("aria-label");
          });
          typeof o == "string" || o && e.setAttribute("aria-label", o.get());
          const l = this.accessibilityProvider.getAriaLevel && this.accessibilityProvider.getAriaLevel(t);
          return typeof l == "number" && e.setAttribute("aria-level", `${l}`), e.setAttribute("aria-selected", String(false)), a;
        }
        setVisible(e) {
          this._rootDomNode.classList.toggle("empty", !e), e || this.stickyScrollFocus.updateElements([], void 0);
        }
        domFocus() {
          this.stickyScrollFocus.domFocus();
        }
        focusedLast() {
          return this.stickyScrollFocus.focusedLast();
        }
        dispose() {
          this.stickyScrollFocus.dispose(), this._previousStateDisposables.dispose(), this._rootDomNode.remove();
        }
      }
      class Loe extends he {
        get domHasFocus() {
          return this._domHasFocus;
        }
        set domHasFocus(e) {
          e !== this._domHasFocus && (this._onDidChangeHasFocus.fire(e), this._domHasFocus = e);
        }
        constructor(e, t) {
          super(), this.container = e, this.view = t, this.focusedIndex = -1, this.elements = [], this._onDidChangeHasFocus = new G(), this.onDidChangeHasFocus = this._onDidChangeHasFocus.event, this._onContextMenu = new G(), this.onContextMenu = this._onContextMenu.event, this._domHasFocus = false, this._register(re(this.container, "focus", () => this.onFocus())), this._register(re(this.container, "blur", () => this.onBlur())), this._register(this.view.onDidFocus(() => this.toggleStickyScrollFocused(false))), this._register(this.view.onKeyDown((i) => this.onKeyDown(i))), this._register(this.view.onMouseDown((i) => this.onMouseDown(i))), this._register(this.view.onContextMenu((i) => this.handleContextMenu(i)));
        }
        handleContextMenu(e) {
          const t = e.browserEvent.target;
          if (!u_(t) && !Lp(t)) {
            this.focusedLast() && this.view.domFocus();
            return;
          }
          if (!Cl(e.browserEvent)) {
            if (!this.state) throw new Error("Context menu should not be triggered when state is undefined");
            const r = this.state.stickyNodes.findIndex((a) => {
              var _a3;
              return a.node.element === ((_a3 = e.element) == null ? void 0 : _a3.element);
            });
            if (r === -1) throw new Error("Context menu should not be triggered when element is not in sticky scroll widget");
            this.container.focus(), this.setFocus(r);
            return;
          }
          if (!this.state || this.focusedIndex < 0) throw new Error("Context menu key should not be triggered when focus is not in sticky scroll widget");
          const n = this.state.stickyNodes[this.focusedIndex].node.element, o = this.elements[this.focusedIndex];
          this._onContextMenu.fire({
            element: n,
            anchor: o,
            browserEvent: e.browserEvent,
            isStickyScroll: true
          });
        }
        onKeyDown(e) {
          if (this.domHasFocus && this.state) {
            if (e.key === "ArrowUp") this.setFocusedElement(Math.max(0, this.focusedIndex - 1)), e.preventDefault(), e.stopPropagation();
            else if (e.key === "ArrowDown" || e.key === "ArrowRight") {
              if (this.focusedIndex >= this.state.count - 1) {
                const t = this.state.stickyNodes[this.state.count - 1].startIndex + 1;
                this.view.domFocus(), this.view.setFocus([
                  t
                ]), this.scrollNodeUnderWidget(t, this.state);
              } else this.setFocusedElement(this.focusedIndex + 1);
              e.preventDefault(), e.stopPropagation();
            }
          }
        }
        onMouseDown(e) {
          const t = e.browserEvent.target;
          !u_(t) && !Lp(t) || (e.browserEvent.preventDefault(), e.browserEvent.stopPropagation());
        }
        updateElements(e, t) {
          if (t && t.count === 0) throw new Error("Sticky scroll state must be undefined when there are no sticky nodes");
          if (t && t.count !== e.length) throw new Error("Sticky scroll focus received illigel state");
          const i = this.focusedIndex;
          if (this.removeFocus(), this.elements = e, this.state = t, t) {
            const n = xs(i, 0, t.count - 1);
            this.setFocus(n);
          } else this.domHasFocus && this.view.domFocus();
          this.container.tabIndex = t ? 0 : -1;
        }
        setFocusedElement(e) {
          const t = this.state;
          if (!t) throw new Error("Cannot set focus when state is undefined");
          if (this.setFocus(e), !(e < t.count - 1) && t.lastNodePartiallyVisible()) {
            const i = t.stickyNodes[e];
            this.scrollNodeUnderWidget(i.endIndex + 1, t);
          }
        }
        scrollNodeUnderWidget(e, t) {
          const i = t.stickyNodes[t.count - 1], n = t.count > 1 ? t.stickyNodes[t.count - 2] : void 0, o = this.view.getElementTop(e), r = n ? n.position + n.height + i.height : i.height;
          this.view.scrollTop = o - r;
        }
        domFocus() {
          if (!this.state) throw new Error("Cannot focus when state is undefined");
          this.container.focus();
        }
        focusedLast() {
          return this.state ? this.view.getHTMLElement().classList.contains("sticky-scroll-focused") : false;
        }
        removeFocus() {
          this.focusedIndex !== -1 && (this.toggleElementFocus(this.elements[this.focusedIndex], false), this.focusedIndex = -1);
        }
        setFocus(e) {
          if (0 > e) throw new Error("addFocus() can not remove focus");
          if (!this.state && e >= 0) throw new Error("Cannot set focus index when state is undefined");
          if (this.state && e >= this.state.count) throw new Error("Cannot set focus index to an index that does not exist");
          const t = this.focusedIndex;
          t >= 0 && this.toggleElementFocus(this.elements[t], false), e >= 0 && this.toggleElementFocus(this.elements[e], true), this.focusedIndex = e;
        }
        toggleElementFocus(e, t) {
          this.toggleElementActiveFocus(e, t && this.domHasFocus), this.toggleElementPassiveFocus(e, t);
        }
        toggleCurrentElementActiveFocus(e) {
          this.focusedIndex !== -1 && this.toggleElementActiveFocus(this.elements[this.focusedIndex], e);
        }
        toggleElementActiveFocus(e, t) {
          e.classList.toggle("focused", t);
        }
        toggleElementPassiveFocus(e, t) {
          e.classList.toggle("passive-focused", t);
        }
        toggleStickyScrollFocused(e) {
          this.view.getHTMLElement().classList.toggle("sticky-scroll-focused", e);
        }
        onFocus() {
          if (!this.state || this.elements.length === 0) throw new Error("Cannot focus when state is undefined or elements are empty");
          this.domHasFocus = true, this.toggleStickyScrollFocused(true), this.toggleCurrentElementActiveFocus(true), this.focusedIndex === -1 && this.setFocus(0);
        }
        onBlur() {
          this.domHasFocus = false, this.toggleCurrentElementActiveFocus(false);
        }
        dispose() {
          this.toggleStickyScrollFocused(false), this._onDidChangeHasFocus.fire(false), super.dispose();
        }
      }
      function Jb(s) {
        let e = _h.Unknown;
        return LL(s.browserEvent.target, "monaco-tl-twistie", "monaco-tl-row") ? e = _h.Twistie : LL(s.browserEvent.target, "monaco-tl-contents", "monaco-tl-row") ? e = _h.Element : LL(s.browserEvent.target, "monaco-tree-type-filter", "monaco-list") && (e = _h.Filter), {
          browserEvent: s.browserEvent,
          element: s.element ? s.element.element : null,
          target: e
        };
      }
      function xoe(s) {
        const e = u_(s.browserEvent.target);
        return {
          element: s.element ? s.element.element : null,
          browserEvent: s.browserEvent,
          anchor: s.anchor,
          isStickyScroll: e
        };
      }
      function M0(s, e) {
        e(s), s.children.forEach((t) => M0(t, e));
      }
      class dx {
        get nodeSet() {
          return this._nodeSet || (this._nodeSet = this.createNodeSet()), this._nodeSet;
        }
        constructor(e, t) {
          this.getFirstViewElementWithTrait = e, this.identityProvider = t, this.nodes = [], this._onDidChange = new G(), this.onDidChange = this._onDidChange.event;
        }
        set(e, t) {
          !(t == null ? void 0 : t.__forceEvent) && Qi(this.nodes, e) || this._set(e, false, t);
        }
        _set(e, t, i) {
          if (this.nodes = [
            ...e
          ], this.elements = void 0, this._nodeSet = void 0, !t) {
            const n = this;
            this._onDidChange.fire({
              get elements() {
                return n.get();
              },
              browserEvent: i
            });
          }
        }
        get() {
          return this.elements || (this.elements = this.nodes.map((e) => e.element)), [
            ...this.elements
          ];
        }
        getNodes() {
          return this.nodes;
        }
        has(e) {
          return this.nodeSet.has(e);
        }
        onDidModelSplice({ insertedNodes: e, deletedNodes: t }) {
          if (!this.identityProvider) {
            const l = this.createNodeSet(), u = (d) => l.delete(d);
            t.forEach((d) => M0(d, u)), this.set([
              ...l.values()
            ]);
            return;
          }
          const i = /* @__PURE__ */ new Set(), n = (l) => i.add(this.identityProvider.getId(l.element).toString());
          t.forEach((l) => M0(l, n));
          const o = /* @__PURE__ */ new Map(), r = (l) => o.set(this.identityProvider.getId(l.element).toString(), l);
          e.forEach((l) => M0(l, r));
          const a = [];
          for (const l of this.nodes) {
            const u = this.identityProvider.getId(l.element).toString();
            if (!i.has(u)) a.push(l);
            else {
              const f = o.get(u);
              f && f.visible && a.push(f);
            }
          }
          if (this.nodes.length > 0 && a.length === 0) {
            const l = this.getFirstViewElementWithTrait();
            l && a.push(l);
          }
          this._set(a, true);
        }
        createNodeSet() {
          const e = /* @__PURE__ */ new Set();
          for (const t of this.nodes) e.add(t);
          return e;
        }
      }
      class koe extends J6 {
        constructor(e, t, i) {
          super(e), this.tree = t, this.stickyScrollProvider = i;
        }
        onViewPointer(e) {
          if (Y6(e.browserEvent.target) || tu(e.browserEvent.target) || rp(e.browserEvent.target) || e.browserEvent.isHandledByList) return;
          const t = e.element;
          if (!t) return super.onViewPointer(e);
          if (this.isSelectionRangeChangeEvent(e) || this.isSelectionSingleChangeEvent(e)) return super.onViewPointer(e);
          const i = e.browserEvent.target, n = i.classList.contains("monaco-tl-twistie") || i.classList.contains("monaco-icon-label") && i.classList.contains("folder-icon") && e.browserEvent.offsetX < 16, o = Lp(e.browserEvent.target);
          let r = false;
          if (o ? r = true : typeof this.tree.expandOnlyOnTwistieClick == "function" ? r = this.tree.expandOnlyOnTwistieClick(t.element) : r = !!this.tree.expandOnlyOnTwistieClick, o) this.handleStickyScrollMouseEvent(e, t);
          else {
            if (r && !n && e.browserEvent.detail !== 2) return super.onViewPointer(e);
            if (!this.tree.expandOnDoubleClick && e.browserEvent.detail === 2) return super.onViewPointer(e);
          }
          if (t.collapsible && (!o || n)) {
            const a = this.tree.getNodeLocation(t), l = e.browserEvent.altKey;
            if (this.tree.setFocus([
              a
            ]), this.tree.toggleCollapsed(a, l), n) {
              e.browserEvent.isHandledByList = true;
              return;
            }
          }
          o || super.onViewPointer(e);
        }
        handleStickyScrollMouseEvent(e, t) {
          if (Cte(e.browserEvent.target) || wte(e.browserEvent.target)) return;
          const i = this.stickyScrollProvider();
          if (!i) throw new Error("Sticky scroll controller not found");
          const n = this.list.indexOf(t), o = this.list.getElementTop(n), r = i.nodePositionTopBelowWidget(t);
          this.tree.scrollTop = o - r, this.list.domFocus(), this.list.setFocus([
            n
          ]), this.list.setSelection([
            n
          ]);
        }
        onDoubleClick(e) {
          e.browserEvent.target.classList.contains("monaco-tl-twistie") || !this.tree.expandOnDoubleClick || e.browserEvent.isHandledByList || super.onDoubleClick(e);
        }
        onMouseDown(e) {
          const t = e.browserEvent.target;
          if (!u_(t) && !Lp(t)) {
            super.onMouseDown(e);
            return;
          }
        }
        onContextMenu(e) {
          const t = e.browserEvent.target;
          if (!u_(t) && !Lp(t)) {
            super.onContextMenu(e);
            return;
          }
        }
      }
      class Doe extends ta {
        constructor(e, t, i, n, o, r, a, l) {
          super(e, t, i, n, l), this.focusTrait = o, this.selectionTrait = r, this.anchorTrait = a;
        }
        createMouseController(e) {
          return new koe(this, e.tree, e.stickyScrollProvider);
        }
        splice(e, t, i = []) {
          if (super.splice(e, t, i), i.length === 0) return;
          const n = [], o = [];
          let r;
          i.forEach((a, l) => {
            this.focusTrait.has(a) && n.push(e + l), this.selectionTrait.has(a) && o.push(e + l), this.anchorTrait.has(a) && (r = e + l);
          }), n.length > 0 && super.setFocus(Nh([
            ...super.getFocus(),
            ...n
          ])), o.length > 0 && super.setSelection(Nh([
            ...super.getSelection(),
            ...o
          ])), typeof r == "number" && super.setAnchor(r);
        }
        setFocus(e, t, i = false) {
          super.setFocus(e, t), i || this.focusTrait.set(e.map((n) => this.element(n)), t);
        }
        setSelection(e, t, i = false) {
          super.setSelection(e, t), i || this.selectionTrait.set(e.map((n) => this.element(n)), t);
        }
        setAnchor(e, t = false) {
          super.setAnchor(e), t || (typeof e > "u" ? this.anchorTrait.set([]) : this.anchorTrait.set([
            this.element(e)
          ]));
        }
      }
      class UB {
        get onDidScroll() {
          return this.view.onDidScroll;
        }
        get onDidChangeFocus() {
          return this.eventBufferer.wrapEvent(this.focus.onDidChange);
        }
        get onDidChangeSelection() {
          return this.eventBufferer.wrapEvent(this.selection.onDidChange);
        }
        get onMouseDblClick() {
          return be.filter(be.map(this.view.onMouseDblClick, Jb), (e) => e.target !== _h.Filter);
        }
        get onMouseOver() {
          return be.map(this.view.onMouseOver, Jb);
        }
        get onMouseOut() {
          return be.map(this.view.onMouseOut, Jb);
        }
        get onContextMenu() {
          var _a3;
          return be.any(be.filter(be.map(this.view.onContextMenu, xoe), (e) => !e.isStickyScroll), ((_a3 = this.stickyScrollController) == null ? void 0 : _a3.onContextMenu) ?? be.None);
        }
        get onPointer() {
          return be.map(this.view.onPointer, Jb);
        }
        get onKeyDown() {
          return this.view.onKeyDown;
        }
        get onDidFocus() {
          return this.view.onDidFocus;
        }
        get onDidChangeModel() {
          return be.signal(this.model.onDidSplice);
        }
        get onDidChangeCollapseState() {
          return this.model.onDidChangeCollapseState;
        }
        get findMode() {
          var _a3;
          return ((_a3 = this.findController) == null ? void 0 : _a3.mode) ?? Ml.Highlight;
        }
        set findMode(e) {
          this.findController && (this.findController.mode = e);
        }
        get findMatchType() {
          var _a3;
          return ((_a3 = this.findController) == null ? void 0 : _a3.matchType) ?? Vh.Fuzzy;
        }
        set findMatchType(e) {
          this.findController && (this.findController.matchType = e);
        }
        get expandOnDoubleClick() {
          return typeof this._options.expandOnDoubleClick > "u" ? true : this._options.expandOnDoubleClick;
        }
        get expandOnlyOnTwistieClick() {
          return typeof this._options.expandOnlyOnTwistieClick > "u" ? true : this._options.expandOnlyOnTwistieClick;
        }
        get onDidDispose() {
          return this.view.onDidDispose;
        }
        constructor(e, t, i, n, o = {}) {
          this._user = e, this._options = o, this.eventBufferer = new B_(), this.onDidChangeFindOpenState = be.None, this.onDidChangeStickyScrollFocused = be.None, this.disposables = new Me(), this._onWillRefilter = new G(), this.onWillRefilter = this._onWillRefilter.event, this._onDidUpdateOptions = new G(), this.treeDelegate = new LN(i);
          const r = new N4(), a = new N4(), l = this.disposables.add(new _oe(a.event)), u = new L8();
          this.renderers = n.map((b) => new Yv(b, () => this.model, r.event, l, u, o));
          for (const b of this.renderers) this.disposables.add(b);
          let d;
          o.keyboardNavigationLabelProvider && (d = new boe(this, o.keyboardNavigationLabelProvider, o.filter), o = {
            ...o,
            filter: d
          }, this.disposables.add(d)), this.focus = new dx(() => this.view.getFocusedElements()[0], o.identityProvider), this.selection = new dx(() => this.view.getSelectedElements()[0], o.identityProvider), this.anchor = new dx(() => this.view.getAnchorElement(), o.identityProvider), this.view = new Doe(e, t, this.treeDelegate, this.renderers, this.focus, this.selection, this.anchor, {
            ...poe(() => this.model, o),
            tree: this,
            stickyScrollProvider: () => this.stickyScrollController
          }), this.model = this.createModel(e, this.view, o), r.input = this.model.onDidChangeCollapseState;
          const f = be.forEach(this.model.onDidSplice, (b) => {
            this.eventBufferer.bufferEvents(() => {
              this.focus.onDidModelSplice(b), this.selection.onDidModelSplice(b);
            });
          }, this.disposables);
          f(() => null, null, this.disposables);
          const m = this.disposables.add(new G()), _ = this.disposables.add(new W_(0));
          if (this.disposables.add(be.any(f, this.focus.onDidChange, this.selection.onDidChange)(() => {
            _.trigger(() => {
              const b = /* @__PURE__ */ new Set();
              for (const v of this.focus.getNodes()) b.add(v);
              for (const v of this.selection.getNodes()) b.add(v);
              m.fire([
                ...b.values()
              ]);
            });
          })), a.input = m.event, o.keyboardSupport !== false) {
            const b = be.chain(this.view.onKeyDown, (v) => v.filter((y) => !tu(y.target)).map((y) => new si(y)));
            be.chain(b, (v) => v.filter((y) => y.keyCode === 15))(this.onLeftArrow, this, this.disposables), be.chain(b, (v) => v.filter((y) => y.keyCode === 17))(this.onRightArrow, this, this.disposables), be.chain(b, (v) => v.filter((y) => y.keyCode === 10))(this.onSpace, this, this.disposables);
          }
          if ((o.findWidgetEnabled ?? true) && o.keyboardNavigationLabelProvider && o.contextViewProvider) {
            const b = this.options.findWidgetStyles ? {
              styles: this.options.findWidgetStyles
            } : void 0;
            this.findController = new voe(this, this.model, this.view, d, o.contextViewProvider, b), this.focusNavigationFilter = (v) => this.findController.shouldAllowFocus(v), this.onDidChangeFindOpenState = this.findController.onDidChangeOpenState, this.disposables.add(this.findController), this.onDidChangeFindMode = this.findController.onDidChangeMode, this.onDidChangeFindMatchType = this.findController.onDidChangeMatchType;
          } else this.onDidChangeFindMode = be.None, this.onDidChangeFindMatchType = be.None;
          o.enableStickyScroll && (this.stickyScrollController = new XP(this, this.model, this.view, this.renderers, this.treeDelegate, o), this.onDidChangeStickyScrollFocused = this.stickyScrollController.onDidChangeHasFocus), this.styleElement = Uo(this.view.getHTMLElement()), this.getHTMLElement().classList.toggle("always", this._options.renderIndentGuides === _g.Always);
        }
        updateOptions(e = {}) {
          var _a3;
          this._options = {
            ...this._options,
            ...e
          };
          for (const t of this.renderers) t.updateOptions(e);
          this.view.updateOptions(this._options), (_a3 = this.findController) == null ? void 0 : _a3.updateOptions(e), this.updateStickyScroll(e), this._onDidUpdateOptions.fire(this._options), this.getHTMLElement().classList.toggle("always", this._options.renderIndentGuides === _g.Always);
        }
        get options() {
          return this._options;
        }
        updateStickyScroll(e) {
          var _a3;
          !this.stickyScrollController && this._options.enableStickyScroll ? (this.stickyScrollController = new XP(this, this.model, this.view, this.renderers, this.treeDelegate, this._options), this.onDidChangeStickyScrollFocused = this.stickyScrollController.onDidChangeHasFocus) : this.stickyScrollController && !this._options.enableStickyScroll && (this.onDidChangeStickyScrollFocused = be.None, this.stickyScrollController.dispose(), this.stickyScrollController = void 0), (_a3 = this.stickyScrollController) == null ? void 0 : _a3.updateOptions(e);
        }
        getHTMLElement() {
          return this.view.getHTMLElement();
        }
        get scrollTop() {
          return this.view.scrollTop;
        }
        set scrollTop(e) {
          this.view.scrollTop = e;
        }
        get scrollHeight() {
          return this.view.scrollHeight;
        }
        get renderHeight() {
          return this.view.renderHeight;
        }
        get ariaLabel() {
          return this.view.ariaLabel;
        }
        set ariaLabel(e) {
          this.view.ariaLabel = e;
        }
        domFocus() {
          var _a3;
          ((_a3 = this.stickyScrollController) == null ? void 0 : _a3.focusedLast()) ? this.stickyScrollController.domFocus() : this.view.domFocus();
        }
        layout(e, t) {
          var _a3;
          this.view.layout(e, t), wg(t) && ((_a3 = this.findController) == null ? void 0 : _a3.layout(t));
        }
        style(e) {
          const t = `.${this.view.domId}`, i = [];
          e.treeIndentGuidesStroke && (i.push(`.monaco-list${t}:hover .monaco-tl-indent > .indent-guide, .monaco-list${t}.always .monaco-tl-indent > .indent-guide  { border-color: ${e.treeInactiveIndentGuidesStroke}; }`), i.push(`.monaco-list${t} .monaco-tl-indent > .indent-guide.active { border-color: ${e.treeIndentGuidesStroke}; }`));
          const n = e.treeStickyScrollBackground ?? e.listBackground;
          n && (i.push(`.monaco-list${t} .monaco-scrollable-element .monaco-tree-sticky-container { background-color: ${n}; }`), i.push(`.monaco-list${t} .monaco-scrollable-element .monaco-tree-sticky-container .monaco-tree-sticky-row { background-color: ${n}; }`)), e.treeStickyScrollBorder && i.push(`.monaco-list${t} .monaco-scrollable-element .monaco-tree-sticky-container { border-bottom: 1px solid ${e.treeStickyScrollBorder}; }`), e.treeStickyScrollShadow && i.push(`.monaco-list${t} .monaco-scrollable-element .monaco-tree-sticky-container .monaco-tree-sticky-container-shadow { box-shadow: ${e.treeStickyScrollShadow} 0 6px 6px -6px inset; height: 3px; }`), e.listFocusForeground && (i.push(`.monaco-list${t}.sticky-scroll-focused .monaco-scrollable-element .monaco-tree-sticky-container:focus .monaco-list-row.focused { color: ${e.listFocusForeground}; }`), i.push(`.monaco-list${t}:not(.sticky-scroll-focused) .monaco-scrollable-element .monaco-tree-sticky-container .monaco-list-row.focused { color: inherit; }`));
          const o = Pl(e.listFocusAndSelectionOutline, Pl(e.listSelectionOutline, e.listFocusOutline ?? ""));
          o && (i.push(`.monaco-list${t}.sticky-scroll-focused .monaco-scrollable-element .monaco-tree-sticky-container:focus .monaco-list-row.focused.selected { outline: 1px solid ${o}; outline-offset: -1px;}`), i.push(`.monaco-list${t}:not(.sticky-scroll-focused) .monaco-scrollable-element .monaco-tree-sticky-container .monaco-list-row.focused.selected { outline: inherit;}`)), e.listFocusOutline && (i.push(`.monaco-list${t}.sticky-scroll-focused .monaco-scrollable-element .monaco-tree-sticky-container:focus .monaco-list-row.focused { outline: 1px solid ${e.listFocusOutline}; outline-offset: -1px; }`), i.push(`.monaco-list${t}:not(.sticky-scroll-focused) .monaco-scrollable-element .monaco-tree-sticky-container .monaco-list-row.focused { outline: inherit; }`), i.push(`.monaco-workbench.context-menu-visible .monaco-list${t}.last-focused.sticky-scroll-focused .monaco-scrollable-element .monaco-tree-sticky-container .monaco-list-row.passive-focused { outline: 1px solid ${e.listFocusOutline}; outline-offset: -1px; }`), i.push(`.monaco-workbench.context-menu-visible .monaco-list${t}.last-focused.sticky-scroll-focused .monaco-list-rows .monaco-list-row.focused { outline: inherit; }`), i.push(`.monaco-workbench.context-menu-visible .monaco-list${t}.last-focused:not(.sticky-scroll-focused) .monaco-tree-sticky-container .monaco-list-rows .monaco-list-row.focused { outline: inherit; }`)), this.styleElement.textContent = i.join(`
`), this.view.style(e);
        }
        getParentElement(e) {
          const t = this.model.getParentNodeLocation(e);
          return this.model.getNode(t).element;
        }
        getFirstElementChild(e) {
          return this.model.getFirstElementChild(e);
        }
        getNode(e) {
          return this.model.getNode(e);
        }
        getNodeLocation(e) {
          return this.model.getNodeLocation(e);
        }
        collapse(e, t = false) {
          return this.model.setCollapsed(e, true, t);
        }
        expand(e, t = false) {
          return this.model.setCollapsed(e, false, t);
        }
        toggleCollapsed(e, t = false) {
          return this.model.setCollapsed(e, void 0, t);
        }
        isCollapsible(e) {
          return this.model.isCollapsible(e);
        }
        setCollapsible(e, t) {
          return this.model.setCollapsible(e, t);
        }
        isCollapsed(e) {
          return this.model.isCollapsed(e);
        }
        refilter() {
          this._onWillRefilter.fire(void 0), this.model.refilter();
        }
        setSelection(e, t) {
          this.eventBufferer.bufferEvents(() => {
            const i = e.map((o) => this.model.getNode(o));
            this.selection.set(i, t);
            const n = e.map((o) => this.model.getListIndex(o)).filter((o) => o > -1);
            this.view.setSelection(n, t, true);
          });
        }
        getSelection() {
          return this.selection.get();
        }
        setFocus(e, t) {
          this.eventBufferer.bufferEvents(() => {
            const i = e.map((o) => this.model.getNode(o));
            this.focus.set(i, t);
            const n = e.map((o) => this.model.getListIndex(o)).filter((o) => o > -1);
            this.view.setFocus(n, t, true);
          });
        }
        focusNext(e = 1, t = false, i, n = Cl(i) && i.altKey ? void 0 : this.focusNavigationFilter) {
          this.view.focusNext(e, t, i, n);
        }
        focusPrevious(e = 1, t = false, i, n = Cl(i) && i.altKey ? void 0 : this.focusNavigationFilter) {
          this.view.focusPrevious(e, t, i, n);
        }
        focusNextPage(e, t = Cl(e) && e.altKey ? void 0 : this.focusNavigationFilter) {
          return this.view.focusNextPage(e, t);
        }
        focusPreviousPage(e, t = Cl(e) && e.altKey ? void 0 : this.focusNavigationFilter) {
          return this.view.focusPreviousPage(e, t, () => {
            var _a3;
            return ((_a3 = this.stickyScrollController) == null ? void 0 : _a3.height) ?? 0;
          });
        }
        focusLast(e, t = Cl(e) && e.altKey ? void 0 : this.focusNavigationFilter) {
          this.view.focusLast(e, t);
        }
        focusFirst(e, t = Cl(e) && e.altKey ? void 0 : this.focusNavigationFilter) {
          this.view.focusFirst(e, t);
        }
        getFocus() {
          return this.focus.get();
        }
        reveal(e, t) {
          this.model.expandTo(e);
          const i = this.model.getListIndex(e);
          if (i !== -1) if (!this.stickyScrollController) this.view.reveal(i, t);
          else {
            const n = this.stickyScrollController.nodePositionTopBelowWidget(this.getNode(e));
            this.view.reveal(i, t, n);
          }
        }
        onLeftArrow(e) {
          e.preventDefault(), e.stopPropagation();
          const t = this.view.getFocusedElements();
          if (t.length === 0) return;
          const i = t[0], n = this.model.getNodeLocation(i);
          if (!this.model.setCollapsed(n, true)) {
            const r = this.model.getParentNodeLocation(n);
            if (!r) return;
            const a = this.model.getListIndex(r);
            this.view.reveal(a), this.view.setFocus([
              a
            ]);
          }
        }
        onRightArrow(e) {
          e.preventDefault(), e.stopPropagation();
          const t = this.view.getFocusedElements();
          if (t.length === 0) return;
          const i = t[0], n = this.model.getNodeLocation(i);
          if (!this.model.setCollapsed(n, false)) {
            if (!i.children.some((l) => l.visible)) return;
            const [r] = this.view.getFocus(), a = r + 1;
            this.view.reveal(a), this.view.setFocus([
              a
            ]);
          }
        }
        onSpace(e) {
          e.preventDefault(), e.stopPropagation();
          const t = this.view.getFocusedElements();
          if (t.length === 0) return;
          const i = t[0], n = this.model.getNodeLocation(i), o = e.browserEvent.altKey;
          this.model.setCollapsed(n, void 0, o);
        }
        dispose() {
          var _a3;
          On(this.disposables), (_a3 = this.stickyScrollController) == null ? void 0 : _a3.dispose(), this.view.dispose();
        }
      }
      class xN {
        constructor(e, t, i = {}) {
          this.user = e, this.rootRef = null, this.nodes = /* @__PURE__ */ new Map(), this.nodesByIdentity = /* @__PURE__ */ new Map(), this.model = new foe(e, t, null, i), this.onDidSplice = this.model.onDidSplice, this.onDidChangeCollapseState = this.model.onDidChangeCollapseState, this.onDidChangeRenderNodeCount = this.model.onDidChangeRenderNodeCount, i.sorter && (this.sorter = {
            compare(n, o) {
              return i.sorter.compare(n.element, o.element);
            }
          }), this.identityProvider = i.identityProvider;
        }
        setChildren(e, t = kt.empty(), i = {}) {
          const n = this.getElementLocation(e);
          this._setChildren(n, this.preserveCollapseState(t), i);
        }
        _setChildren(e, t = kt.empty(), i) {
          const n = /* @__PURE__ */ new Set(), o = /* @__PURE__ */ new Set(), r = (l) => {
            var _a3;
            if (l.element === null) return;
            const u = l;
            if (n.add(u.element), this.nodes.set(u.element, u), this.identityProvider) {
              const d = this.identityProvider.getId(u.element).toString();
              o.add(d), this.nodesByIdentity.set(d, u);
            }
            (_a3 = i.onDidCreateNode) == null ? void 0 : _a3.call(i, u);
          }, a = (l) => {
            var _a3;
            if (l.element === null) return;
            const u = l;
            if (n.has(u.element) || this.nodes.delete(u.element), this.identityProvider) {
              const d = this.identityProvider.getId(u.element).toString();
              o.has(d) || this.nodesByIdentity.delete(d);
            }
            (_a3 = i.onDidDeleteNode) == null ? void 0 : _a3.call(i, u);
          };
          this.model.splice([
            ...e,
            0
          ], Number.MAX_VALUE, t, {
            ...i,
            onDidCreateNode: r,
            onDidDeleteNode: a
          });
        }
        preserveCollapseState(e = kt.empty()) {
          return this.sorter && (e = [
            ...e
          ].sort(this.sorter.compare.bind(this.sorter))), kt.map(e, (t) => {
            let i = this.nodes.get(t.element);
            if (!i && this.identityProvider) {
              const r = this.identityProvider.getId(t.element).toString();
              i = this.nodesByIdentity.get(r);
            }
            if (!i) {
              let r;
              return typeof t.collapsed > "u" ? r = void 0 : t.collapsed === so.Collapsed || t.collapsed === so.PreserveOrCollapsed ? r = true : t.collapsed === so.Expanded || t.collapsed === so.PreserveOrExpanded ? r = false : r = !!t.collapsed, {
                ...t,
                children: this.preserveCollapseState(t.children),
                collapsed: r
              };
            }
            const n = typeof t.collapsible == "boolean" ? t.collapsible : i.collapsible;
            let o;
            return typeof t.collapsed > "u" || t.collapsed === so.PreserveOrCollapsed || t.collapsed === so.PreserveOrExpanded ? o = i.collapsed : t.collapsed === so.Collapsed ? o = true : t.collapsed === so.Expanded ? o = false : o = !!t.collapsed, {
              ...t,
              collapsible: n,
              collapsed: o,
              children: this.preserveCollapseState(t.children)
            };
          });
        }
        rerender(e) {
          const t = this.getElementLocation(e);
          this.model.rerender(t);
        }
        getFirstElementChild(e = null) {
          const t = this.getElementLocation(e);
          return this.model.getFirstElementChild(t);
        }
        has(e) {
          return this.nodes.has(e);
        }
        getListIndex(e) {
          const t = this.getElementLocation(e);
          return this.model.getListIndex(t);
        }
        getListRenderCount(e) {
          const t = this.getElementLocation(e);
          return this.model.getListRenderCount(t);
        }
        isCollapsible(e) {
          const t = this.getElementLocation(e);
          return this.model.isCollapsible(t);
        }
        setCollapsible(e, t) {
          const i = this.getElementLocation(e);
          return this.model.setCollapsible(i, t);
        }
        isCollapsed(e) {
          const t = this.getElementLocation(e);
          return this.model.isCollapsed(t);
        }
        setCollapsed(e, t, i) {
          const n = this.getElementLocation(e);
          return this.model.setCollapsed(n, t, i);
        }
        expandTo(e) {
          const t = this.getElementLocation(e);
          this.model.expandTo(t);
        }
        refilter() {
          this.model.refilter();
        }
        getNode(e = null) {
          if (e === null) return this.model.getNode(this.model.rootRef);
          const t = this.nodes.get(e);
          if (!t) throw new lo(this.user, `Tree element not found: ${e}`);
          return t;
        }
        getNodeLocation(e) {
          return e.element;
        }
        getParentNodeLocation(e) {
          if (e === null) throw new lo(this.user, "Invalid getParentNodeLocation call");
          const t = this.nodes.get(e);
          if (!t) throw new lo(this.user, `Tree element not found: ${e}`);
          const i = this.model.getNodeLocation(t), n = this.model.getParentNodeLocation(i);
          return this.model.getNode(n).element;
        }
        getElementLocation(e) {
          if (e === null) return [];
          const t = this.nodes.get(e);
          if (!t) throw new lo(this.user, `Tree element not found: ${e}`);
          return this.model.getNodeLocation(t);
        }
      }
      function A0(s) {
        const e = [
          s.element
        ], t = s.incompressible || false;
        return {
          element: {
            elements: e,
            incompressible: t
          },
          children: kt.map(kt.from(s.children), A0),
          collapsible: s.collapsible,
          collapsed: s.collapsed
        };
      }
      function R0(s) {
        const e = [
          s.element
        ], t = s.incompressible || false;
        let i, n;
        for (; [n, i] = kt.consume(kt.from(s.children), 2), !(n.length !== 1 || n[0].incompressible); ) s = n[0], e.push(s.element);
        return {
          element: {
            elements: e,
            incompressible: t
          },
          children: kt.map(kt.concat(n, i), R0),
          collapsible: s.collapsible,
          collapsed: s.collapsed
        };
      }
      function _2(s, e = 0) {
        let t;
        return e < s.element.elements.length - 1 ? t = [
          _2(s, e + 1)
        ] : t = kt.map(kt.from(s.children), (i) => _2(i, 0)), e === 0 && s.element.incompressible ? {
          element: s.element.elements[e],
          children: t,
          incompressible: true,
          collapsible: s.collapsible,
          collapsed: s.collapsed
        } : {
          element: s.element.elements[e],
          children: t,
          collapsible: s.collapsible,
          collapsed: s.collapsed
        };
      }
      function JP(s) {
        return _2(s, 0);
      }
      function $B(s, e, t) {
        return s.element === e ? {
          ...s,
          children: t
        } : {
          ...s,
          children: kt.map(kt.from(s.children), (i) => $B(i, e, t))
        };
      }
      const Eoe = (s) => ({
        getId(e) {
          return e.elements.map((t) => s.getId(t).toString()).join("\0");
        }
      });
      class Toe {
        get onDidSplice() {
          return this.model.onDidSplice;
        }
        get onDidChangeCollapseState() {
          return this.model.onDidChangeCollapseState;
        }
        get onDidChangeRenderNodeCount() {
          return this.model.onDidChangeRenderNodeCount;
        }
        constructor(e, t, i = {}) {
          this.user = e, this.rootRef = null, this.nodes = /* @__PURE__ */ new Map(), this.model = new xN(e, t, i), this.enabled = typeof i.compressionEnabled > "u" ? true : i.compressionEnabled, this.identityProvider = i.identityProvider;
        }
        setChildren(e, t = kt.empty(), i) {
          const n = i.diffIdentityProvider && Eoe(i.diffIdentityProvider);
          if (e === null) {
            const b = kt.map(t, this.enabled ? R0 : A0);
            this._setChildren(null, b, {
              diffIdentityProvider: n,
              diffDepth: 1 / 0
            });
            return;
          }
          const o = this.nodes.get(e);
          if (!o) throw new lo(this.user, "Unknown compressed tree node");
          const r = this.model.getNode(o), a = this.model.getParentNodeLocation(o), l = this.model.getNode(a), u = JP(r), d = $B(u, e, t), f = (this.enabled ? R0 : A0)(d), m = i.diffIdentityProvider ? (b, v) => i.diffIdentityProvider.getId(b) === i.diffIdentityProvider.getId(v) : void 0;
          if (Qi(f.element.elements, r.element.elements, m)) {
            this._setChildren(o, f.children || kt.empty(), {
              diffIdentityProvider: n,
              diffDepth: 1
            });
            return;
          }
          const _ = l.children.map((b) => b === r ? f : b);
          this._setChildren(l.element, _, {
            diffIdentityProvider: n,
            diffDepth: r.depth - l.depth
          });
        }
        isCompressionEnabled() {
          return this.enabled;
        }
        setCompressionEnabled(e) {
          if (e === this.enabled) return;
          this.enabled = e;
          const i = this.model.getNode().children, n = kt.map(i, JP), o = kt.map(n, e ? R0 : A0);
          this._setChildren(null, o, {
            diffIdentityProvider: this.identityProvider,
            diffDepth: 1 / 0
          });
        }
        _setChildren(e, t, i) {
          const n = /* @__PURE__ */ new Set(), o = (a) => {
            for (const l of a.element.elements) n.add(l), this.nodes.set(l, a.element);
          }, r = (a) => {
            for (const l of a.element.elements) n.has(l) || this.nodes.delete(l);
          };
          this.model.setChildren(e, t, {
            ...i,
            onDidCreateNode: o,
            onDidDeleteNode: r
          });
        }
        has(e) {
          return this.nodes.has(e);
        }
        getListIndex(e) {
          const t = this.getCompressedNode(e);
          return this.model.getListIndex(t);
        }
        getListRenderCount(e) {
          const t = this.getCompressedNode(e);
          return this.model.getListRenderCount(t);
        }
        getNode(e) {
          if (typeof e > "u") return this.model.getNode();
          const t = this.getCompressedNode(e);
          return this.model.getNode(t);
        }
        getNodeLocation(e) {
          const t = this.model.getNodeLocation(e);
          return t === null ? null : t.elements[t.elements.length - 1];
        }
        getParentNodeLocation(e) {
          const t = this.getCompressedNode(e), i = this.model.getParentNodeLocation(t);
          return i === null ? null : i.elements[i.elements.length - 1];
        }
        getFirstElementChild(e) {
          const t = this.getCompressedNode(e);
          return this.model.getFirstElementChild(t);
        }
        isCollapsible(e) {
          const t = this.getCompressedNode(e);
          return this.model.isCollapsible(t);
        }
        setCollapsible(e, t) {
          const i = this.getCompressedNode(e);
          return this.model.setCollapsible(i, t);
        }
        isCollapsed(e) {
          const t = this.getCompressedNode(e);
          return this.model.isCollapsed(t);
        }
        setCollapsed(e, t, i) {
          const n = this.getCompressedNode(e);
          return this.model.setCollapsed(n, t, i);
        }
        expandTo(e) {
          const t = this.getCompressedNode(e);
          this.model.expandTo(t);
        }
        rerender(e) {
          const t = this.getCompressedNode(e);
          this.model.rerender(t);
        }
        refilter() {
          this.model.refilter();
        }
        getCompressedNode(e) {
          if (e === null) return null;
          const t = this.nodes.get(e);
          if (!t) throw new lo(this.user, `Tree element not found: ${e}`);
          return t;
        }
      }
      const Noe = (s) => s[s.length - 1];
      class kN {
        get element() {
          return this.node.element === null ? null : this.unwrapper(this.node.element);
        }
        get children() {
          return this.node.children.map((e) => new kN(this.unwrapper, e));
        }
        get depth() {
          return this.node.depth;
        }
        get visibleChildrenCount() {
          return this.node.visibleChildrenCount;
        }
        get visibleChildIndex() {
          return this.node.visibleChildIndex;
        }
        get collapsible() {
          return this.node.collapsible;
        }
        get collapsed() {
          return this.node.collapsed;
        }
        get visible() {
          return this.node.visible;
        }
        get filterData() {
          return this.node.filterData;
        }
        constructor(e, t) {
          this.unwrapper = e, this.node = t;
        }
      }
      function Ioe(s, e) {
        return {
          splice(t, i, n) {
            e.splice(t, i, n.map((o) => s.map(o)));
          },
          updateElementHeight(t, i) {
            e.updateElementHeight(t, i);
          }
        };
      }
      function Moe(s, e) {
        return {
          ...e,
          identityProvider: e.identityProvider && {
            getId(t) {
              return e.identityProvider.getId(s(t));
            }
          },
          sorter: e.sorter && {
            compare(t, i) {
              return e.sorter.compare(t.elements[0], i.elements[0]);
            }
          },
          filter: e.filter && {
            filter(t, i) {
              return e.filter.filter(s(t), i);
            }
          }
        };
      }
      class Aoe {
        get onDidSplice() {
          return be.map(this.model.onDidSplice, ({ insertedNodes: e, deletedNodes: t }) => ({
            insertedNodes: e.map((i) => this.nodeMapper.map(i)),
            deletedNodes: t.map((i) => this.nodeMapper.map(i))
          }));
        }
        get onDidChangeCollapseState() {
          return be.map(this.model.onDidChangeCollapseState, ({ node: e, deep: t }) => ({
            node: this.nodeMapper.map(e),
            deep: t
          }));
        }
        get onDidChangeRenderNodeCount() {
          return be.map(this.model.onDidChangeRenderNodeCount, (e) => this.nodeMapper.map(e));
        }
        constructor(e, t, i = {}) {
          this.rootRef = null, this.elementMapper = i.elementMapper || Noe;
          const n = (o) => this.elementMapper(o.elements);
          this.nodeMapper = new yN((o) => new kN(n, o)), this.model = new Toe(e, Ioe(this.nodeMapper, t), Moe(n, i));
        }
        setChildren(e, t = kt.empty(), i = {}) {
          this.model.setChildren(e, t, i);
        }
        isCompressionEnabled() {
          return this.model.isCompressionEnabled();
        }
        setCompressionEnabled(e) {
          this.model.setCompressionEnabled(e);
        }
        has(e) {
          return this.model.has(e);
        }
        getListIndex(e) {
          return this.model.getListIndex(e);
        }
        getListRenderCount(e) {
          return this.model.getListRenderCount(e);
        }
        getNode(e) {
          return this.nodeMapper.map(this.model.getNode(e));
        }
        getNodeLocation(e) {
          return e.element;
        }
        getParentNodeLocation(e) {
          return this.model.getParentNodeLocation(e);
        }
        getFirstElementChild(e) {
          const t = this.model.getFirstElementChild(e);
          return t === null || typeof t > "u" ? t : this.elementMapper(t.elements);
        }
        isCollapsible(e) {
          return this.model.isCollapsible(e);
        }
        setCollapsible(e, t) {
          return this.model.setCollapsible(e, t);
        }
        isCollapsed(e) {
          return this.model.isCollapsed(e);
        }
        setCollapsed(e, t, i) {
          return this.model.setCollapsed(e, t, i);
        }
        expandTo(e) {
          return this.model.expandTo(e);
        }
        rerender(e) {
          return this.model.rerender(e);
        }
        refilter() {
          return this.model.refilter();
        }
        getCompressedTreeNode(e = null) {
          return this.model.getNode(e);
        }
      }
      var Roe = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      };
      class DN extends UB {
        get onDidChangeCollapseState() {
          return this.model.onDidChangeCollapseState;
        }
        constructor(e, t, i, n, o = {}) {
          super(e, t, i, n, o), this.user = e;
        }
        setChildren(e, t = kt.empty(), i) {
          this.model.setChildren(e, t, i);
        }
        rerender(e) {
          if (e === void 0) {
            this.view.rerender();
            return;
          }
          this.model.rerender(e);
        }
        hasElement(e) {
          return this.model.has(e);
        }
        createModel(e, t, i) {
          return new xN(e, t, i);
        }
      }
      class qB {
        get compressedTreeNodeProvider() {
          return this._compressedTreeNodeProvider();
        }
        constructor(e, t, i) {
          this._compressedTreeNodeProvider = e, this.stickyScrollDelegate = t, this.renderer = i, this.templateId = i.templateId, i.onDidChangeTwistieState && (this.onDidChangeTwistieState = i.onDidChangeTwistieState);
        }
        renderTemplate(e) {
          return {
            compressedTreeNode: void 0,
            data: this.renderer.renderTemplate(e)
          };
        }
        renderElement(e, t, i, n) {
          let o = this.stickyScrollDelegate.getCompressedNode(e);
          o || (o = this.compressedTreeNodeProvider.getCompressedTreeNode(e.element)), o.element.elements.length === 1 ? (i.compressedTreeNode = void 0, this.renderer.renderElement(e, t, i.data, n)) : (i.compressedTreeNode = o, this.renderer.renderCompressedElements(o, t, i.data, n));
        }
        disposeElement(e, t, i, n) {
          var _a3, _b3, _c2, _d2;
          i.compressedTreeNode ? (_b3 = (_a3 = this.renderer).disposeCompressedElements) == null ? void 0 : _b3.call(_a3, i.compressedTreeNode, t, i.data, n) : (_d2 = (_c2 = this.renderer).disposeElement) == null ? void 0 : _d2.call(_c2, e, t, i.data, n);
        }
        disposeTemplate(e) {
          this.renderer.disposeTemplate(e.data);
        }
        renderTwistie(e, t) {
          return this.renderer.renderTwistie ? this.renderer.renderTwistie(e, t) : false;
        }
      }
      Roe([
        Li
      ], qB.prototype, "compressedTreeNodeProvider", null);
      class Ooe {
        constructor(e) {
          this.modelProvider = e, this.compressedStickyNodes = /* @__PURE__ */ new Map();
        }
        getCompressedNode(e) {
          return this.compressedStickyNodes.get(e);
        }
        constrainStickyScrollNodes(e, t, i) {
          if (this.compressedStickyNodes.clear(), e.length === 0) return [];
          for (let n = 0; n < e.length; n++) {
            const o = e[n], r = o.position + o.height;
            if (n + 1 < e.length && r + e[n + 1].height > i || n >= t - 1 && t < e.length) {
              const l = e.slice(0, n), u = e.slice(n), d = this.compressStickyNodes(u);
              return [
                ...l,
                d
              ];
            }
          }
          return e;
        }
        compressStickyNodes(e) {
          if (e.length === 0) throw new Error("Can't compress empty sticky nodes");
          const t = this.modelProvider();
          if (!t.isCompressionEnabled()) return e[0];
          const i = [];
          for (let u = 0; u < e.length; u++) {
            const d = e[u], f = t.getCompressedTreeNode(d.node.element);
            if (f.element) {
              if (u !== 0 && f.element.incompressible) break;
              i.push(...f.element.elements);
            }
          }
          if (i.length < 2) return e[0];
          const n = e[e.length - 1], o = {
            elements: i,
            incompressible: false
          }, r = {
            ...n.node,
            children: [],
            element: o
          }, a = new Proxy(e[0].node, {}), l = {
            node: a,
            startIndex: e[0].startIndex,
            endIndex: n.endIndex,
            position: e[0].position,
            height: e[0].height
          };
          return this.compressedStickyNodes.set(a, r), l;
        }
      }
      function Poe(s, e) {
        return e && {
          ...e,
          keyboardNavigationLabelProvider: e.keyboardNavigationLabelProvider && {
            getKeyboardNavigationLabel(t) {
              let i;
              try {
                i = s().getCompressedTreeNode(t);
              } catch {
                return e.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(t);
              }
              return i.element.elements.length === 1 ? e.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(t) : e.keyboardNavigationLabelProvider.getCompressedNodeKeyboardNavigationLabel(i.element.elements);
            }
          }
        };
      }
      class KB extends DN {
        constructor(e, t, i, n, o = {}) {
          const r = () => this, a = new Ooe(() => this.model), l = n.map((u) => new qB(r, a, u));
          super(e, t, i, l, {
            ...Poe(r, o),
            stickyScrollDelegate: a
          });
        }
        setChildren(e, t = kt.empty(), i) {
          this.model.setChildren(e, t, i);
        }
        createModel(e, t, i) {
          return new Aoe(e, t, i);
        }
        updateOptions(e = {}) {
          super.updateOptions(e), typeof e.compressionEnabled < "u" && this.model.setCompressionEnabled(e.compressionEnabled);
        }
        getCompressedTreeNode(e = null) {
          return this.model.getCompressedTreeNode(e);
        }
      }
      function fx(s) {
        return {
          ...s,
          children: [],
          refreshPromise: void 0,
          stale: true,
          slow: false,
          forceExpanded: false
        };
      }
      function b2(s, e) {
        return e.parent ? e.parent === s ? true : b2(s, e.parent) : false;
      }
      function Boe(s, e) {
        return s === e || b2(s, e) || b2(e, s);
      }
      class EN {
        get element() {
          return this.node.element.element;
        }
        get children() {
          return this.node.children.map((e) => new EN(e));
        }
        get depth() {
          return this.node.depth;
        }
        get visibleChildrenCount() {
          return this.node.visibleChildrenCount;
        }
        get visibleChildIndex() {
          return this.node.visibleChildIndex;
        }
        get collapsible() {
          return this.node.collapsible;
        }
        get collapsed() {
          return this.node.collapsed;
        }
        get visible() {
          return this.node.visible;
        }
        get filterData() {
          return this.node.filterData;
        }
        constructor(e) {
          this.node = e;
        }
      }
      class Foe {
        constructor(e, t, i) {
          this.renderer = e, this.nodeMapper = t, this.onDidChangeTwistieState = i, this.renderedNodes = /* @__PURE__ */ new Map(), this.templateId = e.templateId;
        }
        renderTemplate(e) {
          return {
            templateData: this.renderer.renderTemplate(e)
          };
        }
        renderElement(e, t, i, n) {
          this.renderer.renderElement(this.nodeMapper.map(e), t, i.templateData, n);
        }
        renderTwistie(e, t) {
          return e.slow ? (t.classList.add(...wt.asClassNameArray(Te.treeItemLoading)), true) : (t.classList.remove(...wt.asClassNameArray(Te.treeItemLoading)), false);
        }
        disposeElement(e, t, i, n) {
          var _a3, _b3;
          (_b3 = (_a3 = this.renderer).disposeElement) == null ? void 0 : _b3.call(_a3, this.nodeMapper.map(e), t, i.templateData, n);
        }
        disposeTemplate(e) {
          this.renderer.disposeTemplate(e.templateData);
        }
        dispose() {
          this.renderedNodes.clear();
        }
      }
      function e3(s) {
        return {
          browserEvent: s.browserEvent,
          elements: s.elements.map((e) => e.element)
        };
      }
      function t3(s) {
        return {
          browserEvent: s.browserEvent,
          element: s.element && s.element.element,
          target: s.target
        };
      }
      class Voe extends e1 {
        constructor(e) {
          super(e.elements.map((t) => t.element)), this.data = e;
        }
      }
      function gx(s) {
        return s instanceof e1 ? new Voe(s) : s;
      }
      class Woe {
        constructor(e) {
          this.dnd = e;
        }
        getDragURI(e) {
          return this.dnd.getDragURI(e.element);
        }
        getDragLabel(e, t) {
          if (this.dnd.getDragLabel) return this.dnd.getDragLabel(e.map((i) => i.element), t);
        }
        onDragStart(e, t) {
          var _a3, _b3;
          (_b3 = (_a3 = this.dnd).onDragStart) == null ? void 0 : _b3.call(_a3, gx(e), t);
        }
        onDragOver(e, t, i, n, o, r = true) {
          return this.dnd.onDragOver(gx(e), t && t.element, i, n, o);
        }
        drop(e, t, i, n, o) {
          this.dnd.drop(gx(e), t && t.element, i, n, o);
        }
        onDragEnd(e) {
          var _a3, _b3;
          (_b3 = (_a3 = this.dnd).onDragEnd) == null ? void 0 : _b3.call(_a3, e);
        }
        dispose() {
          this.dnd.dispose();
        }
      }
      function jB(s) {
        return s && {
          ...s,
          collapseByDefault: true,
          identityProvider: s.identityProvider && {
            getId(e) {
              return s.identityProvider.getId(e.element);
            }
          },
          dnd: s.dnd && new Woe(s.dnd),
          multipleSelectionController: s.multipleSelectionController && {
            isSelectionSingleChangeEvent(e) {
              return s.multipleSelectionController.isSelectionSingleChangeEvent({
                ...e,
                element: e.element
              });
            },
            isSelectionRangeChangeEvent(e) {
              return s.multipleSelectionController.isSelectionRangeChangeEvent({
                ...e,
                element: e.element
              });
            }
          },
          accessibilityProvider: s.accessibilityProvider && {
            ...s.accessibilityProvider,
            getPosInSet: void 0,
            getSetSize: void 0,
            getRole: s.accessibilityProvider.getRole ? (e) => s.accessibilityProvider.getRole(e.element) : () => "treeitem",
            isChecked: s.accessibilityProvider.isChecked ? (e) => {
              var _a3;
              return !!((_a3 = s.accessibilityProvider) == null ? void 0 : _a3.isChecked(e.element));
            } : void 0,
            getAriaLabel(e) {
              return s.accessibilityProvider.getAriaLabel(e.element);
            },
            getWidgetAriaLabel() {
              return s.accessibilityProvider.getWidgetAriaLabel();
            },
            getWidgetRole: s.accessibilityProvider.getWidgetRole ? () => s.accessibilityProvider.getWidgetRole() : () => "tree",
            getAriaLevel: s.accessibilityProvider.getAriaLevel && ((e) => s.accessibilityProvider.getAriaLevel(e.element)),
            getActiveDescendantId: s.accessibilityProvider.getActiveDescendantId && ((e) => s.accessibilityProvider.getActiveDescendantId(e.element))
          },
          filter: s.filter && {
            filter(e, t) {
              return s.filter.filter(e.element, t);
            }
          },
          keyboardNavigationLabelProvider: s.keyboardNavigationLabelProvider && {
            ...s.keyboardNavigationLabelProvider,
            getKeyboardNavigationLabel(e) {
              return s.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(e.element);
            }
          },
          sorter: void 0,
          expandOnlyOnTwistieClick: typeof s.expandOnlyOnTwistieClick > "u" ? void 0 : typeof s.expandOnlyOnTwistieClick != "function" ? s.expandOnlyOnTwistieClick : (e) => s.expandOnlyOnTwistieClick(e.element),
          defaultFindVisibility: (e) => e.hasChildren && e.stale ? 1 : typeof s.defaultFindVisibility == "number" ? s.defaultFindVisibility : typeof s.defaultFindVisibility > "u" ? 2 : s.defaultFindVisibility(e.element)
        };
      }
      function v2(s, e) {
        e(s), s.children.forEach((t) => v2(t, e));
      }
      class GB {
        get onDidScroll() {
          return this.tree.onDidScroll;
        }
        get onDidChangeFocus() {
          return be.map(this.tree.onDidChangeFocus, e3);
        }
        get onDidChangeSelection() {
          return be.map(this.tree.onDidChangeSelection, e3);
        }
        get onMouseDblClick() {
          return be.map(this.tree.onMouseDblClick, t3);
        }
        get onPointer() {
          return be.map(this.tree.onPointer, t3);
        }
        get onDidFocus() {
          return this.tree.onDidFocus;
        }
        get onDidChangeModel() {
          return this.tree.onDidChangeModel;
        }
        get onDidChangeCollapseState() {
          return this.tree.onDidChangeCollapseState;
        }
        get onDidChangeFindOpenState() {
          return this.tree.onDidChangeFindOpenState;
        }
        get onDidChangeStickyScrollFocused() {
          return this.tree.onDidChangeStickyScrollFocused;
        }
        get onDidDispose() {
          return this.tree.onDidDispose;
        }
        constructor(e, t, i, n, o, r = {}) {
          this.user = e, this.dataSource = o, this.nodes = /* @__PURE__ */ new Map(), this.subTreeRefreshPromises = /* @__PURE__ */ new Map(), this.refreshPromises = /* @__PURE__ */ new Map(), this._onDidRender = new G(), this._onDidChangeNodeSlowState = new G(), this.nodeMapper = new yN((a) => new EN(a)), this.disposables = new Me(), this.identityProvider = r.identityProvider, this.autoExpandSingleChildren = typeof r.autoExpandSingleChildren > "u" ? false : r.autoExpandSingleChildren, this.sorter = r.sorter, this.getDefaultCollapseState = (a) => r.collapseByDefault ? r.collapseByDefault(a) ? so.PreserveOrCollapsed : so.PreserveOrExpanded : void 0, this.tree = this.createTree(e, t, i, n, r), this.onDidChangeFindMode = this.tree.onDidChangeFindMode, this.onDidChangeFindMatchType = this.tree.onDidChangeFindMatchType, this.root = fx({
            element: void 0,
            parent: null,
            hasChildren: true,
            defaultCollapseState: void 0
          }), this.identityProvider && (this.root = {
            ...this.root,
            id: null
          }), this.nodes.set(null, this.root), this.tree.onDidChangeCollapseState(this._onDidChangeCollapseState, this, this.disposables);
        }
        createTree(e, t, i, n, o) {
          const r = new LN(i), a = n.map((u) => new Foe(u, this.nodeMapper, this._onDidChangeNodeSlowState.event)), l = jB(o) || {};
          return new DN(e, t, r, a, l);
        }
        updateOptions(e = {}) {
          this.tree.updateOptions(e);
        }
        getHTMLElement() {
          return this.tree.getHTMLElement();
        }
        get scrollTop() {
          return this.tree.scrollTop;
        }
        set scrollTop(e) {
          this.tree.scrollTop = e;
        }
        get scrollHeight() {
          return this.tree.scrollHeight;
        }
        get renderHeight() {
          return this.tree.renderHeight;
        }
        domFocus() {
          this.tree.domFocus();
        }
        layout(e, t) {
          this.tree.layout(e, t);
        }
        style(e) {
          this.tree.style(e);
        }
        getInput() {
          return this.root.element;
        }
        async setInput(e, t) {
          this.refreshPromises.forEach((n) => n.cancel()), this.refreshPromises.clear(), this.root.element = e;
          const i = t && {
            viewState: t,
            focus: [],
            selection: []
          };
          await this._updateChildren(e, true, false, i), i && (this.tree.setFocus(i.focus), this.tree.setSelection(i.selection)), t && typeof t.scrollTop == "number" && (this.scrollTop = t.scrollTop);
        }
        async _updateChildren(e = this.root.element, t = true, i = false, n, o) {
          if (typeof this.root.element > "u") throw new lo(this.user, "Tree input not set");
          this.root.refreshPromise && (await this.root.refreshPromise, await be.toPromise(this._onDidRender.event));
          const r = this.getDataNode(e);
          if (await this.refreshAndRenderNode(r, t, n, o), i) try {
            this.tree.rerender(r);
          } catch {
          }
        }
        rerender(e) {
          if (e === void 0 || e === this.root.element) {
            this.tree.rerender();
            return;
          }
          const t = this.getDataNode(e);
          this.tree.rerender(t);
        }
        getNode(e = this.root.element) {
          const t = this.getDataNode(e), i = this.tree.getNode(t === this.root ? null : t);
          return this.nodeMapper.map(i);
        }
        collapse(e, t = false) {
          const i = this.getDataNode(e);
          return this.tree.collapse(i === this.root ? null : i, t);
        }
        async expand(e, t = false) {
          if (typeof this.root.element > "u") throw new lo(this.user, "Tree input not set");
          this.root.refreshPromise && (await this.root.refreshPromise, await be.toPromise(this._onDidRender.event));
          const i = this.getDataNode(e);
          if (this.tree.hasElement(i) && !this.tree.isCollapsible(i) || (i.refreshPromise && (await this.root.refreshPromise, await be.toPromise(this._onDidRender.event)), i !== this.root && !i.refreshPromise && !this.tree.isCollapsed(i))) return false;
          const n = this.tree.expand(i === this.root ? null : i, t);
          return i.refreshPromise && (await this.root.refreshPromise, await be.toPromise(this._onDidRender.event)), n;
        }
        setSelection(e, t) {
          const i = e.map((n) => this.getDataNode(n));
          this.tree.setSelection(i, t);
        }
        getSelection() {
          return this.tree.getSelection().map((t) => t.element);
        }
        setFocus(e, t) {
          const i = e.map((n) => this.getDataNode(n));
          this.tree.setFocus(i, t);
        }
        getFocus() {
          return this.tree.getFocus().map((t) => t.element);
        }
        reveal(e, t) {
          this.tree.reveal(this.getDataNode(e), t);
        }
        getParentElement(e) {
          const t = this.tree.getParentElement(this.getDataNode(e));
          return t && t.element;
        }
        getFirstElementChild(e = this.root.element) {
          const t = this.getDataNode(e), i = this.tree.getFirstElementChild(t === this.root ? null : t);
          return i && i.element;
        }
        getDataNode(e) {
          const t = this.nodes.get(e === this.root.element ? null : e);
          if (!t) throw new lo(this.user, `Data tree node not found: ${e}`);
          return t;
        }
        async refreshAndRenderNode(e, t, i, n) {
          await this.refreshNode(e, t, i), !this.disposables.isDisposed && this.render(e, i, n);
        }
        async refreshNode(e, t, i) {
          let n;
          if (this.subTreeRefreshPromises.forEach((o, r) => {
            !n && Boe(r, e) && (n = o.then(() => this.refreshNode(e, t, i)));
          }), n) return n;
          if (e !== this.root && this.tree.getNode(e).collapsed) {
            e.hasChildren = !!this.dataSource.hasChildren(e.element), e.stale = true, this.setChildren(e, [], t, i);
            return;
          }
          return this.doRefreshSubTree(e, t, i);
        }
        async doRefreshSubTree(e, t, i) {
          let n;
          e.refreshPromise = new Promise((o) => n = o), this.subTreeRefreshPromises.set(e, e.refreshPromise), e.refreshPromise.finally(() => {
            e.refreshPromise = void 0, this.subTreeRefreshPromises.delete(e);
          });
          try {
            const o = await this.doRefreshNode(e, t, i);
            e.stale = false, await Wk.settled(o.map((r) => this.doRefreshSubTree(r, t, i)));
          } finally {
            n();
          }
        }
        async doRefreshNode(e, t, i) {
          e.hasChildren = !!this.dataSource.hasChildren(e.element);
          let n;
          if (!e.hasChildren) n = Promise.resolve(kt.empty());
          else {
            const o = this.doGetChildren(e);
            if (S4(o)) n = Promise.resolve(o);
            else {
              const r = Zp(800);
              r.then(() => {
                e.slow = true, this._onDidChangeNodeSlowState.fire(e);
              }, (a) => null), n = o.finally(() => r.cancel());
            }
          }
          try {
            const o = await n;
            return this.setChildren(e, o, t, i);
          } catch (o) {
            if (e !== this.root && this.tree.hasElement(e) && this.tree.collapse(e), O_(o)) return [];
            throw o;
          } finally {
            e.slow && (e.slow = false, this._onDidChangeNodeSlowState.fire(e));
          }
        }
        doGetChildren(e) {
          let t = this.refreshPromises.get(e);
          if (t) return t;
          const i = this.dataSource.getChildren(e.element);
          return S4(i) ? this.processChildren(i) : (t = A9(async () => this.processChildren(await i)), this.refreshPromises.set(e, t), t.finally(() => {
            this.refreshPromises.delete(e);
          }));
        }
        _onDidChangeCollapseState({ node: e, deep: t }) {
          e.element !== null && !e.collapsed && e.element.stale && (t ? this.collapse(e.element.element) : this.refreshAndRenderNode(e.element, false).catch(qt));
        }
        setChildren(e, t, i, n) {
          const o = [
            ...t
          ];
          if (e.children.length === 0 && o.length === 0) return [];
          const r = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map();
          for (const d of e.children) r.set(d.element, d), this.identityProvider && a.set(d.id, {
            node: d,
            collapsed: this.tree.hasElement(d) && this.tree.isCollapsed(d)
          });
          const l = [], u = o.map((d) => {
            const f = !!this.dataSource.hasChildren(d);
            if (!this.identityProvider) {
              const v = fx({
                element: d,
                parent: e,
                hasChildren: f,
                defaultCollapseState: this.getDefaultCollapseState(d)
              });
              return f && v.defaultCollapseState === so.PreserveOrExpanded && l.push(v), v;
            }
            const m = this.identityProvider.getId(d).toString(), _ = a.get(m);
            if (_) {
              const v = _.node;
              return r.delete(v.element), this.nodes.delete(v.element), this.nodes.set(d, v), v.element = d, v.hasChildren = f, i ? _.collapsed ? (v.children.forEach((y) => v2(y, (x) => this.nodes.delete(x.element))), v.children.splice(0, v.children.length), v.stale = true) : l.push(v) : f && !_.collapsed && l.push(v), v;
            }
            const b = fx({
              element: d,
              parent: e,
              id: m,
              hasChildren: f,
              defaultCollapseState: this.getDefaultCollapseState(d)
            });
            return n && n.viewState.focus && n.viewState.focus.indexOf(m) > -1 && n.focus.push(b), n && n.viewState.selection && n.viewState.selection.indexOf(m) > -1 && n.selection.push(b), (n && n.viewState.expanded && n.viewState.expanded.indexOf(m) > -1 || f && b.defaultCollapseState === so.PreserveOrExpanded) && l.push(b), b;
          });
          for (const d of r.values()) v2(d, (f) => this.nodes.delete(f.element));
          for (const d of u) this.nodes.set(d.element, d);
          return e.children.splice(0, e.children.length, ...u), e !== this.root && this.autoExpandSingleChildren && u.length === 1 && l.length === 0 && (u[0].forceExpanded = true, l.push(u[0])), l;
        }
        render(e, t, i) {
          const n = e.children.map((r) => this.asTreeElement(r, t)), o = i && {
            ...i,
            diffIdentityProvider: i.diffIdentityProvider && {
              getId(r) {
                return i.diffIdentityProvider.getId(r.element);
              }
            }
          };
          this.tree.setChildren(e === this.root ? null : e, n, o), e !== this.root && this.tree.setCollapsible(e, e.hasChildren), this._onDidRender.fire();
        }
        asTreeElement(e, t) {
          if (e.stale) return {
            element: e,
            collapsible: e.hasChildren,
            collapsed: true
          };
          let i;
          return t && t.viewState.expanded && e.id && t.viewState.expanded.indexOf(e.id) > -1 ? i = false : e.forceExpanded ? (i = false, e.forceExpanded = false) : i = e.defaultCollapseState, {
            element: e,
            children: e.hasChildren ? kt.map(e.children, (n) => this.asTreeElement(n, t)) : [],
            collapsible: e.hasChildren,
            collapsed: i
          };
        }
        processChildren(e) {
          return this.sorter && (e = [
            ...e
          ].sort(this.sorter.compare.bind(this.sorter))), e;
        }
        dispose() {
          this.disposables.dispose(), this.tree.dispose();
        }
      }
      class TN {
        get element() {
          return {
            elements: this.node.element.elements.map((e) => e.element),
            incompressible: this.node.element.incompressible
          };
        }
        get children() {
          return this.node.children.map((e) => new TN(e));
        }
        get depth() {
          return this.node.depth;
        }
        get visibleChildrenCount() {
          return this.node.visibleChildrenCount;
        }
        get visibleChildIndex() {
          return this.node.visibleChildIndex;
        }
        get collapsible() {
          return this.node.collapsible;
        }
        get collapsed() {
          return this.node.collapsed;
        }
        get visible() {
          return this.node.visible;
        }
        get filterData() {
          return this.node.filterData;
        }
        constructor(e) {
          this.node = e;
        }
      }
      class Hoe {
        constructor(e, t, i, n) {
          this.renderer = e, this.nodeMapper = t, this.compressibleNodeMapperProvider = i, this.onDidChangeTwistieState = n, this.renderedNodes = /* @__PURE__ */ new Map(), this.disposables = [], this.templateId = e.templateId;
        }
        renderTemplate(e) {
          return {
            templateData: this.renderer.renderTemplate(e)
          };
        }
        renderElement(e, t, i, n) {
          this.renderer.renderElement(this.nodeMapper.map(e), t, i.templateData, n);
        }
        renderCompressedElements(e, t, i, n) {
          this.renderer.renderCompressedElements(this.compressibleNodeMapperProvider().map(e), t, i.templateData, n);
        }
        renderTwistie(e, t) {
          return e.slow ? (t.classList.add(...wt.asClassNameArray(Te.treeItemLoading)), true) : (t.classList.remove(...wt.asClassNameArray(Te.treeItemLoading)), false);
        }
        disposeElement(e, t, i, n) {
          var _a3, _b3;
          (_b3 = (_a3 = this.renderer).disposeElement) == null ? void 0 : _b3.call(_a3, this.nodeMapper.map(e), t, i.templateData, n);
        }
        disposeCompressedElements(e, t, i, n) {
          var _a3, _b3;
          (_b3 = (_a3 = this.renderer).disposeCompressedElements) == null ? void 0 : _b3.call(_a3, this.compressibleNodeMapperProvider().map(e), t, i.templateData, n);
        }
        disposeTemplate(e) {
          this.renderer.disposeTemplate(e.templateData);
        }
        dispose() {
          this.renderedNodes.clear(), this.disposables = On(this.disposables);
        }
      }
      function zoe(s) {
        const e = s && jB(s);
        return e && {
          ...e,
          keyboardNavigationLabelProvider: e.keyboardNavigationLabelProvider && {
            ...e.keyboardNavigationLabelProvider,
            getCompressedNodeKeyboardNavigationLabel(t) {
              return s.keyboardNavigationLabelProvider.getCompressedNodeKeyboardNavigationLabel(t.map((i) => i.element));
            }
          }
        };
      }
      class Uoe extends GB {
        constructor(e, t, i, n, o, r, a = {}) {
          super(e, t, i, o, r, a), this.compressionDelegate = n, this.compressibleNodeMapper = new yN((l) => new TN(l)), this.filter = a.filter;
        }
        createTree(e, t, i, n, o) {
          const r = new LN(i), a = n.map((u) => new Hoe(u, this.nodeMapper, () => this.compressibleNodeMapper, this._onDidChangeNodeSlowState.event)), l = zoe(o) || {};
          return new KB(e, t, r, a, l);
        }
        asTreeElement(e, t) {
          return {
            incompressible: this.compressionDelegate.isIncompressible(e.element),
            ...super.asTreeElement(e, t)
          };
        }
        updateOptions(e = {}) {
          this.tree.updateOptions(e);
        }
        render(e, t, i) {
          if (!this.identityProvider) return super.render(e, t);
          const n = (_) => this.identityProvider.getId(_).toString(), o = (_) => {
            const b = /* @__PURE__ */ new Set();
            for (const v of _) {
              const y = this.tree.getCompressedTreeNode(v === this.root ? null : v);
              if (y.element) for (const x of y.element.elements) b.add(n(x.element));
            }
            return b;
          }, r = o(this.tree.getSelection()), a = o(this.tree.getFocus());
          super.render(e, t, i);
          const l = this.getSelection();
          let u = false;
          const d = this.getFocus();
          let f = false;
          const m = (_) => {
            const b = _.element;
            if (b) for (let v = 0; v < b.elements.length; v++) {
              const y = n(b.elements[v].element), x = b.elements[b.elements.length - 1].element;
              r.has(y) && l.indexOf(x) === -1 && (l.push(x), u = true), a.has(y) && d.indexOf(x) === -1 && (d.push(x), f = true);
            }
            _.children.forEach(m);
          };
          m(this.tree.getCompressedTreeNode(e === this.root ? null : e)), u && this.setSelection(l), f && this.setFocus(d);
        }
        processChildren(e) {
          return this.filter && (e = kt.filter(e, (t) => {
            const i = this.filter.filter(t, 1), n = $oe(i);
            if (n === 2) throw new Error("Recursive tree visibility not supported in async data compressed trees");
            return n === 1;
          })), super.processChildren(e);
        }
      }
      function $oe(s) {
        return typeof s == "boolean" ? s ? 1 : 0 : SN(s) ? __(s.visibility) : __(s);
      }
      class qoe extends UB {
        constructor(e, t, i, n, o, r = {}) {
          super(e, t, i, n, r), this.user = e, this.dataSource = o, this.identityProvider = r.identityProvider;
        }
        createModel(e, t, i) {
          return new xN(e, t, i);
        }
      }
      new Ie("isMac", _t, C("isMac", "Whether the operating system is macOS"));
      new Ie("isLinux", Is, C("isLinux", "Whether the operating system is Linux"));
      new Ie("isWindows", Ks, C("isWindows", "Whether the operating system is Windows"));
      new Ie("isWeb", yg, C("isWeb", "Whether the platform is a web browser"));
      new Ie("isMacNative", _t && !yg, C("isMacNative", "Whether the operating system is macOS on a non-browser platform"));
      new Ie("isIOS", Ih, C("isIOS", "Whether the operating system is iOS"));
      new Ie("isMobile", e9, C("isMobile", "Whether the platform is a mobile web browser"));
      new Ie("isDevelopment", false, true);
      new Ie("productQualityType", "", C("productQualityType", "Quality type of VS Code"));
      const YB = "inputFocus", Koe = new Ie(YB, false, C("inputFocus", "Whether keyboard focus is inside an input box"));
      var Ql = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      }, Jt = function(s, e) {
        return function(t, i) {
          e(t, i, s);
        };
      };
      const Fa = pt("listService");
      class joe {
        get lastFocusedList() {
          return this._lastFocusedWidget;
        }
        constructor() {
          this.disposables = new Me(), this.lists = [], this._lastFocusedWidget = void 0, this._hasCreatedStyleController = false;
        }
        setLastFocusedList(e) {
          var _a3, _b3;
          e !== this._lastFocusedWidget && ((_a3 = this._lastFocusedWidget) == null ? void 0 : _a3.getHTMLElement().classList.remove("last-focused"), this._lastFocusedWidget = e, (_b3 = this._lastFocusedWidget) == null ? void 0 : _b3.getHTMLElement().classList.add("last-focused"));
        }
        register(e, t) {
          if (this._hasCreatedStyleController || (this._hasCreatedStyleController = true, new eB(Uo(), "").style(Ng)), this.lists.some((n) => n.widget === e)) throw new Error("Cannot register the same widget multiple times");
          const i = {
            widget: e,
            extraContextKeys: t
          };
          return this.lists.push(i), aT(e.getHTMLElement()) && this.setLastFocusedList(e), ka(e.onDidFocus(() => this.setLastFocusedList(e)), Ze(() => this.lists.splice(this.lists.indexOf(i), 1)), e.onDidDispose(() => {
            this.lists = this.lists.filter((n) => n !== i), this._lastFocusedWidget === e && this.setLastFocusedList(void 0);
          }));
        }
        dispose() {
          this.disposables.dispose();
        }
      }
      const b_ = new Ie("listScrollAtBoundary", "none");
      Ot.or(b_.isEqualTo("top"), b_.isEqualTo("both"));
      Ot.or(b_.isEqualTo("bottom"), b_.isEqualTo("both"));
      const ZB = new Ie("listFocus", true), QB = new Ie("treestickyScrollFocused", false), Nw = new Ie("listSupportsMultiselect", true);
      Ot.and(ZB, Ot.not(YB), QB.negate());
      const NN = new Ie("listHasSelectionOrFocus", false), IN = new Ie("listDoubleSelection", false), MN = new Ie("listMultiSelection", false), Iw = new Ie("listSelectionNavigation", false), Goe = new Ie("listSupportsFind", true), Yoe = new Ie("treeElementCanCollapse", false), Zoe = new Ie("treeElementHasParent", false), Qoe = new Ie("treeElementCanExpand", false), Xoe = new Ie("treeElementHasChild", false), Joe = new Ie("treeFindOpen", false), XB = "listTypeNavigationMode", JB = "listAutomaticKeyboardNavigation";
      function Mw(s, e) {
        const t = s.createScoped(e.getHTMLElement());
        return ZB.bindTo(t), t;
      }
      function Aw(s, e) {
        const t = b_.bindTo(s), i = () => {
          const n = e.scrollTop === 0, o = e.scrollHeight - e.renderHeight - e.scrollTop < 1;
          n && o ? t.set("both") : n ? t.set("top") : o ? t.set("bottom") : t.set("none");
        };
        return i(), e.onDidScroll(i);
      }
      const id = "workbench.list.multiSelectModifier", O0 = "workbench.list.openMode", Wo = "workbench.list.horizontalScrolling", AN = "workbench.list.defaultFindMode", RN = "workbench.list.typeNavigationMode", Zv = "workbench.list.keyboardNavigation", jr = "workbench.list.scrollByPage", ON = "workbench.list.defaultFindMatchType", v_ = "workbench.tree.indent", Qv = "workbench.tree.renderIndentGuides", Gr = "workbench.list.smoothScrolling", Ma = "workbench.list.mouseWheelScrollSensitivity", Aa = "workbench.list.fastScrollSensitivity", Xv = "workbench.tree.expandMode", Jv = "workbench.tree.enableStickyScroll", eC = "workbench.tree.stickyScrollMaxItemCount";
      function Ra(s) {
        return s.getValue(id) === "alt";
      }
      class ere extends he {
        constructor(e) {
          super(), this.configurationService = e, this.useAltAsMultipleSelectionModifier = Ra(e), this.registerListeners();
        }
        registerListeners() {
          this._register(this.configurationService.onDidChangeConfiguration((e) => {
            e.affectsConfiguration(id) && (this.useAltAsMultipleSelectionModifier = Ra(this.configurationService));
          }));
        }
        isSelectionSingleChangeEvent(e) {
          return this.useAltAsMultipleSelectionModifier ? e.browserEvent.altKey : Q6(e);
        }
        isSelectionRangeChangeEvent(e) {
          return X6(e);
        }
      }
      function Rw(s, e) {
        const t = s.get(Si), i = s.get(Pn), n = new Me();
        return [
          {
            ...e,
            keyboardNavigationDelegate: {
              mightProducePrintableCharacter(r) {
                return i.mightProducePrintableCharacter(r);
              }
            },
            smoothScrolling: !!t.getValue(Gr),
            mouseWheelScrollSensitivity: t.getValue(Ma),
            fastScrollSensitivity: t.getValue(Aa),
            multipleSelectionController: e.multipleSelectionController ?? n.add(new ere(t)),
            keyboardNavigationEventFilter: nre(i),
            scrollByPage: !!t.getValue(jr)
          },
          n
        ];
      }
      let i3 = class extends ta {
        constructor(e, t, i, n, o, r, a, l, u) {
          const d = typeof o.horizontalScrolling < "u" ? o.horizontalScrolling : !!l.getValue(Wo), [f, m] = u.invokeFunction(Rw, o);
          super(e, t, i, n, {
            keyboardSupport: false,
            ...f,
            horizontalScrolling: d
          }), this.disposables.add(m), this.contextKeyService = Mw(r, this), this.disposables.add(Aw(this.contextKeyService, this)), this.listSupportsMultiSelect = Nw.bindTo(this.contextKeyService), this.listSupportsMultiSelect.set(o.multipleSelectionSupport !== false), Iw.bindTo(this.contextKeyService).set(!!o.selectionNavigation), this.listHasSelectionOrFocus = NN.bindTo(this.contextKeyService), this.listDoubleSelection = IN.bindTo(this.contextKeyService), this.listMultiSelection = MN.bindTo(this.contextKeyService), this.horizontalScrolling = o.horizontalScrolling, this._useAltAsMultipleSelectionModifier = Ra(l), this.disposables.add(this.contextKeyService), this.disposables.add(a.register(this)), this.updateStyles(o.overrideStyles), this.disposables.add(this.onDidChangeSelection(() => {
            const b = this.getSelection(), v = this.getFocus();
            this.contextKeyService.bufferChangeEvents(() => {
              this.listHasSelectionOrFocus.set(b.length > 0 || v.length > 0), this.listMultiSelection.set(b.length > 1), this.listDoubleSelection.set(b.length === 2);
            });
          })), this.disposables.add(this.onDidChangeFocus(() => {
            const b = this.getSelection(), v = this.getFocus();
            this.listHasSelectionOrFocus.set(b.length > 0 || v.length > 0);
          })), this.disposables.add(l.onDidChangeConfiguration((b) => {
            b.affectsConfiguration(id) && (this._useAltAsMultipleSelectionModifier = Ra(l));
            let v = {};
            if (b.affectsConfiguration(Wo) && this.horizontalScrolling === void 0) {
              const y = !!l.getValue(Wo);
              v = {
                ...v,
                horizontalScrolling: y
              };
            }
            if (b.affectsConfiguration(jr)) {
              const y = !!l.getValue(jr);
              v = {
                ...v,
                scrollByPage: y
              };
            }
            if (b.affectsConfiguration(Gr)) {
              const y = !!l.getValue(Gr);
              v = {
                ...v,
                smoothScrolling: y
              };
            }
            if (b.affectsConfiguration(Ma)) {
              const y = l.getValue(Ma);
              v = {
                ...v,
                mouseWheelScrollSensitivity: y
              };
            }
            if (b.affectsConfiguration(Aa)) {
              const y = l.getValue(Aa);
              v = {
                ...v,
                fastScrollSensitivity: y
              };
            }
            Object.keys(v).length > 0 && this.updateOptions(v);
          })), this.navigator = new eF(this, {
            configurationService: l,
            ...o
          }), this.disposables.add(this.navigator);
        }
        updateOptions(e) {
          super.updateOptions(e), e.overrideStyles !== void 0 && this.updateStyles(e.overrideStyles), e.multipleSelectionSupport !== void 0 && this.listSupportsMultiSelect.set(!!e.multipleSelectionSupport);
        }
        updateStyles(e) {
          this.style(e ? i1(e) : Ng);
        }
      };
      i3 = Ql([
        Jt(5, Mt),
        Jt(6, Fa),
        Jt(7, Si),
        Jt(8, Ft)
      ], i3);
      let n3 = class extends toe {
        constructor(e, t, i, n, o, r, a, l, u) {
          const d = typeof o.horizontalScrolling < "u" ? o.horizontalScrolling : !!l.getValue(Wo), [f, m] = u.invokeFunction(Rw, o);
          super(e, t, i, n, {
            keyboardSupport: false,
            ...f,
            horizontalScrolling: d
          }), this.disposables = new Me(), this.disposables.add(m), this.contextKeyService = Mw(r, this), this.disposables.add(Aw(this.contextKeyService, this.widget)), this.horizontalScrolling = o.horizontalScrolling, this.listSupportsMultiSelect = Nw.bindTo(this.contextKeyService), this.listSupportsMultiSelect.set(o.multipleSelectionSupport !== false), Iw.bindTo(this.contextKeyService).set(!!o.selectionNavigation), this._useAltAsMultipleSelectionModifier = Ra(l), this.disposables.add(this.contextKeyService), this.disposables.add(a.register(this)), this.updateStyles(o.overrideStyles), this.disposables.add(l.onDidChangeConfiguration((b) => {
            b.affectsConfiguration(id) && (this._useAltAsMultipleSelectionModifier = Ra(l));
            let v = {};
            if (b.affectsConfiguration(Wo) && this.horizontalScrolling === void 0) {
              const y = !!l.getValue(Wo);
              v = {
                ...v,
                horizontalScrolling: y
              };
            }
            if (b.affectsConfiguration(jr)) {
              const y = !!l.getValue(jr);
              v = {
                ...v,
                scrollByPage: y
              };
            }
            if (b.affectsConfiguration(Gr)) {
              const y = !!l.getValue(Gr);
              v = {
                ...v,
                smoothScrolling: y
              };
            }
            if (b.affectsConfiguration(Ma)) {
              const y = l.getValue(Ma);
              v = {
                ...v,
                mouseWheelScrollSensitivity: y
              };
            }
            if (b.affectsConfiguration(Aa)) {
              const y = l.getValue(Aa);
              v = {
                ...v,
                fastScrollSensitivity: y
              };
            }
            Object.keys(v).length > 0 && this.updateOptions(v);
          })), this.navigator = new eF(this, {
            configurationService: l,
            ...o
          }), this.disposables.add(this.navigator);
        }
        updateOptions(e) {
          super.updateOptions(e), e.overrideStyles !== void 0 && this.updateStyles(e.overrideStyles), e.multipleSelectionSupport !== void 0 && this.listSupportsMultiSelect.set(!!e.multipleSelectionSupport);
        }
        updateStyles(e) {
          this.style(e ? i1(e) : Ng);
        }
        dispose() {
          this.disposables.dispose(), super.dispose();
        }
      };
      n3 = Ql([
        Jt(5, Mt),
        Jt(6, Fa),
        Jt(7, Si),
        Jt(8, Ft)
      ], n3);
      let s3 = class extends wN {
        constructor(e, t, i, n, o, r, a, l, u, d) {
          const f = typeof r.horizontalScrolling < "u" ? r.horizontalScrolling : !!u.getValue(Wo), [m, _] = d.invokeFunction(Rw, r);
          super(e, t, i, n, o, {
            keyboardSupport: false,
            ...m,
            horizontalScrolling: f
          }), this.disposables.add(_), this.contextKeyService = Mw(a, this), this.disposables.add(Aw(this.contextKeyService, this)), this.listSupportsMultiSelect = Nw.bindTo(this.contextKeyService), this.listSupportsMultiSelect.set(r.multipleSelectionSupport !== false), Iw.bindTo(this.contextKeyService).set(!!r.selectionNavigation), this.listHasSelectionOrFocus = NN.bindTo(this.contextKeyService), this.listDoubleSelection = IN.bindTo(this.contextKeyService), this.listMultiSelection = MN.bindTo(this.contextKeyService), this.horizontalScrolling = r.horizontalScrolling, this._useAltAsMultipleSelectionModifier = Ra(u), this.disposables.add(this.contextKeyService), this.disposables.add(l.register(this)), this.updateStyles(r.overrideStyles), this.disposables.add(this.onDidChangeSelection(() => {
            const v = this.getSelection(), y = this.getFocus();
            this.contextKeyService.bufferChangeEvents(() => {
              this.listHasSelectionOrFocus.set(v.length > 0 || y.length > 0), this.listMultiSelection.set(v.length > 1), this.listDoubleSelection.set(v.length === 2);
            });
          })), this.disposables.add(this.onDidChangeFocus(() => {
            const v = this.getSelection(), y = this.getFocus();
            this.listHasSelectionOrFocus.set(v.length > 0 || y.length > 0);
          })), this.disposables.add(u.onDidChangeConfiguration((v) => {
            v.affectsConfiguration(id) && (this._useAltAsMultipleSelectionModifier = Ra(u));
            let y = {};
            if (v.affectsConfiguration(Wo) && this.horizontalScrolling === void 0) {
              const x = !!u.getValue(Wo);
              y = {
                ...y,
                horizontalScrolling: x
              };
            }
            if (v.affectsConfiguration(jr)) {
              const x = !!u.getValue(jr);
              y = {
                ...y,
                scrollByPage: x
              };
            }
            if (v.affectsConfiguration(Gr)) {
              const x = !!u.getValue(Gr);
              y = {
                ...y,
                smoothScrolling: x
              };
            }
            if (v.affectsConfiguration(Ma)) {
              const x = u.getValue(Ma);
              y = {
                ...y,
                mouseWheelScrollSensitivity: x
              };
            }
            if (v.affectsConfiguration(Aa)) {
              const x = u.getValue(Aa);
              y = {
                ...y,
                fastScrollSensitivity: x
              };
            }
            Object.keys(y).length > 0 && this.updateOptions(y);
          })), this.navigator = new tre(this, {
            configurationService: u,
            ...r
          }), this.disposables.add(this.navigator);
        }
        updateOptions(e) {
          super.updateOptions(e), e.overrideStyles !== void 0 && this.updateStyles(e.overrideStyles), e.multipleSelectionSupport !== void 0 && this.listSupportsMultiSelect.set(!!e.multipleSelectionSupport);
        }
        updateStyles(e) {
          this.style(e ? i1(e) : Ng);
        }
        dispose() {
          this.disposables.dispose(), super.dispose();
        }
      };
      s3 = Ql([
        Jt(6, Mt),
        Jt(7, Fa),
        Jt(8, Si),
        Jt(9, Ft)
      ], s3);
      class PN extends he {
        constructor(e, t) {
          super(), this.widget = e, this._onDidOpen = this._register(new G()), this.onDidOpen = this._onDidOpen.event, this._register(be.filter(this.widget.onDidChangeSelection, (i) => Cl(i.browserEvent))((i) => this.onSelectionFromKeyboard(i))), this._register(this.widget.onPointer((i) => this.onPointer(i.element, i.browserEvent))), this._register(this.widget.onMouseDblClick((i) => this.onMouseDblClick(i.element, i.browserEvent))), typeof (t == null ? void 0 : t.openOnSingleClick) != "boolean" && (t == null ? void 0 : t.configurationService) ? (this.openOnSingleClick = (t == null ? void 0 : t.configurationService.getValue(O0)) !== "doubleClick", this._register(t == null ? void 0 : t.configurationService.onDidChangeConfiguration((i) => {
            i.affectsConfiguration(O0) && (this.openOnSingleClick = (t == null ? void 0 : t.configurationService.getValue(O0)) !== "doubleClick");
          }))) : this.openOnSingleClick = (t == null ? void 0 : t.openOnSingleClick) ?? true;
        }
        onSelectionFromKeyboard(e) {
          if (e.elements.length !== 1) return;
          const t = e.browserEvent, i = typeof t.preserveFocus == "boolean" ? t.preserveFocus : true, n = typeof t.pinned == "boolean" ? t.pinned : !i;
          this._open(this.getSelectedElement(), i, n, false, e.browserEvent);
        }
        onPointer(e, t) {
          if (!this.openOnSingleClick || t.detail === 2) return;
          const n = t.button === 1, o = true, r = n, a = t.ctrlKey || t.metaKey || t.altKey;
          this._open(e, o, r, a, t);
        }
        onMouseDblClick(e, t) {
          if (!t) return;
          const i = t.target;
          if (i.classList.contains("monaco-tl-twistie") || i.classList.contains("monaco-icon-label") && i.classList.contains("folder-icon") && t.offsetX < 16) return;
          const o = false, r = true, a = t.ctrlKey || t.metaKey || t.altKey;
          this._open(e, o, r, a, t);
        }
        _open(e, t, i, n, o) {
          e && this._onDidOpen.fire({
            editorOptions: {
              preserveFocus: t,
              pinned: i,
              revealIfVisible: true
            },
            sideBySide: n,
            element: e,
            browserEvent: o
          });
        }
      }
      class eF extends PN {
        constructor(e, t) {
          super(e, t), this.widget = e;
        }
        getSelectedElement() {
          return this.widget.getSelectedElements()[0];
        }
      }
      class tre extends PN {
        constructor(e, t) {
          super(e, t);
        }
        getSelectedElement() {
          return this.widget.getSelectedElements()[0];
        }
      }
      class ire extends PN {
        constructor(e, t) {
          super(e, t);
        }
        getSelectedElement() {
          return this.widget.getSelection()[0] ?? void 0;
        }
      }
      function nre(s) {
        let e = false;
        return (t) => {
          if (t.toKeyCodeChord().isModifierKey()) return false;
          if (e) return e = false, false;
          const i = s.softDispatch(t, t.target);
          return i.kind === 1 ? (e = true, false) : (e = false, i.kind === 0);
        };
      }
      let C2 = class extends DN {
        constructor(e, t, i, n, o, r, a, l, u) {
          const { options: d, getTypeNavigationMode: f, disposable: m } = r.invokeFunction(r1, o);
          super(e, t, i, n, d), this.disposables.add(m), this.internals = new Wh(this, o, f, o.overrideStyles, a, l, u), this.disposables.add(this.internals);
        }
        updateOptions(e) {
          super.updateOptions(e), this.internals.updateOptions(e);
        }
      };
      C2 = Ql([
        Jt(5, Ft),
        Jt(6, Mt),
        Jt(7, Fa),
        Jt(8, Si)
      ], C2);
      let o3 = class extends KB {
        constructor(e, t, i, n, o, r, a, l, u) {
          const { options: d, getTypeNavigationMode: f, disposable: m } = r.invokeFunction(r1, o);
          super(e, t, i, n, d), this.disposables.add(m), this.internals = new Wh(this, o, f, o.overrideStyles, a, l, u), this.disposables.add(this.internals);
        }
        updateOptions(e = {}) {
          super.updateOptions(e), e.overrideStyles && this.internals.updateStyleOverrides(e.overrideStyles), this.internals.updateOptions(e);
        }
      };
      o3 = Ql([
        Jt(5, Ft),
        Jt(6, Mt),
        Jt(7, Fa),
        Jt(8, Si)
      ], o3);
      let r3 = class extends qoe {
        constructor(e, t, i, n, o, r, a, l, u, d) {
          const { options: f, getTypeNavigationMode: m, disposable: _ } = a.invokeFunction(r1, r);
          super(e, t, i, n, o, f), this.disposables.add(_), this.internals = new Wh(this, r, m, r.overrideStyles, l, u, d), this.disposables.add(this.internals);
        }
        updateOptions(e = {}) {
          super.updateOptions(e), e.overrideStyles !== void 0 && this.internals.updateStyleOverrides(e.overrideStyles), this.internals.updateOptions(e);
        }
      };
      r3 = Ql([
        Jt(6, Ft),
        Jt(7, Mt),
        Jt(8, Fa),
        Jt(9, Si)
      ], r3);
      let a3 = class extends GB {
        get onDidOpen() {
          return this.internals.onDidOpen;
        }
        constructor(e, t, i, n, o, r, a, l, u, d) {
          const { options: f, getTypeNavigationMode: m, disposable: _ } = a.invokeFunction(r1, r);
          super(e, t, i, n, o, f), this.disposables.add(_), this.internals = new Wh(this, r, m, r.overrideStyles, l, u, d), this.disposables.add(this.internals);
        }
        updateOptions(e = {}) {
          super.updateOptions(e), e.overrideStyles && this.internals.updateStyleOverrides(e.overrideStyles), this.internals.updateOptions(e);
        }
      };
      a3 = Ql([
        Jt(6, Ft),
        Jt(7, Mt),
        Jt(8, Fa),
        Jt(9, Si)
      ], a3);
      let l3 = class extends Uoe {
        constructor(e, t, i, n, o, r, a, l, u, d, f) {
          const { options: m, getTypeNavigationMode: _, disposable: b } = l.invokeFunction(r1, a);
          super(e, t, i, n, o, r, m), this.disposables.add(b), this.internals = new Wh(this, a, _, a.overrideStyles, u, d, f), this.disposables.add(this.internals);
        }
        updateOptions(e) {
          super.updateOptions(e), this.internals.updateOptions(e);
        }
      };
      l3 = Ql([
        Jt(7, Ft),
        Jt(8, Mt),
        Jt(9, Fa),
        Jt(10, Si)
      ], l3);
      function tF(s) {
        const e = s.getValue(AN);
        if (e === "highlight") return Ml.Highlight;
        if (e === "filter") return Ml.Filter;
        const t = s.getValue(Zv);
        if (t === "simple" || t === "highlight") return Ml.Highlight;
        if (t === "filter") return Ml.Filter;
      }
      function iF(s) {
        const e = s.getValue(ON);
        if (e === "fuzzy") return Vh.Fuzzy;
        if (e === "contiguous") return Vh.Contiguous;
      }
      function r1(s, e) {
        const t = s.get(Si), i = s.get(Q_), n = s.get(Mt), o = s.get(Ft), r = () => {
          const m = n.getContextKeyValue(XB);
          if (m === "automatic") return xa.Automatic;
          if (m === "trigger" || n.getContextKeyValue(JB) === false) return xa.Trigger;
          const b = t.getValue(RN);
          if (b === "automatic") return xa.Automatic;
          if (b === "trigger") return xa.Trigger;
        }, a = e.horizontalScrolling !== void 0 ? e.horizontalScrolling : !!t.getValue(Wo), [l, u] = o.invokeFunction(Rw, e), d = e.paddingBottom, f = e.renderIndentGuides !== void 0 ? e.renderIndentGuides : t.getValue(Qv);
        return {
          getTypeNavigationMode: r,
          disposable: u,
          options: {
            keyboardSupport: false,
            ...l,
            indent: typeof t.getValue(v_) == "number" ? t.getValue(v_) : void 0,
            renderIndentGuides: f,
            smoothScrolling: !!t.getValue(Gr),
            defaultFindMode: tF(t),
            defaultFindMatchType: iF(t),
            horizontalScrolling: a,
            scrollByPage: !!t.getValue(jr),
            paddingBottom: d,
            hideTwistiesOfChildlessElements: e.hideTwistiesOfChildlessElements,
            expandOnlyOnTwistieClick: e.expandOnlyOnTwistieClick ?? t.getValue(Xv) === "doubleClick",
            contextViewProvider: i,
            findWidgetStyles: Kte,
            enableStickyScroll: !!t.getValue(Jv),
            stickyScrollMaxItemCount: Number(t.getValue(eC))
          }
        };
      }
      let Wh = class {
        get onDidOpen() {
          return this.navigator.onDidOpen;
        }
        constructor(e, t, i, n, o, r, a) {
          this.tree = e, this.disposables = [], this.contextKeyService = Mw(o, e), this.disposables.push(Aw(this.contextKeyService, e)), this.listSupportsMultiSelect = Nw.bindTo(this.contextKeyService), this.listSupportsMultiSelect.set(t.multipleSelectionSupport !== false), Iw.bindTo(this.contextKeyService).set(!!t.selectionNavigation), this.listSupportFindWidget = Goe.bindTo(this.contextKeyService), this.listSupportFindWidget.set(t.findWidgetEnabled ?? true), this.hasSelectionOrFocus = NN.bindTo(this.contextKeyService), this.hasDoubleSelection = IN.bindTo(this.contextKeyService), this.hasMultiSelection = MN.bindTo(this.contextKeyService), this.treeElementCanCollapse = Yoe.bindTo(this.contextKeyService), this.treeElementHasParent = Zoe.bindTo(this.contextKeyService), this.treeElementCanExpand = Qoe.bindTo(this.contextKeyService), this.treeElementHasChild = Xoe.bindTo(this.contextKeyService), this.treeFindOpen = Joe.bindTo(this.contextKeyService), this.treeStickyScrollFocused = QB.bindTo(this.contextKeyService), this._useAltAsMultipleSelectionModifier = Ra(a), this.updateStyleOverrides(n);
          const u = () => {
            const f = e.getFocus()[0];
            if (!f) return;
            const m = e.getNode(f);
            this.treeElementCanCollapse.set(m.collapsible && !m.collapsed), this.treeElementHasParent.set(!!e.getParentElement(f)), this.treeElementCanExpand.set(m.collapsible && m.collapsed), this.treeElementHasChild.set(!!e.getFirstElementChild(f));
          }, d = /* @__PURE__ */ new Set();
          d.add(XB), d.add(JB), this.disposables.push(this.contextKeyService, r.register(e), e.onDidChangeSelection(() => {
            const f = e.getSelection(), m = e.getFocus();
            this.contextKeyService.bufferChangeEvents(() => {
              this.hasSelectionOrFocus.set(f.length > 0 || m.length > 0), this.hasMultiSelection.set(f.length > 1), this.hasDoubleSelection.set(f.length === 2);
            });
          }), e.onDidChangeFocus(() => {
            const f = e.getSelection(), m = e.getFocus();
            this.hasSelectionOrFocus.set(f.length > 0 || m.length > 0), u();
          }), e.onDidChangeCollapseState(u), e.onDidChangeModel(u), e.onDidChangeFindOpenState((f) => this.treeFindOpen.set(f)), e.onDidChangeStickyScrollFocused((f) => this.treeStickyScrollFocused.set(f)), a.onDidChangeConfiguration((f) => {
            let m = {};
            if (f.affectsConfiguration(id) && (this._useAltAsMultipleSelectionModifier = Ra(a)), f.affectsConfiguration(v_)) {
              const _ = a.getValue(v_);
              m = {
                ...m,
                indent: _
              };
            }
            if (f.affectsConfiguration(Qv) && t.renderIndentGuides === void 0) {
              const _ = a.getValue(Qv);
              m = {
                ...m,
                renderIndentGuides: _
              };
            }
            if (f.affectsConfiguration(Gr)) {
              const _ = !!a.getValue(Gr);
              m = {
                ...m,
                smoothScrolling: _
              };
            }
            if (f.affectsConfiguration(AN) || f.affectsConfiguration(Zv)) {
              const _ = tF(a);
              m = {
                ...m,
                defaultFindMode: _
              };
            }
            if (f.affectsConfiguration(RN) || f.affectsConfiguration(Zv)) {
              const _ = i();
              m = {
                ...m,
                typeNavigationMode: _
              };
            }
            if (f.affectsConfiguration(ON)) {
              const _ = iF(a);
              m = {
                ...m,
                defaultFindMatchType: _
              };
            }
            if (f.affectsConfiguration(Wo) && t.horizontalScrolling === void 0) {
              const _ = !!a.getValue(Wo);
              m = {
                ...m,
                horizontalScrolling: _
              };
            }
            if (f.affectsConfiguration(jr)) {
              const _ = !!a.getValue(jr);
              m = {
                ...m,
                scrollByPage: _
              };
            }
            if (f.affectsConfiguration(Xv) && t.expandOnlyOnTwistieClick === void 0 && (m = {
              ...m,
              expandOnlyOnTwistieClick: a.getValue(Xv) === "doubleClick"
            }), f.affectsConfiguration(Jv)) {
              const _ = a.getValue(Jv);
              m = {
                ...m,
                enableStickyScroll: _
              };
            }
            if (f.affectsConfiguration(eC)) {
              const _ = Math.max(1, a.getValue(eC));
              m = {
                ...m,
                stickyScrollMaxItemCount: _
              };
            }
            if (f.affectsConfiguration(Ma)) {
              const _ = a.getValue(Ma);
              m = {
                ...m,
                mouseWheelScrollSensitivity: _
              };
            }
            if (f.affectsConfiguration(Aa)) {
              const _ = a.getValue(Aa);
              m = {
                ...m,
                fastScrollSensitivity: _
              };
            }
            Object.keys(m).length > 0 && e.updateOptions(m);
          }), this.contextKeyService.onDidChangeContext((f) => {
            f.affectsSome(d) && e.updateOptions({
              typeNavigationMode: i()
            });
          })), this.navigator = new ire(e, {
            configurationService: a,
            ...t
          }), this.disposables.push(this.navigator);
        }
        updateOptions(e) {
          e.multipleSelectionSupport !== void 0 && this.listSupportsMultiSelect.set(!!e.multipleSelectionSupport);
        }
        updateStyleOverrides(e) {
          this.tree.style(e ? i1(e) : Ng);
        }
        dispose() {
          this.disposables = On(this.disposables);
        }
      };
      Wh = Ql([
        Jt(4, Mt),
        Jt(5, Fa),
        Jt(6, Si)
      ], Wh);
      const sre = yn.as(Jh.Configuration);
      sre.registerConfiguration({
        id: "workbench",
        order: 7,
        title: C("workbenchConfigurationTitle", "Workbench"),
        type: "object",
        properties: {
          [id]: {
            type: "string",
            enum: [
              "ctrlCmd",
              "alt"
            ],
            markdownEnumDescriptions: [
              C("multiSelectModifier.ctrlCmd", "Maps to `Control` on Windows and Linux and to `Command` on macOS."),
              C("multiSelectModifier.alt", "Maps to `Alt` on Windows and Linux and to `Option` on macOS.")
            ],
            default: "ctrlCmd",
            description: C({
              key: "multiSelectModifier",
              comment: [
                "- `ctrlCmd` refers to a value the setting can take and should not be localized.",
                "- `Control` and `Command` refer to the modifier keys Ctrl or Cmd on the keyboard and can be localized."
              ]
            }, "The modifier to be used to add an item in trees and lists to a multi-selection with the mouse (for example in the explorer, open editors and scm view). The 'Open to Side' mouse gestures - if supported - will adapt such that they do not conflict with the multiselect modifier.")
          },
          [O0]: {
            type: "string",
            enum: [
              "singleClick",
              "doubleClick"
            ],
            default: "singleClick",
            description: C({
              key: "openModeModifier",
              comment: [
                "`singleClick` and `doubleClick` refers to a value the setting can take and should not be localized."
              ]
            }, "Controls how to open items in trees and lists using the mouse (if supported). Note that some trees and lists might choose to ignore this setting if it is not applicable.")
          },
          [Wo]: {
            type: "boolean",
            default: false,
            description: C("horizontalScrolling setting", "Controls whether lists and trees support horizontal scrolling in the workbench. Warning: turning on this setting has a performance implication.")
          },
          [jr]: {
            type: "boolean",
            default: false,
            description: C("list.scrollByPage", "Controls whether clicks in the scrollbar scroll page by page.")
          },
          [v_]: {
            type: "number",
            default: 8,
            minimum: 4,
            maximum: 40,
            description: C("tree indent setting", "Controls tree indentation in pixels.")
          },
          [Qv]: {
            type: "string",
            enum: [
              "none",
              "onHover",
              "always"
            ],
            default: "onHover",
            description: C("render tree indent guides", "Controls whether the tree should render indent guides.")
          },
          [Gr]: {
            type: "boolean",
            default: false,
            description: C("list smoothScrolling setting", "Controls whether lists and trees have smooth scrolling.")
          },
          [Ma]: {
            type: "number",
            default: 1,
            markdownDescription: C("Mouse Wheel Scroll Sensitivity", "A multiplier to be used on the `deltaX` and `deltaY` of mouse wheel scroll events.")
          },
          [Aa]: {
            type: "number",
            default: 5,
            markdownDescription: C("Fast Scroll Sensitivity", "Scrolling speed multiplier when pressing `Alt`.")
          },
          [AN]: {
            type: "string",
            enum: [
              "highlight",
              "filter"
            ],
            enumDescriptions: [
              C("defaultFindModeSettingKey.highlight", "Highlight elements when searching. Further up and down navigation will traverse only the highlighted elements."),
              C("defaultFindModeSettingKey.filter", "Filter elements when searching.")
            ],
            default: "highlight",
            description: C("defaultFindModeSettingKey", "Controls the default find mode for lists and trees in the workbench.")
          },
          [Zv]: {
            type: "string",
            enum: [
              "simple",
              "highlight",
              "filter"
            ],
            enumDescriptions: [
              C("keyboardNavigationSettingKey.simple", "Simple keyboard navigation focuses elements which match the keyboard input. Matching is done only on prefixes."),
              C("keyboardNavigationSettingKey.highlight", "Highlight keyboard navigation highlights elements which match the keyboard input. Further up and down navigation will traverse only the highlighted elements."),
              C("keyboardNavigationSettingKey.filter", "Filter keyboard navigation will filter out and hide all the elements which do not match the keyboard input.")
            ],
            default: "highlight",
            description: C("keyboardNavigationSettingKey", "Controls the keyboard navigation style for lists and trees in the workbench. Can be simple, highlight and filter."),
            deprecated: true,
            deprecationMessage: C("keyboardNavigationSettingKeyDeprecated", "Please use 'workbench.list.defaultFindMode' and	'workbench.list.typeNavigationMode' instead.")
          },
          [ON]: {
            type: "string",
            enum: [
              "fuzzy",
              "contiguous"
            ],
            enumDescriptions: [
              C("defaultFindMatchTypeSettingKey.fuzzy", "Use fuzzy matching when searching."),
              C("defaultFindMatchTypeSettingKey.contiguous", "Use contiguous matching when searching.")
            ],
            default: "fuzzy",
            description: C("defaultFindMatchTypeSettingKey", "Controls the type of matching used when searching lists and trees in the workbench.")
          },
          [Xv]: {
            type: "string",
            enum: [
              "singleClick",
              "doubleClick"
            ],
            default: "singleClick",
            description: C("expand mode", "Controls how tree folders are expanded when clicking the folder names. Note that some trees and lists might choose to ignore this setting if it is not applicable.")
          },
          [Jv]: {
            type: "boolean",
            default: true,
            description: C("sticky scroll", "Controls whether sticky scrolling is enabled in trees.")
          },
          [eC]: {
            type: "number",
            minimum: 1,
            default: 7,
            markdownDescription: C("sticky scroll maximum items", "Controls the number of sticky elements displayed in the tree when {0} is enabled.", "`#workbench.tree.enableStickyScroll#`")
          },
          [RN]: {
            type: "string",
            enum: [
              "automatic",
              "trigger"
            ],
            default: "automatic",
            markdownDescription: C("typeNavigationMode2", "Controls how type navigation works in lists and trees in the workbench. When set to `trigger`, type navigation begins once the `list.triggerTypeNavigation` command is run.")
          }
        }
      });
      class kh extends he {
        constructor(e, t) {
          super(), this.options = t, this.text = "", this.title = "", this.highlights = [], this.didEverRender = false, this.supportIcons = (t == null ? void 0 : t.supportIcons) ?? false, this.domNode = Ne(e, He("span.monaco-highlighted-label"));
        }
        get element() {
          return this.domNode;
        }
        set(e, t = [], i = "", n) {
          e || (e = ""), n && (e = kh.escapeNewLines(e, t)), !(this.didEverRender && this.text === e && this.title === i && $s(this.highlights, t)) && (this.text = e, this.title = i, this.highlights = t, this.render());
        }
        render() {
          var _a3, _b3, _c2;
          const e = [];
          let t = 0;
          for (const i of this.highlights) {
            if (i.end === i.start) continue;
            if (t < i.start) {
              const r = this.text.substring(t, i.start);
              this.supportIcons ? e.push(...wh(r)) : e.push(r), t = i.start;
            }
            const n = this.text.substring(t, i.end), o = He("span.highlight", void 0, ...this.supportIcons ? wh(n) : [
              n
            ]);
            i.extraClasses && o.classList.add(...i.extraClasses), e.push(o), t = i.end;
          }
          if (t < this.text.length) {
            const i = this.text.substring(t);
            this.supportIcons ? e.push(...wh(i)) : e.push(i);
          }
          if (gs(this.domNode, ...e), (_b3 = (_a3 = this.options) == null ? void 0 : _a3.hoverDelegate) == null ? void 0 : _b3.showNativeHover) this.domNode.title = this.title;
          else if (!this.customHover && this.title !== "") {
            const i = ((_c2 = this.options) == null ? void 0 : _c2.hoverDelegate) ?? $o("mouse");
            this.customHover = this._register(Ba().setupManagedHover(i, this.domNode, this.title));
          } else this.customHover && this.customHover.update(this.title);
          this.didEverRender = true;
        }
        static escapeNewLines(e, t) {
          let i = 0, n = 0;
          return e.replace(/\r\n|\r|\n/g, (o, r) => {
            n = o === `\r
` ? -1 : 0, r += i;
            for (const a of t) a.end <= r || (a.start >= r && (a.start += n), a.end >= r && (a.end += n));
            return i += n, "\u23CE";
          });
        }
      }
      class Km {
        constructor(e) {
          this._element = e;
        }
        get element() {
          return this._element;
        }
        set textContent(e) {
          this.disposed || e === this._textContent || (this._textContent = e, this._element.textContent = e);
        }
        set classNames(e) {
          this.disposed || $s(e, this._classNames) || (this._classNames = e, this._element.classList.value = "", this._element.classList.add(...e));
        }
        set empty(e) {
          this.disposed || e === this._empty || (this._empty = e, this._element.style.marginLeft = e ? "0" : "");
        }
        dispose() {
          this.disposed = true;
        }
      }
      class c3 extends he {
        constructor(e, t) {
          super(), this.customHovers = /* @__PURE__ */ new Map(), this.creationOptions = t, this.domNode = this._register(new Km(Ne(e, He(".monaco-icon-label")))), this.labelContainer = Ne(this.domNode.element, He(".monaco-icon-label-container")), this.nameContainer = Ne(this.labelContainer, He("span.monaco-icon-name-container")), (t == null ? void 0 : t.supportHighlights) || (t == null ? void 0 : t.supportIcons) ? this.nameNode = this._register(new are(this.nameContainer, !!t.supportIcons)) : this.nameNode = new ore(this.nameContainer), this.hoverDelegate = (t == null ? void 0 : t.hoverDelegate) ?? $o("mouse");
        }
        get element() {
          return this.domNode.element;
        }
        setLabel(e, t, i) {
          const n = [
            "monaco-icon-label"
          ], o = [
            "monaco-icon-label-container"
          ];
          let r = "";
          i && (i.extraClasses && n.push(...i.extraClasses), i.italic && n.push("italic"), i.strikethrough && n.push("strikethrough"), i.disabledCommand && o.push("disabled"), i.title && (typeof i.title == "string" ? r += i.title : r += e));
          const a = this.domNode.element.querySelector(".monaco-icon-label-iconpath");
          if (i == null ? void 0 : i.iconPath) {
            let l;
            !a || !wn(a) ? (l = He(".monaco-icon-label-iconpath"), this.domNode.element.prepend(l)) : l = a, l.style.backgroundImage = ql(i == null ? void 0 : i.iconPath);
          } else a && a.remove();
          if (this.domNode.classNames = n, this.domNode.element.setAttribute("aria-label", r), this.labelContainer.classList.value = "", this.labelContainer.classList.add(...o), this.setupHover((i == null ? void 0 : i.descriptionTitle) ? this.labelContainer : this.element, i == null ? void 0 : i.title), this.nameNode.setLabel(e, i), t || this.descriptionNode) {
            const l = this.getOrCreateDescriptionNode();
            l instanceof kh ? (l.set(t || "", i ? i.descriptionMatches : void 0, void 0, i == null ? void 0 : i.labelEscapeNewLines), this.setupHover(l.element, i == null ? void 0 : i.descriptionTitle)) : (l.textContent = t && (i == null ? void 0 : i.labelEscapeNewLines) ? kh.escapeNewLines(t, []) : t || "", this.setupHover(l.element, (i == null ? void 0 : i.descriptionTitle) || ""), l.empty = !t);
          }
          if ((i == null ? void 0 : i.suffix) || this.suffixNode) {
            const l = this.getOrCreateSuffixNode();
            l.textContent = (i == null ? void 0 : i.suffix) ?? "";
          }
        }
        setupHover(e, t) {
          const i = this.customHovers.get(e);
          if (i && (i.dispose(), this.customHovers.delete(e)), !t) {
            e.removeAttribute("title");
            return;
          }
          if (this.hoverDelegate.showNativeHover) (function(o, r) {
            ho(r) ? o.title = I6(r) : (r == null ? void 0 : r.markdownNotSupportedFallback) ? o.title = r.markdownNotSupportedFallback : o.removeAttribute("title");
          })(e, t);
          else {
            const n = Ba().setupManagedHover(this.hoverDelegate, e, t);
            n && this.customHovers.set(e, n);
          }
        }
        dispose() {
          super.dispose();
          for (const e of this.customHovers.values()) e.dispose();
          this.customHovers.clear();
        }
        getOrCreateSuffixNode() {
          if (!this.suffixNode) {
            const e = this._register(new Km($K(this.nameContainer, He("span.monaco-icon-suffix-container"))));
            this.suffixNode = this._register(new Km(Ne(e.element, He("span.label-suffix"))));
          }
          return this.suffixNode;
        }
        getOrCreateDescriptionNode() {
          var _a3;
          if (!this.descriptionNode) {
            const e = this._register(new Km(Ne(this.labelContainer, He("span.monaco-icon-description-container"))));
            ((_a3 = this.creationOptions) == null ? void 0 : _a3.supportDescriptionHighlights) ? this.descriptionNode = this._register(new kh(Ne(e.element, He("span.label-description")), {
              supportIcons: !!this.creationOptions.supportIcons
            })) : this.descriptionNode = this._register(new Km(Ne(e.element, He("span.label-description"))));
          }
          return this.descriptionNode;
        }
      }
      class ore {
        constructor(e) {
          this.container = e, this.label = void 0, this.singleLabel = void 0;
        }
        setLabel(e, t) {
          if (!(this.label === e && $s(this.options, t))) if (this.label = e, this.options = t, typeof e == "string") this.singleLabel || (this.container.innerText = "", this.container.classList.remove("multiple"), this.singleLabel = Ne(this.container, He("a.label-name", {
            id: t == null ? void 0 : t.domId
          }))), this.singleLabel.textContent = e;
          else {
            this.container.innerText = "", this.container.classList.add("multiple"), this.singleLabel = void 0;
            for (let i = 0; i < e.length; i++) {
              const n = e[i], o = (t == null ? void 0 : t.domId) && `${t == null ? void 0 : t.domId}_${i}`;
              Ne(this.container, He("a.label-name", {
                id: o,
                "data-icon-label-count": e.length,
                "data-icon-label-index": i,
                role: "treeitem"
              }, n)), i < e.length - 1 && Ne(this.container, He("span.label-separator", void 0, (t == null ? void 0 : t.separator) || "/"));
            }
          }
        }
      }
      function rre(s, e, t) {
        if (!t) return;
        let i = 0;
        return s.map((n) => {
          const o = {
            start: i,
            end: i + n.length
          }, r = t.map((a) => Hn.intersect(o, a)).filter((a) => !Hn.isEmpty(a)).map(({ start: a, end: l }) => ({
            start: a - i,
            end: l - i
          }));
          return i = o.end + e.length, r;
        });
      }
      class are extends he {
        constructor(e, t) {
          super(), this.container = e, this.supportIcons = t, this.label = void 0, this.singleLabel = void 0;
        }
        setLabel(e, t) {
          if (!(this.label === e && $s(this.options, t))) if (this.label = e, this.options = t, typeof e == "string") this.singleLabel || (this.container.innerText = "", this.container.classList.remove("multiple"), this.singleLabel = this._register(new kh(Ne(this.container, He("a.label-name", {
            id: t == null ? void 0 : t.domId
          })), {
            supportIcons: this.supportIcons
          }))), this.singleLabel.set(e, t == null ? void 0 : t.matches, void 0, t == null ? void 0 : t.labelEscapeNewLines);
          else {
            this.container.innerText = "", this.container.classList.add("multiple"), this.singleLabel = void 0;
            const i = (t == null ? void 0 : t.separator) || "/", n = rre(e, i, t == null ? void 0 : t.matches);
            for (let o = 0; o < e.length; o++) {
              const r = e[o], a = n ? n[o] : void 0, l = (t == null ? void 0 : t.domId) && `${t == null ? void 0 : t.domId}_${o}`, u = He("a.label-name", {
                id: l,
                "data-icon-label-count": e.length,
                "data-icon-label-index": o,
                role: "treeitem"
              });
              this._register(new kh(Ne(this.container, u), {
                supportIcons: this.supportIcons
              })).set(r, a, void 0, t == null ? void 0 : t.labelEscapeNewLines), o < e.length - 1 && Ne(u, He("span.label-separator", void 0, i));
            }
          }
        }
      }
      const e0 = He;
      class BN extends he {
        constructor(e, t, i) {
          super(), this.os = t, this.keyElements = /* @__PURE__ */ new Set(), this.options = i || /* @__PURE__ */ Object.create(null);
          const n = this.options.keybindingLabelForeground;
          this.domNode = Ne(e, e0(".monaco-keybinding")), n && (this.domNode.style.color = n), this.hover = this._register(Ba().setupManagedHover($o("mouse"), this.domNode, "")), this.didEverRender = false, e.appendChild(this.domNode);
        }
        get element() {
          return this.domNode;
        }
        set(e, t) {
          this.didEverRender && this.keybinding === e && BN.areSame(this.matches, t) || (this.keybinding = e, this.matches = t, this.render());
        }
        render() {
          if (this.clear(), this.keybinding) {
            const e = this.keybinding.getChords();
            e[0] && this.renderChord(this.domNode, e[0], this.matches ? this.matches.firstPart : null);
            for (let i = 1; i < e.length; i++) Ne(this.domNode, e0("span.monaco-keybinding-key-chord-separator", void 0, " ")), this.renderChord(this.domNode, e[i], this.matches ? this.matches.chordPart : null);
            const t = this.options.disableTitle ?? false ? void 0 : this.keybinding.getAriaLabel() || void 0;
            this.hover.update(t), this.domNode.setAttribute("aria-label", t || "");
          } else this.options && this.options.renderUnboundKeybindings && this.renderUnbound(this.domNode);
          this.didEverRender = true;
        }
        clear() {
          $r(this.domNode), this.keyElements.clear();
        }
        renderChord(e, t, i) {
          const n = GT.modifierLabels[this.os];
          t.ctrlKey && this.renderKey(e, n.ctrlKey, !!(i == null ? void 0 : i.ctrlKey), n.separator), t.shiftKey && this.renderKey(e, n.shiftKey, !!(i == null ? void 0 : i.shiftKey), n.separator), t.altKey && this.renderKey(e, n.altKey, !!(i == null ? void 0 : i.altKey), n.separator), t.metaKey && this.renderKey(e, n.metaKey, !!(i == null ? void 0 : i.metaKey), n.separator);
          const o = t.keyLabel;
          o && this.renderKey(e, o, !!(i == null ? void 0 : i.keyCode), "");
        }
        renderKey(e, t, i, n) {
          Ne(e, this.createKeyElement(t, i ? ".highlight" : "")), n && Ne(e, e0("span.monaco-keybinding-key-separator", void 0, n));
        }
        renderUnbound(e) {
          Ne(e, this.createKeyElement(C("unbound", "Unbound")));
        }
        createKeyElement(e, t = "") {
          const i = e0("span.monaco-keybinding-key" + t, void 0, e);
          return this.keyElements.add(i), this.options.keybindingLabelBackground && (i.style.backgroundColor = this.options.keybindingLabelBackground), this.options.keybindingLabelBorder && (i.style.borderColor = this.options.keybindingLabelBorder), this.options.keybindingLabelBottomBorder && (i.style.borderBottomColor = this.options.keybindingLabelBottomBorder), this.options.keybindingLabelShadow && (i.style.boxShadow = `inset 0 -1px 0 ${this.options.keybindingLabelShadow}`), i;
        }
        static areSame(e, t) {
          return e === t || !e && !t ? true : !!e && !!t && $s(e.firstPart, t.firstPart) && $s(e.chordPart, t.chordPart);
        }
      }
      const u3 = new iu(() => {
        const s = new Intl.Collator(void 0, {
          numeric: true,
          sensitivity: "base"
        });
        return {
          collator: s,
          collatorIsNumeric: s.resolvedOptions().numeric
        };
      });
      function lre(s, e, t = false) {
        const i = s || "", n = e || "", o = u3.value.collator.compare(i, n);
        return u3.value.collatorIsNumeric && o === 0 && i !== n ? i < n ? -1 : 1 : o;
      }
      function cre(s, e, t) {
        const i = s.toLowerCase(), n = e.toLowerCase(), o = ure(s, e, t);
        if (o) return o;
        const r = i.endsWith(t), a = n.endsWith(t);
        if (r !== a) return r ? -1 : 1;
        const l = lre(i, n);
        return l !== 0 ? l : i.localeCompare(n);
      }
      function ure(s, e, t) {
        const i = s.toLowerCase(), n = e.toLowerCase(), o = i.startsWith(t), r = n.startsWith(t);
        if (o !== r) return o ? -1 : 1;
        if (o && r) {
          if (i.length < n.length) return -1;
          if (i.length > n.length) return 1;
        }
        return 0;
      }
      var Ow = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      }, w2 = function(s, e) {
        return function(t, i) {
          e(t, i, s);
        };
      }, y2;
      const Nr = He;
      class nF {
        constructor(e, t, i) {
          this.index = e, this.hasCheckbox = t, this._hidden = false, this._init = new iu(() => {
            const n = i.label ?? "", o = sp(n).text.trim(), r = i.ariaLabel || [
              n,
              this.saneDescription,
              this.saneDetail
            ].map((a) => nJ(a)).filter((a) => !!a).join(", ");
            return {
              saneLabel: n,
              saneSortLabel: o,
              saneAriaLabel: r
            };
          }), this._saneDescription = i.description, this._saneTooltip = i.tooltip;
        }
        get saneLabel() {
          return this._init.value.saneLabel;
        }
        get saneSortLabel() {
          return this._init.value.saneSortLabel;
        }
        get saneAriaLabel() {
          return this._init.value.saneAriaLabel;
        }
        get element() {
          return this._element;
        }
        set element(e) {
          this._element = e;
        }
        get hidden() {
          return this._hidden;
        }
        set hidden(e) {
          this._hidden = e;
        }
        get saneDescription() {
          return this._saneDescription;
        }
        set saneDescription(e) {
          this._saneDescription = e;
        }
        get saneDetail() {
          return this._saneDetail;
        }
        set saneDetail(e) {
          this._saneDetail = e;
        }
        get saneTooltip() {
          return this._saneTooltip;
        }
        set saneTooltip(e) {
          this._saneTooltip = e;
        }
        get labelHighlights() {
          return this._labelHighlights;
        }
        set labelHighlights(e) {
          this._labelHighlights = e;
        }
        get descriptionHighlights() {
          return this._descriptionHighlights;
        }
        set descriptionHighlights(e) {
          this._descriptionHighlights = e;
        }
        get detailHighlights() {
          return this._detailHighlights;
        }
        set detailHighlights(e) {
          this._detailHighlights = e;
        }
      }
      class Nn extends nF {
        constructor(e, t, i, n, o, r) {
          var _a3, _b3, _c2;
          super(e, t, o), this.fireButtonTriggered = i, this._onChecked = n, this.item = o, this._separator = r, this._checked = false, this.onChecked = t ? be.map(be.filter(this._onChecked.event, (a) => a.element === this), (a) => a.checked) : be.None, this._saneDetail = o.detail, this._labelHighlights = (_a3 = o.highlights) == null ? void 0 : _a3.label, this._descriptionHighlights = (_b3 = o.highlights) == null ? void 0 : _b3.description, this._detailHighlights = (_c2 = o.highlights) == null ? void 0 : _c2.detail;
        }
        get separator() {
          return this._separator;
        }
        set separator(e) {
          this._separator = e;
        }
        get checked() {
          return this._checked;
        }
        set checked(e) {
          e !== this._checked && (this._checked = e, this._onChecked.fire({
            element: this,
            checked: e
          }));
        }
        get checkboxDisabled() {
          return !!this.item.disabled;
        }
      }
      var wa;
      (function(s) {
        s[s.NONE = 0] = "NONE", s[s.MOUSE_HOVER = 1] = "MOUSE_HOVER", s[s.ACTIVE_ITEM = 2] = "ACTIVE_ITEM";
      })(wa || (wa = {}));
      class ju extends nF {
        constructor(e, t, i) {
          super(e, false, i), this.fireSeparatorButtonTriggered = t, this.separator = i, this.children = new Array(), this.focusInsideSeparator = wa.NONE;
        }
      }
      class hre {
        getHeight(e) {
          return e instanceof ju ? 30 : e.saneDetail ? 44 : 22;
        }
        getTemplateId(e) {
          return e instanceof Nn ? tC.ID : Pw.ID;
        }
      }
      class dre {
        getWidgetAriaLabel() {
          return C("quickInput", "Quick Input");
        }
        getAriaLabel(e) {
          var _a3;
          return ((_a3 = e.separator) == null ? void 0 : _a3.label) ? `${e.saneAriaLabel}, ${e.separator.label}` : e.saneAriaLabel;
        }
        getWidgetRole() {
          return "listbox";
        }
        getRole(e) {
          return e.hasCheckbox ? "checkbox" : "option";
        }
        isChecked(e) {
          if (!(!e.hasCheckbox || !(e instanceof Nn))) return {
            get value() {
              return e.checked;
            },
            onDidChange: (t) => e.onChecked(() => t())
          };
        }
      }
      class sF {
        constructor(e) {
          this.hoverDelegate = e;
        }
        renderTemplate(e) {
          const t = /* @__PURE__ */ Object.create(null);
          t.toDisposeElement = new Me(), t.toDisposeTemplate = new Me(), t.entry = Ne(e, Nr(".quick-input-list-entry"));
          const i = Ne(t.entry, Nr("label.quick-input-list-label"));
          t.toDisposeTemplate.add(ln(i, Ce.CLICK, (u) => {
            t.checkbox.offsetParent || u.preventDefault();
          })), t.checkbox = Ne(i, Nr("input.quick-input-list-checkbox")), t.checkbox.type = "checkbox";
          const n = Ne(i, Nr(".quick-input-list-rows")), o = Ne(n, Nr(".quick-input-list-row")), r = Ne(n, Nr(".quick-input-list-row"));
          t.label = new c3(o, {
            supportHighlights: true,
            supportDescriptionHighlights: true,
            supportIcons: true,
            hoverDelegate: this.hoverDelegate
          }), t.toDisposeTemplate.add(t.label), t.icon = uT(t.label.element, Nr(".quick-input-list-icon"));
          const a = Ne(o, Nr(".quick-input-list-entry-keybinding"));
          t.keybinding = new BN(a, ur), t.toDisposeTemplate.add(t.keybinding);
          const l = Ne(r, Nr(".quick-input-list-label-meta"));
          return t.detail = new c3(l, {
            supportHighlights: true,
            supportIcons: true,
            hoverDelegate: this.hoverDelegate
          }), t.toDisposeTemplate.add(t.detail), t.separator = Ne(t.entry, Nr(".quick-input-list-separator")), t.actionBar = new Wl(t.entry, this.hoverDelegate ? {
            hoverDelegate: this.hoverDelegate
          } : void 0), t.actionBar.domNode.classList.add("quick-input-list-entry-action-bar"), t.toDisposeTemplate.add(t.actionBar), t;
        }
        disposeTemplate(e) {
          e.toDisposeElement.dispose(), e.toDisposeTemplate.dispose();
        }
        disposeElement(e, t, i) {
          i.toDisposeElement.clear(), i.actionBar.clear();
        }
      }
      let tC = (_j2 = class extends sF {
        constructor(e, t) {
          super(e), this.themeService = t, this._itemsWithSeparatorsFrequency = /* @__PURE__ */ new Map();
        }
        get templateId() {
          return y2.ID;
        }
        renderTemplate(e) {
          const t = super.renderTemplate(e);
          return t.toDisposeTemplate.add(ln(t.checkbox, Ce.CHANGE, (i) => {
            t.element.checked = t.checkbox.checked;
          })), t;
        }
        renderElement(e, t, i) {
          var _a3;
          const n = e.element;
          i.element = n, n.element = i.entry ?? void 0;
          const o = n.item;
          i.checkbox.checked = n.checked, i.toDisposeElement.add(n.onChecked((m) => i.checkbox.checked = m)), i.checkbox.disabled = n.checkboxDisabled;
          const { labelHighlights: r, descriptionHighlights: a, detailHighlights: l } = n;
          if (o.iconPath) {
            const m = rw(this.themeService.getColorTheme().type) ? o.iconPath.dark : o.iconPath.light ?? o.iconPath.dark, _ = st.revive(m);
            i.icon.className = "quick-input-list-icon", i.icon.style.backgroundImage = ql(_);
          } else i.icon.style.backgroundImage = "", i.icon.className = o.iconClass ? `quick-input-list-icon ${o.iconClass}` : "";
          let u;
          !n.saneTooltip && n.saneDescription && (u = {
            markdown: {
              value: n.saneDescription,
              supportThemeIcons: true
            },
            markdownNotSupportedFallback: n.saneDescription
          });
          const d = {
            matches: r || [],
            descriptionTitle: u,
            descriptionMatches: a || [],
            labelEscapeNewLines: true
          };
          if (d.extraClasses = o.iconClasses, d.italic = o.italic, d.strikethrough = o.strikethrough, i.entry.classList.remove("quick-input-list-separator-as-item"), i.label.setLabel(n.saneLabel, n.saneDescription, d), i.keybinding.set(o.keybinding), n.saneDetail) {
            let m;
            n.saneTooltip || (m = {
              markdown: {
                value: n.saneDetail,
                supportThemeIcons: true
              },
              markdownNotSupportedFallback: n.saneDetail
            }), i.detail.element.style.display = "", i.detail.setLabel(n.saneDetail, void 0, {
              matches: l,
              title: m,
              labelEscapeNewLines: true
            });
          } else i.detail.element.style.display = "none";
          ((_a3 = n.separator) == null ? void 0 : _a3.label) ? (i.separator.textContent = n.separator.label, i.separator.style.display = "", this.addItemWithSeparator(n)) : i.separator.style.display = "none", i.entry.classList.toggle("quick-input-list-separator-border", !!n.separator);
          const f = o.buttons;
          f && f.length ? (i.actionBar.push(f.map((m, _) => Ip(m, `id-${_}`, () => n.fireButtonTriggered({
            button: m,
            item: n.item
          }))), {
            icon: true,
            label: false
          }), i.entry.classList.add("has-actions")) : i.entry.classList.remove("has-actions");
        }
        disposeElement(e, t, i) {
          this.removeItemWithSeparator(e.element), super.disposeElement(e, t, i);
        }
        isItemWithSeparatorVisible(e) {
          return this._itemsWithSeparatorsFrequency.has(e);
        }
        addItemWithSeparator(e) {
          this._itemsWithSeparatorsFrequency.set(e, (this._itemsWithSeparatorsFrequency.get(e) || 0) + 1);
        }
        removeItemWithSeparator(e) {
          const t = this._itemsWithSeparatorsFrequency.get(e) || 0;
          t > 1 ? this._itemsWithSeparatorsFrequency.set(e, t - 1) : this._itemsWithSeparatorsFrequency.delete(e);
        }
      }, y2 = _j2, _j2.ID = "quickpickitem", _j2);
      tC = y2 = Ow([
        w2(1, vr)
      ], tC);
      const _Pw = class _Pw extends sF {
        constructor() {
          super(...arguments), this._visibleSeparatorsFrequency = /* @__PURE__ */ new Map();
        }
        get templateId() {
          return _Pw.ID;
        }
        get visibleSeparators() {
          return [
            ...this._visibleSeparatorsFrequency.keys()
          ];
        }
        isSeparatorVisible(e) {
          return this._visibleSeparatorsFrequency.has(e);
        }
        renderTemplate(e) {
          const t = super.renderTemplate(e);
          return t.checkbox.style.display = "none", t;
        }
        renderElement(e, t, i) {
          const n = e.element;
          i.element = n, n.element = i.entry ?? void 0, n.element.classList.toggle("focus-inside", !!n.focusInsideSeparator);
          const o = n.separator, { labelHighlights: r, descriptionHighlights: a, detailHighlights: l } = n;
          i.icon.style.backgroundImage = "", i.icon.className = "";
          let u;
          !n.saneTooltip && n.saneDescription && (u = {
            markdown: {
              value: n.saneDescription,
              supportThemeIcons: true
            },
            markdownNotSupportedFallback: n.saneDescription
          });
          const d = {
            matches: r || [],
            descriptionTitle: u,
            descriptionMatches: a || [],
            labelEscapeNewLines: true
          };
          if (i.entry.classList.add("quick-input-list-separator-as-item"), i.label.setLabel(n.saneLabel, n.saneDescription, d), n.saneDetail) {
            let m;
            n.saneTooltip || (m = {
              markdown: {
                value: n.saneDetail,
                supportThemeIcons: true
              },
              markdownNotSupportedFallback: n.saneDetail
            }), i.detail.element.style.display = "", i.detail.setLabel(n.saneDetail, void 0, {
              matches: l,
              title: m,
              labelEscapeNewLines: true
            });
          } else i.detail.element.style.display = "none";
          i.separator.style.display = "none", i.entry.classList.add("quick-input-list-separator-border");
          const f = o.buttons;
          f && f.length ? (i.actionBar.push(f.map((m, _) => Ip(m, `id-${_}`, () => n.fireSeparatorButtonTriggered({
            button: m,
            separator: n.separator
          }))), {
            icon: true,
            label: false
          }), i.entry.classList.add("has-actions")) : i.entry.classList.remove("has-actions"), this.addSeparator(n);
        }
        disposeElement(e, t, i) {
          var _a3;
          this.removeSeparator(e.element), this.isSeparatorVisible(e.element) || ((_a3 = e.element.element) == null ? void 0 : _a3.classList.remove("focus-inside")), super.disposeElement(e, t, i);
        }
        addSeparator(e) {
          this._visibleSeparatorsFrequency.set(e, (this._visibleSeparatorsFrequency.get(e) || 0) + 1);
        }
        removeSeparator(e) {
          const t = this._visibleSeparatorsFrequency.get(e) || 0;
          t > 1 ? this._visibleSeparatorsFrequency.set(e, t - 1) : this._visibleSeparatorsFrequency.delete(e);
        }
      };
      _Pw.ID = "quickpickseparator";
      let Pw = _Pw;
      let C_ = class extends he {
        constructor(e, t, i, n, o, r) {
          super(), this.parent = e, this.hoverDelegate = t, this.linkOpenerDelegate = i, this.accessibilityService = r, this._onKeyDown = new G(), this._onLeave = new G(), this.onLeave = this._onLeave.event, this._visibleCountObservable = Ct("VisibleCount", 0), this.onChangedVisibleCount = be.fromObservable(this._visibleCountObservable, this._store), this._allVisibleCheckedObservable = Ct("AllVisibleChecked", false), this.onChangedAllVisibleChecked = be.fromObservable(this._allVisibleCheckedObservable, this._store), this._checkedCountObservable = Ct("CheckedCount", 0), this.onChangedCheckedCount = be.fromObservable(this._checkedCountObservable, this._store), this._checkedElementsObservable = UD({
            equalsFn: Qi
          }, new Array()), this.onChangedCheckedElements = be.fromObservable(this._checkedElementsObservable, this._store), this._onButtonTriggered = new G(), this.onButtonTriggered = this._onButtonTriggered.event, this._onSeparatorButtonTriggered = new G(), this.onSeparatorButtonTriggered = this._onSeparatorButtonTriggered.event, this._elementChecked = new G(), this._elementCheckedEventBufferer = new B_(), this._hasCheckboxes = false, this._inputElements = new Array(), this._elementTree = new Array(), this._itemElements = new Array(), this._elementDisposable = this._register(new Me()), this._matchOnDescription = false, this._matchOnDetail = false, this._matchOnLabel = true, this._matchOnLabelMode = "fuzzy", this._sortByLabel = true, this._shouldLoop = true, this._container = Ne(this.parent, Nr(".quick-input-list")), this._separatorRenderer = new Pw(t), this._itemRenderer = o.createInstance(tC, t), this._tree = this._register(o.createInstance(C2, "QuickInput", this._container, new hre(), [
            this._itemRenderer,
            this._separatorRenderer
          ], {
            filter: {
              filter(a) {
                return a.hidden ? 0 : a instanceof ju ? 2 : 1;
              }
            },
            sorter: {
              compare: (a, l) => {
                if (!this.sortByLabel || !this._lastQueryString) return 0;
                const u = this._lastQueryString.toLowerCase();
                return gre(a, l, u);
              }
            },
            accessibilityProvider: new dre(),
            setRowLineHeight: false,
            multipleSelectionSupport: false,
            hideTwistiesOfChildlessElements: true,
            renderIndentGuides: _g.None,
            findWidgetEnabled: false,
            indent: 0,
            horizontalScrolling: false,
            allowNonCollapsibleParents: true,
            alwaysConsumeMouseWheel: true
          })), this._tree.getHTMLElement().id = n, this._registerListeners();
        }
        get onDidChangeFocus() {
          return be.map(this._tree.onDidChangeFocus, (e) => e.elements.filter((t) => t instanceof Nn).map((t) => t.item), this._store);
        }
        get onDidChangeSelection() {
          return be.map(this._tree.onDidChangeSelection, (e) => ({
            items: e.elements.filter((t) => t instanceof Nn).map((t) => t.item),
            event: e.browserEvent
          }), this._store);
        }
        get displayed() {
          return this._container.style.display !== "none";
        }
        set displayed(e) {
          this._container.style.display = e ? "" : "none";
        }
        get scrollTop() {
          return this._tree.scrollTop;
        }
        set scrollTop(e) {
          this._tree.scrollTop = e;
        }
        get ariaLabel() {
          return this._tree.ariaLabel;
        }
        set ariaLabel(e) {
          this._tree.ariaLabel = e ?? "";
        }
        set enabled(e) {
          this._tree.getHTMLElement().style.pointerEvents = e ? "" : "none";
        }
        get matchOnDescription() {
          return this._matchOnDescription;
        }
        set matchOnDescription(e) {
          this._matchOnDescription = e;
        }
        get matchOnDetail() {
          return this._matchOnDetail;
        }
        set matchOnDetail(e) {
          this._matchOnDetail = e;
        }
        get matchOnLabel() {
          return this._matchOnLabel;
        }
        set matchOnLabel(e) {
          this._matchOnLabel = e;
        }
        get matchOnLabelMode() {
          return this._matchOnLabelMode;
        }
        set matchOnLabelMode(e) {
          this._matchOnLabelMode = e;
        }
        get sortByLabel() {
          return this._sortByLabel;
        }
        set sortByLabel(e) {
          this._sortByLabel = e;
        }
        get shouldLoop() {
          return this._shouldLoop;
        }
        set shouldLoop(e) {
          this._shouldLoop = e;
        }
        _registerListeners() {
          this._registerOnKeyDown(), this._registerOnContainerClick(), this._registerOnMouseMiddleClick(), this._registerOnTreeModelChanged(), this._registerOnElementChecked(), this._registerOnContextMenu(), this._registerHoverListeners(), this._registerSelectionChangeListener(), this._registerSeparatorActionShowingListeners();
        }
        _registerOnKeyDown() {
          this._register(this._tree.onKeyDown((e) => {
            const t = new si(e);
            switch (t.keyCode) {
              case 10:
                this.toggleCheckbox();
                break;
            }
            this._onKeyDown.fire(t);
          }));
        }
        _registerOnContainerClick() {
          this._register(re(this._container, Ce.CLICK, (e) => {
            (e.x || e.y) && this._onLeave.fire();
          }));
        }
        _registerOnMouseMiddleClick() {
          this._register(re(this._container, Ce.AUXCLICK, (e) => {
            e.button === 1 && this._onLeave.fire();
          }));
        }
        _registerOnTreeModelChanged() {
          this._register(this._tree.onDidChangeModel(() => {
            const e = this._itemElements.filter((t) => !t.hidden).length;
            this._visibleCountObservable.set(e, void 0), this._hasCheckboxes && this._updateCheckedObservables();
          }));
        }
        _registerOnElementChecked() {
          this._register(this._elementCheckedEventBufferer.wrapEvent(this._elementChecked.event, (e, t) => t)((e) => this._updateCheckedObservables()));
        }
        _registerOnContextMenu() {
          this._register(this._tree.onContextMenu((e) => {
            e.element && (e.browserEvent.preventDefault(), this._tree.setSelection([
              e.element
            ]));
          }));
        }
        _registerHoverListeners() {
          const e = this._register(new R9(this.hoverDelegate.delay));
          this._register(this._tree.onMouseOver(async (t) => {
            var _a3;
            if (aO(t.browserEvent.target)) {
              e.cancel();
              return;
            }
            if (!(!aO(t.browserEvent.relatedTarget) && an(t.browserEvent.relatedTarget, (_a3 = t.element) == null ? void 0 : _a3.element))) try {
              await e.trigger(async () => {
                t.element instanceof Nn && this.showHover(t.element);
              });
            } catch (i) {
              if (!O_(i)) throw i;
            }
          })), this._register(this._tree.onMouseOut((t) => {
            var _a3;
            an(t.browserEvent.relatedTarget, (_a3 = t.element) == null ? void 0 : _a3.element) || e.cancel();
          }));
        }
        _registerSeparatorActionShowingListeners() {
          this._register(this._tree.onDidChangeFocus((e) => {
            const t = e.elements[0] ? this._tree.getParentElement(e.elements[0]) : null;
            for (const i of this._separatorRenderer.visibleSeparators) {
              const n = i === t;
              !!(i.focusInsideSeparator & wa.ACTIVE_ITEM) !== n && (n ? i.focusInsideSeparator |= wa.ACTIVE_ITEM : i.focusInsideSeparator &= ~wa.ACTIVE_ITEM, this._tree.rerender(i));
            }
          })), this._register(this._tree.onMouseOver((e) => {
            const t = e.element ? this._tree.getParentElement(e.element) : null;
            for (const i of this._separatorRenderer.visibleSeparators) {
              if (i !== t) continue;
              !!(i.focusInsideSeparator & wa.MOUSE_HOVER) || (i.focusInsideSeparator |= wa.MOUSE_HOVER, this._tree.rerender(i));
            }
          })), this._register(this._tree.onMouseOut((e) => {
            const t = e.element ? this._tree.getParentElement(e.element) : null;
            for (const i of this._separatorRenderer.visibleSeparators) {
              if (i !== t) continue;
              !!(i.focusInsideSeparator & wa.MOUSE_HOVER) && (i.focusInsideSeparator &= ~wa.MOUSE_HOVER, this._tree.rerender(i));
            }
          }));
        }
        _registerSelectionChangeListener() {
          this._register(this._tree.onDidChangeSelection((e) => {
            const t = e.elements.filter((i) => i instanceof Nn);
            t.length !== e.elements.length && (e.elements.length === 1 && e.elements[0] instanceof ju && (this._tree.setFocus([
              e.elements[0].children[0]
            ]), this._tree.reveal(e.elements[0], 0)), this._tree.setSelection(t));
          }));
        }
        setAllVisibleChecked(e) {
          this._elementCheckedEventBufferer.bufferEvents(() => {
            this._itemElements.forEach((t) => {
              !t.hidden && !t.checkboxDisabled && (t.checked = e);
            });
          });
        }
        setElements(e) {
          this._elementDisposable.clear(), this._lastQueryString = void 0, this._inputElements = e, this._hasCheckboxes = this.parent.classList.contains("show-checkboxes");
          let t;
          this._itemElements = new Array(), this._elementTree = e.reduce((i, n, o) => {
            let r;
            if (n.type === "separator") {
              if (!n.buttons) return i;
              t = new ju(o, (a) => this._onSeparatorButtonTriggered.fire(a), n), r = t;
            } else {
              const a = o > 0 ? e[o - 1] : void 0;
              let l;
              a && a.type === "separator" && !a.buttons && (t = void 0, l = a);
              const u = new Nn(o, this._hasCheckboxes, (d) => this._onButtonTriggered.fire(d), this._elementChecked, n, l);
              if (this._itemElements.push(u), t) return t.children.push(u), i;
              r = u;
            }
            return i.push(r), i;
          }, new Array()), this._setElementsToTree(this._elementTree), this.accessibilityService.isScreenReaderOptimized() && setTimeout(() => {
            const i = this._tree.getHTMLElement().querySelector(".monaco-list-row.focused"), n = i == null ? void 0 : i.parentNode;
            if (i && n) {
              const o = i.nextSibling;
              i.remove(), n.insertBefore(i, o);
            }
          }, 0);
        }
        setFocusedElements(e) {
          const t = e.map((i) => this._itemElements.find((n) => n.item === i)).filter((i) => !!i).filter((i) => !i.hidden);
          if (this._tree.setFocus(t), e.length > 0) {
            const i = this._tree.getFocus()[0];
            i && this._tree.reveal(i);
          }
        }
        getActiveDescendant() {
          return this._tree.getHTMLElement().getAttribute("aria-activedescendant");
        }
        setSelectedElements(e) {
          const t = e.map((i) => this._itemElements.find((n) => n.item === i)).filter((i) => !!i);
          this._tree.setSelection(t);
        }
        getCheckedElements() {
          return this._itemElements.filter((e) => e.checked).map((e) => e.item);
        }
        setCheckedElements(e) {
          this._elementCheckedEventBufferer.bufferEvents(() => {
            const t = /* @__PURE__ */ new Set();
            for (const i of e) t.add(i);
            for (const i of this._itemElements) i.checked = t.has(i.item);
          });
        }
        focus(e) {
          var _a3;
          if (this._itemElements.length) switch (e === Zt.Second && this._itemElements.length < 2 && (e = Zt.First), e) {
            case Zt.First:
              this._tree.scrollTop = 0, this._tree.focusFirst(void 0, (t) => t.element instanceof Nn);
              break;
            case Zt.Second: {
              this._tree.scrollTop = 0;
              let t = false;
              this._tree.focusFirst(void 0, (i) => i.element instanceof Nn ? t ? true : (t = !t, false) : false);
              break;
            }
            case Zt.Last:
              this._tree.scrollTop = this._tree.scrollHeight, this._tree.focusLast(void 0, (t) => t.element instanceof Nn);
              break;
            case Zt.Next: {
              const t = this._tree.getFocus();
              this._tree.focusNext(void 0, this._shouldLoop, void 0, (n) => n.element instanceof Nn ? (this._tree.reveal(n.element), true) : false);
              const i = this._tree.getFocus();
              t.length && t[0] === i[0] && t[0] === this._itemElements[this._itemElements.length - 1] && this._onLeave.fire();
              break;
            }
            case Zt.Previous: {
              const t = this._tree.getFocus();
              this._tree.focusPrevious(void 0, this._shouldLoop, void 0, (n) => {
                if (!(n.element instanceof Nn)) return false;
                const o = this._tree.getParentElement(n.element);
                return o === null || o.children[0] !== n.element ? this._tree.reveal(n.element) : this._tree.reveal(o), true;
              });
              const i = this._tree.getFocus();
              t.length && t[0] === i[0] && t[0] === this._itemElements[0] && this._onLeave.fire();
              break;
            }
            case Zt.NextPage:
              this._tree.focusNextPage(void 0, (t) => t.element instanceof Nn ? (this._tree.reveal(t.element), true) : false);
              break;
            case Zt.PreviousPage:
              this._tree.focusPreviousPage(void 0, (t) => {
                if (!(t.element instanceof Nn)) return false;
                const i = this._tree.getParentElement(t.element);
                return i === null || i.children[0] !== t.element ? this._tree.reveal(t.element) : this._tree.reveal(i), true;
              });
              break;
            case Zt.NextSeparator: {
              let t = false;
              const i = this._tree.getFocus()[0];
              this._tree.focusNext(void 0, true, void 0, (o) => {
                if (t) return true;
                if (o.element instanceof ju) t = true, this._separatorRenderer.isSeparatorVisible(o.element) ? this._tree.reveal(o.element.children[0]) : this._tree.reveal(o.element, 0);
                else if (o.element instanceof Nn) {
                  if (o.element.separator) return this._itemRenderer.isItemWithSeparatorVisible(o.element) ? this._tree.reveal(o.element) : this._tree.reveal(o.element, 0), true;
                  if (o.element === this._elementTree[0]) return this._tree.reveal(o.element, 0), true;
                }
                return false;
              });
              const n = this._tree.getFocus()[0];
              i === n && (this._tree.scrollTop = this._tree.scrollHeight, this._tree.focusLast(void 0, (o) => o.element instanceof Nn));
              break;
            }
            case Zt.PreviousSeparator: {
              let t, i = !!((_a3 = this._tree.getFocus()[0]) == null ? void 0 : _a3.separator);
              this._tree.focusPrevious(void 0, true, void 0, (n) => {
                if (n.element instanceof ju) i ? t || (this._separatorRenderer.isSeparatorVisible(n.element) ? this._tree.reveal(n.element) : this._tree.reveal(n.element, 0), t = n.element.children[0]) : i = true;
                else if (n.element instanceof Nn && !t) {
                  if (n.element.separator) this._itemRenderer.isItemWithSeparatorVisible(n.element) ? this._tree.reveal(n.element) : this._tree.reveal(n.element, 0), t = n.element;
                  else if (n.element === this._elementTree[0]) return this._tree.reveal(n.element, 0), true;
                }
                return false;
              }), t && this._tree.setFocus([
                t
              ]);
              break;
            }
          }
        }
        clearFocus() {
          this._tree.setFocus([]);
        }
        domFocus() {
          this._tree.domFocus();
        }
        layout(e) {
          this._tree.getHTMLElement().style.maxHeight = e ? `${Math.floor(e / 44) * 44 + 6}px` : "", this._tree.layout();
        }
        filter(e) {
          if (this._lastQueryString = e, !(this._sortByLabel || this._matchOnLabel || this._matchOnDescription || this._matchOnDetail)) return this._tree.layout(), false;
          const t = e;
          if (e = e.trim(), !e || !(this.matchOnLabel || this.matchOnDescription || this.matchOnDetail)) this._itemElements.forEach((i) => {
            i.labelHighlights = void 0, i.descriptionHighlights = void 0, i.detailHighlights = void 0, i.hidden = false;
            const n = i.index && this._inputElements[i.index - 1];
            i.item && (i.separator = n && n.type === "separator" && !n.buttons ? n : void 0);
          });
          else {
            let i;
            this._itemElements.forEach((n) => {
              let o;
              this.matchOnLabelMode === "fuzzy" ? o = this.matchOnLabel ? KL(e, sp(n.saneLabel)) ?? void 0 : void 0 : o = this.matchOnLabel ? fre(t, sp(n.saneLabel)) ?? void 0 : void 0;
              const r = this.matchOnDescription ? KL(e, sp(n.saneDescription || "")) ?? void 0 : void 0, a = this.matchOnDetail ? KL(e, sp(n.saneDetail || "")) ?? void 0 : void 0;
              if (o || r || a ? (n.labelHighlights = o, n.descriptionHighlights = r, n.detailHighlights = a, n.hidden = false) : (n.labelHighlights = void 0, n.descriptionHighlights = void 0, n.detailHighlights = void 0, n.hidden = n.item ? !n.item.alwaysShow : true), n.item ? n.separator = void 0 : n.separator && (n.hidden = true), !this.sortByLabel) {
                const l = n.index && this._inputElements[n.index - 1] || void 0;
                (l == null ? void 0 : l.type) === "separator" && !l.buttons && (i = l), i && !n.hidden && (n.separator = i, i = void 0);
              }
            });
          }
          return this._setElementsToTree(this._sortByLabel && e ? this._itemElements : this._elementTree), this._tree.layout(), true;
        }
        toggleCheckbox() {
          this._elementCheckedEventBufferer.bufferEvents(() => {
            const e = this._tree.getFocus().filter((i) => i instanceof Nn), t = this._allVisibleChecked(e);
            for (const i of e) i.checkboxDisabled || (i.checked = !t);
          });
        }
        style(e) {
          this._tree.style(e);
        }
        toggleHover() {
          const e = this._tree.getFocus()[0];
          if (!(e == null ? void 0 : e.saneTooltip) || !(e instanceof Nn)) return;
          if (this._lastHover && !this._lastHover.isDisposed) {
            this._lastHover.dispose();
            return;
          }
          this.showHover(e);
          const t = new Me();
          t.add(this._tree.onDidChangeFocus((i) => {
            i.elements[0] instanceof Nn && this.showHover(i.elements[0]);
          })), this._lastHover && t.add(this._lastHover), this._elementDisposable.add(t);
        }
        _setElementsToTree(e) {
          const t = new Array();
          for (const i of e) i instanceof ju ? t.push({
            element: i,
            collapsible: false,
            collapsed: false,
            children: i.children.map((n) => ({
              element: n,
              collapsible: false,
              collapsed: false
            }))
          }) : t.push({
            element: i,
            collapsible: false,
            collapsed: false
          });
          this._tree.setChildren(null, t);
        }
        _allVisibleChecked(e, t = true) {
          for (let i = 0, n = e.length; i < n; i++) {
            const o = e[i];
            if (!o.hidden) if (o.checked) t = true;
            else return false;
          }
          return t;
        }
        _updateCheckedObservables() {
          Yi((e) => {
            this._allVisibleCheckedObservable.set(this._allVisibleChecked(this._itemElements, false), e);
            const t = this._itemElements.filter((i) => i.checked).length;
            this._checkedCountObservable.set(t, e), this._checkedElementsObservable.set(this.getCheckedElements(), e);
          });
        }
        showHover(e) {
          var _a3, _b3, _c2;
          this._lastHover && !this._lastHover.isDisposed && ((_b3 = (_a3 = this.hoverDelegate).onDidHideHover) == null ? void 0 : _b3.call(_a3), (_c2 = this._lastHover) == null ? void 0 : _c2.dispose()), !(!e.element || !e.saneTooltip) && (this._lastHover = this.hoverDelegate.showHover({
            content: e.saneTooltip,
            target: e.element,
            linkHandler: (t) => {
              this.linkOpenerDelegate(t);
            },
            appearance: {
              showPointer: true
            },
            container: this._container,
            position: {
              hoverPosition: 1
            }
          }, false));
        }
      };
      Ow([
        Li
      ], C_.prototype, "onDidChangeFocus", null);
      Ow([
        Li
      ], C_.prototype, "onDidChangeSelection", null);
      C_ = Ow([
        w2(4, Ft),
        w2(5, ea)
      ], C_);
      function fre(s, e) {
        const { text: t, iconOffsets: i } = e;
        if (!i || i.length === 0) return h3(s, t);
        const n = WC(t, " "), o = t.length - n.length, r = h3(s, n);
        if (r) for (const a of r) {
          const l = i[a.start + o] + o;
          a.start += l, a.end += l;
        }
        return r;
      }
      function h3(s, e) {
        const t = e.toLowerCase().indexOf(s.toLowerCase());
        return t !== -1 ? [
          {
            start: t,
            end: t + s.length
          }
        ] : null;
      }
      function gre(s, e, t) {
        const i = s.labelHighlights || [], n = e.labelHighlights || [];
        return i.length && !n.length ? -1 : !i.length && n.length ? 1 : i.length === 0 && n.length === 0 ? 0 : cre(s.saneSortLabel, e.saneSortLabel, t);
      }
      const oF = {
        weight: 200,
        when: Ot.and(Ot.equals(VB, "quickPick"), Ase),
        metadata: {
          description: C("quickPick", "Used while in the context of the quick pick. If you change one keybinding for this command, you should change all of the other keybindings (modifier variants) of this command as well.")
        }
      };
      function Hs(s, e = {}) {
        z_.registerCommandAndKeybindingRule({
          ...oF,
          ...s,
          secondary: mre(s.primary, s.secondary ?? [], e)
        });
      }
      const iC = _t ? 256 : 2048;
      function mre(s, e, t = {}) {
        return t.withAltMod && e.push(512 + s), t.withCtrlMod && (e.push(iC + s), t.withAltMod && e.push(512 + iC + s)), t.withCmdMod && _t && (e.push(2048 + s), t.withCtrlMod && e.push(2304 + s), t.withAltMod && (e.push(2560 + s), t.withCtrlMod && e.push(2816 + s))), e;
      }
      function oo(s, e) {
        return (t) => {
          const i = t.get(kw).currentQuickInput;
          if (i) return e && i.quickNavigate ? i.focus(e) : i.focus(s);
        };
      }
      Hs({
        id: "quickInput.pageNext",
        primary: 12,
        handler: oo(Zt.NextPage)
      }, {
        withAltMod: true,
        withCtrlMod: true,
        withCmdMod: true
      });
      Hs({
        id: "quickInput.pagePrevious",
        primary: 11,
        handler: oo(Zt.PreviousPage)
      }, {
        withAltMod: true,
        withCtrlMod: true,
        withCmdMod: true
      });
      Hs({
        id: "quickInput.first",
        primary: iC + 14,
        handler: oo(Zt.First)
      }, {
        withAltMod: true,
        withCmdMod: true
      });
      Hs({
        id: "quickInput.last",
        primary: iC + 13,
        handler: oo(Zt.Last)
      }, {
        withAltMod: true,
        withCmdMod: true
      });
      Hs({
        id: "quickInput.next",
        primary: 18,
        handler: oo(Zt.Next)
      }, {
        withCtrlMod: true
      });
      Hs({
        id: "quickInput.previous",
        primary: 16,
        handler: oo(Zt.Previous)
      }, {
        withCtrlMod: true
      });
      const d3 = C("quickInput.nextSeparatorWithQuickAccessFallback", "If we're in quick access mode, this will navigate to the next item. If we are not in quick access mode, this will navigate to the next separator."), f3 = C("quickInput.previousSeparatorWithQuickAccessFallback", "If we're in quick access mode, this will navigate to the previous item. If we are not in quick access mode, this will navigate to the previous separator.");
      _t ? (Hs({
        id: "quickInput.nextSeparatorWithQuickAccessFallback",
        primary: 2066,
        handler: oo(Zt.NextSeparator, Zt.Next),
        metadata: {
          description: d3
        }
      }), Hs({
        id: "quickInput.nextSeparator",
        primary: 2578,
        secondary: [
          2322
        ],
        handler: oo(Zt.NextSeparator)
      }, {
        withCtrlMod: true
      }), Hs({
        id: "quickInput.previousSeparatorWithQuickAccessFallback",
        primary: 2064,
        handler: oo(Zt.PreviousSeparator, Zt.Previous),
        metadata: {
          description: f3
        }
      }), Hs({
        id: "quickInput.previousSeparator",
        primary: 2576,
        secondary: [
          2320
        ],
        handler: oo(Zt.PreviousSeparator)
      }, {
        withCtrlMod: true
      })) : (Hs({
        id: "quickInput.nextSeparatorWithQuickAccessFallback",
        primary: 530,
        handler: oo(Zt.NextSeparator, Zt.Next),
        metadata: {
          description: d3
        }
      }), Hs({
        id: "quickInput.nextSeparator",
        primary: 2578,
        handler: oo(Zt.NextSeparator)
      }), Hs({
        id: "quickInput.previousSeparatorWithQuickAccessFallback",
        primary: 528,
        handler: oo(Zt.PreviousSeparator, Zt.Previous),
        metadata: {
          description: f3
        }
      }), Hs({
        id: "quickInput.previousSeparator",
        primary: 2576,
        handler: oo(Zt.PreviousSeparator)
      }));
      Hs({
        id: "quickInput.acceptInBackground",
        when: Ot.and(oF.when, Ot.or(Koe.negate(), Pse)),
        primary: 17,
        weight: 250,
        handler: (s) => {
          var _a3;
          (_a3 = s.get(kw).currentQuickInput) == null ? void 0 : _a3.accept(true);
        }
      }, {
        withAltMod: true,
        withCtrlMod: true,
        withCmdMod: true
      });
      var pre = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      }, mx = function(s, e) {
        return function(t, i) {
          e(t, i, s);
        };
      }, S2;
      const Ws = He;
      let L2 = (_k2 = class extends he {
        get currentQuickInput() {
          return this.controller ?? void 0;
        }
        get container() {
          return this._container;
        }
        constructor(e, t, i, n) {
          super(), this.options = e, this.layoutService = t, this.instantiationService = i, this.contextKeyService = n, this.enabled = true, this.onDidAcceptEmitter = this._register(new G()), this.onDidCustomEmitter = this._register(new G()), this.onDidTriggerButtonEmitter = this._register(new G()), this.keyMods = {
            ctrlCmd: false,
            alt: false
          }, this.controller = null, this.onShowEmitter = this._register(new G()), this.onShow = this.onShowEmitter.event, this.onHideEmitter = this._register(new G()), this.onHide = this.onHideEmitter.event, this.inQuickInputContext = Mse.bindTo(this.contextKeyService), this.quickInputTypeContext = Rse.bindTo(this.contextKeyService), this.endOfQuickInputBoxContext = Ose.bindTo(this.contextKeyService), this.idPrefix = e.idPrefix, this._container = e.container, this.styles = e.styles, this._register(be.runAndSubscribe($C, ({ window: o, disposables: r }) => this.registerKeyModsListeners(o, r), {
            window: Kt,
            disposables: this._store
          })), this._register(EK((o) => {
            this.ui && Oe(this.ui.container) === o && (this.reparentUI(this.layoutService.mainContainer), this.layout(this.layoutService.mainContainerDimension, this.layoutService.mainContainerOffset.quickPickTop));
          }));
        }
        registerKeyModsListeners(e, t) {
          const i = (n) => {
            this.keyMods.ctrlCmd = n.ctrlKey || n.metaKey, this.keyMods.alt = n.altKey;
          };
          for (const n of [
            Ce.KEY_DOWN,
            Ce.KEY_UP,
            Ce.MOUSE_DOWN
          ]) t.add(re(e, n, i, true));
        }
        getUI(e) {
          if (this.ui) return e && Oe(this._container) !== Oe(this.layoutService.activeContainer) && (this.reparentUI(this.layoutService.activeContainer), this.layout(this.layoutService.activeContainerDimension, this.layoutService.activeContainerOffset.quickPickTop)), this.ui;
          const t = Ne(this._container, Ws(".quick-input-widget.show-file-icons"));
          t.tabIndex = -1, t.style.display = "none";
          const i = Uo(t), n = Ne(t, Ws(".quick-input-titlebar")), o = this._register(new Wl(n, {
            hoverDelegate: this.options.hoverDelegate
          }));
          o.domNode.classList.add("quick-input-left-action-bar");
          const r = Ne(n, Ws(".quick-input-title")), a = this._register(new Wl(n, {
            hoverDelegate: this.options.hoverDelegate
          }));
          a.domNode.classList.add("quick-input-right-action-bar");
          const l = Ne(t, Ws(".quick-input-header")), u = Ne(l, Ws("input.quick-input-check-all"));
          u.type = "checkbox", u.setAttribute("aria-label", C("quickInput.checkAll", "Toggle all checkboxes")), this._register(ln(u, Ce.CHANGE, (K) => {
            const te = u.checked;
            j.setAllVisibleChecked(te);
          })), this._register(re(u, Ce.CLICK, (K) => {
            (K.x || K.y) && _.setFocus();
          }));
          const d = Ne(l, Ws(".quick-input-description")), f = Ne(l, Ws(".quick-input-and-message")), m = Ne(f, Ws(".quick-input-filter")), _ = this._register(new Qse(m, this.styles.inputBox, this.styles.toggle));
          _.setAttribute("aria-describedby", `${this.idPrefix}message`);
          const b = Ne(m, Ws(".quick-input-visible-count"));
          b.setAttribute("aria-live", "polite"), b.setAttribute("aria-atomic", "true");
          const v = new qP(b, {
            countFormat: C({
              key: "quickInput.visibleCount",
              comment: [
                "This tells the user how many items are shown in a list of items to select from. The items can be anything. Currently not visible, but read by screen readers."
              ]
            }, "{0} Results")
          }, this.styles.countBadge), y = Ne(m, Ws(".quick-input-count"));
          y.setAttribute("aria-live", "polite");
          const x = new qP(y, {
            countFormat: C({
              key: "quickInput.countSelected",
              comment: [
                "This tells the user how many items are selected in a list of items to select from. The items can be anything."
              ]
            }, "{0} Selected")
          }, this.styles.countBadge), L = this._register(new Wl(l, {
            hoverDelegate: this.options.hoverDelegate
          }));
          L.domNode.classList.add("quick-input-inline-action-bar");
          const D = Ne(l, Ws(".quick-input-action")), k = this._register(new p2(D, this.styles.button));
          k.label = C("ok", "OK"), this._register(k.onDidClick((K) => {
            this.onDidAcceptEmitter.fire();
          }));
          const T = Ne(l, Ws(".quick-input-action")), M = this._register(new p2(T, {
            ...this.styles.button,
            supportIcons: true
          }));
          M.label = C("custom", "Custom"), this._register(M.onDidClick((K) => {
            this.onDidCustomEmitter.fire();
          }));
          const I = Ne(f, Ws(`#${this.idPrefix}message.quick-input-message`)), R = this._register(new bN(t, this.styles.progressBar));
          R.getContainer().classList.add("quick-input-progress");
          const A = Ne(t, Ws(".quick-input-html-widget"));
          A.tabIndex = -1;
          const Y = Ne(t, Ws(".quick-input-description")), U = this.idPrefix + "list", j = this._register(this.instantiationService.createInstance(C_, t, this.options.hoverDelegate, this.options.linkOpenerDelegate, U));
          _.setAttribute("aria-controls", U), this._register(j.onDidChangeFocus(() => {
            _.setAttribute("aria-activedescendant", j.getActiveDescendant() ?? "");
          })), this._register(j.onChangedAllVisibleChecked((K) => {
            u.checked = K;
          })), this._register(j.onChangedVisibleCount((K) => {
            v.setCount(K);
          })), this._register(j.onChangedCheckedCount((K) => {
            x.setCount(K);
          })), this._register(j.onLeave(() => {
            setTimeout(() => {
              this.controller && (_.setFocus(), this.controller instanceof jv && this.controller.canSelectMany && j.clearFocus());
            }, 0);
          }));
          const ee = Qp(t);
          return this._register(ee), this._register(re(t, Ce.FOCUS, (K) => {
            const te = this.getUI();
            if (an(K.relatedTarget, te.inputContainer)) {
              const H = te.inputBox.isSelectionAtEnd();
              this.endOfQuickInputBoxContext.get() !== H && this.endOfQuickInputBoxContext.set(H);
            }
            an(K.relatedTarget, te.container) || (this.inQuickInputContext.set(true), this.previousFocusElement = wn(K.relatedTarget) ? K.relatedTarget : void 0);
          }, true)), this._register(ee.onDidBlur(() => {
            !this.getUI().ignoreFocusOut && !this.options.ignoreFocusOut() && this.hide(pg.Blur), this.inQuickInputContext.set(false), this.endOfQuickInputBoxContext.set(false), this.previousFocusElement = void 0;
          })), this._register(_.onKeyDown((K) => {
            const te = this.getUI().inputBox.isSelectionAtEnd();
            this.endOfQuickInputBoxContext.get() !== te && this.endOfQuickInputBoxContext.set(te);
          })), this._register(re(t, Ce.FOCUS, (K) => {
            _.setFocus();
          })), this._register(ln(t, Ce.KEY_DOWN, (K) => {
            if (!an(K.target, A)) switch (K.keyCode) {
              case 3:
                dt.stop(K, true), this.enabled && this.onDidAcceptEmitter.fire();
                break;
              case 9:
                dt.stop(K, true), this.hide(pg.Gesture);
                break;
              case 2:
                if (!K.altKey && !K.ctrlKey && !K.metaKey) {
                  const te = [
                    ".quick-input-list .monaco-action-bar .always-visible",
                    ".quick-input-list-entry:hover .monaco-action-bar",
                    ".monaco-list-row.focused .monaco-action-bar"
                  ];
                  if (t.classList.contains("show-checkboxes") ? te.push("input") : te.push("input[type=text]"), this.getUI().list.displayed && te.push(".monaco-list"), this.getUI().message && te.push(".quick-input-message a"), this.getUI().widget) {
                    if (an(K.target, this.getUI().widget)) break;
                    te.push(".quick-input-html-widget");
                  }
                  const H = t.querySelectorAll(te.join(", "));
                  K.shiftKey && K.target === H[0] ? (dt.stop(K, true), j.clearFocus()) : !K.shiftKey && an(K.target, H[H.length - 1]) && (dt.stop(K, true), H[0].focus());
                }
                break;
              case 10:
                K.ctrlKey && (dt.stop(K, true), this.getUI().list.toggleHover());
                break;
            }
          })), this.ui = {
            container: t,
            styleSheet: i,
            leftActionBar: o,
            titleBar: n,
            title: r,
            description1: Y,
            description2: d,
            widget: A,
            rightActionBar: a,
            inlineActionBar: L,
            checkAll: u,
            inputContainer: f,
            filterContainer: m,
            inputBox: _,
            visibleCountContainer: b,
            visibleCount: v,
            countContainer: y,
            count: x,
            okContainer: D,
            ok: k,
            message: I,
            customButtonContainer: T,
            customButton: M,
            list: j,
            progressBar: R,
            onDidAccept: this.onDidAcceptEmitter.event,
            onDidCustom: this.onDidCustomEmitter.event,
            onDidTriggerButton: this.onDidTriggerButtonEmitter.event,
            ignoreFocusOut: false,
            keyMods: this.keyMods,
            show: (K) => this.show(K),
            hide: () => this.hide(),
            setVisibilities: (K) => this.setVisibilities(K),
            setEnabled: (K) => this.setEnabled(K),
            setContextKey: (K) => this.options.setContextKey(K),
            linkOpenerDelegate: (K) => this.options.linkOpenerDelegate(K)
          }, this.updateStyles(), this.ui;
        }
        reparentUI(e) {
          this.ui && (this._container = e, Ne(this._container, this.ui.container));
        }
        pick(e, t = {}, i = mr.None) {
          return new Promise((n, o) => {
            let r = (d) => {
              var _a3;
              r = n, (_a3 = t.onKeyMods) == null ? void 0 : _a3.call(t, a.keyMods), n(d);
            };
            if (i.isCancellationRequested) {
              r(void 0);
              return;
            }
            const a = this.createQuickPick({
              useSeparators: true
            });
            let l;
            const u = [
              a,
              a.onDidAccept(() => {
                if (a.canSelectMany) r(a.selectedItems.slice()), a.hide();
                else {
                  const d = a.activeItems[0];
                  d && (r(d), a.hide());
                }
              }),
              a.onDidChangeActive((d) => {
                const f = d[0];
                f && t.onDidFocus && t.onDidFocus(f);
              }),
              a.onDidChangeSelection((d) => {
                if (!a.canSelectMany) {
                  const f = d[0];
                  f && (r(f), a.hide());
                }
              }),
              a.onDidTriggerItemButton((d) => t.onDidTriggerItemButton && t.onDidTriggerItemButton({
                ...d,
                removeItem: () => {
                  const f = a.items.indexOf(d.item);
                  if (f !== -1) {
                    const m = a.items.slice(), _ = m.splice(f, 1), b = a.activeItems.filter((y) => y !== _[0]), v = a.keepScrollPosition;
                    a.keepScrollPosition = true, a.items = m, b && (a.activeItems = b), a.keepScrollPosition = v;
                  }
                }
              })),
              a.onDidTriggerSeparatorButton((d) => {
                var _a3;
                return (_a3 = t.onDidTriggerSeparatorButton) == null ? void 0 : _a3.call(t, d);
              }),
              a.onDidChangeValue((d) => {
                l && !d && (a.activeItems.length !== 1 || a.activeItems[0] !== l) && (a.activeItems = [
                  l
                ]);
              }),
              i.onCancellationRequested(() => {
                a.hide();
              }),
              a.onDidHide(() => {
                On(u), r(void 0);
              })
            ];
            a.title = t.title, t.value && (a.value = t.value), a.canSelectMany = !!t.canPickMany, a.placeholder = t.placeHolder, a.ignoreFocusOut = !!t.ignoreFocusLost, a.matchOnDescription = !!t.matchOnDescription, a.matchOnDetail = !!t.matchOnDetail, a.matchOnLabel = t.matchOnLabel === void 0 || t.matchOnLabel, a.quickNavigate = t.quickNavigate, a.hideInput = !!t.hideInput, a.contextKey = t.contextKey, a.busy = true, Promise.all([
              e,
              t.activeItem
            ]).then(([d, f]) => {
              l = f, a.busy = false, a.items = d, a.canSelectMany && (a.selectedItems = d.filter((m) => m.type !== "separator" && m.picked)), l && (a.activeItems = [
                l
              ]);
            }), a.show(), Promise.resolve(e).then(void 0, (d) => {
              o(d), a.hide();
            });
          });
        }
        createQuickPick(e = {
          useSeparators: false
        }) {
          const t = this.getUI(true);
          return new jv(t);
        }
        createInputBox() {
          const e = this.getUI(true);
          return new Bse(e);
        }
        show(e) {
          const t = this.getUI(true);
          this.onShowEmitter.fire();
          const i = this.controller;
          this.controller = e, i == null ? void 0 : i.didHide(), this.setEnabled(true), t.leftActionBar.clear(), t.title.textContent = "", t.description1.textContent = "", t.description2.textContent = "", gs(t.widget), t.rightActionBar.clear(), t.inlineActionBar.clear(), t.checkAll.checked = false, t.inputBox.placeholder = "", t.inputBox.password = false, t.inputBox.showDecoration(Ui.Ignore), t.visibleCount.setCount(0), t.count.setCount(0), gs(t.message), t.progressBar.stop(), t.list.setElements([]), t.list.matchOnDescription = false, t.list.matchOnDetail = false, t.list.matchOnLabel = true, t.list.sortByLabel = true, t.ignoreFocusOut = false, t.inputBox.toggles = void 0;
          const n = this.options.backKeybindingLabel();
          g2.tooltip = n ? C("quickInput.backWithKeybinding", "Back ({0})", n) : C("quickInput.back", "Back"), t.container.style.display = "", this.updateLayout(), t.inputBox.setFocus(), this.quickInputTypeContext.set(e.type);
        }
        isVisible() {
          return !!this.ui && this.ui.container.style.display !== "none";
        }
        setVisibilities(e) {
          const t = this.getUI();
          t.title.style.display = e.title ? "" : "none", t.description1.style.display = e.description && (e.inputBox || e.checkAll) ? "" : "none", t.description2.style.display = e.description && !(e.inputBox || e.checkAll) ? "" : "none", t.checkAll.style.display = e.checkAll ? "" : "none", t.inputContainer.style.display = e.inputBox ? "" : "none", t.filterContainer.style.display = e.inputBox ? "" : "none", t.visibleCountContainer.style.display = e.visibleCount ? "" : "none", t.countContainer.style.display = e.count ? "" : "none", t.okContainer.style.display = e.ok ? "" : "none", t.customButtonContainer.style.display = e.customButton ? "" : "none", t.message.style.display = e.message ? "" : "none", t.progressBar.getContainer().style.display = e.progressBar ? "" : "none", t.list.displayed = !!e.list, t.container.classList.toggle("show-checkboxes", !!e.checkBox), t.container.classList.toggle("hidden-input", !e.inputBox && !e.description), this.updateLayout();
        }
        setEnabled(e) {
          if (e !== this.enabled) {
            this.enabled = e;
            for (const t of this.getUI().leftActionBar.viewItems) t.action.enabled = e;
            for (const t of this.getUI().rightActionBar.viewItems) t.action.enabled = e;
            this.getUI().checkAll.disabled = !e, this.getUI().inputBox.enabled = e, this.getUI().ok.enabled = e, this.getUI().list.enabled = e;
          }
        }
        hide(e) {
          var _a3;
          const t = this.controller;
          if (!t) return;
          t.willHide(e);
          const i = (_a3 = this.ui) == null ? void 0 : _a3.container, n = i && !Q9(i);
          if (this.controller = null, this.onHideEmitter.fire(), i && (i.style.display = "none"), !n) {
            let o = this.previousFocusElement;
            for (; o && !o.offsetParent; ) o = o.parentElement ?? void 0;
            (o == null ? void 0 : o.offsetParent) ? (o.focus(), this.previousFocusElement = void 0) : this.options.returnFocus();
          }
          t.didHide(e);
        }
        layout(e, t) {
          this.dimension = e, this.titleBarOffset = t, this.updateLayout();
        }
        updateLayout() {
          if (this.ui && this.isVisible()) {
            this.ui.container.style.top = `${this.titleBarOffset}px`;
            const e = this.ui.container.style, t = Math.min(this.dimension.width * 0.62, S2.MAX_WIDTH);
            e.width = t + "px", e.marginLeft = "-" + t / 2 + "px", this.ui.inputBox.layout(), this.ui.list.layout(this.dimension && this.dimension.height * 0.4);
          }
        }
        applyStyles(e) {
          this.styles = e, this.updateStyles();
        }
        updateStyles() {
          if (this.ui) {
            const { quickInputTitleBackground: e, quickInputBackground: t, quickInputForeground: i, widgetBorder: n, widgetShadow: o } = this.styles.widget;
            this.ui.titleBar.style.backgroundColor = e ?? "", this.ui.container.style.backgroundColor = t ?? "", this.ui.container.style.color = i ?? "", this.ui.container.style.border = n ? `1px solid ${n}` : "", this.ui.container.style.boxShadow = o ? `0 0 8px 2px ${o}` : "", this.ui.list.style(this.styles.list);
            const r = [];
            this.styles.pickerGroup.pickerGroupBorder && r.push(`.quick-input-list .quick-input-list-entry { border-top-color:  ${this.styles.pickerGroup.pickerGroupBorder}; }`), this.styles.pickerGroup.pickerGroupForeground && r.push(`.quick-input-list .quick-input-list-separator { color:  ${this.styles.pickerGroup.pickerGroupForeground}; }`), this.styles.pickerGroup.pickerGroupForeground && r.push(".quick-input-list .quick-input-list-separator-as-item { color: var(--vscode-descriptionForeground); }"), (this.styles.keybindingLabel.keybindingLabelBackground || this.styles.keybindingLabel.keybindingLabelBorder || this.styles.keybindingLabel.keybindingLabelBottomBorder || this.styles.keybindingLabel.keybindingLabelShadow || this.styles.keybindingLabel.keybindingLabelForeground) && (r.push(".quick-input-list .monaco-keybinding > .monaco-keybinding-key {"), this.styles.keybindingLabel.keybindingLabelBackground && r.push(`background-color: ${this.styles.keybindingLabel.keybindingLabelBackground};`), this.styles.keybindingLabel.keybindingLabelBorder && r.push(`border-color: ${this.styles.keybindingLabel.keybindingLabelBorder};`), this.styles.keybindingLabel.keybindingLabelBottomBorder && r.push(`border-bottom-color: ${this.styles.keybindingLabel.keybindingLabelBottomBorder};`), this.styles.keybindingLabel.keybindingLabelShadow && r.push(`box-shadow: inset 0 -1px 0 ${this.styles.keybindingLabel.keybindingLabelShadow};`), this.styles.keybindingLabel.keybindingLabelForeground && r.push(`color: ${this.styles.keybindingLabel.keybindingLabelForeground};`), r.push("}"));
            const a = r.join(`
`);
            a !== this.ui.styleSheet.textContent && (this.ui.styleSheet.textContent = a);
          }
        }
      }, S2 = _k2, _k2.MAX_WIDTH = 600, _k2);
      L2 = S2 = pre([
        mx(1, du),
        mx(2, Ft),
        mx(3, Mt)
      ], L2);
      var _re = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      }, jm = function(s, e) {
        return function(t, i) {
          e(t, i, s);
        };
      };
      let x2 = class extends qY {
        get controller() {
          return this._controller || (this._controller = this._register(this.createController())), this._controller;
        }
        get hasController() {
          return !!this._controller;
        }
        get currentQuickInput() {
          return this.controller.currentQuickInput;
        }
        get quickAccess() {
          return this._quickAccess || (this._quickAccess = this._register(this.instantiationService.createInstance(f2))), this._quickAccess;
        }
        constructor(e, t, i, n, o) {
          super(i), this.instantiationService = e, this.contextKeyService = t, this.layoutService = n, this.configurationService = o, this._onShow = this._register(new G()), this._onHide = this._register(new G()), this.contexts = /* @__PURE__ */ new Map();
        }
        createController(e = this.layoutService, t) {
          const i = {
            idPrefix: "quickInput_",
            container: e.activeContainer,
            ignoreFocusOut: () => false,
            backKeybindingLabel: () => {
            },
            setContextKey: (o) => this.setContextKey(o),
            linkOpenerDelegate: (o) => {
              this.instantiationService.invokeFunction((r) => {
                r.get(X_).open(o, {
                  allowCommands: true,
                  fromUserGesture: true
                });
              });
            },
            returnFocus: () => e.focus(),
            styles: this.computeStyles(),
            hoverDelegate: this._register(this.instantiationService.createInstance(m2))
          }, n = this._register(this.instantiationService.createInstance(L2, {
            ...i,
            ...t
          }));
          return n.layout(e.activeContainerDimension, e.activeContainerOffset.quickPickTop), this._register(e.onDidLayoutActiveContainer((o) => {
            Oe(e.activeContainer) === Oe(n.container) && n.layout(o, e.activeContainerOffset.quickPickTop);
          })), this._register(e.onDidChangeActiveContainer(() => {
            n.isVisible() || n.layout(e.activeContainerDimension, e.activeContainerOffset.quickPickTop);
          })), this._register(n.onShow(() => {
            this.resetContextKeys(), this._onShow.fire();
          })), this._register(n.onHide(() => {
            this.resetContextKeys(), this._onHide.fire();
          })), n;
        }
        setContextKey(e) {
          let t;
          e && (t = this.contexts.get(e), t || (t = new Ie(e, false).bindTo(this.contextKeyService), this.contexts.set(e, t))), !(t && t.get()) && (this.resetContextKeys(), t == null ? void 0 : t.set(true));
        }
        resetContextKeys() {
          this.contexts.forEach((e) => {
            e.get() && e.reset();
          });
        }
        pick(e, t, i = mr.None) {
          return this.controller.pick(e, t, i);
        }
        createQuickPick(e = {
          useSeparators: false
        }) {
          return this.controller.createQuickPick(e);
        }
        createInputBox() {
          return this.controller.createInputBox();
        }
        updateStyles() {
          this.hasController && this.controller.applyStyles(this.computeStyles());
        }
        computeStyles() {
          return {
            widget: {
              quickInputBackground: we(E5),
              quickInputForeground: we(rX),
              quickInputTitleBackground: we(aX),
              widgetBorder: we($Z),
              widgetShadow: we(Y_)
            },
            inputBox: nB,
            toggle: iB,
            countBadge: jte,
            button: $te,
            progressBar: qte,
            keybindingLabel: Ute,
            list: i1({
              listBackground: E5,
              listFocusBackground: LD,
              listFocusForeground: SD,
              listInactiveFocusForeground: SD,
              listInactiveSelectionIconForeground: v6,
              listInactiveFocusBackground: LD,
              listFocusOutline: Ai,
              listInactiveFocusOutline: Ai
            }),
            pickerGroup: {
              pickerGroupBorder: we(lX),
              pickerGroupForeground: we(b6)
            }
          };
        }
      };
      x2 = _re([
        jm(0, Ft),
        jm(1, Mt),
        jm(2, vr),
        jm(3, du),
        jm(4, Si)
      ], x2);
      var rF = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      }, oh = function(s, e) {
        return function(t, i) {
          e(t, i, s);
        };
      };
      let k2 = class extends x2 {
        constructor(e, t, i, n, o, r) {
          super(t, i, n, new uD(e.getContainerDomNode(), o), r), this.host = void 0;
          const a = w_.get(e);
          if (a) {
            const l = a.widget;
            this.host = {
              _serviceBrand: void 0,
              get mainContainer() {
                return l.getDomNode();
              },
              getContainer() {
                return l.getDomNode();
              },
              whenContainerStylesLoaded() {
              },
              get containers() {
                return [
                  l.getDomNode()
                ];
              },
              get activeContainer() {
                return l.getDomNode();
              },
              get mainContainerDimension() {
                return e.getLayoutInfo();
              },
              get activeContainerDimension() {
                return e.getLayoutInfo();
              },
              get onDidLayoutMainContainer() {
                return e.onDidLayoutChange;
              },
              get onDidLayoutActiveContainer() {
                return e.onDidLayoutChange;
              },
              get onDidLayoutContainer() {
                return be.map(e.onDidLayoutChange, (u) => ({
                  container: l.getDomNode(),
                  dimension: u
                }));
              },
              get onDidChangeActiveContainer() {
                return be.None;
              },
              get onDidAddContainer() {
                return be.None;
              },
              get mainContainerOffset() {
                return {
                  top: 0,
                  quickPickTop: 0
                };
              },
              get activeContainerOffset() {
                return {
                  top: 0,
                  quickPickTop: 0
                };
              },
              focus: () => e.focus()
            };
          } else this.host = void 0;
        }
        createController() {
          return super.createController(this.host);
        }
      };
      k2 = rF([
        oh(1, Ft),
        oh(2, Mt),
        oh(3, vr),
        oh(4, Xi),
        oh(5, Si)
      ], k2);
      let D2 = class {
        get activeService() {
          const e = this.codeEditorService.getFocusedCodeEditor();
          if (!e) throw new Error("Quick input service needs a focused editor to work.");
          let t = this.mapEditorToService.get(e);
          if (!t) {
            const i = t = this.instantiationService.createInstance(k2, e);
            this.mapEditorToService.set(e, t), tg(e.onDidDispose)(() => {
              i.dispose(), this.mapEditorToService.delete(e);
            });
          }
          return t;
        }
        get currentQuickInput() {
          return this.activeService.currentQuickInput;
        }
        get quickAccess() {
          return this.activeService.quickAccess;
        }
        constructor(e, t) {
          this.instantiationService = e, this.codeEditorService = t, this.mapEditorToService = /* @__PURE__ */ new Map();
        }
        pick(e, t, i = mr.None) {
          return this.activeService.pick(e, t, i);
        }
        createQuickPick(e = {
          useSeparators: false
        }) {
          return this.activeService.createQuickPick(e);
        }
        createInputBox() {
          return this.activeService.createInputBox();
        }
      };
      D2 = rF([
        oh(0, Ft),
        oh(1, Xi)
      ], D2);
      const _w_ = class _w_ {
        static get(e) {
          return e.getContribution(_w_.ID);
        }
        constructor(e) {
          this.editor = e, this.widget = new FN(this.editor);
        }
        dispose() {
          this.widget.dispose();
        }
      };
      _w_.ID = "editor.controller.quickInput";
      let w_ = _w_;
      const _FN = class _FN {
        constructor(e) {
          this.codeEditor = e, this.domNode = document.createElement("div"), this.codeEditor.addOverlayWidget(this);
        }
        getId() {
          return _FN.ID;
        }
        getDomNode() {
          return this.domNode;
        }
        getPosition() {
          return {
            preference: 2
          };
        }
        dispose() {
          this.codeEditor.removeOverlayWidget(this);
        }
      };
      _FN.ID = "editor.contrib.quickInputWidget";
      let FN = _FN;
      l8(w_.ID, w_, 4);
      class bre {
        constructor(e, t, i, n, o) {
          this._parsedThemeRuleBrand = void 0, this.token = e, this.index = t, this.fontStyle = i, this.foreground = n, this.background = o;
        }
      }
      function vre(s) {
        if (!s || !Array.isArray(s)) return [];
        const e = [];
        let t = 0;
        for (let i = 0, n = s.length; i < n; i++) {
          const o = s[i];
          let r = -1;
          if (typeof o.fontStyle == "string") {
            r = 0;
            const u = o.fontStyle.split(" ");
            for (let d = 0, f = u.length; d < f; d++) switch (u[d]) {
              case "italic":
                r = r | 1;
                break;
              case "bold":
                r = r | 2;
                break;
              case "underline":
                r = r | 4;
                break;
              case "strikethrough":
                r = r | 8;
                break;
            }
          }
          let a = null;
          typeof o.foreground == "string" && (a = o.foreground);
          let l = null;
          typeof o.background == "string" && (l = o.background), e[t++] = new bre(o.token || "", i, r, a, l);
        }
        return e;
      }
      function Cre(s, e) {
        s.sort((d, f) => {
          const m = xre(d.token, f.token);
          return m !== 0 ? m : d.index - f.index;
        });
        let t = 0, i = "000000", n = "ffffff";
        for (; s.length >= 1 && s[0].token === ""; ) {
          const d = s.shift();
          d.fontStyle !== -1 && (t = d.fontStyle), d.foreground !== null && (i = d.foreground), d.background !== null && (n = d.background);
        }
        const o = new yre();
        for (const d of e) o.getId(d);
        const r = o.getId(i), a = o.getId(n), l = new VN(t, r, a), u = new WN(l);
        for (let d = 0, f = s.length; d < f; d++) {
          const m = s[d];
          u.insert(m.token, m.fontStyle, o.getId(m.foreground), o.getId(m.background));
        }
        return new aF(o, u);
      }
      const wre = /^#?([0-9A-Fa-f]{6})([0-9A-Fa-f]{2})?$/;
      class yre {
        constructor() {
          this._lastColorId = 0, this._id2color = [], this._color2id = /* @__PURE__ */ new Map();
        }
        getId(e) {
          if (e === null) return 0;
          const t = e.match(wre);
          if (!t) throw new Error("Illegal value for token color: " + e);
          e = t[1].toUpperCase();
          let i = this._color2id.get(e);
          return i || (i = ++this._lastColorId, this._color2id.set(e, i), this._id2color[i] = le.fromHex("#" + e), i);
        }
        getColorMap() {
          return this._id2color.slice(0);
        }
      }
      class aF {
        static createFromRawTokenTheme(e, t) {
          return this.createFromParsedTokenTheme(vre(e), t);
        }
        static createFromParsedTokenTheme(e, t) {
          return Cre(e, t);
        }
        constructor(e, t) {
          this._colorMap = e, this._root = t, this._cache = /* @__PURE__ */ new Map();
        }
        getColorMap() {
          return this._colorMap.getColorMap();
        }
        _match(e) {
          return this._root.match(e);
        }
        match(e, t) {
          let i = this._cache.get(t);
          if (typeof i > "u") {
            const n = this._match(t), o = Lre(t);
            i = (n.metadata | o << 8) >>> 0, this._cache.set(t, i);
          }
          return (i | e << 0) >>> 0;
        }
      }
      const Sre = /\b(comment|string|regex|regexp)\b/;
      function Lre(s) {
        const e = s.match(Sre);
        if (!e) return 0;
        switch (e[1]) {
          case "comment":
            return 1;
          case "string":
            return 2;
          case "regex":
            return 3;
          case "regexp":
            return 3;
        }
        throw new Error("Unexpected match for standard token type!");
      }
      function xre(s, e) {
        return s < e ? -1 : s > e ? 1 : 0;
      }
      class VN {
        constructor(e, t, i) {
          this._themeTrieElementRuleBrand = void 0, this._fontStyle = e, this._foreground = t, this._background = i, this.metadata = (this._fontStyle << 11 | this._foreground << 15 | this._background << 24) >>> 0;
        }
        clone() {
          return new VN(this._fontStyle, this._foreground, this._background);
        }
        acceptOverwrite(e, t, i) {
          e !== -1 && (this._fontStyle = e), t !== 0 && (this._foreground = t), i !== 0 && (this._background = i), this.metadata = (this._fontStyle << 11 | this._foreground << 15 | this._background << 24) >>> 0;
        }
      }
      class WN {
        constructor(e) {
          this._themeTrieElementBrand = void 0, this._mainRule = e, this._children = /* @__PURE__ */ new Map();
        }
        match(e) {
          if (e === "") return this._mainRule;
          const t = e.indexOf(".");
          let i, n;
          t === -1 ? (i = e, n = "") : (i = e.substring(0, t), n = e.substring(t + 1));
          const o = this._children.get(i);
          return typeof o < "u" ? o.match(n) : this._mainRule;
        }
        insert(e, t, i, n) {
          if (e === "") {
            this._mainRule.acceptOverwrite(t, i, n);
            return;
          }
          const o = e.indexOf(".");
          let r, a;
          o === -1 ? (r = e, a = "") : (r = e.substring(0, o), a = e.substring(o + 1));
          let l = this._children.get(r);
          typeof l > "u" && (l = new WN(this._mainRule.clone()), this._children.set(r, l)), l.insert(a, t, i, n);
        }
      }
      function kre(s) {
        const e = [];
        for (let t = 1, i = s.length; t < i; t++) {
          const n = s[t];
          e[t] = `.mtk${t} { color: ${n}; }`;
        }
        return e.push(".mtki { font-style: italic; }"), e.push(".mtkb { font-weight: bold; }"), e.push(".mtku { text-decoration: underline; text-underline-position: under; }"), e.push(".mtks { text-decoration: line-through; }"), e.push(".mtks.mtku { text-decoration: underline line-through; text-underline-position: under; }"), e.join(`
`);
      }
      const Dre = {
        base: "vs",
        inherit: false,
        rules: [
          {
            token: "",
            foreground: "000000",
            background: "fffffe"
          },
          {
            token: "invalid",
            foreground: "cd3131"
          },
          {
            token: "emphasis",
            fontStyle: "italic"
          },
          {
            token: "strong",
            fontStyle: "bold"
          },
          {
            token: "variable",
            foreground: "001188"
          },
          {
            token: "variable.predefined",
            foreground: "4864AA"
          },
          {
            token: "constant",
            foreground: "dd0000"
          },
          {
            token: "comment",
            foreground: "008000"
          },
          {
            token: "number",
            foreground: "098658"
          },
          {
            token: "number.hex",
            foreground: "3030c0"
          },
          {
            token: "regexp",
            foreground: "800000"
          },
          {
            token: "annotation",
            foreground: "808080"
          },
          {
            token: "type",
            foreground: "008080"
          },
          {
            token: "delimiter",
            foreground: "000000"
          },
          {
            token: "delimiter.html",
            foreground: "383838"
          },
          {
            token: "delimiter.xml",
            foreground: "0000FF"
          },
          {
            token: "tag",
            foreground: "800000"
          },
          {
            token: "tag.id.pug",
            foreground: "4F76AC"
          },
          {
            token: "tag.class.pug",
            foreground: "4F76AC"
          },
          {
            token: "meta.scss",
            foreground: "800000"
          },
          {
            token: "metatag",
            foreground: "e00000"
          },
          {
            token: "metatag.content.html",
            foreground: "FF0000"
          },
          {
            token: "metatag.html",
            foreground: "808080"
          },
          {
            token: "metatag.xml",
            foreground: "808080"
          },
          {
            token: "metatag.php",
            fontStyle: "bold"
          },
          {
            token: "key",
            foreground: "863B00"
          },
          {
            token: "string.key.json",
            foreground: "A31515"
          },
          {
            token: "string.value.json",
            foreground: "0451A5"
          },
          {
            token: "attribute.name",
            foreground: "FF0000"
          },
          {
            token: "attribute.value",
            foreground: "0451A5"
          },
          {
            token: "attribute.value.number",
            foreground: "098658"
          },
          {
            token: "attribute.value.unit",
            foreground: "098658"
          },
          {
            token: "attribute.value.html",
            foreground: "0000FF"
          },
          {
            token: "attribute.value.xml",
            foreground: "0000FF"
          },
          {
            token: "string",
            foreground: "A31515"
          },
          {
            token: "string.html",
            foreground: "0000FF"
          },
          {
            token: "string.sql",
            foreground: "FF0000"
          },
          {
            token: "string.yaml",
            foreground: "0451A5"
          },
          {
            token: "keyword",
            foreground: "0000FF"
          },
          {
            token: "keyword.json",
            foreground: "0451A5"
          },
          {
            token: "keyword.flow",
            foreground: "AF00DB"
          },
          {
            token: "keyword.flow.scss",
            foreground: "0000FF"
          },
          {
            token: "operator.scss",
            foreground: "666666"
          },
          {
            token: "operator.sql",
            foreground: "778899"
          },
          {
            token: "operator.swift",
            foreground: "666666"
          },
          {
            token: "predefined.sql",
            foreground: "C700C7"
          }
        ],
        colors: {
          [qr]: "#FFFFFE",
          [G_]: "#000000",
          [o6]: "#E5EBF1",
          [s1]: "#D3D3D3",
          [o1]: "#939393",
          [r6]: "#ADD6FF4D"
        }
      }, Ere = {
        base: "vs-dark",
        inherit: false,
        rules: [
          {
            token: "",
            foreground: "D4D4D4",
            background: "1E1E1E"
          },
          {
            token: "invalid",
            foreground: "f44747"
          },
          {
            token: "emphasis",
            fontStyle: "italic"
          },
          {
            token: "strong",
            fontStyle: "bold"
          },
          {
            token: "variable",
            foreground: "74B0DF"
          },
          {
            token: "variable.predefined",
            foreground: "4864AA"
          },
          {
            token: "variable.parameter",
            foreground: "9CDCFE"
          },
          {
            token: "constant",
            foreground: "569CD6"
          },
          {
            token: "comment",
            foreground: "608B4E"
          },
          {
            token: "number",
            foreground: "B5CEA8"
          },
          {
            token: "number.hex",
            foreground: "5BB498"
          },
          {
            token: "regexp",
            foreground: "B46695"
          },
          {
            token: "annotation",
            foreground: "cc6666"
          },
          {
            token: "type",
            foreground: "3DC9B0"
          },
          {
            token: "delimiter",
            foreground: "DCDCDC"
          },
          {
            token: "delimiter.html",
            foreground: "808080"
          },
          {
            token: "delimiter.xml",
            foreground: "808080"
          },
          {
            token: "tag",
            foreground: "569CD6"
          },
          {
            token: "tag.id.pug",
            foreground: "4F76AC"
          },
          {
            token: "tag.class.pug",
            foreground: "4F76AC"
          },
          {
            token: "meta.scss",
            foreground: "A79873"
          },
          {
            token: "meta.tag",
            foreground: "CE9178"
          },
          {
            token: "metatag",
            foreground: "DD6A6F"
          },
          {
            token: "metatag.content.html",
            foreground: "9CDCFE"
          },
          {
            token: "metatag.html",
            foreground: "569CD6"
          },
          {
            token: "metatag.xml",
            foreground: "569CD6"
          },
          {
            token: "metatag.php",
            fontStyle: "bold"
          },
          {
            token: "key",
            foreground: "9CDCFE"
          },
          {
            token: "string.key.json",
            foreground: "9CDCFE"
          },
          {
            token: "string.value.json",
            foreground: "CE9178"
          },
          {
            token: "attribute.name",
            foreground: "9CDCFE"
          },
          {
            token: "attribute.value",
            foreground: "CE9178"
          },
          {
            token: "attribute.value.number.css",
            foreground: "B5CEA8"
          },
          {
            token: "attribute.value.unit.css",
            foreground: "B5CEA8"
          },
          {
            token: "attribute.value.hex.css",
            foreground: "D4D4D4"
          },
          {
            token: "string",
            foreground: "CE9178"
          },
          {
            token: "string.sql",
            foreground: "FF0000"
          },
          {
            token: "keyword",
            foreground: "569CD6"
          },
          {
            token: "keyword.flow",
            foreground: "C586C0"
          },
          {
            token: "keyword.json",
            foreground: "CE9178"
          },
          {
            token: "keyword.flow.scss",
            foreground: "569CD6"
          },
          {
            token: "operator.scss",
            foreground: "909090"
          },
          {
            token: "operator.sql",
            foreground: "778899"
          },
          {
            token: "operator.swift",
            foreground: "909090"
          },
          {
            token: "predefined.sql",
            foreground: "FF00FF"
          }
        ],
        colors: {
          [qr]: "#1E1E1E",
          [G_]: "#D4D4D4",
          [o6]: "#3A3D41",
          [s1]: "#404040",
          [o1]: "#707070",
          [r6]: "#ADD6FF26"
        }
      }, Tre = {
        base: "hc-black",
        inherit: false,
        rules: [
          {
            token: "",
            foreground: "FFFFFF",
            background: "000000"
          },
          {
            token: "invalid",
            foreground: "f44747"
          },
          {
            token: "emphasis",
            fontStyle: "italic"
          },
          {
            token: "strong",
            fontStyle: "bold"
          },
          {
            token: "variable",
            foreground: "1AEBFF"
          },
          {
            token: "variable.parameter",
            foreground: "9CDCFE"
          },
          {
            token: "constant",
            foreground: "569CD6"
          },
          {
            token: "comment",
            foreground: "608B4E"
          },
          {
            token: "number",
            foreground: "FFFFFF"
          },
          {
            token: "regexp",
            foreground: "C0C0C0"
          },
          {
            token: "annotation",
            foreground: "569CD6"
          },
          {
            token: "type",
            foreground: "3DC9B0"
          },
          {
            token: "delimiter",
            foreground: "FFFF00"
          },
          {
            token: "delimiter.html",
            foreground: "FFFF00"
          },
          {
            token: "tag",
            foreground: "569CD6"
          },
          {
            token: "tag.id.pug",
            foreground: "4F76AC"
          },
          {
            token: "tag.class.pug",
            foreground: "4F76AC"
          },
          {
            token: "meta",
            foreground: "D4D4D4"
          },
          {
            token: "meta.tag",
            foreground: "CE9178"
          },
          {
            token: "metatag",
            foreground: "569CD6"
          },
          {
            token: "metatag.content.html",
            foreground: "1AEBFF"
          },
          {
            token: "metatag.html",
            foreground: "569CD6"
          },
          {
            token: "metatag.xml",
            foreground: "569CD6"
          },
          {
            token: "metatag.php",
            fontStyle: "bold"
          },
          {
            token: "key",
            foreground: "9CDCFE"
          },
          {
            token: "string.key",
            foreground: "9CDCFE"
          },
          {
            token: "string.value",
            foreground: "CE9178"
          },
          {
            token: "attribute.name",
            foreground: "569CD6"
          },
          {
            token: "attribute.value",
            foreground: "3FF23F"
          },
          {
            token: "string",
            foreground: "CE9178"
          },
          {
            token: "string.sql",
            foreground: "FF0000"
          },
          {
            token: "keyword",
            foreground: "569CD6"
          },
          {
            token: "keyword.flow",
            foreground: "C586C0"
          },
          {
            token: "operator.sql",
            foreground: "778899"
          },
          {
            token: "operator.swift",
            foreground: "909090"
          },
          {
            token: "predefined.sql",
            foreground: "FF00FF"
          }
        ],
        colors: {
          [qr]: "#000000",
          [G_]: "#FFFFFF",
          [s1]: "#FFFFFF",
          [o1]: "#FFFFFF"
        }
      }, Nre = {
        base: "hc-light",
        inherit: false,
        rules: [
          {
            token: "",
            foreground: "292929",
            background: "FFFFFF"
          },
          {
            token: "invalid",
            foreground: "B5200D"
          },
          {
            token: "emphasis",
            fontStyle: "italic"
          },
          {
            token: "strong",
            fontStyle: "bold"
          },
          {
            token: "variable",
            foreground: "264F70"
          },
          {
            token: "variable.predefined",
            foreground: "4864AA"
          },
          {
            token: "constant",
            foreground: "dd0000"
          },
          {
            token: "comment",
            foreground: "008000"
          },
          {
            token: "number",
            foreground: "098658"
          },
          {
            token: "number.hex",
            foreground: "3030c0"
          },
          {
            token: "regexp",
            foreground: "800000"
          },
          {
            token: "annotation",
            foreground: "808080"
          },
          {
            token: "type",
            foreground: "008080"
          },
          {
            token: "delimiter",
            foreground: "000000"
          },
          {
            token: "delimiter.html",
            foreground: "383838"
          },
          {
            token: "tag",
            foreground: "800000"
          },
          {
            token: "tag.id.pug",
            foreground: "4F76AC"
          },
          {
            token: "tag.class.pug",
            foreground: "4F76AC"
          },
          {
            token: "meta.scss",
            foreground: "800000"
          },
          {
            token: "metatag",
            foreground: "e00000"
          },
          {
            token: "metatag.content.html",
            foreground: "B5200D"
          },
          {
            token: "metatag.html",
            foreground: "808080"
          },
          {
            token: "metatag.xml",
            foreground: "808080"
          },
          {
            token: "metatag.php",
            fontStyle: "bold"
          },
          {
            token: "key",
            foreground: "863B00"
          },
          {
            token: "string.key.json",
            foreground: "A31515"
          },
          {
            token: "string.value.json",
            foreground: "0451A5"
          },
          {
            token: "attribute.name",
            foreground: "264F78"
          },
          {
            token: "attribute.value",
            foreground: "0451A5"
          },
          {
            token: "string",
            foreground: "A31515"
          },
          {
            token: "string.sql",
            foreground: "B5200D"
          },
          {
            token: "keyword",
            foreground: "0000FF"
          },
          {
            token: "keyword.flow",
            foreground: "AF00DB"
          },
          {
            token: "operator.sql",
            foreground: "778899"
          },
          {
            token: "operator.swift",
            foreground: "666666"
          },
          {
            token: "predefined.sql",
            foreground: "C700C7"
          }
        ],
        colors: {
          [qr]: "#FFFFFF",
          [G_]: "#292929",
          [s1]: "#292929",
          [o1]: "#292929"
        }
      }, Ire = {
        IconContribution: "base.contributions.icons"
      };
      var g3;
      (function(s) {
        function e(t, i) {
          let n = t.defaults;
          for (; wt.isThemeIcon(n); ) {
            const o = nd.getIcon(n.id);
            if (!o) return;
            n = o.defaults;
          }
          return n;
        }
        s.getDefinition = e;
      })(g3 || (g3 = {}));
      var m3;
      (function(s) {
        function e(i) {
          return {
            weight: i.weight,
            style: i.style,
            src: i.src.map((n) => ({
              format: n.format,
              location: n.location.toString()
            }))
          };
        }
        s.toJSONObject = e;
        function t(i) {
          const n = (o) => ho(o) ? o : void 0;
          if (i && Array.isArray(i.src) && i.src.every((o) => ho(o.format) && ho(o.location))) return {
            weight: n(i.weight),
            style: n(i.style),
            src: i.src.map((o) => ({
              format: o.format,
              location: st.parse(o.location)
            }))
          };
        }
        s.fromJSONObject = t;
      })(m3 || (m3 = {}));
      class Mre {
        constructor() {
          this._onDidChange = new G(), this.onDidChange = this._onDidChange.event, this.iconSchema = {
            definitions: {
              icons: {
                type: "object",
                properties: {
                  fontId: {
                    type: "string",
                    description: C("iconDefinition.fontId", "The id of the font to use. If not set, the font that is defined first is used.")
                  },
                  fontCharacter: {
                    type: "string",
                    description: C("iconDefinition.fontCharacter", "The font character associated with the icon definition.")
                  }
                },
                additionalProperties: false,
                defaultSnippets: [
                  {
                    body: {
                      fontCharacter: "\\\\e030"
                    }
                  }
                ]
              }
            },
            type: "object",
            properties: {}
          }, this.iconReferenceSchema = {
            type: "string",
            pattern: `^${wt.iconNameExpression}$`,
            enum: [],
            enumDescriptions: []
          }, this.iconsById = {}, this.iconFontsById = {};
        }
        registerIcon(e, t, i, n) {
          const o = this.iconsById[e];
          if (o) {
            if (i && !o.description) {
              o.description = i, this.iconSchema.properties[e].markdownDescription = `${i} $(${e})`;
              const l = this.iconReferenceSchema.enum.indexOf(e);
              l !== -1 && (this.iconReferenceSchema.enumDescriptions[l] = i), this._onDidChange.fire();
            }
            return o;
          }
          const r = {
            id: e,
            description: i,
            defaults: t,
            deprecationMessage: n
          };
          this.iconsById[e] = r;
          const a = {
            $ref: "#/definitions/icons"
          };
          return n && (a.deprecationMessage = n), i && (a.markdownDescription = `${i}: $(${e})`), this.iconSchema.properties[e] = a, this.iconReferenceSchema.enum.push(e), this.iconReferenceSchema.enumDescriptions.push(i || ""), this._onDidChange.fire(), {
            id: e
          };
        }
        getIcons() {
          return Object.keys(this.iconsById).map((e) => this.iconsById[e]);
        }
        getIcon(e) {
          return this.iconsById[e];
        }
        getIconSchema() {
          return this.iconSchema;
        }
        toString() {
          const e = (o, r) => o.id.localeCompare(r.id), t = (o) => {
            for (; wt.isThemeIcon(o.defaults); ) o = this.iconsById[o.defaults.id];
            return `codicon codicon-${o ? o.id : ""}`;
          }, i = [];
          i.push("| preview     | identifier                        | default codicon ID                | description"), i.push("| ----------- | --------------------------------- | --------------------------------- | --------------------------------- |");
          const n = Object.keys(this.iconsById).map((o) => this.iconsById[o]);
          for (const o of n.filter((r) => !!r.description).sort(e)) i.push(`|<i class="${t(o)}"></i>|${o.id}|${wt.isThemeIcon(o.defaults) ? o.defaults.id : o.id}|${o.description || ""}|`);
          i.push("| preview     | identifier                        "), i.push("| ----------- | --------------------------------- |");
          for (const o of n.filter((r) => !wt.isThemeIcon(r.defaults)).sort(e)) i.push(`|<i class="${t(o)}"></i>|${o.id}|`);
          return i.join(`
`);
        }
      }
      const nd = new Mre();
      yn.add(Ire.IconContribution, nd);
      function mu(s, e, t, i) {
        return nd.registerIcon(s, e, t, i);
      }
      function lF() {
        return nd;
      }
      function Are() {
        const s = C9();
        for (const e in s) {
          const t = "\\" + s[e].toString(16);
          nd.registerIcon(e, {
            fontCharacter: t
          });
        }
      }
      Are();
      const cF = "vscode://schemas/icons", uF = yn.as(sw.JSONContribution);
      uF.registerSchema(cF, nd.getIconSchema());
      const p3 = new ns(() => uF.notifySchemaChanged(cF), 200);
      nd.onDidChange(() => {
        p3.isScheduled() || p3.schedule();
      });
      mu("widget-close", Te.close, C("widgetClose", "Icon for the close action in widgets."));
      mu("goto-previous-location", Te.arrowUp, C("previousChangeIcon", "Icon for goto previous editor location."));
      mu("goto-next-location", Te.arrowDown, C("nextChangeIcon", "Icon for goto next editor location."));
      wt.modify(Te.sync, "spin");
      wt.modify(Te.loading, "spin");
      function Rre(s) {
        const e = new Me(), t = e.add(new G()), i = lF();
        return e.add(i.onDidChange(() => t.fire())), s && e.add(s.onDidProductIconThemeChange(() => t.fire())), {
          dispose: () => e.dispose(),
          onDidChange: t.event,
          getCSS() {
            const n = s ? s.getProductIconTheme() : new hF(), o = {}, r = [], a = [];
            for (const l of i.getIcons()) {
              const u = n.getIcon(l);
              if (!u) continue;
              const d = u.font, f = `--vscode-icon-${l.id}-font-family`, m = `--vscode-icon-${l.id}-content`;
              d ? (o[d.id] = d.definition, a.push(`${f}: ${kL(d.id)};`, `${m}: '${u.fontCharacter}';`), r.push(`.codicon-${l.id}:before { content: '${u.fontCharacter}'; font-family: ${kL(d.id)}; }`)) : (a.push(`${m}: '${u.fontCharacter}'; ${f}: 'codicon';`), r.push(`.codicon-${l.id}:before { content: '${u.fontCharacter}'; }`));
            }
            for (const l in o) {
              const u = o[l], d = u.weight ? `font-weight: ${u.weight};` : "", f = u.style ? `font-style: ${u.style};` : "", m = u.src.map((_) => `${ql(_.location)} format('${_.format}')`).join(", ");
              r.push(`@font-face { src: ${m}; font-family: ${kL(l)};${d}${f} font-display: block; }`);
            }
            return r.push(`:root { ${a.join(" ")} }`), r.join(`
`);
          }
        };
      }
      class hF {
        getIcon(e) {
          const t = lF();
          let i = e.defaults;
          for (; wt.isThemeIcon(i); ) {
            const n = t.getIcon(i.id);
            if (!n) return;
            i = n.defaults;
          }
          return i;
        }
      }
      const Pc = "vs", Mp = "vs-dark", jf = "hc-black", Gf = "hc-light", dF = yn.as(X8.ColorContribution), Ore = yn.as(O8.ThemingContribution);
      class fF {
        constructor(e, t) {
          this.semanticHighlighting = false, this.themeData = t;
          const i = t.base;
          e.length > 0 ? (P0(e) ? this.id = e : this.id = i + " " + e, this.themeName = e) : (this.id = i, this.themeName = i), this.colors = null, this.defaultColors = /* @__PURE__ */ Object.create(null), this._tokenTheme = null;
        }
        get base() {
          return this.themeData.base;
        }
        notifyBaseUpdated() {
          this.themeData.inherit && (this.colors = null, this._tokenTheme = null);
        }
        getColors() {
          if (!this.colors) {
            const e = /* @__PURE__ */ new Map();
            for (const t in this.themeData.colors) e.set(t, le.fromHex(this.themeData.colors[t]));
            if (this.themeData.inherit) {
              const t = E2(this.themeData.base);
              for (const i in t.colors) e.has(i) || e.set(i, le.fromHex(t.colors[i]));
            }
            this.colors = e;
          }
          return this.colors;
        }
        getColor(e, t) {
          const i = this.getColors().get(e);
          if (i) return i;
          if (t !== false) return this.getDefault(e);
        }
        getDefault(e) {
          let t = this.defaultColors[e];
          return t || (t = dF.resolveDefaultColor(e, this), this.defaultColors[e] = t, t);
        }
        defines(e) {
          return this.getColors().has(e);
        }
        get type() {
          switch (this.base) {
            case Pc:
              return Fo.LIGHT;
            case jf:
              return Fo.HIGH_CONTRAST_DARK;
            case Gf:
              return Fo.HIGH_CONTRAST_LIGHT;
            default:
              return Fo.DARK;
          }
        }
        get tokenTheme() {
          if (!this._tokenTheme) {
            let e = [], t = [];
            if (this.themeData.inherit) {
              const o = E2(this.themeData.base);
              e = o.rules, o.encodedTokensColors && (t = o.encodedTokensColors);
            }
            const i = this.themeData.colors["editor.foreground"], n = this.themeData.colors["editor.background"];
            if (i || n) {
              const o = {
                token: ""
              };
              i && (o.foreground = i), n && (o.background = n), e.push(o);
            }
            e = e.concat(this.themeData.rules), this.themeData.encodedTokensColors && (t = this.themeData.encodedTokensColors), this._tokenTheme = aF.createFromRawTokenTheme(e, t);
          }
          return this._tokenTheme;
        }
        getTokenStyleMetadata(e, t, i) {
          const o = this.tokenTheme._match([
            e
          ].concat(t).join(".")).metadata, r = Pr.getForeground(o), a = Pr.getFontStyle(o);
          return {
            foreground: r,
            italic: !!(a & 1),
            bold: !!(a & 2),
            underline: !!(a & 4),
            strikethrough: !!(a & 8)
          };
        }
      }
      function P0(s) {
        return s === Pc || s === Mp || s === jf || s === Gf;
      }
      function E2(s) {
        switch (s) {
          case Pc:
            return Dre;
          case Mp:
            return Ere;
          case jf:
            return Tre;
          case Gf:
            return Nre;
        }
      }
      function t0(s) {
        const e = E2(s);
        return new fF(s, e);
      }
      class Pre extends he {
        constructor() {
          super(), this._onColorThemeChange = this._register(new G()), this.onDidColorThemeChange = this._onColorThemeChange.event, this._onProductIconThemeChange = this._register(new G()), this.onDidProductIconThemeChange = this._onProductIconThemeChange.event, this._environment = /* @__PURE__ */ Object.create(null), this._builtInProductIconTheme = new hF(), this._autoDetectHighContrast = true, this._knownThemes = /* @__PURE__ */ new Map(), this._knownThemes.set(Pc, t0(Pc)), this._knownThemes.set(Mp, t0(Mp)), this._knownThemes.set(jf, t0(jf)), this._knownThemes.set(Gf, t0(Gf));
          const e = this._register(Rre(this));
          this._codiconCSS = e.getCSS(), this._themeCSS = "", this._allCSS = `${this._codiconCSS}
${this._themeCSS}`, this._globalStyleElement = null, this._styleElements = [], this._colorMapOverride = null, this.setTheme(Pc), this._onOSSchemeChanged(), this._register(e.onDidChange(() => {
            this._codiconCSS = e.getCSS(), this._updateCSS();
          })), T9(Kt, "(forced-colors: active)", () => {
            this._onOSSchemeChanged();
          });
        }
        registerEditorContainer(e) {
          return sv(e) ? this._registerShadowDomContainer(e) : this._registerRegularEditorContainer();
        }
        _registerRegularEditorContainer() {
          return this._globalStyleElement || (this._globalStyleElement = Uo(void 0, (e) => {
            e.className = "monaco-colors", e.textContent = this._allCSS;
          }), this._styleElements.push(this._globalStyleElement)), he.None;
        }
        _registerShadowDomContainer(e) {
          const t = Uo(e, (i) => {
            i.className = "monaco-colors", i.textContent = this._allCSS;
          });
          return this._styleElements.push(t), {
            dispose: () => {
              for (let i = 0; i < this._styleElements.length; i++) if (this._styleElements[i] === t) {
                this._styleElements.splice(i, 1);
                return;
              }
            }
          };
        }
        defineTheme(e, t) {
          if (!/^[a-z0-9\-]+$/i.test(e)) throw new Error("Illegal theme name!");
          if (!P0(t.base) && !P0(e)) throw new Error("Illegal theme base!");
          this._knownThemes.set(e, new fF(e, t)), P0(e) && this._knownThemes.forEach((i) => {
            i.base === e && i.notifyBaseUpdated();
          }), this._theme.themeName === e && this.setTheme(e);
        }
        getColorTheme() {
          return this._theme;
        }
        setColorMapOverride(e) {
          this._colorMapOverride = e, this._updateThemeOrColorMap();
        }
        setTheme(e) {
          let t;
          this._knownThemes.has(e) ? t = this._knownThemes.get(e) : t = this._knownThemes.get(Pc), this._updateActualTheme(t);
        }
        _updateActualTheme(e) {
          !e || this._theme === e || (this._theme = e, this._updateThemeOrColorMap());
        }
        _onOSSchemeChanged() {
          if (this._autoDetectHighContrast) {
            const e = Kt.matchMedia("(forced-colors: active)").matches;
            if (e !== Bf(this._theme.type)) {
              let t;
              rw(this._theme.type) ? t = e ? jf : Mp : t = e ? Gf : Pc, this._updateActualTheme(this._knownThemes.get(t));
            }
          }
        }
        setAutoDetectHighContrast(e) {
          this._autoDetectHighContrast = e, this._onOSSchemeChanged();
        }
        _updateThemeOrColorMap() {
          const e = [], t = {}, i = {
            addRule: (r) => {
              t[r] || (e.push(r), t[r] = true);
            }
          };
          Ore.getThemingParticipants().forEach((r) => r(this._theme, i, this._environment));
          const n = [];
          for (const r of dF.getColors()) {
            const a = this._theme.getColor(r.id, true);
            a && n.push(`${TT(r.id)}: ${a.toString()};`);
          }
          i.addRule(`.monaco-editor, .monaco-diff-editor, .monaco-component { ${n.join(`
`)} }`);
          const o = this._colorMapOverride || this._theme.tokenTheme.getColorMap();
          i.addRule(kre(o)), this._themeCSS = e.join(`
`), this._updateCSS(), Bi.setColorMap(o), this._onColorThemeChange.fire(this._theme);
        }
        _updateCSS() {
          this._allCSS = `${this._codiconCSS}
${this._themeCSS}`, this._styleElements.forEach((e) => e.textContent = this._allCSS);
        }
        getFileIconTheme() {
          return {
            hasFileIcons: false,
            hasFolderIcons: false,
            hidesExplorerArrows: false
          };
        }
        getProductIconTheme() {
          return this._builtInProductIconTheme;
        }
      }
      const wr = pt("themeService");
      var Bre = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      }, px = function(s, e) {
        return function(t, i) {
          e(t, i, s);
        };
      };
      let T2 = class extends he {
        constructor(e, t, i) {
          super(), this._contextKeyService = e, this._layoutService = t, this._configurationService = i, this._accessibilitySupport = 0, this._onDidChangeScreenReaderOptimized = new G(), this._onDidChangeReducedMotion = new G(), this._onDidChangeLinkUnderline = new G(), this._accessibilityModeEnabledContext = UJ.bindTo(this._contextKeyService);
          const n = () => this._accessibilityModeEnabledContext.set(this.isScreenReaderOptimized());
          this._register(this._configurationService.onDidChangeConfiguration((r) => {
            r.affectsConfiguration("editor.accessibilitySupport") && (n(), this._onDidChangeScreenReaderOptimized.fire()), r.affectsConfiguration("workbench.reduceMotion") && (this._configMotionReduced = this._configurationService.getValue("workbench.reduceMotion"), this._onDidChangeReducedMotion.fire());
          })), n(), this._register(this.onDidChangeScreenReaderOptimized(() => n()));
          const o = Kt.matchMedia("(prefers-reduced-motion: reduce)");
          this._systemMotionReduced = o.matches, this._configMotionReduced = this._configurationService.getValue("workbench.reduceMotion"), this._linkUnderlinesEnabled = this._configurationService.getValue("accessibility.underlineLinks"), this.initReducedMotionListeners(o), this.initLinkUnderlineListeners();
        }
        initReducedMotionListeners(e) {
          this._register(re(e, "change", () => {
            this._systemMotionReduced = e.matches, this._configMotionReduced === "auto" && this._onDidChangeReducedMotion.fire();
          }));
          const t = () => {
            const i = this.isMotionReduced();
            this._layoutService.mainContainer.classList.toggle("reduce-motion", i), this._layoutService.mainContainer.classList.toggle("enable-motion", !i);
          };
          t(), this._register(this.onDidChangeReducedMotion(() => t()));
        }
        initLinkUnderlineListeners() {
          this._register(this._configurationService.onDidChangeConfiguration((t) => {
            if (t.affectsConfiguration("accessibility.underlineLinks")) {
              const i = this._configurationService.getValue("accessibility.underlineLinks");
              this._linkUnderlinesEnabled = i, this._onDidChangeLinkUnderline.fire();
            }
          }));
          const e = () => {
            const t = this._linkUnderlinesEnabled;
            this._layoutService.mainContainer.classList.toggle("underline-links", t);
          };
          e(), this._register(this.onDidChangeLinkUnderlines(() => e()));
        }
        onDidChangeLinkUnderlines(e) {
          return this._onDidChangeLinkUnderline.event(e);
        }
        get onDidChangeScreenReaderOptimized() {
          return this._onDidChangeScreenReaderOptimized.event;
        }
        isScreenReaderOptimized() {
          const e = this._configurationService.getValue("editor.accessibilitySupport");
          return e === "on" || e === "auto" && this._accessibilitySupport === 2;
        }
        get onDidChangeReducedMotion() {
          return this._onDidChangeReducedMotion.event;
        }
        isMotionReduced() {
          const e = this._configMotionReduced;
          return e === "on" || e === "auto" && this._systemMotionReduced;
        }
        getAccessibilitySupport() {
          return this._accessibilitySupport;
        }
      };
      T2 = Bre([
        px(0, Mt),
        px(1, du),
        px(2, Si)
      ], T2);
      var Bw = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      }, Ea = function(s, e) {
        return function(t, i) {
          e(t, i, s);
        };
      }, of, cp;
      let N2 = class {
        constructor(e, t, i) {
          this._commandService = e, this._keybindingService = t, this._hiddenStates = new I2(i);
        }
        createMenu(e, t, i) {
          return new nC(e, this._hiddenStates, {
            emitEventsForSubmenuChanges: false,
            eventDebounceDelay: 50,
            ...i
          }, this._commandService, this._keybindingService, t);
        }
        getMenuActions(e, t, i) {
          const n = new nC(e, this._hiddenStates, {
            emitEventsForSubmenuChanges: false,
            eventDebounceDelay: 50,
            ...i
          }, this._commandService, this._keybindingService, t), o = n.getActions(i);
          return n.dispose(), o;
        }
        resetHiddenStates(e) {
          this._hiddenStates.reset(e);
        }
      };
      N2 = Bw([
        Ea(0, po),
        Ea(1, Pn),
        Ea(2, Sw)
      ], N2);
      let I2 = (_l2 = class {
        constructor(e) {
          this._storageService = e, this._disposables = new Me(), this._onDidChange = new G(), this.onDidChange = this._onDidChange.event, this._ignoreChangeEvent = false, this._hiddenByDefaultCache = /* @__PURE__ */ new Map();
          try {
            const t = e.get(of._key, 0, "{}");
            this._data = JSON.parse(t);
          } catch {
            this._data = /* @__PURE__ */ Object.create(null);
          }
          this._disposables.add(e.onDidChangeValue(0, of._key, this._disposables)(() => {
            if (!this._ignoreChangeEvent) try {
              const t = e.get(of._key, 0, "{}");
              this._data = JSON.parse(t);
            } catch (t) {
              console.log("FAILED to read storage after UPDATE", t);
            }
            this._onDidChange.fire();
          }));
        }
        dispose() {
          this._onDidChange.dispose(), this._disposables.dispose();
        }
        _isHiddenByDefault(e, t) {
          return this._hiddenByDefaultCache.get(`${e.id}/${t}`) ?? false;
        }
        setDefaultState(e, t, i) {
          this._hiddenByDefaultCache.set(`${e.id}/${t}`, i);
        }
        isHidden(e, t) {
          var _a3;
          const i = this._isHiddenByDefault(e, t), n = ((_a3 = this._data[e.id]) == null ? void 0 : _a3.includes(t)) ?? false;
          return i ? !n : n;
        }
        updateHidden(e, t, i) {
          this._isHiddenByDefault(e, t) && (i = !i);
          const o = this._data[e.id];
          if (i) o ? o.indexOf(t) < 0 && o.push(t) : this._data[e.id] = [
            t
          ];
          else if (o) {
            const r = o.indexOf(t);
            r >= 0 && fU(o, r), o.length === 0 && delete this._data[e.id];
          }
          this._persist();
        }
        reset(e) {
          if (e === void 0) this._data = /* @__PURE__ */ Object.create(null), this._persist();
          else {
            for (const { id: t } of e) this._data[t] && delete this._data[t];
            this._persist();
          }
        }
        _persist() {
          try {
            this._ignoreChangeEvent = true;
            const e = JSON.stringify(this._data);
            this._storageService.store(of._key, e, 0, 0);
          } finally {
            this._ignoreChangeEvent = false;
          }
        }
      }, of = _l2, _l2._key = "menu.hiddenCommands", _l2);
      I2 = of = Bw([
        Ea(0, Sw)
      ], I2);
      class Ap {
        constructor(e, t) {
          this._id = e, this._collectContextKeysForSubmenus = t, this._menuGroups = [], this._allMenuIds = /* @__PURE__ */ new Set(), this._structureContextKeys = /* @__PURE__ */ new Set(), this._preconditionContextKeys = /* @__PURE__ */ new Set(), this._toggledContextKeys = /* @__PURE__ */ new Set(), this.refresh();
        }
        get allMenuIds() {
          return this._allMenuIds;
        }
        get structureContextKeys() {
          return this._structureContextKeys;
        }
        get preconditionContextKeys() {
          return this._preconditionContextKeys;
        }
        get toggledContextKeys() {
          return this._toggledContextKeys;
        }
        refresh() {
          this._menuGroups.length = 0, this._allMenuIds.clear(), this._structureContextKeys.clear(), this._preconditionContextKeys.clear(), this._toggledContextKeys.clear();
          const e = this._sort(sg.getMenuItems(this._id));
          let t;
          for (const i of e) {
            const n = i.group || "";
            (!t || t[0] !== n) && (t = [
              n,
              []
            ], this._menuGroups.push(t)), t[1].push(i), this._collectContextKeysAndSubmenuIds(i);
          }
          this._allMenuIds.add(this._id);
        }
        _sort(e) {
          return e;
        }
        _collectContextKeysAndSubmenuIds(e) {
          if (Ap._fillInKbExprKeys(e.when, this._structureContextKeys), bp(e)) {
            if (e.command.precondition && Ap._fillInKbExprKeys(e.command.precondition, this._preconditionContextKeys), e.command.toggled) {
              const t = e.command.toggled.condition || e.command.toggled;
              Ap._fillInKbExprKeys(t, this._toggledContextKeys);
            }
          } else this._collectContextKeysForSubmenus && (sg.getMenuItems(e.submenu).forEach(this._collectContextKeysAndSubmenuIds, this), this._allMenuIds.add(e.submenu));
        }
        static _fillInKbExprKeys(e, t) {
          if (e) for (const i of e.keys()) t.add(i);
        }
      }
      let M2 = cp = class extends Ap {
        constructor(e, t, i, n, o, r) {
          super(e, i), this._hiddenStates = t, this._commandService = n, this._keybindingService = o, this._contextKeyService = r, this.refresh();
        }
        createActionGroups(e) {
          const t = [];
          for (const i of this._menuGroups) {
            const [n, o] = i;
            let r;
            for (const a of o) if (this._contextKeyService.contextMatchesRules(a.when)) {
              const l = bp(a);
              l && this._hiddenStates.setDefaultState(this._id, a.command.id, !!a.isHiddenByDefault);
              const u = Fre(this._id, l ? a.command : a, this._hiddenStates);
              if (l) {
                const d = gF(this._commandService, this._keybindingService, a.command.id, a.when);
                (r ?? (r = [])).push(new Fl(a.command, a.alt, e, u, d, this._contextKeyService, this._commandService));
              } else {
                const d = new cp(a.submenu, this._hiddenStates, this._collectContextKeysForSubmenus, this._commandService, this._keybindingService, this._contextKeyService).createActionGroups(e), f = $n.join(...d.map((m) => m[1]));
                f.length > 0 && (r ?? (r = [])).push(new vp(a, u, f));
              }
            }
            r && r.length > 0 && t.push([
              n,
              r
            ]);
          }
          return t;
        }
        _sort(e) {
          return e.sort(cp._compareMenuItems);
        }
        static _compareMenuItems(e, t) {
          const i = e.group, n = t.group;
          if (i !== n) {
            if (i) {
              if (!n) return -1;
            } else return 1;
            if (i === "navigation") return -1;
            if (n === "navigation") return 1;
            const a = i.localeCompare(n);
            if (a !== 0) return a;
          }
          const o = e.order || 0, r = t.order || 0;
          return o < r ? -1 : o > r ? 1 : cp._compareTitles(bp(e) ? e.command.title : e.title, bp(t) ? t.command.title : t.title);
        }
        static _compareTitles(e, t) {
          const i = typeof e == "string" ? e : e.original, n = typeof t == "string" ? t : t.original;
          return i.localeCompare(n);
        }
      };
      M2 = cp = Bw([
        Ea(3, po),
        Ea(4, Pn),
        Ea(5, Mt)
      ], M2);
      let nC = class {
        constructor(e, t, i, n, o, r) {
          this._disposables = new Me(), this._menuInfo = new M2(e, t, i.emitEventsForSubmenuChanges, n, o, r);
          const a = new ns(() => {
            this._menuInfo.refresh(), this._onDidChange.fire({
              menu: this,
              isStructuralChange: true,
              isEnablementChange: true,
              isToggleChange: true
            });
          }, i.eventDebounceDelay);
          this._disposables.add(a), this._disposables.add(sg.onDidChangeMenu((f) => {
            for (const m of this._menuInfo.allMenuIds) if (f.has(m)) {
              a.schedule();
              break;
            }
          }));
          const l = this._disposables.add(new Me()), u = (f) => {
            let m = false, _ = false, b = false;
            for (const v of f) if (m = m || v.isStructuralChange, _ = _ || v.isEnablementChange, b = b || v.isToggleChange, m && _ && b) break;
            return {
              menu: this,
              isStructuralChange: m,
              isEnablementChange: _,
              isToggleChange: b
            };
          }, d = () => {
            l.add(r.onDidChangeContext((f) => {
              const m = f.affectsSome(this._menuInfo.structureContextKeys), _ = f.affectsSome(this._menuInfo.preconditionContextKeys), b = f.affectsSome(this._menuInfo.toggledContextKeys);
              (m || _ || b) && this._onDidChange.fire({
                menu: this,
                isStructuralChange: m,
                isEnablementChange: _,
                isToggleChange: b
              });
            })), l.add(t.onDidChange((f) => {
              this._onDidChange.fire({
                menu: this,
                isStructuralChange: true,
                isEnablementChange: false,
                isToggleChange: false
              });
            }));
          };
          this._onDidChange = new u9({
            onWillAddFirstListener: d,
            onDidRemoveLastListener: l.clear.bind(l),
            delay: i.eventDebounceDelay,
            merge: u
          }), this.onDidChange = this._onDidChange.event;
        }
        getActions(e) {
          return this._menuInfo.createActionGroups(e);
        }
        dispose() {
          this._disposables.dispose(), this._onDidChange.dispose();
        }
      };
      nC = Bw([
        Ea(3, po),
        Ea(4, Pn),
        Ea(5, Mt)
      ], nC);
      function Fre(s, e, t) {
        const i = Lj(e) ? e.submenu.id : e.id, n = typeof e.title == "string" ? e.title : e.title.value, o = Af({
          id: `hide/${s.id}/${i}`,
          label: C("hide.label", "Hide '{0}'", n),
          run() {
            t.updateHidden(s, i, true);
          }
        }), r = Af({
          id: `toggle/${s.id}/${i}`,
          label: n,
          get checked() {
            return !t.isHidden(s, i);
          },
          run() {
            t.updateHidden(s, i, !!this.checked);
          }
        });
        return {
          hide: o,
          toggle: r,
          get isHidden() {
            return !r.checked;
          }
        };
      }
      function gF(s, e, t, i = void 0, n = true) {
        return Af({
          id: `configureKeybinding/${t}`,
          label: C("configure keybinding", "Configure Keybinding"),
          enabled: n,
          run() {
            const r = !!!e.lookupKeybinding(t) && i ? i.serialize() : void 0;
            s.executeCommand("workbench.action.openGlobalKeybindings", `@command:${t}` + (r ? ` +when:${r}` : ""));
          }
        });
      }
      var Vre = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      }, _3 = function(s, e) {
        return function(t, i) {
          e(t, i, s);
        };
      }, A2;
      const b3 = "application/vnd.code.resources";
      let R2 = (_m = class extends he {
        constructor(e, t) {
          super(), this.layoutService = e, this.logService = t, this.mapTextToType = /* @__PURE__ */ new Map(), this.findText = "", this.resources = [], this.resourcesStateHash = void 0, (su || N9) && this.installWebKitWriteTextWorkaround(), this._register(be.runAndSubscribe($C, ({ window: i, disposables: n }) => {
            n.add(re(i.document, "copy", () => this.clearResourcesState()));
          }, {
            window: Kt,
            disposables: this._store
          }));
        }
        installWebKitWriteTextWorkaround() {
          const e = () => {
            const t = new P9();
            this.webKitPendingClipboardWritePromise && !this.webKitPendingClipboardWritePromise.isSettled && this.webKitPendingClipboardWritePromise.cancel(), this.webKitPendingClipboardWritePromise = t, Jm().navigator.clipboard.write([
              new ClipboardItem({
                "text/plain": t.p
              })
            ]).catch(async (i) => {
              (!(i instanceof Error) || i.name !== "NotAllowedError" || !t.isRejected) && this.logService.error(i);
            });
          };
          this._register(be.runAndSubscribe(this.layoutService.onDidAddContainer, ({ container: t, disposables: i }) => {
            i.add(re(t, "click", e)), i.add(re(t, "keydown", e));
          }, {
            container: this.layoutService.mainContainer,
            disposables: this._store
          }));
        }
        async writeText(e, t) {
          if (this.clearResourcesState(), t) {
            this.mapTextToType.set(t, e);
            return;
          }
          if (this.webKitPendingClipboardWritePromise) return this.webKitPendingClipboardWritePromise.complete(e);
          try {
            return await Jm().navigator.clipboard.writeText(e);
          } catch (i) {
            console.error(i);
          }
          this.fallbackWriteText(e);
        }
        fallbackWriteText(e) {
          const t = lT(), i = t.activeElement, n = t.body.appendChild(He("textarea", {
            "aria-hidden": true
          }));
          n.style.height = "1px", n.style.width = "1px", n.style.position = "absolute", n.value = e, n.focus(), n.select(), t.execCommand("copy"), wn(i) && i.focus(), n.remove();
        }
        async readText(e) {
          if (e) return this.mapTextToType.get(e) || "";
          try {
            return await Jm().navigator.clipboard.readText();
          } catch (t) {
            console.error(t);
          }
          return "";
        }
        async readFindText() {
          return this.findText;
        }
        async writeFindText(e) {
          this.findText = e;
        }
        async readResources() {
          try {
            const t = await Jm().navigator.clipboard.read();
            for (const i of t) if (i.types.includes(`web ${b3}`)) {
              const n = await i.getType(`web ${b3}`);
              return JSON.parse(await n.text()).map((r) => st.from(r));
            }
          } catch {
          }
          const e = await this.computeResourcesStateHash();
          return this.resourcesStateHash !== e && this.clearResourcesState(), this.resources;
        }
        async computeResourcesStateHash() {
          if (this.resources.length === 0) return;
          const e = await this.readText();
          return K9(e.substring(0, A2.MAX_RESOURCE_STATE_SOURCE_LENGTH));
        }
        clearInternalState() {
          this.clearResourcesState();
        }
        clearResourcesState() {
          this.resources = [], this.resourcesStateHash = void 0;
        }
      }, A2 = _m, _m.MAX_RESOURCE_STATE_SOURCE_LENGTH = 1e3, _m);
      R2 = A2 = Vre([
        _3(0, du),
        _3(1, Xr)
      ], R2);
      const HN = pt("clipboardService");
      var Wre = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      }, Hre = function(s, e) {
        return function(t, i) {
          e(t, i, s);
        };
      };
      const Rp = "data-keybinding-context";
      class zN {
        constructor(e, t) {
          this._id = e, this._parent = t, this._value = /* @__PURE__ */ Object.create(null), this._value._contextId = e;
        }
        get value() {
          return {
            ...this._value
          };
        }
        setValue(e, t) {
          return this._value[e] !== t ? (this._value[e] = t, true) : false;
        }
        removeValue(e) {
          return e in this._value ? (delete this._value[e], true) : false;
        }
        getValue(e) {
          const t = this._value[e];
          return typeof t > "u" && this._parent ? this._parent.getValue(e) : t;
        }
      }
      const _bg = class _bg extends zN {
        constructor() {
          super(-1, null);
        }
        setValue(e, t) {
          return false;
        }
        removeValue(e) {
          return false;
        }
        getValue(e) {
        }
      };
      _bg.INSTANCE = new _bg();
      let bg = _bg;
      const _sC = class _sC extends zN {
        constructor(e, t, i) {
          super(e, null), this._configurationService = t, this._values = Sp.forConfigKeys(), this._listener = this._configurationService.onDidChangeConfiguration((n) => {
            if (n.source === 7) {
              const o = Array.from(this._values, ([r]) => r);
              this._values.clear(), i.fire(new C3(o));
            } else {
              const o = [];
              for (const r of n.affectedKeys) {
                const a = `config.${r}`, l = this._values.findSuperstr(a);
                l !== void 0 && (o.push(...kt.map(l, ([u]) => u)), this._values.deleteSuperstr(a)), this._values.has(a) && (o.push(a), this._values.delete(a));
              }
              i.fire(new C3(o));
            }
          });
        }
        dispose() {
          this._listener.dispose();
        }
        getValue(e) {
          if (e.indexOf(_sC._keyPrefix) !== 0) return super.getValue(e);
          if (this._values.has(e)) return this._values.get(e);
          const t = e.substr(_sC._keyPrefix.length), i = this._configurationService.getValue(t);
          let n;
          switch (typeof i) {
            case "number":
            case "boolean":
            case "string":
              n = i;
              break;
            default:
              Array.isArray(i) ? n = JSON.stringify(i) : n = i;
          }
          return this._values.set(e, n), n;
        }
        setValue(e, t) {
          return super.setValue(e, t);
        }
        removeValue(e) {
          return super.removeValue(e);
        }
      };
      _sC._keyPrefix = "config.";
      let sC = _sC;
      class zre {
        constructor(e, t, i) {
          this._service = e, this._key = t, this._defaultValue = i, this.reset();
        }
        set(e) {
          this._service.setContext(this._key, e);
        }
        reset() {
          typeof this._defaultValue > "u" ? this._service.removeContext(this._key) : this._service.setContext(this._key, this._defaultValue);
        }
        get() {
          return this._service.getContextKeyValue(this._key);
        }
      }
      class v3 {
        constructor(e) {
          this.key = e;
        }
        affectsSome(e) {
          return e.has(this.key);
        }
        allKeysContainedIn(e) {
          return this.affectsSome(e);
        }
      }
      class C3 {
        constructor(e) {
          this.keys = e;
        }
        affectsSome(e) {
          for (const t of this.keys) if (e.has(t)) return true;
          return false;
        }
        allKeysContainedIn(e) {
          return this.keys.every((t) => e.has(t));
        }
      }
      class Ure {
        constructor(e) {
          this.events = e;
        }
        affectsSome(e) {
          for (const t of this.events) if (t.affectsSome(e)) return true;
          return false;
        }
        allKeysContainedIn(e) {
          return this.events.every((t) => t.allKeysContainedIn(e));
        }
      }
      function $re(s, e) {
        return s.allKeysContainedIn(new Set(Object.keys(e)));
      }
      class mF extends he {
        constructor(e) {
          super(), this._onDidChangeContext = this._register(new jp({
            merge: (t) => new Ure(t)
          })), this.onDidChangeContext = this._onDidChangeContext.event, this._isDisposed = false, this._myContextId = e;
        }
        createKey(e, t) {
          if (this._isDisposed) throw new Error("AbstractContextKeyService has been disposed");
          return new zre(this, e, t);
        }
        bufferChangeEvents(e) {
          this._onDidChangeContext.pause();
          try {
            e();
          } finally {
            this._onDidChangeContext.resume();
          }
        }
        createScoped(e) {
          if (this._isDisposed) throw new Error("AbstractContextKeyService has been disposed");
          return new qre(this, e);
        }
        contextMatchesRules(e) {
          if (this._isDisposed) throw new Error("AbstractContextKeyService has been disposed");
          const t = this.getContextValuesContainer(this._myContextId);
          return e ? e.evaluate(t) : true;
        }
        getContextKeyValue(e) {
          if (!this._isDisposed) return this.getContextValuesContainer(this._myContextId).getValue(e);
        }
        setContext(e, t) {
          if (this._isDisposed) return;
          const i = this.getContextValuesContainer(this._myContextId);
          i && i.setValue(e, t) && this._onDidChangeContext.fire(new v3(e));
        }
        removeContext(e) {
          this._isDisposed || this.getContextValuesContainer(this._myContextId).removeValue(e) && this._onDidChangeContext.fire(new v3(e));
        }
        getContext(e) {
          return this._isDisposed ? bg.INSTANCE : this.getContextValuesContainer(Kre(e));
        }
        dispose() {
          super.dispose(), this._isDisposed = true;
        }
      }
      let O2 = class extends mF {
        constructor(e) {
          super(0), this._contexts = /* @__PURE__ */ new Map(), this._lastContextId = 0;
          const t = this._register(new sC(this._myContextId, e, this._onDidChangeContext));
          this._contexts.set(this._myContextId, t);
        }
        getContextValuesContainer(e) {
          return this._isDisposed ? bg.INSTANCE : this._contexts.get(e) || bg.INSTANCE;
        }
        createChildContext(e = this._myContextId) {
          if (this._isDisposed) throw new Error("ContextKeyService has been disposed");
          const t = ++this._lastContextId;
          return this._contexts.set(t, new zN(t, this.getContextValuesContainer(e))), t;
        }
        disposeContext(e) {
          this._isDisposed || this._contexts.delete(e);
        }
      };
      O2 = Wre([
        Hre(0, Si)
      ], O2);
      class qre extends mF {
        constructor(e, t) {
          if (super(e.createChildContext()), this._parentChangeListener = this._register(new Ul()), this._parent = e, this._updateParentChangeListener(), this._domNode = t, this._domNode.hasAttribute(Rp)) {
            let i = "";
            this._domNode.classList && (i = Array.from(this._domNode.classList.values()).join(", ")), console.error(`Element already has context attribute${i ? ": " + i : ""}`);
          }
          this._domNode.setAttribute(Rp, String(this._myContextId));
        }
        _updateParentChangeListener() {
          this._parentChangeListener.value = this._parent.onDidChangeContext((e) => {
            const i = this._parent.getContextValuesContainer(this._myContextId).value;
            $re(e, i) || this._onDidChangeContext.fire(e);
          });
        }
        dispose() {
          this._isDisposed || (this._parent.disposeContext(this._myContextId), this._domNode.removeAttribute(Rp), super.dispose());
        }
        getContextValuesContainer(e) {
          return this._isDisposed ? bg.INSTANCE : this._parent.getContextValuesContainer(e);
        }
        createChildContext(e = this._myContextId) {
          if (this._isDisposed) throw new Error("ScopedContextKeyService has been disposed");
          return this._parent.createChildContext(e);
        }
        disposeContext(e) {
          this._isDisposed || this._parent.disposeContext(e);
        }
      }
      function Kre(s) {
        for (; s; ) {
          if (s.hasAttribute(Rp)) {
            const e = s.getAttribute(Rp);
            return e ? parseInt(e, 10) : NaN;
          }
          s = s.parentElement;
        }
        return 0;
      }
      function jre(s, e, t) {
        s.get(Mt).createKey(String(e), Gre(t));
      }
      function Gre(s) {
        return Z7(s, (e) => {
          if (typeof e == "object" && e.$mid === 1) return st.revive(e).toString();
          if (e instanceof st) return e.toString();
        });
      }
      Os.registerCommand("_setContext", jre);
      Os.registerCommand({
        id: "getContextKeyInfo",
        handler() {
          return [
            ...Ie.all()
          ].sort((s, e) => s.key.localeCompare(e.key));
        },
        metadata: {
          description: C("getContextKeyInfo", "A command that returns information about context keys"),
          args: []
        }
      });
      Os.registerCommand("_generateContextKeyInfo", function() {
        const s = [], e = /* @__PURE__ */ new Set();
        for (const t of Ie.all()) e.has(t.key) || (e.add(t.key), s.push(t));
        s.sort((t, i) => t.key.localeCompare(i.key)), console.log(JSON.stringify(s, void 0, 2));
      });
      let Yre = class {
        constructor(e, t) {
          this.key = e, this.data = t, this.incoming = /* @__PURE__ */ new Map(), this.outgoing = /* @__PURE__ */ new Map();
        }
      };
      class w3 {
        constructor(e) {
          this._hashFn = e, this._nodes = /* @__PURE__ */ new Map();
        }
        roots() {
          const e = [];
          for (const t of this._nodes.values()) t.outgoing.size === 0 && e.push(t);
          return e;
        }
        insertEdge(e, t) {
          const i = this.lookupOrInsertNode(e), n = this.lookupOrInsertNode(t);
          i.outgoing.set(n.key, n), n.incoming.set(i.key, i);
        }
        removeNode(e) {
          const t = this._hashFn(e);
          this._nodes.delete(t);
          for (const i of this._nodes.values()) i.outgoing.delete(t), i.incoming.delete(t);
        }
        lookupOrInsertNode(e) {
          const t = this._hashFn(e);
          let i = this._nodes.get(t);
          return i || (i = new Yre(t, e), this._nodes.set(t, i)), i;
        }
        isEmpty() {
          return this._nodes.size === 0;
        }
        toString() {
          const e = [];
          for (const [t, i] of this._nodes) e.push(`${t}
	(-> incoming)[${[
            ...i.incoming.keys()
          ].join(", ")}]
	(outgoing ->)[${[
            ...i.outgoing.keys()
          ].join(",")}]
`);
          return e.join(`
`);
        }
        findCycleSlow() {
          for (const [e, t] of this._nodes) {
            const i = /* @__PURE__ */ new Set([
              e
            ]), n = this._findCycle(t, i);
            if (n) return n;
          }
        }
        _findCycle(e, t) {
          for (const [i, n] of e.outgoing) {
            if (t.has(i)) return [
              ...t,
              i
            ].join(" -> ");
            t.add(i);
            const o = this._findCycle(n, t);
            if (o) return o;
            t.delete(i);
          }
        }
      }
      class Mg {
        constructor(...e) {
          this._entries = /* @__PURE__ */ new Map();
          for (const [t, i] of e) this.set(t, i);
        }
        set(e, t) {
          const i = this._entries.get(e);
          return this._entries.set(e, t), i;
        }
        get(e) {
          return this._entries.get(e);
        }
      }
      const Zre = false;
      class y3 extends Error {
        constructor(e) {
          super("cyclic dependency between services"), this.message = e.findCycleSlow() ?? `UNABLE to detect cycle, dumping graph: 
${e.toString()}`;
        }
      }
      class oC {
        constructor(e = new Mg(), t = false, i, n = Zre) {
          this._services = e, this._strict = t, this._parent = i, this._enableTracing = n, this._isDisposed = false, this._servicesToMaybeDispose = /* @__PURE__ */ new Set(), this._children = /* @__PURE__ */ new Set(), this._activeInstantiations = /* @__PURE__ */ new Set(), this._services.set(Ft, this), this._globalGraph = n ? (i == null ? void 0 : i._globalGraph) ?? new w3((o) => o) : void 0;
        }
        dispose() {
          if (!this._isDisposed) {
            this._isDisposed = true, On(this._children), this._children.clear();
            for (const e of this._servicesToMaybeDispose) l9(e) && e.dispose();
            this._servicesToMaybeDispose.clear();
          }
        }
        _throwIfDisposed() {
          if (this._isDisposed) throw new Error("InstantiationService has been disposed");
        }
        createChild(e, t) {
          this._throwIfDisposed();
          const i = this, n = new class extends oC {
            dispose() {
              i._children.delete(n), super.dispose();
            }
          }(e, this._strict, this, this._enableTracing);
          return this._children.add(n), t == null ? void 0 : t.add(n), n;
        }
        invokeFunction(e, ...t) {
          this._throwIfDisposed();
          const i = No.traceInvocation(this._enableTracing, e);
          let n = false;
          try {
            return e({
              get: (r) => {
                if (n) throw FE("service accessor is only valid during the invocation of its target method");
                const a = this._getOrCreateServiceInstance(r, i);
                if (!a) throw new Error(`[invokeFunction] unknown service '${r}'`);
                return a;
              }
            }, ...t);
          } finally {
            n = true, i.stop();
          }
        }
        createInstance(e, ...t) {
          this._throwIfDisposed();
          let i, n;
          return e instanceof ya ? (i = No.traceCreation(this._enableTracing, e.ctor), n = this._createInstance(e.ctor, e.staticArguments.concat(t), i)) : (i = No.traceCreation(this._enableTracing, e), n = this._createInstance(e, t, i)), i.stop(), n;
        }
        _createInstance(e, t = [], i) {
          const n = Wr.getServiceDependencies(e).sort((a, l) => a.index - l.index), o = [];
          for (const a of n) {
            const l = this._getOrCreateServiceInstance(a.id, i);
            l || this._throwIfStrict(`[createInstance] ${e.name} depends on UNKNOWN service ${a.id}.`, false), o.push(l);
          }
          const r = n.length > 0 ? n[0].index : t.length;
          if (t.length !== r) {
            console.trace(`[createInstance] First service dependency of ${e.name} at position ${r + 1} conflicts with ${t.length} static arguments`);
            const a = r - t.length;
            a > 0 ? t = t.concat(new Array(a)) : t = t.slice(0, r);
          }
          return Reflect.construct(e, t.concat(o));
        }
        _setCreatedServiceInstance(e, t) {
          if (this._services.get(e) instanceof ya) this._services.set(e, t);
          else if (this._parent) this._parent._setCreatedServiceInstance(e, t);
          else throw new Error("illegalState - setting UNKNOWN service instance");
        }
        _getServiceInstanceOrDescriptor(e) {
          const t = this._services.get(e);
          return !t && this._parent ? this._parent._getServiceInstanceOrDescriptor(e) : t;
        }
        _getOrCreateServiceInstance(e, t) {
          this._globalGraph && this._globalGraphImplicitDependency && this._globalGraph.insertEdge(this._globalGraphImplicitDependency, String(e));
          const i = this._getServiceInstanceOrDescriptor(e);
          return i instanceof ya ? this._safeCreateAndCacheServiceInstance(e, i, t.branch(e, true)) : (t.branch(e, false), i);
        }
        _safeCreateAndCacheServiceInstance(e, t, i) {
          if (this._activeInstantiations.has(e)) throw new Error(`illegal state - RECURSIVELY instantiating service '${e}'`);
          this._activeInstantiations.add(e);
          try {
            return this._createAndCacheServiceInstance(e, t, i);
          } finally {
            this._activeInstantiations.delete(e);
          }
        }
        _createAndCacheServiceInstance(e, t, i) {
          var _a3;
          const n = new w3((l) => l.id.toString());
          let o = 0;
          const r = [
            {
              id: e,
              desc: t,
              _trace: i
            }
          ], a = /* @__PURE__ */ new Set();
          for (; r.length; ) {
            const l = r.pop();
            if (!a.has(String(l.id))) {
              if (a.add(String(l.id)), n.lookupOrInsertNode(l), o++ > 1e3) throw new y3(n);
              for (const u of Wr.getServiceDependencies(l.desc.ctor)) {
                const d = this._getServiceInstanceOrDescriptor(u.id);
                if (d || this._throwIfStrict(`[createInstance] ${e} depends on ${u.id} which is NOT registered.`, true), (_a3 = this._globalGraph) == null ? void 0 : _a3.insertEdge(String(l.id), String(u.id)), d instanceof ya) {
                  const f = {
                    id: u.id,
                    desc: d,
                    _trace: l._trace.branch(u.id, true)
                  };
                  n.insertEdge(l, f), r.push(f);
                }
              }
            }
          }
          for (; ; ) {
            const l = n.roots();
            if (l.length === 0) {
              if (!n.isEmpty()) throw new y3(n);
              break;
            }
            for (const { data: u } of l) {
              if (this._getServiceInstanceOrDescriptor(u.id) instanceof ya) {
                const f = this._createServiceInstanceWithOwner(u.id, u.desc.ctor, u.desc.staticArguments, u.desc.supportsDelayedInstantiation, u._trace);
                this._setCreatedServiceInstance(u.id, f);
              }
              n.removeNode(u);
            }
          }
          return this._getServiceInstanceOrDescriptor(e);
        }
        _createServiceInstanceWithOwner(e, t, i = [], n, o) {
          if (this._services.get(e) instanceof ya) return this._createServiceInstance(e, t, i, n, o, this._servicesToMaybeDispose);
          if (this._parent) return this._parent._createServiceInstanceWithOwner(e, t, i, n, o);
          throw new Error(`illegalState - creating UNKNOWN service instance ${t.name}`);
        }
        _createServiceInstance(e, t, i = [], n, o, r) {
          if (n) {
            const a = new oC(void 0, this._strict, this, this._enableTracing);
            a._globalGraphImplicitDependency = String(e);
            const l = /* @__PURE__ */ new Map(), u = new eK(() => {
              const d = a._createInstance(t, i, o);
              for (const [f, m] of l) {
                const _ = d[f];
                if (typeof _ == "function") for (const b of m) b.disposable = _.apply(d, b.listener);
              }
              return l.clear(), r.add(d), d;
            });
            return new Proxy(/* @__PURE__ */ Object.create(null), {
              get(d, f) {
                if (!u.isInitialized && typeof f == "string" && (f.startsWith("onDid") || f.startsWith("onWill"))) {
                  let b = l.get(f);
                  return b || (b = new Us(), l.set(f, b)), (y, x, L) => {
                    if (u.isInitialized) return u.value[f](y, x, L);
                    {
                      const D = {
                        listener: [
                          y,
                          x,
                          L
                        ],
                        disposable: void 0
                      }, k = b.push(D);
                      return Ze(() => {
                        var _a3;
                        k(), (_a3 = D.disposable) == null ? void 0 : _a3.dispose();
                      });
                    }
                  };
                }
                if (f in d) return d[f];
                const m = u.value;
                let _ = m[f];
                return typeof _ != "function" || (_ = _.bind(m), d[f] = _), _;
              },
              set(d, f, m) {
                return u.value[f] = m, true;
              },
              getPrototypeOf(d) {
                return t.prototype;
              }
            });
          } else {
            const a = this._createInstance(t, i, o);
            return r.add(a), a;
          }
        }
        _throwIfStrict(e, t) {
          if (t && console.warn(e), this._strict) throw new Error(e);
        }
      }
      const _No = class _No {
        static traceInvocation(e, t) {
          return e ? new _No(2, t.name || new Error().stack.split(`
`).slice(3, 4).join(`
`)) : _No._None;
        }
        static traceCreation(e, t) {
          return e ? new _No(1, t.name) : _No._None;
        }
        constructor(e, t) {
          this.type = e, this.name = t, this._start = Date.now(), this._dep = [];
        }
        branch(e, t) {
          const i = new _No(3, e.toString());
          return this._dep.push([
            e,
            t,
            i
          ]), i;
        }
        stop() {
          const e = Date.now() - this._start;
          _No._totals += e;
          let t = false;
          function i(o, r) {
            const a = [], l = new Array(o + 1).join("	");
            for (const [u, d, f] of r._dep) if (d && f) {
              t = true, a.push(`${l}CREATES -> ${u}`);
              const m = i(o + 1, f);
              m && a.push(m);
            } else a.push(`${l}uses -> ${u}`);
            return a.join(`
`);
          }
          const n = [
            `${this.type === 1 ? "CREATE" : "CALL"} ${this.name}`,
            `${i(1, this)}`,
            `DONE, took ${e.toFixed(2)}ms (grand total ${_No._totals.toFixed(2)}ms)`
          ];
          (e > 2 || t) && _No.all.add(n.join(`
`));
        }
      };
      _No.all = /* @__PURE__ */ new Set();
      _No._None = new class extends _No {
        constructor() {
          super(0, null);
        }
        stop() {
        }
        branch() {
          return this;
        }
      }();
      _No._totals = 0;
      let No = _No;
      const Qre = /* @__PURE__ */ new Set([
        it.inMemory,
        it.vscodeSourceControl,
        it.walkThrough,
        it.walkThroughSnippet,
        it.vscodeChatCodeBlock
      ]);
      class Xre {
        constructor() {
          this._byResource = new fs(), this._byOwner = /* @__PURE__ */ new Map();
        }
        set(e, t, i) {
          let n = this._byResource.get(e);
          n || (n = /* @__PURE__ */ new Map(), this._byResource.set(e, n)), n.set(t, i);
          let o = this._byOwner.get(t);
          o || (o = new fs(), this._byOwner.set(t, o)), o.set(e, i);
        }
        get(e, t) {
          var _a3;
          return (_a3 = this._byResource.get(e)) == null ? void 0 : _a3.get(t);
        }
        delete(e, t) {
          let i = false, n = false;
          const o = this._byResource.get(e);
          o && (i = o.delete(t));
          const r = this._byOwner.get(t);
          if (r && (n = r.delete(e)), i !== n) throw new Error("illegal state");
          return i && n;
        }
        values(e) {
          var _a3, _b3;
          return typeof e == "string" ? ((_a3 = this._byOwner.get(e)) == null ? void 0 : _a3.values()) ?? kt.empty() : st.isUri(e) ? ((_b3 = this._byResource.get(e)) == null ? void 0 : _b3.values()) ?? kt.empty() : kt.map(kt.concat(...this._byOwner.values()), (t) => t[1]);
        }
      }
      class Jre {
        constructor(e) {
          this.errors = 0, this.infos = 0, this.warnings = 0, this.unknowns = 0, this._data = new fs(), this._service = e, this._subscription = e.onMarkerChanged(this._update, this);
        }
        dispose() {
          this._subscription.dispose();
        }
        _update(e) {
          for (const t of e) {
            const i = this._data.get(t);
            i && this._substract(i);
            const n = this._resourceStats(t);
            this._add(n), this._data.set(t, n);
          }
        }
        _resourceStats(e) {
          const t = {
            errors: 0,
            warnings: 0,
            infos: 0,
            unknowns: 0
          };
          if (Qre.has(e.scheme)) return t;
          for (const { severity: i } of this._service.read({
            resource: e
          })) i === Ro.Error ? t.errors += 1 : i === Ro.Warning ? t.warnings += 1 : i === Ro.Info ? t.infos += 1 : t.unknowns += 1;
          return t;
        }
        _substract(e) {
          this.errors -= e.errors, this.warnings -= e.warnings, this.infos -= e.infos, this.unknowns -= e.unknowns;
        }
        _add(e) {
          this.errors += e.errors, this.warnings += e.warnings, this.infos += e.infos, this.unknowns += e.unknowns;
        }
      }
      class Nc {
        constructor() {
          this._onMarkerChanged = new u9({
            delay: 0,
            merge: Nc._merge
          }), this.onMarkerChanged = this._onMarkerChanged.event, this._data = new Xre(), this._stats = new Jre(this);
        }
        dispose() {
          this._stats.dispose(), this._onMarkerChanged.dispose();
        }
        remove(e, t) {
          for (const i of t || []) this.changeOne(e, i, []);
        }
        changeOne(e, t, i) {
          if (_U(i)) this._data.delete(t, e) && this._onMarkerChanged.fire([
            t
          ]);
          else {
            const n = [];
            for (const o of i) {
              const r = Nc._toMarker(e, t, o);
              r && n.push(r);
            }
            this._data.set(t, e, n), this._onMarkerChanged.fire([
              t
            ]);
          }
        }
        static _toMarker(e, t, i) {
          let { code: n, severity: o, message: r, source: a, startLineNumber: l, startColumn: u, endLineNumber: d, endColumn: f, relatedInformation: m, tags: _ } = i;
          if (r) return l = l > 0 ? l : 1, u = u > 0 ? u : 1, d = d >= l ? d : l, f = f > 0 ? f : u, {
            resource: t,
            owner: e,
            code: n,
            severity: o,
            message: r,
            source: a,
            startLineNumber: l,
            startColumn: u,
            endLineNumber: d,
            endColumn: f,
            relatedInformation: m,
            tags: _
          };
        }
        changeAll(e, t) {
          const i = [], n = this._data.values(e);
          if (n) for (const o of n) {
            const r = kt.first(o);
            r && (i.push(r.resource), this._data.delete(r.resource, e));
          }
          if (OC(t)) {
            const o = new fs();
            for (const { resource: r, marker: a } of t) {
              const l = Nc._toMarker(e, r, a);
              if (!l) continue;
              const u = o.get(r);
              u ? u.push(l) : (o.set(r, [
                l
              ]), i.push(r));
            }
            for (const [r, a] of o) this._data.set(r, e, a);
          }
          i.length > 0 && this._onMarkerChanged.fire(i);
        }
        read(e = /* @__PURE__ */ Object.create(null)) {
          let { owner: t, resource: i, severities: n, take: o } = e;
          if ((!o || o < 0) && (o = -1), t && i) {
            const r = this._data.get(i, t);
            if (r) {
              const a = [];
              for (const l of r) if (Nc._accept(l, n)) {
                const u = a.push(l);
                if (o > 0 && u === o) break;
              }
              return a;
            } else return [];
          } else if (!t && !i) {
            const r = [];
            for (const a of this._data.values()) for (const l of a) if (Nc._accept(l, n)) {
              const u = r.push(l);
              if (o > 0 && u === o) return r;
            }
            return r;
          } else {
            const r = this._data.values(i ?? t), a = [];
            for (const l of r) for (const u of l) if (Nc._accept(u, n)) {
              const d = a.push(u);
              if (o > 0 && d === o) return a;
            }
            return a;
          }
        }
        static _accept(e, t) {
          return t === void 0 || (t & e.severity) === e.severity;
        }
        static _merge(e) {
          const t = new fs();
          for (const i of e) for (const n of i) t.set(n, true);
          return Array.from(t.keys());
        }
      }
      class eae extends he {
        get configurationModel() {
          return this._configurationModel;
        }
        constructor(e) {
          super(), this.logService = e, this._configurationModel = Cn.createEmptyModel(this.logService);
        }
        reload() {
          return this.resetConfigurationModel(), this.configurationModel;
        }
        getConfigurationDefaultOverrides() {
          return {};
        }
        resetConfigurationModel() {
          this._configurationModel = Cn.createEmptyModel(this.logService);
          const e = yn.as(Jh.Configuration).getConfigurationProperties();
          this.updateConfigurationModel(Object.keys(e), e);
        }
        updateConfigurationModel(e, t) {
          const i = this.getConfigurationDefaultOverrides();
          for (const n of e) {
            const o = i[n], r = t[n];
            o !== void 0 ? this._configurationModel.setValue(n, o) : r ? this._configurationModel.setValue(n, r.default) : this._configurationModel.removeValue(n);
          }
        }
      }
      const Fw = pt("accessibilitySignalService");
      const _et = class _et {
        static register(e) {
          return new _et(e.fileName);
        }
        constructor(e) {
          this.fileName = e;
        }
      };
      _et.error = _et.register({
        fileName: "error.mp3"
      });
      _et.warning = _et.register({
        fileName: "warning.mp3"
      });
      _et.success = _et.register({
        fileName: "success.mp3"
      });
      _et.foldedArea = _et.register({
        fileName: "foldedAreas.mp3"
      });
      _et.break = _et.register({
        fileName: "break.mp3"
      });
      _et.quickFixes = _et.register({
        fileName: "quickFixes.mp3"
      });
      _et.taskCompleted = _et.register({
        fileName: "taskCompleted.mp3"
      });
      _et.taskFailed = _et.register({
        fileName: "taskFailed.mp3"
      });
      _et.terminalBell = _et.register({
        fileName: "terminalBell.mp3"
      });
      _et.diffLineInserted = _et.register({
        fileName: "diffLineInserted.mp3"
      });
      _et.diffLineDeleted = _et.register({
        fileName: "diffLineDeleted.mp3"
      });
      _et.diffLineModified = _et.register({
        fileName: "diffLineModified.mp3"
      });
      _et.chatRequestSent = _et.register({
        fileName: "chatRequestSent.mp3"
      });
      _et.chatResponseReceived1 = _et.register({
        fileName: "chatResponseReceived1.mp3"
      });
      _et.chatResponseReceived2 = _et.register({
        fileName: "chatResponseReceived2.mp3"
      });
      _et.chatResponseReceived3 = _et.register({
        fileName: "chatResponseReceived3.mp3"
      });
      _et.chatResponseReceived4 = _et.register({
        fileName: "chatResponseReceived4.mp3"
      });
      _et.clear = _et.register({
        fileName: "clear.mp3"
      });
      _et.save = _et.register({
        fileName: "save.mp3"
      });
      _et.format = _et.register({
        fileName: "format.mp3"
      });
      _et.voiceRecordingStarted = _et.register({
        fileName: "voiceRecordingStarted.mp3"
      });
      _et.voiceRecordingStopped = _et.register({
        fileName: "voiceRecordingStopped.mp3"
      });
      _et.progress = _et.register({
        fileName: "progress.mp3"
      });
      let et = _et;
      class tae {
        constructor(e) {
          this.randomOneOf = e;
        }
      }
      const _Bt = class _Bt {
        constructor(e, t, i, n, o, r) {
          this.sound = e, this.name = t, this.legacySoundSettingsKey = i, this.settingsKey = n, this.legacyAnnouncementSettingsKey = o, this.announcementMessage = r;
        }
        static register(e) {
          const t = new tae("randomOneOf" in e.sound ? e.sound.randomOneOf : [
            e.sound
          ]), i = new _Bt(t, e.name, e.legacySoundSettingsKey, e.settingsKey, e.legacyAnnouncementSettingsKey, e.announcementMessage);
          return _Bt._signals.add(i), i;
        }
      };
      _Bt._signals = /* @__PURE__ */ new Set();
      _Bt.errorAtPosition = _Bt.register({
        name: C("accessibilitySignals.positionHasError.name", "Error at Position"),
        sound: et.error,
        announcementMessage: C("accessibility.signals.positionHasError", "Error"),
        settingsKey: "accessibility.signals.positionHasError",
        delaySettingsKey: "accessibility.signalOptions.delays.errorAtPosition"
      });
      _Bt.warningAtPosition = _Bt.register({
        name: C("accessibilitySignals.positionHasWarning.name", "Warning at Position"),
        sound: et.warning,
        announcementMessage: C("accessibility.signals.positionHasWarning", "Warning"),
        settingsKey: "accessibility.signals.positionHasWarning",
        delaySettingsKey: "accessibility.signalOptions.delays.warningAtPosition"
      });
      _Bt.errorOnLine = _Bt.register({
        name: C("accessibilitySignals.lineHasError.name", "Error on Line"),
        sound: et.error,
        legacySoundSettingsKey: "audioCues.lineHasError",
        legacyAnnouncementSettingsKey: "accessibility.alert.error",
        announcementMessage: C("accessibility.signals.lineHasError", "Error on Line"),
        settingsKey: "accessibility.signals.lineHasError"
      });
      _Bt.warningOnLine = _Bt.register({
        name: C("accessibilitySignals.lineHasWarning.name", "Warning on Line"),
        sound: et.warning,
        legacySoundSettingsKey: "audioCues.lineHasWarning",
        legacyAnnouncementSettingsKey: "accessibility.alert.warning",
        announcementMessage: C("accessibility.signals.lineHasWarning", "Warning on Line"),
        settingsKey: "accessibility.signals.lineHasWarning"
      });
      _Bt.foldedArea = _Bt.register({
        name: C("accessibilitySignals.lineHasFoldedArea.name", "Folded Area on Line"),
        sound: et.foldedArea,
        legacySoundSettingsKey: "audioCues.lineHasFoldedArea",
        legacyAnnouncementSettingsKey: "accessibility.alert.foldedArea",
        announcementMessage: C("accessibility.signals.lineHasFoldedArea", "Folded"),
        settingsKey: "accessibility.signals.lineHasFoldedArea"
      });
      _Bt.break = _Bt.register({
        name: C("accessibilitySignals.lineHasBreakpoint.name", "Breakpoint on Line"),
        sound: et.break,
        legacySoundSettingsKey: "audioCues.lineHasBreakpoint",
        legacyAnnouncementSettingsKey: "accessibility.alert.breakpoint",
        announcementMessage: C("accessibility.signals.lineHasBreakpoint", "Breakpoint"),
        settingsKey: "accessibility.signals.lineHasBreakpoint"
      });
      _Bt.inlineSuggestion = _Bt.register({
        name: C("accessibilitySignals.lineHasInlineSuggestion.name", "Inline Suggestion on Line"),
        sound: et.quickFixes,
        legacySoundSettingsKey: "audioCues.lineHasInlineSuggestion",
        settingsKey: "accessibility.signals.lineHasInlineSuggestion"
      });
      _Bt.terminalQuickFix = _Bt.register({
        name: C("accessibilitySignals.terminalQuickFix.name", "Terminal Quick Fix"),
        sound: et.quickFixes,
        legacySoundSettingsKey: "audioCues.terminalQuickFix",
        legacyAnnouncementSettingsKey: "accessibility.alert.terminalQuickFix",
        announcementMessage: C("accessibility.signals.terminalQuickFix", "Quick Fix"),
        settingsKey: "accessibility.signals.terminalQuickFix"
      });
      _Bt.onDebugBreak = _Bt.register({
        name: C("accessibilitySignals.onDebugBreak.name", "Debugger Stopped on Breakpoint"),
        sound: et.break,
        legacySoundSettingsKey: "audioCues.onDebugBreak",
        legacyAnnouncementSettingsKey: "accessibility.alert.onDebugBreak",
        announcementMessage: C("accessibility.signals.onDebugBreak", "Breakpoint"),
        settingsKey: "accessibility.signals.onDebugBreak"
      });
      _Bt.noInlayHints = _Bt.register({
        name: C("accessibilitySignals.noInlayHints", "No Inlay Hints on Line"),
        sound: et.error,
        legacySoundSettingsKey: "audioCues.noInlayHints",
        legacyAnnouncementSettingsKey: "accessibility.alert.noInlayHints",
        announcementMessage: C("accessibility.signals.noInlayHints", "No Inlay Hints"),
        settingsKey: "accessibility.signals.noInlayHints"
      });
      _Bt.taskCompleted = _Bt.register({
        name: C("accessibilitySignals.taskCompleted", "Task Completed"),
        sound: et.taskCompleted,
        legacySoundSettingsKey: "audioCues.taskCompleted",
        legacyAnnouncementSettingsKey: "accessibility.alert.taskCompleted",
        announcementMessage: C("accessibility.signals.taskCompleted", "Task Completed"),
        settingsKey: "accessibility.signals.taskCompleted"
      });
      _Bt.taskFailed = _Bt.register({
        name: C("accessibilitySignals.taskFailed", "Task Failed"),
        sound: et.taskFailed,
        legacySoundSettingsKey: "audioCues.taskFailed",
        legacyAnnouncementSettingsKey: "accessibility.alert.taskFailed",
        announcementMessage: C("accessibility.signals.taskFailed", "Task Failed"),
        settingsKey: "accessibility.signals.taskFailed"
      });
      _Bt.terminalCommandFailed = _Bt.register({
        name: C("accessibilitySignals.terminalCommandFailed", "Terminal Command Failed"),
        sound: et.error,
        legacySoundSettingsKey: "audioCues.terminalCommandFailed",
        legacyAnnouncementSettingsKey: "accessibility.alert.terminalCommandFailed",
        announcementMessage: C("accessibility.signals.terminalCommandFailed", "Command Failed"),
        settingsKey: "accessibility.signals.terminalCommandFailed"
      });
      _Bt.terminalCommandSucceeded = _Bt.register({
        name: C("accessibilitySignals.terminalCommandSucceeded", "Terminal Command Succeeded"),
        sound: et.success,
        announcementMessage: C("accessibility.signals.terminalCommandSucceeded", "Command Succeeded"),
        settingsKey: "accessibility.signals.terminalCommandSucceeded"
      });
      _Bt.terminalBell = _Bt.register({
        name: C("accessibilitySignals.terminalBell", "Terminal Bell"),
        sound: et.terminalBell,
        legacySoundSettingsKey: "audioCues.terminalBell",
        legacyAnnouncementSettingsKey: "accessibility.alert.terminalBell",
        announcementMessage: C("accessibility.signals.terminalBell", "Terminal Bell"),
        settingsKey: "accessibility.signals.terminalBell"
      });
      _Bt.notebookCellCompleted = _Bt.register({
        name: C("accessibilitySignals.notebookCellCompleted", "Notebook Cell Completed"),
        sound: et.taskCompleted,
        legacySoundSettingsKey: "audioCues.notebookCellCompleted",
        legacyAnnouncementSettingsKey: "accessibility.alert.notebookCellCompleted",
        announcementMessage: C("accessibility.signals.notebookCellCompleted", "Notebook Cell Completed"),
        settingsKey: "accessibility.signals.notebookCellCompleted"
      });
      _Bt.notebookCellFailed = _Bt.register({
        name: C("accessibilitySignals.notebookCellFailed", "Notebook Cell Failed"),
        sound: et.taskFailed,
        legacySoundSettingsKey: "audioCues.notebookCellFailed",
        legacyAnnouncementSettingsKey: "accessibility.alert.notebookCellFailed",
        announcementMessage: C("accessibility.signals.notebookCellFailed", "Notebook Cell Failed"),
        settingsKey: "accessibility.signals.notebookCellFailed"
      });
      _Bt.diffLineInserted = _Bt.register({
        name: C("accessibilitySignals.diffLineInserted", "Diff Line Inserted"),
        sound: et.diffLineInserted,
        legacySoundSettingsKey: "audioCues.diffLineInserted",
        settingsKey: "accessibility.signals.diffLineInserted"
      });
      _Bt.diffLineDeleted = _Bt.register({
        name: C("accessibilitySignals.diffLineDeleted", "Diff Line Deleted"),
        sound: et.diffLineDeleted,
        legacySoundSettingsKey: "audioCues.diffLineDeleted",
        settingsKey: "accessibility.signals.diffLineDeleted"
      });
      _Bt.diffLineModified = _Bt.register({
        name: C("accessibilitySignals.diffLineModified", "Diff Line Modified"),
        sound: et.diffLineModified,
        legacySoundSettingsKey: "audioCues.diffLineModified",
        settingsKey: "accessibility.signals.diffLineModified"
      });
      _Bt.chatRequestSent = _Bt.register({
        name: C("accessibilitySignals.chatRequestSent", "Chat Request Sent"),
        sound: et.chatRequestSent,
        legacySoundSettingsKey: "audioCues.chatRequestSent",
        legacyAnnouncementSettingsKey: "accessibility.alert.chatRequestSent",
        announcementMessage: C("accessibility.signals.chatRequestSent", "Chat Request Sent"),
        settingsKey: "accessibility.signals.chatRequestSent"
      });
      _Bt.chatResponseReceived = _Bt.register({
        name: C("accessibilitySignals.chatResponseReceived", "Chat Response Received"),
        legacySoundSettingsKey: "audioCues.chatResponseReceived",
        sound: {
          randomOneOf: [
            et.chatResponseReceived1,
            et.chatResponseReceived2,
            et.chatResponseReceived3,
            et.chatResponseReceived4
          ]
        },
        settingsKey: "accessibility.signals.chatResponseReceived"
      });
      _Bt.progress = _Bt.register({
        name: C("accessibilitySignals.progress", "Progress"),
        sound: et.progress,
        legacySoundSettingsKey: "audioCues.chatResponsePending",
        legacyAnnouncementSettingsKey: "accessibility.alert.progress",
        announcementMessage: C("accessibility.signals.progress", "Progress"),
        settingsKey: "accessibility.signals.progress"
      });
      _Bt.clear = _Bt.register({
        name: C("accessibilitySignals.clear", "Clear"),
        sound: et.clear,
        legacySoundSettingsKey: "audioCues.clear",
        legacyAnnouncementSettingsKey: "accessibility.alert.clear",
        announcementMessage: C("accessibility.signals.clear", "Clear"),
        settingsKey: "accessibility.signals.clear"
      });
      _Bt.save = _Bt.register({
        name: C("accessibilitySignals.save", "Save"),
        sound: et.save,
        legacySoundSettingsKey: "audioCues.save",
        legacyAnnouncementSettingsKey: "accessibility.alert.save",
        announcementMessage: C("accessibility.signals.save", "Save"),
        settingsKey: "accessibility.signals.save"
      });
      _Bt.format = _Bt.register({
        name: C("accessibilitySignals.format", "Format"),
        sound: et.format,
        legacySoundSettingsKey: "audioCues.format",
        legacyAnnouncementSettingsKey: "accessibility.alert.format",
        announcementMessage: C("accessibility.signals.format", "Format"),
        settingsKey: "accessibility.signals.format"
      });
      _Bt.voiceRecordingStarted = _Bt.register({
        name: C("accessibilitySignals.voiceRecordingStarted", "Voice Recording Started"),
        sound: et.voiceRecordingStarted,
        legacySoundSettingsKey: "audioCues.voiceRecordingStarted",
        settingsKey: "accessibility.signals.voiceRecordingStarted"
      });
      _Bt.voiceRecordingStopped = _Bt.register({
        name: C("accessibilitySignals.voiceRecordingStopped", "Voice Recording Stopped"),
        sound: et.voiceRecordingStopped,
        legacySoundSettingsKey: "audioCues.voiceRecordingStopped",
        settingsKey: "accessibility.signals.voiceRecordingStopped"
      });
      let Bt = _Bt;
      class iae extends he {
        constructor(e, t = []) {
          super(), this.logger = new kj([
            e,
            ...t
          ]), this._register(e.onDidChangeLogLevel((i) => this.setLevel(i)));
        }
        get onDidChangeLogLevel() {
          return this.logger.onDidChangeLogLevel;
        }
        setLevel(e) {
          this.logger.setLevel(e);
        }
        getLevel() {
          return this.logger.getLevel();
        }
        trace(e, ...t) {
          this.logger.trace(e, ...t);
        }
        debug(e, ...t) {
          this.logger.debug(e, ...t);
        }
        info(e, ...t) {
          this.logger.info(e, ...t);
        }
        warn(e, ...t) {
          this.logger.warn(e, ...t);
        }
        error(e, ...t) {
          this.logger.error(e, ...t);
        }
      }
      const nae = [];
      function sae() {
        return nae.slice(0);
      }
      class oae {
        getParseResult(e) {
        }
      }
      var Va = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      }, Mi = function(s, e) {
        return function(t, i) {
          e(t, i, s);
        };
      };
      class rae {
        constructor(e) {
          this.disposed = false, this.model = e, this._onWillDispose = new G();
        }
        get textEditorModel() {
          return this.model;
        }
        dispose() {
          this.disposed = true, this._onWillDispose.fire();
        }
      }
      let P2 = class {
        constructor(e) {
          this.modelService = e;
        }
        createModelReference(e) {
          const t = this.modelService.getModel(e);
          return t ? Promise.resolve(new B$(new rae(t))) : Promise.reject(new Error("Model not found"));
        }
      };
      P2 = Va([
        Mi(0, _s)
      ], P2);
      const _UN = class _UN {
        show() {
          return _UN.NULL_PROGRESS_RUNNER;
        }
        async showWhile(e, t) {
          await e;
        }
      };
      _UN.NULL_PROGRESS_RUNNER = {
        done: () => {
        },
        total: () => {
        },
        worked: () => {
        }
      };
      let UN = _UN;
      class aae {
        withProgress(e, t, i) {
          return t({
            report: () => {
            }
          });
        }
      }
      class lae {
        constructor() {
          this.isExtensionDevelopment = false, this.isBuilt = false;
        }
      }
      class cae {
        async confirm(e) {
          return {
            confirmed: this.doConfirm(e.message, e.detail),
            checkboxChecked: false
          };
        }
        doConfirm(e, t) {
          let i = e;
          return t && (i = i + `

` + t), Kt.confirm(i);
        }
        async prompt(e) {
          var _a3;
          let t;
          if (this.doConfirm(e.message, e.detail)) {
            const n = [
              ...e.buttons ?? []
            ];
            e.cancelButton && typeof e.cancelButton != "string" && typeof e.cancelButton != "boolean" && n.push(e.cancelButton), t = await ((_a3 = n[0]) == null ? void 0 : _a3.run({
              checkboxChecked: false
            }));
          }
          return {
            result: t
          };
        }
        async error(e, t) {
          await this.prompt({
            type: Ui.Error,
            message: e,
            detail: t
          });
        }
      }
      const _rC = class _rC {
        info(e) {
          return this.notify({
            severity: Ui.Info,
            message: e
          });
        }
        warn(e) {
          return this.notify({
            severity: Ui.Warning,
            message: e
          });
        }
        error(e) {
          return this.notify({
            severity: Ui.Error,
            message: e
          });
        }
        notify(e) {
          switch (e.severity) {
            case Ui.Error:
              console.error(e.message);
              break;
            case Ui.Warning:
              console.warn(e.message);
              break;
            default:
              console.log(e.message);
              break;
          }
          return _rC.NO_OP;
        }
        prompt(e, t, i, n) {
          return _rC.NO_OP;
        }
        status(e, t) {
          return he.None;
        }
      };
      _rC.NO_OP = new ZY();
      let rC = _rC;
      let B2 = class {
        constructor(e) {
          this._onWillExecuteCommand = new G(), this._onDidExecuteCommand = new G(), this.onDidExecuteCommand = this._onDidExecuteCommand.event, this._instantiationService = e;
        }
        executeCommand(e, ...t) {
          const i = Os.getCommand(e);
          if (!i) return Promise.reject(new Error(`command '${e}' not found`));
          try {
            this._onWillExecuteCommand.fire({
              commandId: e,
              args: t
            });
            const n = this._instantiationService.invokeFunction.apply(this._instantiationService, [
              i.handler,
              ...t
            ]);
            return this._onDidExecuteCommand.fire({
              commandId: e,
              args: t
            }), Promise.resolve(n);
          } catch (n) {
            return Promise.reject(n);
          }
        }
      };
      B2 = Va([
        Mi(0, Ft)
      ], B2);
      let vg = class extends mee {
        constructor(e, t, i, n, o, r) {
          super(e, t, i, n, o), this._cachedResolver = null, this._dynamicKeybindings = [], this._domNodeListeners = [];
          const a = (_) => {
            const b = new Me();
            b.add(re(_, Ce.KEY_DOWN, (v) => {
              const y = new si(v);
              this._dispatch(y, y.target) && (y.preventDefault(), y.stopPropagation());
            })), b.add(re(_, Ce.KEY_UP, (v) => {
              const y = new si(v);
              this._singleModifierDispatch(y, y.target) && y.preventDefault();
            })), this._domNodeListeners.push(new uae(_, b));
          }, l = (_) => {
            for (let b = 0; b < this._domNodeListeners.length; b++) {
              const v = this._domNodeListeners[b];
              v.domNode === _ && (this._domNodeListeners.splice(b, 1), v.dispose());
            }
          }, u = (_) => {
            _.getOption(61) || a(_.getContainerDomNode());
          }, d = (_) => {
            _.getOption(61) || l(_.getContainerDomNode());
          };
          this._register(r.onCodeEditorAdd(u)), this._register(r.onCodeEditorRemove(d)), r.listCodeEditors().forEach(u);
          const f = (_) => {
            a(_.getContainerDomNode());
          }, m = (_) => {
            l(_.getContainerDomNode());
          };
          this._register(r.onDiffEditorAdd(f)), this._register(r.onDiffEditorRemove(m)), r.listDiffEditors().forEach(f);
        }
        addDynamicKeybinding(e, t, i, n) {
          return ka(Os.registerCommand(e, i), this.addDynamicKeybindings([
            {
              keybinding: t,
              command: e,
              when: n
            }
          ]));
        }
        addDynamicKeybindings(e) {
          const t = e.map((i) => ({
            keybinding: Bk(i.keybinding, ur),
            command: i.command ?? null,
            commandArgs: i.commandArgs,
            when: i.when,
            weight1: 1e3,
            weight2: 0,
            extensionId: null,
            isBuiltinExtension: false
          }));
          return this._dynamicKeybindings = this._dynamicKeybindings.concat(t), this.updateResolver(), Ze(() => {
            for (let i = 0; i < this._dynamicKeybindings.length; i++) if (this._dynamicKeybindings[i] === t[0]) {
              this._dynamicKeybindings.splice(i, t.length), this.updateResolver();
              return;
            }
          });
        }
        updateResolver() {
          this._cachedResolver = null, this._onDidUpdateKeybindings.fire();
        }
        _getResolver() {
          if (!this._cachedResolver) {
            const e = this._toNormalizedKeybindingItems(z_.getDefaultKeybindings(), true), t = this._toNormalizedKeybindingItems(this._dynamicKeybindings, false);
            this._cachedResolver = new yp(e, t, (i) => this._log(i));
          }
          return this._cachedResolver;
        }
        _documentHasFocus() {
          return Kt.document.hasFocus();
        }
        _toNormalizedKeybindingItems(e, t) {
          const i = [];
          let n = 0;
          for (const o of e) {
            const r = o.when || void 0, a = o.keybinding;
            if (!a) i[n++] = new Q5(void 0, o.command, o.commandArgs, r, t, null, false);
            else {
              const l = c_.resolveKeybinding(a, ur);
              for (const u of l) i[n++] = new Q5(u, o.command, o.commandArgs, r, t, null, false);
            }
          }
          return i;
        }
        resolveKeyboardEvent(e) {
          const t = new Mh(e.ctrlKey, e.shiftKey, e.altKey, e.metaKey, e.keyCode);
          return new c_([
            t
          ], ur);
        }
      };
      vg = Va([
        Mi(0, Mt),
        Mi(1, po),
        Mi(2, Qh),
        Mi(3, Jr),
        Mi(4, Xr),
        Mi(5, Xi)
      ], vg);
      class uae extends he {
        constructor(e, t) {
          super(), this.domNode = e, this._register(t);
        }
      }
      function S3(s) {
        return s && typeof s == "object" && (!s.overrideIdentifier || typeof s.overrideIdentifier == "string") && (!s.resource || s.resource instanceof st);
      }
      let aC = class {
        constructor(e) {
          this.logService = e, this._onDidChangeConfiguration = new G(), this.onDidChangeConfiguration = this._onDidChangeConfiguration.event;
          const t = new eae(e);
          this._configuration = new mw(t.reload(), Cn.createEmptyModel(e), Cn.createEmptyModel(e), Cn.createEmptyModel(e), Cn.createEmptyModel(e), Cn.createEmptyModel(e), new fs(), Cn.createEmptyModel(e), new fs(), e), t.dispose();
        }
        getValue(e, t) {
          const i = typeof e == "string" ? e : void 0, n = S3(e) ? e : S3(t) ? t : {};
          return this._configuration.getValue(i, n, void 0);
        }
        updateValues(e) {
          const t = {
            data: this._configuration.toData()
          }, i = [];
          for (const n of e) {
            const [o, r] = n;
            this.getValue(o) !== r && (this._configuration.updateValue(o, r), i.push(o));
          }
          if (i.length > 0) {
            const n = new uee({
              keys: i,
              overrides: []
            }, t, this._configuration, void 0, this.logService);
            n.source = 8, this._onDidChangeConfiguration.fire(n);
          }
          return Promise.resolve();
        }
        updateValue(e, t, i, n) {
          return this.updateValues([
            [
              e,
              t
            ]
          ]);
        }
        inspect(e, t = {}) {
          return this._configuration.inspect(e, t, void 0);
        }
      };
      aC = Va([
        Mi(0, Xr)
      ], aC);
      let F2 = class {
        constructor(e, t, i) {
          this.configurationService = e, this.modelService = t, this.languageService = i, this._onDidChangeConfiguration = new G(), this.configurationService.onDidChangeConfiguration((n) => {
            this._onDidChangeConfiguration.fire({
              affectedKeys: n.affectedKeys,
              affectsConfiguration: (o, r) => n.affectsConfiguration(r)
            });
          });
        }
        getValue(e, t, i) {
          const n = X.isIPosition(t) ? t : null, o = n ? typeof i == "string" ? i : void 0 : typeof t == "string" ? t : void 0, r = e ? this.getLanguage(e, n) : void 0;
          return typeof o > "u" ? this.configurationService.getValue({
            resource: e,
            overrideIdentifier: r
          }) : this.configurationService.getValue(o, {
            resource: e,
            overrideIdentifier: r
          });
        }
        getLanguage(e, t) {
          const i = this.modelService.getModel(e);
          return i ? t ? i.getLanguageIdAtPosition(t.lineNumber, t.column) : i.getLanguageId() : this.languageService.guessLanguageIdByFilepathOrFirstLine(e);
        }
      };
      F2 = Va([
        Mi(0, Si),
        Mi(1, _s),
        Mi(2, un)
      ], F2);
      let V2 = class {
        constructor(e) {
          this.configurationService = e;
        }
        getEOL(e, t) {
          const i = this.configurationService.getValue("files.eol", {
            overrideIdentifier: t,
            resource: e
          });
          return i && typeof i == "string" && i !== "auto" ? i : Is || _t ? `
` : `\r
`;
        }
      };
      V2 = Va([
        Mi(0, Si)
      ], V2);
      class hae {
        publicLog2() {
        }
      }
      const _lC = class _lC {
        constructor() {
          const e = st.from({
            scheme: _lC.SCHEME,
            authority: "model",
            path: "/"
          });
          this.workspace = {
            id: Nee,
            folders: [
              new Eee({
                uri: e,
                name: "",
                index: 0
              })
            ]
          };
        }
        getWorkspace() {
          return this.workspace;
        }
        getWorkspaceFolder(e) {
          return e && e.scheme === _lC.SCHEME ? this.workspace.folders[0] : null;
        }
      };
      _lC.SCHEME = "inmemory";
      let lC = _lC;
      function cC(s, e, t) {
        if (!e || !(s instanceof aC)) return;
        const i = [];
        Object.keys(e).forEach((n) => {
          see(n) && i.push([
            `editor.${n}`,
            e[n]
          ]), t && oee(n) && i.push([
            `diffEditor.${n}`,
            e[n]
          ]);
        }), i.length > 0 && s.updateValues(i);
      }
      let W2 = class {
        constructor(e) {
          this._modelService = e;
        }
        hasPreviewHandler() {
          return false;
        }
        async apply(e, t) {
          const i = Array.isArray(e) ? e : jT.convert(e), n = /* @__PURE__ */ new Map();
          for (const a of i) {
            if (!(a instanceof yh)) throw new Error("bad edit - only text edits are supported");
            const l = this._modelService.getModel(a.resource);
            if (!l) throw new Error("bad edit - model not found");
            if (typeof a.versionId == "number" && l.getVersionId() !== a.versionId) throw new Error("bad state - model changed in the meantime");
            let u = n.get(l);
            u || (u = [], n.set(l, u)), u.push(aee.replaceMove(z.lift(a.textEdit.range), a.textEdit.text));
          }
          let o = 0, r = 0;
          for (const [a, l] of n) a.pushStackElement(), a.pushEditOperations([], l, () => []), a.pushStackElement(), r += 1, o += l.length;
          return {
            ariaSummary: Ak(WD.bulkEditServiceSummary, o, r),
            isApplied: o > 0
          };
        }
      };
      W2 = Va([
        Mi(0, _s)
      ], W2);
      class dae {
        getUriLabel(e, t) {
          return e.scheme === "file" ? e.fsPath : e.path;
        }
        getUriBasenameLabel(e) {
          return UT(e);
        }
      }
      let H2 = class extends QJ {
        constructor(e, t) {
          super(e), this._codeEditorService = t;
        }
        showContextView(e, t, i) {
          if (!t) {
            const n = this._codeEditorService.getFocusedCodeEditor() || this._codeEditorService.getActiveCodeEditor();
            n && (t = n.getContainerDomNode());
          }
          return super.showContextView(e, t, i);
        }
      };
      H2 = Va([
        Mi(0, du),
        Mi(1, Xi)
      ], H2);
      class fae {
        constructor() {
          this._neverEmitter = new G(), this.onDidChangeTrust = this._neverEmitter.event;
        }
        isWorkspaceTrusted() {
          return true;
        }
      }
      class gae extends Pv {
        constructor() {
          super();
        }
      }
      class mae extends iae {
        constructor() {
          super(new xj());
        }
      }
      let z2 = class extends QD {
        constructor(e, t, i, n, o, r) {
          super(e, t, i, n, o, r), this.configure({
            blockMouse: false
          });
        }
      };
      z2 = Va([
        Mi(0, Qh),
        Mi(1, Jr),
        Mi(2, Q_),
        Mi(3, Pn),
        Mi(4, Zh),
        Mi(5, Mt)
      ], z2);
      const U2 = {
        amdModuleId: "vs/editor/common/services/editorSimpleWorker",
        esmModuleLocation: void 0,
        label: "editorWorkerService"
      };
      let $2 = class extends rD {
        constructor(e, t, i, n, o) {
          super(U2, e, t, i, n, o);
        }
      };
      $2 = Va([
        Mi(0, _s),
        Mi(1, xT),
        Mi(2, Xr),
        Mi(3, Pa),
        Mi(4, jt)
      ], $2);
      class pae {
        async playSignal(e, t) {
        }
      }
      Lt(Xr, mae, 0);
      Lt(Si, aC, 0);
      Lt(xT, F2, 0);
      Lt(R8, V2, 0);
      Lt(Dee, lC, 0);
      Lt(wee, dae, 0);
      Lt(Qh, hae, 0);
      Lt(V8, cae, 0);
      Lt(q8, lae, 0);
      Lt(Jr, rC, 0);
      Lt(td, Nc, 0);
      Lt(un, gae, 0);
      Lt(wr, Pre, 0);
      Lt(_s, h2, 0);
      Lt(mB, i2, 0);
      Lt(Mt, O2, 0);
      Lt(yee, aae, 0);
      Lt(YT, UN, 0);
      Lt(Sw, Hte, 0);
      Lt(n1, $2, 0);
      Lt(tee, W2, 0);
      Lt(Iee, fae, 0);
      Lt(qC, P2, 0);
      Lt(ea, T2, 0);
      Lt(Fa, joe, 0);
      Lt(po, B2, 0);
      Lt(Pn, vg, 0);
      Lt(kw, D2, 0);
      Lt(Q_, H2, 0);
      Lt(X_, t2, 0);
      Lt(HN, R2, 0);
      Lt(Gl, z2, 0);
      Lt(Zh, N2, 0);
      Lt(Fw, pae, 0);
      Lt(AB, oae, 0);
      var Pe;
      (function(s) {
        const e = new Mg();
        for (const [l, u] of SO()) e.set(l, u);
        const t = new oC(e, true);
        e.set(Ft, t);
        function i(l) {
          n || r({});
          const u = e.get(l);
          if (!u) throw new Error("Missing service " + l);
          return u instanceof ya ? t.invokeFunction((d) => d.get(l)) : u;
        }
        s.get = i;
        let n = false;
        const o = new G();
        function r(l) {
          if (n) return t;
          n = true;
          for (const [d, f] of SO()) e.get(d) || e.set(d, f);
          for (const d in l) if (l.hasOwnProperty(d)) {
            const f = pt(d);
            e.get(f) instanceof ya && e.set(f, l[d]);
          }
          const u = sae();
          for (const d of u) try {
            t.createInstance(d);
          } catch (f) {
            qt(f);
          }
          return o.fire(), t;
        }
        s.initialize = r;
        function a(l) {
          if (n) return l();
          const u = new Me(), d = u.add(o.event(() => {
            d.dispose(), u.add(l());
          }));
          return u;
        }
        s.withServices = a;
      })(Pe || (Pe = {}));
      function _ae(s, e) {
        return new bae(s, e);
      }
      class bae extends pv {
        constructor(e, t) {
          const i = {
            amdModuleId: U2.amdModuleId,
            esmModuleLocation: U2.esmModuleLocation,
            label: t.label
          };
          super(i, t.keepIdleModels || false, e), this._foreignModuleId = t.moduleId, this._foreignModuleCreateData = t.createData || null, this._foreignModuleHost = t.host || null, this._foreignProxy = null;
        }
        fhr(e, t) {
          if (!this._foreignModuleHost || typeof this._foreignModuleHost[e] != "function") return Promise.reject(new Error("Missing method " + e + " or missing main thread foreign host."));
          try {
            return Promise.resolve(this._foreignModuleHost[e].apply(this._foreignModuleHost, t));
          } catch (i) {
            return Promise.reject(i);
          }
        }
        _getForeignProxy() {
          return this._foreignProxy || (this._foreignProxy = this._getProxy().then((e) => {
            const t = this._foreignModuleHost ? Mx(this._foreignModuleHost) : [];
            return e.$loadForeignModule(this._foreignModuleId, this._foreignModuleCreateData, t).then((i) => {
              this._foreignModuleCreateData = null;
              const n = (a, l) => e.$fmr(a, l), o = (a, l) => function() {
                const u = Array.prototype.slice.call(arguments, 0);
                return l(a, u);
              }, r = {};
              for (const a of i) r[a] = o(a, n);
              return r;
            });
          })), this._foreignProxy;
        }
        getProxy() {
          return this._getForeignProxy();
        }
        withSyncedResources(e) {
          return this.workerWithSyncedResources(e).then((t) => this.getProxy());
        }
      }
      const $N = {
        ICodeEditor: "vs.editor.ICodeEditor",
        IDiffEditor: "vs.editor.IDiffEditor"
      };
      class dr {
        constructor(e, t, i, n) {
          this.startColumn = e, this.endColumn = t, this.className = i, this.type = n, this._lineDecorationBrand = void 0;
        }
        static _equals(e, t) {
          return e.startColumn === t.startColumn && e.endColumn === t.endColumn && e.className === t.className && e.type === t.type;
        }
        static equalsArr(e, t) {
          const i = e.length, n = t.length;
          if (i !== n) return false;
          for (let o = 0; o < i; o++) if (!dr._equals(e[o], t[o])) return false;
          return true;
        }
        static extractWrapped(e, t, i) {
          if (e.length === 0) return e;
          const n = t + 1, o = i + 1, r = i - t, a = [];
          let l = 0;
          for (const u of e) u.endColumn <= n || u.startColumn >= o || (a[l++] = new dr(Math.max(1, u.startColumn - n + 1), Math.min(r + 1, u.endColumn - n + 1), u.className, u.type));
          return a;
        }
        static filter(e, t, i, n) {
          if (e.length === 0) return [];
          const o = [];
          let r = 0;
          for (let a = 0, l = e.length; a < l; a++) {
            const u = e[a], d = u.range;
            if (d.endLineNumber < t || d.startLineNumber > t || d.isEmpty() && (u.type === 0 || u.type === 3)) continue;
            const f = d.startLineNumber === t ? d.startColumn : i, m = d.endLineNumber === t ? d.endColumn : n;
            o[r++] = new dr(f, m, u.inlineClassName, u.type);
          }
          return o;
        }
        static _typeCompare(e, t) {
          const i = [
            2,
            0,
            1,
            3
          ];
          return i[e] - i[t];
        }
        static compare(e, t) {
          if (e.startColumn !== t.startColumn) return e.startColumn - t.startColumn;
          if (e.endColumn !== t.endColumn) return e.endColumn - t.endColumn;
          const i = dr._typeCompare(e.type, t.type);
          return i !== 0 ? i : e.className !== t.className ? e.className < t.className ? -1 : 1 : 0;
        }
      }
      class L3 {
        constructor(e, t, i, n) {
          this.startOffset = e, this.endOffset = t, this.className = i, this.metadata = n;
        }
      }
      class uC {
        constructor() {
          this.stopOffsets = [], this.classNames = [], this.metadata = [], this.count = 0;
        }
        static _metadata(e) {
          let t = 0;
          for (let i = 0, n = e.length; i < n; i++) t |= e[i];
          return t;
        }
        consumeLowerThan(e, t, i) {
          for (; this.count > 0 && this.stopOffsets[0] < e; ) {
            let n = 0;
            for (; n + 1 < this.count && this.stopOffsets[n] === this.stopOffsets[n + 1]; ) n++;
            i.push(new L3(t, this.stopOffsets[n], this.classNames.join(" "), uC._metadata(this.metadata))), t = this.stopOffsets[n] + 1, this.stopOffsets.splice(0, n + 1), this.classNames.splice(0, n + 1), this.metadata.splice(0, n + 1), this.count -= n + 1;
          }
          return this.count > 0 && t < e && (i.push(new L3(t, e - 1, this.classNames.join(" "), uC._metadata(this.metadata))), t = e), t;
        }
        insert(e, t, i) {
          if (this.count === 0 || this.stopOffsets[this.count - 1] <= e) this.stopOffsets.push(e), this.classNames.push(t), this.metadata.push(i);
          else for (let n = 0; n < this.count; n++) if (this.stopOffsets[n] >= e) {
            this.stopOffsets.splice(n, 0, e), this.classNames.splice(n, 0, t), this.metadata.splice(n, 0, i);
            break;
          }
          this.count++;
        }
      }
      class vae {
        static normalize(e, t) {
          if (t.length === 0) return [];
          const i = [], n = new uC();
          let o = 0;
          for (let r = 0, a = t.length; r < a; r++) {
            const l = t[r];
            let u = l.startColumn, d = l.endColumn;
            const f = l.className, m = l.type === 1 ? 2 : l.type === 2 ? 4 : 0;
            if (u > 1) {
              const v = e.charCodeAt(u - 2);
              on(v) && u--;
            }
            if (d > 1) {
              const v = e.charCodeAt(d - 2);
              on(v) && d--;
            }
            const _ = u - 1, b = d - 2;
            o = n.consumeLowerThan(_, o, i), n.count === 0 && (o = _), n.insert(b, f, m);
          }
          return n.consumeLowerThan(1073741824, o, i), i;
        }
      }
      class rn {
        constructor(e, t, i, n) {
          this.endIndex = e, this.type = t, this.metadata = i, this.containsRTL = n, this._linePartBrand = void 0;
        }
        isWhitespace() {
          return !!(this.metadata & 1);
        }
        isPseudoAfter() {
          return !!(this.metadata & 4);
        }
      }
      class pF {
        constructor(e, t) {
          this.startOffset = e, this.endOffset = t;
        }
        equals(e) {
          return this.startOffset === e.startOffset && this.endOffset === e.endOffset;
        }
      }
      class Ag {
        constructor(e, t, i, n, o, r, a, l, u, d, f, m, _, b, v, y, x, L, D) {
          this.useMonospaceOptimizations = e, this.canUseHalfwidthRightwardsArrow = t, this.lineContent = i, this.continuesWithWrappedLine = n, this.isBasicASCII = o, this.containsRTL = r, this.fauxIndentLength = a, this.lineTokens = l, this.lineDecorations = u.sort(dr.compare), this.tabSize = d, this.startVisibleColumn = f, this.spaceWidth = m, this.stopRenderingLineAfter = v, this.renderWhitespace = y === "all" ? 4 : y === "boundary" ? 1 : y === "selection" ? 2 : y === "trailing" ? 3 : 0, this.renderControlCharacters = x, this.fontLigatures = L, this.selectionsOnLine = D && D.sort((M, I) => M.startOffset < I.startOffset ? -1 : 1);
          const k = Math.abs(b - m), T = Math.abs(_ - m);
          k < T ? (this.renderSpaceWidth = b, this.renderSpaceCharCode = 11825) : (this.renderSpaceWidth = _, this.renderSpaceCharCode = 183);
        }
        sameSelection(e) {
          if (this.selectionsOnLine === null) return e === null;
          if (e === null || e.length !== this.selectionsOnLine.length) return false;
          for (let t = 0; t < this.selectionsOnLine.length; t++) if (!this.selectionsOnLine[t].equals(e[t])) return false;
          return true;
        }
        equals(e) {
          return this.useMonospaceOptimizations === e.useMonospaceOptimizations && this.canUseHalfwidthRightwardsArrow === e.canUseHalfwidthRightwardsArrow && this.lineContent === e.lineContent && this.continuesWithWrappedLine === e.continuesWithWrappedLine && this.isBasicASCII === e.isBasicASCII && this.containsRTL === e.containsRTL && this.fauxIndentLength === e.fauxIndentLength && this.tabSize === e.tabSize && this.startVisibleColumn === e.startVisibleColumn && this.spaceWidth === e.spaceWidth && this.renderSpaceWidth === e.renderSpaceWidth && this.renderSpaceCharCode === e.renderSpaceCharCode && this.stopRenderingLineAfter === e.stopRenderingLineAfter && this.renderWhitespace === e.renderWhitespace && this.renderControlCharacters === e.renderControlCharacters && this.fontLigatures === e.fontLigatures && dr.equalsArr(this.lineDecorations, e.lineDecorations) && this.lineTokens.equals(e.lineTokens) && this.sameSelection(e.selectionsOnLine);
        }
      }
      class _F {
        constructor(e, t) {
          this.partIndex = e, this.charIndex = t;
        }
      }
      class Sa {
        static getPartIndex(e) {
          return (e & 4294901760) >>> 16;
        }
        static getCharIndex(e) {
          return (e & 65535) >>> 0;
        }
        constructor(e, t) {
          this.length = e, this._data = new Uint32Array(this.length), this._horizontalOffset = new Uint32Array(this.length);
        }
        setColumnInfo(e, t, i, n) {
          const o = (t << 16 | i << 0) >>> 0;
          this._data[e - 1] = o, this._horizontalOffset[e - 1] = n;
        }
        getHorizontalOffset(e) {
          return this._horizontalOffset.length === 0 ? 0 : this._horizontalOffset[e - 1];
        }
        charOffsetToPartData(e) {
          return this.length === 0 ? 0 : e < 0 ? this._data[0] : e >= this.length ? this._data[this.length - 1] : this._data[e];
        }
        getDomPosition(e) {
          const t = this.charOffsetToPartData(e - 1), i = Sa.getPartIndex(t), n = Sa.getCharIndex(t);
          return new _F(i, n);
        }
        getColumn(e, t) {
          return this.partDataToCharOffset(e.partIndex, t, e.charIndex) + 1;
        }
        partDataToCharOffset(e, t, i) {
          if (this.length === 0) return 0;
          const n = (e << 16 | i << 0) >>> 0;
          let o = 0, r = this.length - 1;
          for (; o + 1 < r; ) {
            const v = o + r >>> 1, y = this._data[v];
            if (y === n) return v;
            y > n ? r = v : o = v;
          }
          if (o === r) return o;
          const a = this._data[o], l = this._data[r];
          if (a === n) return o;
          if (l === n) return r;
          const u = Sa.getPartIndex(a), d = Sa.getCharIndex(a), f = Sa.getPartIndex(l);
          let m;
          u !== f ? m = t : m = Sa.getCharIndex(l);
          const _ = i - d, b = m - i;
          return _ <= b ? o : r;
        }
      }
      class q2 {
        constructor(e, t, i) {
          this._renderLineOutputBrand = void 0, this.characterMapping = e, this.containsRTL = t, this.containsForeignElements = i;
        }
      }
      function qN(s, e) {
        if (s.lineContent.length === 0) {
          if (s.lineDecorations.length > 0) {
            e.appendString("<span>");
            let t = 0, i = 0, n = 0;
            for (const r of s.lineDecorations) (r.type === 1 || r.type === 2) && (e.appendString('<span class="'), e.appendString(r.className), e.appendString('"></span>'), r.type === 1 && (n |= 1, t++), r.type === 2 && (n |= 2, i++));
            e.appendString("</span>");
            const o = new Sa(1, t + i);
            return o.setColumnInfo(1, t, 0, 0), new q2(o, false, n);
          }
          return e.appendString("<span><span></span></span>"), new q2(new Sa(0, 0), false, 0);
        }
        return Eae(yae(s), e);
      }
      class Cae {
        constructor(e, t, i, n) {
          this.characterMapping = e, this.html = t, this.containsRTL = i, this.containsForeignElements = n;
        }
      }
      function Vw(s) {
        const e = new iw(1e4), t = qN(s, e);
        return new Cae(t.characterMapping, e.build(), t.containsRTL, t.containsForeignElements);
      }
      class wae {
        constructor(e, t, i, n, o, r, a, l, u, d, f, m, _, b, v, y) {
          this.fontIsMonospace = e, this.canUseHalfwidthRightwardsArrow = t, this.lineContent = i, this.len = n, this.isOverflowing = o, this.overflowingCharCount = r, this.parts = a, this.containsForeignElements = l, this.fauxIndentLength = u, this.tabSize = d, this.startVisibleColumn = f, this.containsRTL = m, this.spaceWidth = _, this.renderSpaceCharCode = b, this.renderWhitespace = v, this.renderControlCharacters = y;
        }
      }
      function yae(s) {
        const e = s.lineContent;
        let t, i, n;
        s.stopRenderingLineAfter !== -1 && s.stopRenderingLineAfter < e.length ? (t = true, i = e.length - s.stopRenderingLineAfter, n = s.stopRenderingLineAfter) : (t = false, i = 0, n = e.length);
        let o = Sae(e, s.containsRTL, s.lineTokens, s.fauxIndentLength, n);
        s.renderControlCharacters && !s.isBasicASCII && (o = xae(e, o)), (s.renderWhitespace === 4 || s.renderWhitespace === 1 || s.renderWhitespace === 2 && s.selectionsOnLine || s.renderWhitespace === 3 && !s.continuesWithWrappedLine) && (o = kae(s, e, n, o));
        let r = 0;
        if (s.lineDecorations.length > 0) {
          for (let a = 0, l = s.lineDecorations.length; a < l; a++) {
            const u = s.lineDecorations[a];
            u.type === 3 || u.type === 1 ? r |= 1 : u.type === 2 && (r |= 2);
          }
          o = Dae(e, n, o, s.lineDecorations);
        }
        return s.containsRTL || (o = Lae(e, o, !s.isBasicASCII || s.fontLigatures)), new wae(s.useMonospaceOptimizations, s.canUseHalfwidthRightwardsArrow, e, n, t, i, o, r, s.fauxIndentLength, s.tabSize, s.startVisibleColumn, s.containsRTL, s.spaceWidth, s.renderSpaceCharCode, s.renderWhitespace, s.renderControlCharacters);
      }
      function Sae(s, e, t, i, n) {
        const o = [];
        let r = 0;
        i > 0 && (o[r++] = new rn(i, "", 0, false));
        let a = i;
        for (let l = 0, u = t.getCount(); l < u; l++) {
          const d = t.getEndOffset(l);
          if (d <= i) continue;
          const f = t.getClassName(l);
          if (d >= n) {
            const _ = e ? Yp(s.substring(a, n)) : false;
            o[r++] = new rn(n, f, 0, _);
            break;
          }
          const m = e ? Yp(s.substring(a, d)) : false;
          o[r++] = new rn(d, f, 0, m), a = d;
        }
        return o;
      }
      function Lae(s, e, t) {
        let i = 0;
        const n = [];
        let o = 0;
        if (t) for (let r = 0, a = e.length; r < a; r++) {
          const l = e[r], u = l.endIndex;
          if (i + 50 < u) {
            const d = l.type, f = l.metadata, m = l.containsRTL;
            let _ = -1, b = i;
            for (let v = i; v < u; v++) s.charCodeAt(v) === 32 && (_ = v), _ !== -1 && v - b >= 50 && (n[o++] = new rn(_ + 1, d, f, m), b = _ + 1, _ = -1);
            b !== u && (n[o++] = new rn(u, d, f, m));
          } else n[o++] = l;
          i = u;
        }
        else for (let r = 0, a = e.length; r < a; r++) {
          const l = e[r], u = l.endIndex, d = u - i;
          if (d > 50) {
            const f = l.type, m = l.metadata, _ = l.containsRTL, b = Math.ceil(d / 50);
            for (let v = 1; v < b; v++) {
              const y = i + v * 50;
              n[o++] = new rn(y, f, m, _);
            }
            n[o++] = new rn(u, f, m, _);
          } else n[o++] = l;
          i = u;
        }
        return n;
      }
      function bF(s) {
        return s < 32 ? s !== 9 : s === 127 || s >= 8234 && s <= 8238 || s >= 8294 && s <= 8297 || s >= 8206 && s <= 8207 || s === 1564;
      }
      function xae(s, e) {
        const t = [];
        let i = new rn(0, "", 0, false), n = 0;
        for (const o of e) {
          const r = o.endIndex;
          for (; n < r; n++) {
            const a = s.charCodeAt(n);
            bF(a) && (n > i.endIndex && (i = new rn(n, o.type, o.metadata, o.containsRTL), t.push(i)), i = new rn(n + 1, "mtkcontrol", o.metadata, false), t.push(i));
          }
          n > i.endIndex && (i = new rn(r, o.type, o.metadata, o.containsRTL), t.push(i));
        }
        return t;
      }
      function kae(s, e, t, i) {
        const n = s.continuesWithWrappedLine, o = s.fauxIndentLength, r = s.tabSize, a = s.startVisibleColumn, l = s.useMonospaceOptimizations, u = s.selectionsOnLine, d = s.renderWhitespace === 1, f = s.renderWhitespace === 3, m = s.renderSpaceWidth !== s.spaceWidth, _ = [];
        let b = 0, v = 0, y = i[v].type, x = i[v].containsRTL, L = i[v].endIndex;
        const D = i.length;
        let k = false, T = qs(e), M;
        T === -1 ? (k = true, T = t, M = t) : M = qh(e);
        let I = false, R = 0, A = u && u[R], Y = a % r;
        for (let j = o; j < t; j++) {
          const ee = e.charCodeAt(j);
          A && j >= A.endOffset && (R++, A = u && u[R]);
          let K;
          if (j < T || j > M) K = true;
          else if (ee === 9) K = true;
          else if (ee === 32) if (d) if (I) K = true;
          else {
            const te = j + 1 < t ? e.charCodeAt(j + 1) : 0;
            K = te === 32 || te === 9;
          }
          else K = true;
          else K = false;
          if (K && u && (K = !!A && A.startOffset <= j && A.endOffset > j), K && f && (K = k || j > M), K && x && j >= T && j <= M && (K = false), I) {
            if (!K || !l && Y >= r) {
              if (m) {
                const te = b > 0 ? _[b - 1].endIndex : o;
                for (let H = te + 1; H <= j; H++) _[b++] = new rn(H, "mtkw", 1, false);
              } else _[b++] = new rn(j, "mtkw", 1, false);
              Y = Y % r;
            }
          } else (j === L || K && j > o) && (_[b++] = new rn(j, y, 0, x), Y = Y % r);
          for (ee === 9 ? Y = r : nu(ee) ? Y += 2 : Y++, I = K; j === L && (v++, v < D); ) y = i[v].type, x = i[v].containsRTL, L = i[v].endIndex;
        }
        let U = false;
        if (I) if (n && d) {
          const j = t > 0 ? e.charCodeAt(t - 1) : 0, ee = t > 1 ? e.charCodeAt(t - 2) : 0;
          j === 32 && ee !== 32 && ee !== 9 || (U = true);
        } else U = true;
        if (U) if (m) {
          const j = b > 0 ? _[b - 1].endIndex : o;
          for (let ee = j + 1; ee <= t; ee++) _[b++] = new rn(ee, "mtkw", 1, false);
        } else _[b++] = new rn(t, "mtkw", 1, false);
        else _[b++] = new rn(t, y, 0, x);
        return _;
      }
      function Dae(s, e, t, i) {
        i.sort(dr.compare);
        const n = vae.normalize(s, i), o = n.length;
        let r = 0;
        const a = [];
        let l = 0, u = 0;
        for (let f = 0, m = t.length; f < m; f++) {
          const _ = t[f], b = _.endIndex, v = _.type, y = _.metadata, x = _.containsRTL;
          for (; r < o && n[r].startOffset < b; ) {
            const L = n[r];
            if (L.startOffset > u && (u = L.startOffset, a[l++] = new rn(u, v, y, x)), L.endOffset + 1 <= b) u = L.endOffset + 1, a[l++] = new rn(u, v + " " + L.className, y | L.metadata, x), r++;
            else {
              u = b, a[l++] = new rn(u, v + " " + L.className, y | L.metadata, x);
              break;
            }
          }
          b > u && (u = b, a[l++] = new rn(u, v, y, x));
        }
        const d = t[t.length - 1].endIndex;
        if (r < o && n[r].startOffset === d) for (; r < o && n[r].startOffset === d; ) {
          const f = n[r];
          a[l++] = new rn(u, f.className, f.metadata, false), r++;
        }
        return a;
      }
      function Eae(s, e) {
        const t = s.fontIsMonospace, i = s.canUseHalfwidthRightwardsArrow, n = s.containsForeignElements, o = s.lineContent, r = s.len, a = s.isOverflowing, l = s.overflowingCharCount, u = s.parts, d = s.fauxIndentLength, f = s.tabSize, m = s.startVisibleColumn, _ = s.containsRTL, b = s.spaceWidth, v = s.renderSpaceCharCode, y = s.renderWhitespace, x = s.renderControlCharacters, L = new Sa(r + 1, u.length);
        let D = false, k = 0, T = m, M = 0, I = 0, R = 0;
        _ ? e.appendString('<span dir="ltr">') : e.appendString("<span>");
        for (let A = 0, Y = u.length; A < Y; A++) {
          const U = u[A], j = U.endIndex, ee = U.type, K = U.containsRTL, te = y !== 0 && U.isWhitespace(), H = te && !t && (ee === "mtkw" || !n), se = k === j && U.isPseudoAfter();
          if (M = 0, e.appendString("<span "), K && e.appendString('style="unicode-bidi:isolate" '), e.appendString('class="'), e.appendString(H ? "mtkz" : ee), e.appendASCIICharCode(34), te) {
            let de = 0;
            {
              let fe = k, W = T;
              for (; fe < j; fe++) {
                const xe = (o.charCodeAt(fe) === 9 ? f - W % f : 1) | 0;
                de += xe, fe >= d && (W += xe);
              }
            }
            for (H && (e.appendString(' style="width:'), e.appendString(String(b * de)), e.appendString('px"')), e.appendASCIICharCode(62); k < j; k++) {
              L.setColumnInfo(k + 1, A - R, M, I), R = 0;
              const fe = o.charCodeAt(k);
              let W, ne;
              if (fe === 9) {
                W = f - T % f | 0, ne = W, !i || ne > 1 ? e.appendCharCode(8594) : e.appendCharCode(65515);
                for (let xe = 2; xe <= ne; xe++) e.appendCharCode(160);
              } else W = 2, ne = 1, e.appendCharCode(v), e.appendCharCode(8204);
              M += W, I += ne, k >= d && (T += ne);
            }
          } else for (e.appendASCIICharCode(62); k < j; k++) {
            L.setColumnInfo(k + 1, A - R, M, I), R = 0;
            const de = o.charCodeAt(k);
            let fe = 1, W = 1;
            switch (de) {
              case 9:
                fe = f - T % f, W = fe;
                for (let ne = 1; ne <= fe; ne++) e.appendCharCode(160);
                break;
              case 32:
                e.appendCharCode(160);
                break;
              case 60:
                e.appendString("&lt;");
                break;
              case 62:
                e.appendString("&gt;");
                break;
              case 38:
                e.appendString("&amp;");
                break;
              case 0:
                x ? e.appendCharCode(9216) : e.appendString("&#00;");
                break;
              case 65279:
              case 8232:
              case 8233:
              case 133:
                e.appendCharCode(65533);
                break;
              default:
                nu(de) && W++, x && de < 32 ? e.appendCharCode(9216 + de) : x && de === 127 ? e.appendCharCode(9249) : x && bF(de) ? (e.appendString("[U+"), e.appendString(Tae(de)), e.appendString("]"), fe = 8, W = fe) : e.appendCharCode(de);
            }
            M += fe, I += W, k >= d && (T += W);
          }
          se ? R++ : R = 0, k >= r && !D && U.isPseudoAfter() && (D = true, L.setColumnInfo(k + 1, A, M, I)), e.appendString("</span>");
        }
        return D || L.setColumnInfo(r + 1, u.length - 1, M, I), a && (e.appendString('<span class="mtkoverflow">'), e.appendString(C("showMore", "Show more ({0})", Nae(l))), e.appendString("</span>")), e.appendString("</span>"), new q2(L, _, n);
      }
      function Tae(s) {
        return s.toString(16).toUpperCase().padStart(4, "0");
      }
      function Nae(s) {
        return s < 1024 ? C("overflow.chars", "{0} chars", s) : s < 1024 * 1024 ? `${(s / 1024).toFixed(1)} KB` : `${(s / 1024 / 1024).toFixed(1)} MB`;
      }
      class x3 {
        constructor(e, t, i, n) {
          this._viewportBrand = void 0, this.top = e | 0, this.left = t | 0, this.width = i | 0, this.height = n | 0;
        }
      }
      class Iae {
        constructor(e, t) {
          this.tabSize = e, this.data = t;
        }
      }
      class KN {
        constructor(e, t, i, n, o, r, a) {
          this._viewLineDataBrand = void 0, this.content = e, this.continuesWithWrappedLine = t, this.minColumn = i, this.maxColumn = n, this.startVisibleColumn = o, this.tokens = r, this.inlineDecorations = a;
        }
      }
      class mo {
        constructor(e, t, i, n, o, r, a, l, u, d) {
          this.minColumn = e, this.maxColumn = t, this.content = i, this.continuesWithWrappedLine = n, this.isBasicASCII = mo.isBasicASCII(i, r), this.containsRTL = mo.containsRTL(i, this.isBasicASCII, o), this.tokens = a, this.inlineDecorations = l, this.tabSize = u, this.startVisibleColumn = d;
        }
        static isBasicASCII(e, t) {
          return t ? ZE(e) : true;
        }
        static containsRTL(e, t, i) {
          return !t && i ? Yp(e) : false;
        }
      }
      class Op {
        constructor(e, t, i) {
          this.range = e, this.inlineClassName = t, this.type = i;
        }
      }
      class Mae {
        constructor(e, t, i, n) {
          this.startOffset = e, this.endOffset = t, this.inlineClassName = i, this.inlineClassNameAffectsLetterSpacing = n;
        }
        toInlineDecoration(e) {
          return new Op(new z(e, this.startOffset + 1, e, this.endOffset + 1), this.inlineClassName, this.inlineClassNameAffectsLetterSpacing ? 3 : 0);
        }
      }
      class vF {
        constructor(e, t) {
          this._viewModelDecorationBrand = void 0, this.range = e, this.options = t;
        }
      }
      class y_ {
        constructor(e, t, i) {
          this.color = e, this.zIndex = t, this.data = i;
        }
        static compareByRenderingProps(e, t) {
          return e.zIndex === t.zIndex ? e.color < t.color ? -1 : e.color > t.color ? 1 : 0 : e.zIndex - t.zIndex;
        }
        static equals(e, t) {
          return e.color === t.color && e.zIndex === t.zIndex && Qi(e.data, t.data);
        }
        static equalsArr(e, t) {
          return Qi(e, t, y_.equals);
        }
      }
      function Aae(s) {
        return Array.isArray(s);
      }
      function Rae(s) {
        return !Aae(s);
      }
      function CF(s) {
        return typeof s == "string";
      }
      function k3(s) {
        return !CF(s);
      }
      function rh(s) {
        return !s;
      }
      function Hl(s, e) {
        return s.ignoreCase && e ? e.toLowerCase() : e;
      }
      function D3(s) {
        return s.replace(/[&<>'"_]/g, "-");
      }
      function Oae(s, e) {
        console.log(`${s.languageId}: ${e}`);
      }
      function ni(s, e) {
        return new Error(`${s.languageId}: ${e}`);
      }
      function Bc(s, e, t, i, n) {
        const o = /\$((\$)|(#)|(\d\d?)|[sS](\d\d?)|@(\w+))/g;
        let r = null;
        return e.replace(o, function(a, l, u, d, f, m, _, b, v) {
          return rh(u) ? rh(d) ? !rh(f) && f < i.length ? Hl(s, i[f]) : !rh(_) && s && typeof s[_] == "string" ? s[_] : (r === null && (r = n.split("."), r.unshift(n)), !rh(m) && m < r.length ? Hl(s, r[m]) : "") : Hl(s, t) : "$";
        });
      }
      function Pae(s, e, t) {
        const i = /\$[sS](\d\d?)/g;
        let n = null;
        return e.replace(i, function(o, r) {
          return n === null && (n = t.split("."), n.unshift(t)), !rh(r) && r < n.length ? Hl(s, n[r]) : "";
        });
      }
      function i0(s, e) {
        let t = e;
        for (; t && t.length > 0; ) {
          const i = s.tokenizer[t];
          if (i) return i;
          const n = t.lastIndexOf(".");
          n < 0 ? t = null : t = t.substr(0, n);
        }
        return null;
      }
      function Bae(s, e) {
        let t = e;
        for (; t && t.length > 0; ) {
          if (s.stateNames[t]) return true;
          const n = t.lastIndexOf(".");
          n < 0 ? t = null : t = t.substr(0, n);
        }
        return false;
      }
      var Fae = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      }, Vae = function(s, e) {
        return function(t, i) {
          e(t, i, s);
        };
      }, K2;
      const wF = 5;
      const _S_ = class _S_ {
        static create(e, t) {
          return this._INSTANCE.create(e, t);
        }
        constructor(e) {
          this._maxCacheDepth = e, this._entries = /* @__PURE__ */ Object.create(null);
        }
        create(e, t) {
          if (e !== null && e.depth >= this._maxCacheDepth) return new Yf(e, t);
          let i = Yf.getStackElementId(e);
          i.length > 0 && (i += "|"), i += t;
          let n = this._entries[i];
          return n || (n = new Yf(e, t), this._entries[i] = n, n);
        }
      };
      _S_._INSTANCE = new _S_(wF);
      let S_ = _S_;
      class Yf {
        constructor(e, t) {
          this.parent = e, this.state = t, this.depth = (this.parent ? this.parent.depth : 0) + 1;
        }
        static getStackElementId(e) {
          let t = "";
          for (; e !== null; ) t.length > 0 && (t += "|"), t += e.state, e = e.parent;
          return t;
        }
        static _equals(e, t) {
          for (; e !== null && t !== null; ) {
            if (e === t) return true;
            if (e.state !== t.state) return false;
            e = e.parent, t = t.parent;
          }
          return e === null && t === null;
        }
        equals(e) {
          return Yf._equals(this, e);
        }
        push(e) {
          return S_.create(this, e);
        }
        pop() {
          return this.parent;
        }
        popall() {
          let e = this;
          for (; e.parent; ) e = e.parent;
          return e;
        }
        switchTo(e) {
          return S_.create(this.parent, e);
        }
      }
      class Sf {
        constructor(e, t) {
          this.languageId = e, this.state = t;
        }
        equals(e) {
          return this.languageId === e.languageId && this.state.equals(e.state);
        }
        clone() {
          return this.state.clone() === this.state ? this : new Sf(this.languageId, this.state);
        }
      }
      const _Fc = class _Fc {
        static create(e, t) {
          return this._INSTANCE.create(e, t);
        }
        constructor(e) {
          this._maxCacheDepth = e, this._entries = /* @__PURE__ */ Object.create(null);
        }
        create(e, t) {
          if (t !== null) return new Pp(e, t);
          if (e !== null && e.depth >= this._maxCacheDepth) return new Pp(e, t);
          const i = Yf.getStackElementId(e);
          let n = this._entries[i];
          return n || (n = new Pp(e, null), this._entries[i] = n, n);
        }
      };
      _Fc._INSTANCE = new _Fc(wF);
      let Fc = _Fc;
      class Pp {
        constructor(e, t) {
          this.stack = e, this.embeddedLanguageData = t;
        }
        clone() {
          return (this.embeddedLanguageData ? this.embeddedLanguageData.clone() : null) === this.embeddedLanguageData ? this : Fc.create(this.stack, this.embeddedLanguageData);
        }
        equals(e) {
          return !(e instanceof Pp) || !this.stack.equals(e.stack) ? false : this.embeddedLanguageData === null && e.embeddedLanguageData === null ? true : this.embeddedLanguageData === null || e.embeddedLanguageData === null ? false : this.embeddedLanguageData.equals(e.embeddedLanguageData);
        }
      }
      class Wae {
        constructor() {
          this._tokens = [], this._languageId = null, this._lastTokenType = null, this._lastTokenLanguage = null;
        }
        enterLanguage(e) {
          this._languageId = e;
        }
        emit(e, t) {
          this._lastTokenType === t && this._lastTokenLanguage === this._languageId || (this._lastTokenType = t, this._lastTokenLanguage = this._languageId, this._tokens.push(new Gp(e, t, this._languageId)));
        }
        nestedLanguageTokenize(e, t, i, n) {
          const o = i.languageId, r = i.state, a = Bi.get(o);
          if (!a) return this.enterLanguage(o), this.emit(n, ""), r;
          const l = a.tokenize(e, t, r);
          if (n !== 0) for (const u of l.tokens) this._tokens.push(new Gp(u.offset + n, u.type, u.language));
          else this._tokens = this._tokens.concat(l.tokens);
          return this._lastTokenType = null, this._lastTokenLanguage = null, this._languageId = null, l.endState;
        }
        finalize(e) {
          return new $E(this._tokens, e);
        }
      }
      class hC {
        constructor(e, t) {
          this._languageService = e, this._theme = t, this._prependTokens = null, this._tokens = [], this._currentLanguageId = 0, this._lastTokenMetadata = 0;
        }
        enterLanguage(e) {
          this._currentLanguageId = this._languageService.languageIdCodec.encodeLanguageId(e);
        }
        emit(e, t) {
          const i = this._theme.match(this._currentLanguageId, t) | 1024;
          this._lastTokenMetadata !== i && (this._lastTokenMetadata = i, this._tokens.push(e), this._tokens.push(i));
        }
        static _merge(e, t, i) {
          const n = e !== null ? e.length : 0, o = t.length, r = i !== null ? i.length : 0;
          if (n === 0 && o === 0 && r === 0) return new Uint32Array(0);
          if (n === 0 && o === 0) return i;
          if (o === 0 && r === 0) return e;
          const a = new Uint32Array(n + o + r);
          e !== null && a.set(e);
          for (let l = 0; l < o; l++) a[n + l] = t[l];
          return i !== null && a.set(i, n + o), a;
        }
        nestedLanguageTokenize(e, t, i, n) {
          const o = i.languageId, r = i.state, a = Bi.get(o);
          if (!a) return this.enterLanguage(o), this.emit(n, ""), r;
          const l = a.tokenizeEncoded(e, t, r);
          if (n !== 0) for (let u = 0, d = l.tokens.length; u < d; u += 2) l.tokens[u] += n;
          return this._prependTokens = hC._merge(this._prependTokens, this._tokens, l.tokens), this._tokens = [], this._currentLanguageId = 0, this._lastTokenMetadata = 0, l.endState;
        }
        finalize(e) {
          return new VC(hC._merge(this._prependTokens, this._tokens, null), e);
        }
      }
      let L_ = K2 = class extends he {
        constructor(e, t, i, n, o) {
          super(), this._configurationService = o, this._languageService = e, this._standaloneThemeService = t, this._languageId = i, this._lexer = n, this._embeddedLanguages = /* @__PURE__ */ Object.create(null), this.embeddedLoaded = Promise.resolve(void 0);
          let r = false;
          this._register(Bi.onDidChange((a) => {
            if (r) return;
            let l = false;
            for (let u = 0, d = a.changedLanguages.length; u < d; u++) {
              const f = a.changedLanguages[u];
              if (this._embeddedLanguages[f]) {
                l = true;
                break;
              }
            }
            l && (r = true, Bi.handleChange([
              this._languageId
            ]), r = false);
          })), this._maxTokenizationLineLength = this._configurationService.getValue("editor.maxTokenizationLineLength", {
            overrideIdentifier: this._languageId
          }), this._register(this._configurationService.onDidChangeConfiguration((a) => {
            a.affectsConfiguration("editor.maxTokenizationLineLength") && (this._maxTokenizationLineLength = this._configurationService.getValue("editor.maxTokenizationLineLength", {
              overrideIdentifier: this._languageId
            }));
          }));
        }
        getLoadStatus() {
          const e = [];
          for (const t in this._embeddedLanguages) {
            const i = Bi.get(t);
            if (i) {
              if (i instanceof K2) {
                const n = i.getLoadStatus();
                n.loaded === false && e.push(n.promise);
              }
              continue;
            }
            Bi.isResolved(t) || e.push(Bi.getOrCreate(t));
          }
          return e.length === 0 ? {
            loaded: true
          } : {
            loaded: false,
            promise: Promise.all(e).then((t) => {
            })
          };
        }
        getInitialState() {
          const e = S_.create(null, this._lexer.start);
          return Fc.create(e, null);
        }
        tokenize(e, t, i) {
          if (e.length >= this._maxTokenizationLineLength) return B6(this._languageId, i);
          const n = new Wae(), o = this._tokenize(e, t, i, n);
          return n.finalize(o);
        }
        tokenizeEncoded(e, t, i) {
          if (e.length >= this._maxTokenizationLineLength) return KT(this._languageService.languageIdCodec.encodeLanguageId(this._languageId), i);
          const n = new hC(this._languageService, this._standaloneThemeService.getColorTheme().tokenTheme), o = this._tokenize(e, t, i, n);
          return n.finalize(o);
        }
        _tokenize(e, t, i, n) {
          return i.embeddedLanguageData ? this._nestedTokenize(e, t, i, 0, n) : this._myTokenize(e, t, i, 0, n);
        }
        _findLeavingNestedLanguageOffset(e, t) {
          let i = this._lexer.tokenizer[t.stack.state];
          if (!i && (i = i0(this._lexer, t.stack.state), !i)) throw ni(this._lexer, "tokenizer state is not defined: " + t.stack.state);
          let n = -1, o = false;
          for (const r of i) {
            if (!k3(r.action) || r.action.nextEmbedded !== "@pop") continue;
            o = true;
            let a = r.resolveRegex(t.stack.state);
            const l = a.source;
            if (l.substr(0, 4) === "^(?:" && l.substr(l.length - 1, 1) === ")") {
              const d = (a.ignoreCase ? "i" : "") + (a.unicode ? "u" : "");
              a = new RegExp(l.substr(4, l.length - 5), d);
            }
            const u = e.search(a);
            u === -1 || u !== 0 && r.matchOnlyAtLineStart || (n === -1 || u < n) && (n = u);
          }
          if (!o) throw ni(this._lexer, 'no rule containing nextEmbedded: "@pop" in tokenizer embedded state: ' + t.stack.state);
          return n;
        }
        _nestedTokenize(e, t, i, n, o) {
          const r = this._findLeavingNestedLanguageOffset(e, i);
          if (r === -1) {
            const u = o.nestedLanguageTokenize(e, t, i.embeddedLanguageData, n);
            return Fc.create(i.stack, new Sf(i.embeddedLanguageData.languageId, u));
          }
          const a = e.substring(0, r);
          a.length > 0 && o.nestedLanguageTokenize(a, false, i.embeddedLanguageData, n);
          const l = e.substring(r);
          return this._myTokenize(l, t, i, n + r, o);
        }
        _safeRuleName(e) {
          return e ? e.name : "(unknown)";
        }
        _myTokenize(e, t, i, n, o) {
          o.enterLanguage(this._languageId);
          const r = e.length, a = t && this._lexer.includeLF ? e + `
` : e, l = a.length;
          let u = i.embeddedLanguageData, d = i.stack, f = 0, m = null, _ = true;
          for (; _ || f < l; ) {
            const b = f, v = d.depth, y = m ? m.groups.length : 0, x = d.state;
            let L = null, D = null, k = null, T = null, M = null;
            if (m) {
              L = m.matches;
              const A = m.groups.shift();
              D = A.matched, k = A.action, T = m.rule, m.groups.length === 0 && (m = null);
            } else {
              if (!_ && f >= l) break;
              _ = false;
              let A = this._lexer.tokenizer[x];
              if (!A && (A = i0(this._lexer, x), !A)) throw ni(this._lexer, "tokenizer state is not defined: " + x);
              const Y = a.substr(f);
              for (const U of A) if ((f === 0 || !U.matchOnlyAtLineStart) && (L = Y.match(U.resolveRegex(x)), L)) {
                D = L[0], k = U.action;
                break;
              }
            }
            if (L || (L = [
              ""
            ], D = ""), k || (f < l && (L = [
              a.charAt(f)
            ], D = L[0]), k = this._lexer.defaultToken), D === null) break;
            for (f += D.length; Rae(k) && k3(k) && k.test; ) k = k.test(D, L, x, f === l);
            let I = null;
            if (typeof k == "string" || Array.isArray(k)) I = k;
            else if (k.group) I = k.group;
            else if (k.token !== null && k.token !== void 0) {
              if (k.tokenSubst ? I = Bc(this._lexer, k.token, D, L, x) : I = k.token, k.nextEmbedded) if (k.nextEmbedded === "@pop") {
                if (!u) throw ni(this._lexer, "cannot pop embedded language if not inside one");
                u = null;
              } else {
                if (u) throw ni(this._lexer, "cannot enter embedded language from within an embedded language");
                M = Bc(this._lexer, k.nextEmbedded, D, L, x);
              }
              if (k.goBack && (f = Math.max(0, f - k.goBack)), k.switchTo && typeof k.switchTo == "string") {
                let A = Bc(this._lexer, k.switchTo, D, L, x);
                if (A[0] === "@" && (A = A.substr(1)), i0(this._lexer, A)) d = d.switchTo(A);
                else throw ni(this._lexer, "trying to switch to a state '" + A + "' that is undefined in rule: " + this._safeRuleName(T));
              } else {
                if (k.transform && typeof k.transform == "function") throw ni(this._lexer, "action.transform not supported");
                if (k.next) if (k.next === "@push") {
                  if (d.depth >= this._lexer.maxStack) throw ni(this._lexer, "maximum tokenizer stack size reached: [" + d.state + "," + d.parent.state + ",...]");
                  d = d.push(x);
                } else if (k.next === "@pop") {
                  if (d.depth <= 1) throw ni(this._lexer, "trying to pop an empty stack in rule: " + this._safeRuleName(T));
                  d = d.pop();
                } else if (k.next === "@popall") d = d.popall();
                else {
                  let A = Bc(this._lexer, k.next, D, L, x);
                  if (A[0] === "@" && (A = A.substr(1)), i0(this._lexer, A)) d = d.push(A);
                  else throw ni(this._lexer, "trying to set a next state '" + A + "' that is undefined in rule: " + this._safeRuleName(T));
                }
              }
              k.log && typeof k.log == "string" && Oae(this._lexer, this._lexer.languageId + ": " + Bc(this._lexer, k.log, D, L, x));
            }
            if (I === null) throw ni(this._lexer, "lexer rule has no well-defined action in rule: " + this._safeRuleName(T));
            const R = (A) => {
              const Y = this._languageService.getLanguageIdByLanguageName(A) || this._languageService.getLanguageIdByMimeType(A) || A, U = this._getNestedEmbeddedLanguageData(Y);
              if (f < l) {
                const j = e.substr(f);
                return this._nestedTokenize(j, t, Fc.create(d, U), n + f, o);
              } else return Fc.create(d, U);
            };
            if (Array.isArray(I)) {
              if (m && m.groups.length > 0) throw ni(this._lexer, "groups cannot be nested: " + this._safeRuleName(T));
              if (L.length !== I.length + 1) throw ni(this._lexer, "matched number of groups does not match the number of actions in rule: " + this._safeRuleName(T));
              let A = 0;
              for (let Y = 1; Y < L.length; Y++) A += L[Y].length;
              if (A !== D.length) throw ni(this._lexer, "with groups, all characters should be matched in consecutive groups in rule: " + this._safeRuleName(T));
              m = {
                rule: T,
                matches: L,
                groups: []
              };
              for (let Y = 0; Y < I.length; Y++) m.groups[Y] = {
                action: I[Y],
                matched: L[Y + 1]
              };
              f -= D.length;
              continue;
            } else {
              if (I === "@rematch" && (f -= D.length, D = "", L = null, I = "", M !== null)) return R(M);
              if (D.length === 0) {
                if (l === 0 || v !== d.depth || x !== d.state || (m ? m.groups.length : 0) !== y) continue;
                throw ni(this._lexer, "no progress in tokenizer in rule: " + this._safeRuleName(T));
              }
              let A = null;
              if (CF(I) && I.indexOf("@brackets") === 0) {
                const Y = I.substr(9), U = Hae(this._lexer, D);
                if (!U) throw ni(this._lexer, "@brackets token returned but no bracket defined as: " + D);
                A = D3(U.token + Y);
              } else {
                const Y = I === "" ? "" : I + this._lexer.tokenPostfix;
                A = D3(Y);
              }
              b < r && o.emit(b + n, A);
            }
            if (M !== null) return R(M);
          }
          return Fc.create(d, u);
        }
        _getNestedEmbeddedLanguageData(e) {
          if (!this._languageService.isRegisteredLanguageId(e)) return new Sf(e, a_);
          e !== this._languageId && (this._languageService.requestBasicLanguageFeatures(e), Bi.getOrCreate(e), this._embeddedLanguages[e] = true);
          const t = Bi.get(e);
          return t ? new Sf(e, t.getInitialState()) : new Sf(e, a_);
        }
      };
      L_ = K2 = Fae([
        Vae(4, Si)
      ], L_);
      function Hae(s, e) {
        if (!e) return null;
        e = Hl(s, e);
        const t = s.brackets;
        for (const i of t) {
          if (i.open === e) return {
            token: i.token,
            bracketType: 1
          };
          if (i.close === e) return {
            token: i.token,
            bracketType: -1
          };
        }
        return null;
      }
      const zae = Xh("standaloneColorizer", {
        createHTML: (s) => s
      });
      class jN {
        static colorizeElement(e, t, i, n) {
          n = n || {};
          const o = n.theme || "vs", r = n.mimeType || i.getAttribute("lang") || i.getAttribute("data-lang");
          if (!r) return console.error("Mode not detected"), Promise.resolve();
          const a = t.getLanguageIdByMimeType(r) || r;
          e.setTheme(o);
          const l = i.firstChild ? i.firstChild.nodeValue : "";
          i.className += " " + o;
          const u = (d) => {
            const f = (zae == null ? void 0 : zae.createHTML(d)) ?? d;
            i.innerHTML = f;
          };
          return this.colorize(t, l || "", a, n).then(u, (d) => console.error(d));
        }
        static async colorize(e, t, i, n) {
          const o = e.languageIdCodec;
          let r = 4;
          n && typeof n.tabSize == "number" && (r = n.tabSize), XE(t) && (t = t.substr(1));
          const a = xg(t);
          if (!e.isRegisteredLanguageId(i)) return E3(a, r, o);
          const l = await Bi.getOrCreate(i);
          return l ? Uae(a, r, l, o) : E3(a, r, o);
        }
        static colorizeLine(e, t, i, n, o = 4) {
          const r = mo.isBasicASCII(e, t), a = mo.containsRTL(e, r, i);
          return Vw(new Ag(false, true, e, false, r, a, 0, n, [], o, 0, 0, 0, 0, -1, "none", false, false, null)).html;
        }
        static colorizeModelLine(e, t, i = 4) {
          const n = e.getLineContent(t);
          e.tokenization.forceTokenization(t);
          const r = e.tokenization.getLineTokens(t).inflate();
          return this.colorizeLine(n, e.mightContainNonBasicASCII(), e.mightContainRTL(), r, i);
        }
      }
      function Uae(s, e, t, i) {
        return new Promise((n, o) => {
          const r = () => {
            const a = $ae(s, e, t, i);
            if (t instanceof L_) {
              const l = t.getLoadStatus();
              if (l.loaded === false) {
                l.promise.then(r, o);
                return;
              }
            }
            n(a);
          };
          r();
        });
      }
      function E3(s, e, t) {
        let i = [];
        const o = new Uint32Array(2);
        o[0] = 0, o[1] = 33587200;
        for (let r = 0, a = s.length; r < a; r++) {
          const l = s[r];
          o[0] = l.length;
          const u = new Fi(o, l, t), d = mo.isBasicASCII(l, true), f = mo.containsRTL(l, d, true), m = Vw(new Ag(false, true, l, false, d, f, 0, u, [], e, 0, 0, 0, 0, -1, "none", false, false, null));
          i = i.concat(m.html), i.push("<br/>");
        }
        return i.join("");
      }
      function $ae(s, e, t, i) {
        let n = [], o = t.getInitialState();
        for (let r = 0, a = s.length; r < a; r++) {
          const l = s[r], u = t.tokenizeEncoded(l, true, o);
          Fi.convertToEndOffset(u.tokens, l.length);
          const d = new Fi(u.tokens, l, i), f = mo.isBasicASCII(l, true), m = mo.containsRTL(l, f, true), _ = Vw(new Ag(false, true, l, false, f, m, 0, d.inflate(), [], e, 0, 0, 0, 0, -1, "none", false, false, null));
          n = n.concat(_.html), n.push("<br/>"), o = u.endState;
        }
        return n.join("");
      }
      var qae = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      }, Kae = function(s, e) {
        return function(t, i) {
          e(t, i, s);
        };
      };
      let dC = (_n2 = class {
        constructor(e, t) {
        }
        dispose() {
        }
      }, _n2.ID = "editor.contrib.markerDecorations", _n2);
      dC = qae([
        Kae(1, mB)
      ], dC);
      l8(dC.ID, dC, 0);
      class yF extends he {
        constructor(e, t) {
          super(), this._onDidChange = this._register(new G()), this.onDidChange = this._onDidChange.event, this._referenceDomElement = e, this._width = -1, this._height = -1, this._resizeObserver = null, this.measureReferenceDomElement(false, t);
        }
        dispose() {
          this.stopObserving(), super.dispose();
        }
        getWidth() {
          return this._width;
        }
        getHeight() {
          return this._height;
        }
        startObserving() {
          if (!this._resizeObserver && this._referenceDomElement) {
            let e = null;
            const t = () => {
              e ? this.observe({
                width: e.width,
                height: e.height
              }) : this.observe();
            };
            let i = false, n = false;
            const o = () => {
              if (i && !n) try {
                i = false, n = true, t();
              } finally {
                Gs(Oe(this._referenceDomElement), () => {
                  n = false, o();
                });
              }
            };
            this._resizeObserver = new ResizeObserver((r) => {
              r && r[0] && r[0].contentRect ? e = {
                width: r[0].contentRect.width,
                height: r[0].contentRect.height
              } : e = null, i = true, o();
            }), this._resizeObserver.observe(this._referenceDomElement);
          }
        }
        stopObserving() {
          this._resizeObserver && (this._resizeObserver.disconnect(), this._resizeObserver = null);
        }
        observe(e) {
          this.measureReferenceDomElement(true, e);
        }
        measureReferenceDomElement(e, t) {
          let i = 0, n = 0;
          t ? (i = t.width, n = t.height) : this._referenceDomElement && (i = this._referenceDomElement.clientWidth, n = this._referenceDomElement.clientHeight), i = Math.max(5, i), n = Math.max(5, n), (this._width !== i || this._height !== n) && (this._width = i, this._height = n, e && this._onDidChange.fire());
        }
      }
      const _Dh = class _Dh {
        constructor(e, t) {
          this.key = e, this.migrate = t;
        }
        apply(e) {
          const t = _Dh._read(e, this.key), i = (o) => _Dh._read(e, o), n = (o, r) => _Dh._write(e, o, r);
          this.migrate(t, i, n);
        }
        static _read(e, t) {
          if (typeof e > "u") return;
          const i = t.indexOf(".");
          if (i >= 0) {
            const n = t.substring(0, i);
            return this._read(e[n], t.substring(i + 1));
          }
          return e[t];
        }
        static _write(e, t, i) {
          const n = t.indexOf(".");
          if (n >= 0) {
            const o = t.substring(0, n);
            e[o] = e[o] || {}, this._write(e[o], t.substring(n + 1), i);
            return;
          }
          e[t] = i;
        }
      };
      _Dh.items = [];
      let Dh = _Dh;
      function ia(s, e) {
        Dh.items.push(new Dh(s, e));
      }
      function Ys(s, e) {
        ia(s, (t, i, n) => {
          if (typeof t < "u") {
            for (const [o, r] of e) if (t === o) {
              n(s, r);
              return;
            }
          }
        });
      }
      function jae(s) {
        Dh.items.forEach((e) => e.apply(s));
      }
      Ys("wordWrap", [
        [
          true,
          "on"
        ],
        [
          false,
          "off"
        ]
      ]);
      Ys("lineNumbers", [
        [
          true,
          "on"
        ],
        [
          false,
          "off"
        ]
      ]);
      Ys("cursorBlinking", [
        [
          "visible",
          "solid"
        ]
      ]);
      Ys("renderWhitespace", [
        [
          true,
          "boundary"
        ],
        [
          false,
          "none"
        ]
      ]);
      Ys("renderLineHighlight", [
        [
          true,
          "line"
        ],
        [
          false,
          "none"
        ]
      ]);
      Ys("acceptSuggestionOnEnter", [
        [
          true,
          "on"
        ],
        [
          false,
          "off"
        ]
      ]);
      Ys("tabCompletion", [
        [
          false,
          "off"
        ],
        [
          true,
          "onlySnippets"
        ]
      ]);
      Ys("hover", [
        [
          true,
          {
            enabled: true
          }
        ],
        [
          false,
          {
            enabled: false
          }
        ]
      ]);
      Ys("parameterHints", [
        [
          true,
          {
            enabled: true
          }
        ],
        [
          false,
          {
            enabled: false
          }
        ]
      ]);
      Ys("autoIndent", [
        [
          false,
          "advanced"
        ],
        [
          true,
          "full"
        ]
      ]);
      Ys("matchBrackets", [
        [
          true,
          "always"
        ],
        [
          false,
          "never"
        ]
      ]);
      Ys("renderFinalNewline", [
        [
          true,
          "on"
        ],
        [
          false,
          "off"
        ]
      ]);
      Ys("cursorSmoothCaretAnimation", [
        [
          true,
          "on"
        ],
        [
          false,
          "off"
        ]
      ]);
      Ys("occurrencesHighlight", [
        [
          true,
          "singleFile"
        ],
        [
          false,
          "off"
        ]
      ]);
      Ys("wordBasedSuggestions", [
        [
          true,
          "matchingDocuments"
        ],
        [
          false,
          "off"
        ]
      ]);
      ia("autoClosingBrackets", (s, e, t) => {
        s === false && (t("autoClosingBrackets", "never"), typeof e("autoClosingQuotes") > "u" && t("autoClosingQuotes", "never"), typeof e("autoSurround") > "u" && t("autoSurround", "never"));
      });
      ia("renderIndentGuides", (s, e, t) => {
        typeof s < "u" && (t("renderIndentGuides", void 0), typeof e("guides.indentation") > "u" && t("guides.indentation", !!s));
      });
      ia("highlightActiveIndentGuide", (s, e, t) => {
        typeof s < "u" && (t("highlightActiveIndentGuide", void 0), typeof e("guides.highlightActiveIndentation") > "u" && t("guides.highlightActiveIndentation", !!s));
      });
      const Gae = {
        method: "showMethods",
        function: "showFunctions",
        constructor: "showConstructors",
        deprecated: "showDeprecated",
        field: "showFields",
        variable: "showVariables",
        class: "showClasses",
        struct: "showStructs",
        interface: "showInterfaces",
        module: "showModules",
        property: "showProperties",
        event: "showEvents",
        operator: "showOperators",
        unit: "showUnits",
        value: "showValues",
        constant: "showConstants",
        enum: "showEnums",
        enumMember: "showEnumMembers",
        keyword: "showKeywords",
        text: "showWords",
        color: "showColors",
        file: "showFiles",
        reference: "showReferences",
        folder: "showFolders",
        typeParameter: "showTypeParameters",
        snippet: "showSnippets"
      };
      ia("suggest.filteredTypes", (s, e, t) => {
        if (s && typeof s == "object") {
          for (const i of Object.entries(Gae)) s[i[0]] === false && typeof e(`suggest.${i[1]}`) > "u" && t(`suggest.${i[1]}`, false);
          t("suggest.filteredTypes", void 0);
        }
      });
      ia("quickSuggestions", (s, e, t) => {
        if (typeof s == "boolean") {
          const i = s ? "on" : "off";
          t("quickSuggestions", {
            comments: i,
            strings: i,
            other: i
          });
        }
      });
      ia("experimental.stickyScroll.enabled", (s, e, t) => {
        typeof s == "boolean" && (t("experimental.stickyScroll.enabled", void 0), typeof e("stickyScroll.enabled") > "u" && t("stickyScroll.enabled", s));
      });
      ia("experimental.stickyScroll.maxLineCount", (s, e, t) => {
        typeof s == "number" && (t("experimental.stickyScroll.maxLineCount", void 0), typeof e("stickyScroll.maxLineCount") > "u" && t("stickyScroll.maxLineCount", s));
      });
      ia("codeActionsOnSave", (s, e, t) => {
        if (s && typeof s == "object") {
          let i = false;
          const n = {};
          for (const o of Object.entries(s)) typeof o[1] == "boolean" ? (i = true, n[o[0]] = o[1] ? "explicit" : "never") : n[o[0]] = o[1];
          i && t("codeActionsOnSave", n);
        }
      });
      ia("codeActionWidget.includeNearbyQuickfixes", (s, e, t) => {
        typeof s == "boolean" && (t("codeActionWidget.includeNearbyQuickfixes", void 0), typeof e("codeActionWidget.includeNearbyQuickFixes") > "u" && t("codeActionWidget.includeNearbyQuickFixes", s));
      });
      ia("lightbulb.enabled", (s, e, t) => {
        typeof s == "boolean" && t("lightbulb.enabled", s ? void 0 : "off");
      });
      class Yae {
        constructor() {
          this._tabFocus = false, this._onDidChangeTabFocus = new G(), this.onDidChangeTabFocus = this._onDidChangeTabFocus.event;
        }
        getTabFocusMode() {
          return this._tabFocus;
        }
        setTabFocusMode(e) {
          this._tabFocus = e, this._onDidChangeTabFocus.fire(this._tabFocus);
        }
      }
      const fC = new Yae();
      var Zae = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      }, Qae = function(s, e) {
        return function(t, i) {
          e(t, i, s);
        };
      };
      let j2 = class extends he {
        constructor(e, t, i, n, o) {
          super(), this._accessibilityService = o, this._onDidChange = this._register(new G()), this.onDidChange = this._onDidChange.event, this._onDidChangeFast = this._register(new G()), this.onDidChangeFast = this._onDidChangeFast.event, this._isDominatedByLongLines = false, this._viewLineCount = 1, this._lineNumbersDigitCount = 1, this._reservedHeight = 0, this._glyphMarginDecorationLaneCount = 1, this._computeOptionsMemory = new r9(), this.isSimpleWidget = e, this.contextMenuId = t, this._containerObserver = this._register(new yF(n, i.dimension)), this._targetWindowId = Oe(n).vscodeWindowId, this._rawOptions = T3(i), this._validatedOptions = Vc.validateOptions(this._rawOptions), this.options = this._computeOptions(), this.options.get(13) && this._containerObserver.startObserving(), this._register(Ic.onDidChangeZoomLevel(() => this._recomputeOptions())), this._register(fC.onDidChangeTabFocus(() => this._recomputeOptions())), this._register(this._containerObserver.onDidChange(() => this._recomputeOptions())), this._register(Gk.onDidChange(() => this._recomputeOptions())), this._register(rv.getInstance(Oe(n)).onDidChange(() => this._recomputeOptions())), this._register(this._accessibilityService.onDidChangeScreenReaderOptimized(() => this._recomputeOptions()));
        }
        _recomputeOptions() {
          const e = this._computeOptions(), t = Vc.checkEquals(this.options, e);
          t !== null && (this.options = e, this._onDidChangeFast.fire(t), this._onDidChange.fire(t));
        }
        _computeOptions() {
          const e = this._readEnvConfiguration(), t = Ch.createFromValidatedSettings(this._validatedOptions, e.pixelRatio, this.isSimpleWidget), i = this._readFontInfo(t), n = {
            memory: this._computeOptionsMemory,
            outerWidth: e.outerWidth,
            outerHeight: e.outerHeight - this._reservedHeight,
            fontInfo: i,
            extraEditorClassName: e.extraEditorClassName,
            isDominatedByLongLines: this._isDominatedByLongLines,
            viewLineCount: this._viewLineCount,
            lineNumbersDigitCount: this._lineNumbersDigitCount,
            emptySelectionClipboard: e.emptySelectionClipboard,
            pixelRatio: e.pixelRatio,
            tabFocusMode: fC.getTabFocusMode(),
            accessibilitySupport: e.accessibilitySupport,
            glyphMarginDecorationLaneCount: this._glyphMarginDecorationLaneCount
          };
          return Vc.computeOptions(this._validatedOptions, n);
        }
        _readEnvConfiguration() {
          return {
            extraEditorClassName: Jae(),
            outerWidth: this._containerObserver.getWidth(),
            outerHeight: this._containerObserver.getHeight(),
            emptySelectionClipboard: HC || pr,
            pixelRatio: rv.getInstance(rO(this._targetWindowId, true).window).value,
            accessibilitySupport: this._accessibilityService.isScreenReaderOptimized() ? 2 : this._accessibilityService.getAccessibilitySupport()
          };
        }
        _readFontInfo(e) {
          return Gk.readFontInfo(rO(this._targetWindowId, true).window, e);
        }
        getRawOptions() {
          return this._rawOptions;
        }
        updateOptions(e) {
          const t = T3(e);
          Vc.applyUpdate(this._rawOptions, t) && (this._validatedOptions = Vc.validateOptions(this._rawOptions), this._recomputeOptions());
        }
        observeContainer(e) {
          this._containerObserver.observe(e);
        }
        setIsDominatedByLongLines(e) {
          this._isDominatedByLongLines !== e && (this._isDominatedByLongLines = e, this._recomputeOptions());
        }
        setModelLineCount(e) {
          const t = Xae(e);
          this._lineNumbersDigitCount !== t && (this._lineNumbersDigitCount = t, this._recomputeOptions());
        }
        setViewLineCount(e) {
          this._viewLineCount !== e && (this._viewLineCount = e, this._recomputeOptions());
        }
        setReservedHeight(e) {
          this._reservedHeight !== e && (this._reservedHeight = e, this._recomputeOptions());
        }
        setGlyphMarginDecorationLaneCount(e) {
          this._glyphMarginDecorationLaneCount !== e && (this._glyphMarginDecorationLaneCount = e, this._recomputeOptions());
        }
      };
      j2 = Zae([
        Qae(4, ea)
      ], j2);
      function Xae(s) {
        let e = 0;
        for (; s; ) s = Math.floor(s / 10), e++;
        return e || 1;
      }
      function Jae() {
        let s = "";
        return !su && !N9 && (s += "no-user-select "), su && (s += "no-minimap-shadow ", s += "enable-user-select "), _t && (s += "mac "), s;
      }
      class ele {
        constructor() {
          this._values = [];
        }
        _read(e) {
          return this._values[e];
        }
        get(e) {
          return this._values[e];
        }
        _write(e, t) {
          this._values[e] = t;
        }
      }
      class tle {
        constructor() {
          this._values = [];
        }
        _read(e) {
          if (e >= this._values.length) throw new Error("Cannot read uninitialized value");
          return this._values[e];
        }
        get(e) {
          return this._read(e);
        }
        _write(e, t) {
          this._values[e] = t;
        }
      }
      class Vc {
        static validateOptions(e) {
          const t = new ele();
          for (const i of lf) {
            const n = i.name === "_never_" ? void 0 : e[i.name];
            t._write(i.id, i.validate(n));
          }
          return t;
        }
        static computeOptions(e, t) {
          const i = new tle();
          for (const n of lf) i._write(n.id, n.compute(t, i, e._read(n.id)));
          return i;
        }
        static _deepEquals(e, t) {
          if (typeof e != "object" || typeof t != "object" || !e || !t) return e === t;
          if (Array.isArray(e) || Array.isArray(t)) return Array.isArray(e) && Array.isArray(t) ? Qi(e, t) : false;
          if (Object.keys(e).length !== Object.keys(t).length) return false;
          for (const i in e) if (!Vc._deepEquals(e[i], t[i])) return false;
          return true;
        }
        static checkEquals(e, t) {
          const i = [];
          let n = false;
          for (const o of lf) {
            const r = !Vc._deepEquals(e._read(o.id), t._read(o.id));
            i[o.id] = r, r && (n = true);
          }
          return n ? new o9(i) : null;
        }
        static applyUpdate(e, t) {
          let i = false;
          for (const n of lf) if (t.hasOwnProperty(n.name)) {
            const o = n.applyUpdate(e[n.name], t[n.name]);
            e[n.name] = o.newValue, i = i || o.didChange;
          }
          return i;
        }
      }
      function T3(s) {
        const e = Dc(s);
        return jae(e), e;
      }
      var Kc;
      (function(s) {
        const e = {
          total: 0,
          min: Number.MAX_VALUE,
          max: 0
        }, t = {
          ...e
        }, i = {
          ...e
        }, n = {
          ...e
        };
        let o = 0;
        const r = {
          keydown: 0,
          input: 0,
          render: 0
        };
        function a() {
          x(), performance.mark("inputlatency/start"), performance.mark("keydown/start"), r.keydown = 1, queueMicrotask(l);
        }
        s.onKeyDown = a;
        function l() {
          r.keydown === 1 && (performance.mark("keydown/end"), r.keydown = 2);
        }
        function u() {
          performance.mark("input/start"), r.input = 1, y();
        }
        s.onBeforeInput = u;
        function d() {
          r.input === 0 && u(), queueMicrotask(f);
        }
        s.onInput = d;
        function f() {
          r.input === 1 && (performance.mark("input/end"), r.input = 2);
        }
        function m() {
          x();
        }
        s.onKeyUp = m;
        function _() {
          x();
        }
        s.onSelectionChange = _;
        function b() {
          r.keydown === 2 && r.input === 2 && r.render === 0 && (performance.mark("render/start"), r.render = 1, queueMicrotask(v), y());
        }
        s.onRenderStart = b;
        function v() {
          r.render === 1 && (performance.mark("render/end"), r.render = 2);
        }
        function y() {
          setTimeout(x);
        }
        function x() {
          r.keydown === 2 && r.input === 2 && r.render === 2 && (performance.mark("inputlatency/end"), performance.measure("keydown", "keydown/start", "keydown/end"), performance.measure("input", "input/start", "input/end"), performance.measure("render", "render/start", "render/end"), performance.measure("inputlatency", "inputlatency/start", "inputlatency/end"), L("keydown", e), L("input", t), L("render", i), L("inputlatency", n), o++, D());
        }
        function L(I, R) {
          const A = performance.getEntriesByName(I)[0].duration;
          R.total += A, R.min = Math.min(R.min, A), R.max = Math.max(R.max, A);
        }
        function D() {
          performance.clearMarks("keydown/start"), performance.clearMarks("keydown/end"), performance.clearMarks("input/start"), performance.clearMarks("input/end"), performance.clearMarks("render/start"), performance.clearMarks("render/end"), performance.clearMarks("inputlatency/start"), performance.clearMarks("inputlatency/end"), performance.clearMeasures("keydown"), performance.clearMeasures("input"), performance.clearMeasures("render"), performance.clearMeasures("inputlatency"), r.keydown = 0, r.input = 0, r.render = 0;
        }
        function k() {
          if (o === 0) return;
          const I = {
            keydown: T(e),
            input: T(t),
            render: T(i),
            total: T(n),
            sampleCount: o
          };
          return M(e), M(t), M(i), M(n), o = 0, I;
        }
        s.getAndClearMeasurements = k;
        function T(I) {
          return {
            average: I.total / o,
            max: I.max,
            min: I.min
          };
        }
        function M(I) {
          I.total = 0, I.min = Number.MAX_VALUE, I.max = 0;
        }
      })(Kc || (Kc = {}));
      class Ww {
        constructor(e, t) {
          this.x = e, this.y = t, this._pageCoordinatesBrand = void 0;
        }
        toClientCoordinates(e) {
          return new SF(this.x - e.scrollX, this.y - e.scrollY);
        }
      }
      class SF {
        constructor(e, t) {
          this.clientX = e, this.clientY = t, this._clientCoordinatesBrand = void 0;
        }
        toPageCoordinates(e) {
          return new Ww(this.clientX + e.scrollX, this.clientY + e.scrollY);
        }
      }
      class ile {
        constructor(e, t, i, n) {
          this.x = e, this.y = t, this.width = i, this.height = n, this._editorPagePositionBrand = void 0;
        }
      }
      class nle {
        constructor(e, t) {
          this.x = e, this.y = t, this._positionRelativeToEditorBrand = void 0;
        }
      }
      function GN(s) {
        const e = Bo(s);
        return new ile(e.left, e.top, e.width, e.height);
      }
      function YN(s, e, t) {
        const i = e.width / s.offsetWidth, n = e.height / s.offsetHeight, o = (t.x - e.x) / i, r = (t.y - e.y) / n;
        return new nle(o, r);
      }
      class cu extends Vr {
        constructor(e, t, i) {
          super(Oe(i), e), this._editorMouseEventBrand = void 0, this.isFromPointerCapture = t, this.pos = new Ww(this.posx, this.posy), this.editorPos = GN(i), this.relativePos = YN(i, this.editorPos, this.pos);
        }
      }
      class sle {
        constructor(e) {
          this._editorViewDomNode = e;
        }
        _create(e) {
          return new cu(e, false, this._editorViewDomNode);
        }
        onContextMenu(e, t) {
          return re(e, "contextmenu", (i) => {
            t(this._create(i));
          });
        }
        onMouseUp(e, t) {
          return re(e, "mouseup", (i) => {
            t(this._create(i));
          });
        }
        onMouseDown(e, t) {
          return re(e, Ce.MOUSE_DOWN, (i) => {
            t(this._create(i));
          });
        }
        onPointerDown(e, t) {
          return re(e, Ce.POINTER_DOWN, (i) => {
            t(this._create(i), i.pointerId);
          });
        }
        onMouseLeave(e, t) {
          return re(e, Ce.MOUSE_LEAVE, (i) => {
            t(this._create(i));
          });
        }
        onMouseMove(e, t) {
          return re(e, "mousemove", (i) => t(this._create(i)));
        }
      }
      class ole {
        constructor(e) {
          this._editorViewDomNode = e;
        }
        _create(e) {
          return new cu(e, false, this._editorViewDomNode);
        }
        onPointerUp(e, t) {
          return re(e, "pointerup", (i) => {
            t(this._create(i));
          });
        }
        onPointerDown(e, t) {
          return re(e, Ce.POINTER_DOWN, (i) => {
            t(this._create(i), i.pointerId);
          });
        }
        onPointerLeave(e, t) {
          return re(e, Ce.POINTER_LEAVE, (i) => {
            t(this._create(i));
          });
        }
        onPointerMove(e, t) {
          return re(e, "pointermove", (i) => t(this._create(i)));
        }
      }
      class rle extends he {
        constructor(e) {
          super(), this._editorViewDomNode = e, this._globalPointerMoveMonitor = this._register(new uw()), this._keydownListener = null;
        }
        startMonitoring(e, t, i, n, o) {
          this._keydownListener = ln(e.ownerDocument, "keydown", (r) => {
            r.toKeyCodeChord().isModifierKey() || this._globalPointerMoveMonitor.stopMonitoring(true, r.browserEvent);
          }, true), this._globalPointerMoveMonitor.startMonitoring(e, t, i, (r) => {
            n(new cu(r, true, this._editorViewDomNode));
          }, (r) => {
            this._keydownListener.dispose(), o(r);
          });
        }
        stopMonitoring() {
          this._globalPointerMoveMonitor.stopMonitoring(true);
        }
      }
      const _LF = class _LF {
        constructor(e) {
          this._editor = e, this._instanceId = ++_LF._idPool, this._counter = 0, this._rules = /* @__PURE__ */ new Map(), this._garbageCollectionScheduler = new ns(() => this.garbageCollect(), 1e3);
        }
        createClassNameRef(e) {
          const t = this.getOrCreateRule(e);
          return t.increaseRefCount(), {
            className: t.className,
            dispose: () => {
              t.decreaseRefCount(), this._garbageCollectionScheduler.schedule();
            }
          };
        }
        getOrCreateRule(e) {
          const t = this.computeUniqueKey(e);
          let i = this._rules.get(t);
          if (!i) {
            const n = this._counter++;
            i = new ale(t, `dyn-rule-${this._instanceId}-${n}`, sv(this._editor.getContainerDomNode()) ? this._editor.getContainerDomNode() : void 0, e), this._rules.set(t, i);
          }
          return i;
        }
        computeUniqueKey(e) {
          return JSON.stringify(e);
        }
        garbageCollect() {
          for (const e of this._rules.values()) e.hasReferences() || (this._rules.delete(e.key), e.dispose());
        }
      };
      _LF._idPool = 0;
      let LF = _LF;
      class ale {
        constructor(e, t, i, n) {
          this.key = e, this.className = t, this.properties = n, this._referenceCount = 0, this._styleElementDisposables = new Me(), this._styleElement = Uo(i, void 0, this._styleElementDisposables), this._styleElement.textContent = this.getCssText(this.className, this.properties);
        }
        getCssText(e, t) {
          let i = `.${e} {`;
          for (const n in t) {
            const o = t[n];
            let r;
            typeof o == "object" ? r = we(o.id) : r = o;
            const a = lle(n);
            i += `
	${a}: ${r};`;
          }
          return i += `
}`, i;
        }
        dispose() {
          this._styleElementDisposables.dispose(), this._styleElement = void 0;
        }
        increaseRefCount() {
          this._referenceCount++;
        }
        decreaseRefCount() {
          this._referenceCount--;
        }
        hasReferences() {
          return this._referenceCount > 0;
        }
      }
      function lle(s) {
        return s.replace(/(^[A-Z])/, ([e]) => e.toLowerCase()).replace(/([A-Z])/g, ([e]) => `-${e.toLowerCase()}`);
      }
      class a1 extends he {
        constructor() {
          super(), this._shouldRender = true;
        }
        shouldRender() {
          return this._shouldRender;
        }
        forceShouldRender() {
          this._shouldRender = true;
        }
        setShouldRender() {
          this._shouldRender = true;
        }
        onDidRender() {
          this._shouldRender = false;
        }
        onCompositionStart(e) {
          return false;
        }
        onCompositionEnd(e) {
          return false;
        }
        onConfigurationChanged(e) {
          return false;
        }
        onCursorStateChanged(e) {
          return false;
        }
        onDecorationsChanged(e) {
          return false;
        }
        onFlushed(e) {
          return false;
        }
        onFocusChanged(e) {
          return false;
        }
        onLanguageConfigurationChanged(e) {
          return false;
        }
        onLineMappingChanged(e) {
          return false;
        }
        onLinesChanged(e) {
          return false;
        }
        onLinesDeleted(e) {
          return false;
        }
        onLinesInserted(e) {
          return false;
        }
        onRevealRangeRequest(e) {
          return false;
        }
        onScrollChanged(e) {
          return false;
        }
        onThemeChanged(e) {
          return false;
        }
        onTokensChanged(e) {
          return false;
        }
        onTokensColorsChanged(e) {
          return false;
        }
        onZonesChanged(e) {
          return false;
        }
        handleEvents(e) {
          let t = false;
          for (let i = 0, n = e.length; i < n; i++) {
            const o = e[i];
            switch (o.type) {
              case 0:
                this.onCompositionStart(o) && (t = true);
                break;
              case 1:
                this.onCompositionEnd(o) && (t = true);
                break;
              case 2:
                this.onConfigurationChanged(o) && (t = true);
                break;
              case 3:
                this.onCursorStateChanged(o) && (t = true);
                break;
              case 4:
                this.onDecorationsChanged(o) && (t = true);
                break;
              case 5:
                this.onFlushed(o) && (t = true);
                break;
              case 6:
                this.onFocusChanged(o) && (t = true);
                break;
              case 7:
                this.onLanguageConfigurationChanged(o) && (t = true);
                break;
              case 8:
                this.onLineMappingChanged(o) && (t = true);
                break;
              case 9:
                this.onLinesChanged(o) && (t = true);
                break;
              case 10:
                this.onLinesDeleted(o) && (t = true);
                break;
              case 11:
                this.onLinesInserted(o) && (t = true);
                break;
              case 12:
                this.onRevealRangeRequest(o) && (t = true);
                break;
              case 13:
                this.onScrollChanged(o) && (t = true);
                break;
              case 15:
                this.onTokensChanged(o) && (t = true);
                break;
              case 14:
                this.onThemeChanged(o) && (t = true);
                break;
              case 16:
                this.onTokensColorsChanged(o) && (t = true);
                break;
              case 17:
                this.onZonesChanged(o) && (t = true);
                break;
              default:
                console.info("View received unknown event: "), console.info(o);
            }
          }
          t && (this._shouldRender = true);
        }
      }
      class Zs extends a1 {
        constructor(e) {
          super(), this._context = e, this._context.addEventHandler(this);
        }
        dispose() {
          this._context.removeEventHandler(this), super.dispose();
        }
      }
      class Yr {
        static write(e, t) {
          e.setAttribute("data-mprt", String(t));
        }
        static read(e) {
          const t = e.getAttribute("data-mprt");
          return t === null ? 0 : parseInt(t, 10);
        }
        static collect(e, t) {
          const i = [];
          let n = 0;
          for (; e && e !== e.ownerDocument.body && e !== t; ) e.nodeType === e.ELEMENT_NODE && (i[n++] = this.read(e)), e = e.parentElement;
          const o = new Uint8Array(n);
          for (let r = 0; r < n; r++) o[r] = i[n - r - 1];
          return o;
        }
      }
      class cle {
        constructor(e, t) {
          this._restrictedRenderingContextBrand = void 0, this._viewLayout = e, this.viewportData = t, this.scrollWidth = this._viewLayout.getScrollWidth(), this.scrollHeight = this._viewLayout.getScrollHeight(), this.visibleRange = this.viewportData.visibleRange, this.bigNumbersDelta = this.viewportData.bigNumbersDelta;
          const i = this._viewLayout.getCurrentViewport();
          this.scrollTop = i.top, this.scrollLeft = i.left, this.viewportWidth = i.width, this.viewportHeight = i.height;
        }
        getScrolledTopFromAbsoluteTop(e) {
          return e - this.scrollTop;
        }
        getVerticalOffsetForLineNumber(e, t) {
          return this._viewLayout.getVerticalOffsetForLineNumber(e, t);
        }
        getVerticalOffsetAfterLineNumber(e, t) {
          return this._viewLayout.getVerticalOffsetAfterLineNumber(e, t);
        }
        getDecorationsInViewport() {
          return this.viewportData.getDecorationsInViewport();
        }
      }
      class ule extends cle {
        constructor(e, t, i) {
          super(e, t), this._renderingContextBrand = void 0, this._viewLines = i;
        }
        linesVisibleRangesForRange(e, t) {
          return this._viewLines.linesVisibleRangesForRange(e, t);
        }
        visibleRangeForPosition(e) {
          return this._viewLines.visibleRangeForPosition(e);
        }
      }
      class hle {
        constructor(e, t, i, n) {
          this.outsideRenderedLine = e, this.lineNumber = t, this.ranges = i, this.continuesOnNextLine = n;
        }
      }
      class Hw {
        static from(e) {
          const t = new Array(e.length);
          for (let i = 0, n = e.length; i < n; i++) {
            const o = e[i];
            t[i] = new Hw(o.left, o.width);
          }
          return t;
        }
        constructor(e, t) {
          this._horizontalRangeBrand = void 0, this.left = Math.round(e), this.width = Math.round(t);
        }
        toString() {
          return `[${this.left},${this.width}]`;
        }
      }
      class Eh {
        constructor(e, t) {
          this._floatHorizontalRangeBrand = void 0, this.left = e, this.width = t;
        }
        toString() {
          return `[${this.left},${this.width}]`;
        }
        static compare(e, t) {
          return e.left - t.left;
        }
      }
      class dle {
        constructor(e, t) {
          this.outsideRenderedLine = e, this.originalLeft = t, this.left = Math.round(this.originalLeft);
        }
      }
      class N3 {
        constructor(e, t) {
          this.outsideRenderedLine = e, this.ranges = t;
        }
      }
      class B0 {
        static _createRange() {
          return this._handyReadyRange || (this._handyReadyRange = document.createRange()), this._handyReadyRange;
        }
        static _detachRange(e, t) {
          e.selectNodeContents(t);
        }
        static _readClientRects(e, t, i, n, o) {
          const r = this._createRange();
          try {
            return r.setStart(e, t), r.setEnd(i, n), r.getClientRects();
          } catch {
            return null;
          } finally {
            this._detachRange(r, o);
          }
        }
        static _mergeAdjacentRanges(e) {
          if (e.length === 1) return e;
          e.sort(Eh.compare);
          const t = [];
          let i = 0, n = e[0];
          for (let o = 1, r = e.length; o < r; o++) {
            const a = e[o];
            n.left + n.width + 0.9 >= a.left ? n.width = Math.max(n.width, a.left + a.width - n.left) : (t[i++] = n, n = a);
          }
          return t[i++] = n, t;
        }
        static _createHorizontalRangesFromClientRects(e, t, i) {
          if (!e || e.length === 0) return null;
          const n = [];
          for (let o = 0, r = e.length; o < r; o++) {
            const a = e[o];
            n[o] = new Eh(Math.max(0, (a.left - t) / i), a.width / i);
          }
          return this._mergeAdjacentRanges(n);
        }
        static readHorizontalRanges(e, t, i, n, o, r) {
          const l = e.children.length - 1;
          if (0 > l) return null;
          if (t = Math.min(l, Math.max(0, t)), n = Math.min(l, Math.max(0, n)), t === n && i === o && i === 0 && !e.children[t].firstChild) {
            const m = e.children[t].getClientRects();
            return r.markDidDomLayout(), this._createHorizontalRangesFromClientRects(m, r.clientRectDeltaLeft, r.clientRectScale);
          }
          t !== n && n > 0 && o === 0 && (n--, o = 1073741824);
          let u = e.children[t].firstChild, d = e.children[n].firstChild;
          if ((!u || !d) && (!u && i === 0 && t > 0 && (u = e.children[t - 1].firstChild, i = 1073741824), !d && o === 0 && n > 0 && (d = e.children[n - 1].firstChild, o = 1073741824)), !u || !d) return null;
          i = Math.min(u.textContent.length, Math.max(0, i)), o = Math.min(d.textContent.length, Math.max(0, o));
          const f = this._readClientRects(u, i, d, o, r.endNode);
          return r.markDidDomLayout(), this._createHorizontalRangesFromClientRects(f, r.clientRectDeltaLeft, r.clientRectScale);
        }
      }
      const fle = /* @__PURE__ */ function() {
        return j0 ? true : !(Is || pr || su);
      }();
      let Zf = true;
      class I3 {
        constructor(e, t) {
          this.themeType = t;
          const i = e.options, n = i.get(50);
          i.get(38) === "off" ? this.renderWhitespace = i.get(100) : this.renderWhitespace = "none", this.renderControlCharacters = i.get(95), this.spaceWidth = n.spaceWidth, this.middotWidth = n.middotWidth, this.wsmiddotWidth = n.wsmiddotWidth, this.useMonospaceOptimizations = n.isMonospace && !i.get(33), this.canUseHalfwidthRightwardsArrow = n.canUseHalfwidthRightwardsArrow, this.lineHeight = i.get(67), this.stopRenderingLineAfter = i.get(118), this.fontLigatures = i.get(51);
        }
        equals(e) {
          return this.themeType === e.themeType && this.renderWhitespace === e.renderWhitespace && this.renderControlCharacters === e.renderControlCharacters && this.spaceWidth === e.spaceWidth && this.middotWidth === e.middotWidth && this.wsmiddotWidth === e.wsmiddotWidth && this.useMonospaceOptimizations === e.useMonospaceOptimizations && this.canUseHalfwidthRightwardsArrow === e.canUseHalfwidthRightwardsArrow && this.lineHeight === e.lineHeight && this.stopRenderingLineAfter === e.stopRenderingLineAfter && this.fontLigatures === e.fontLigatures;
        }
      }
      const _Tl = class _Tl {
        constructor(e) {
          this._options = e, this._isMaybeInvalid = true, this._renderedViewLine = null;
        }
        getDomNode() {
          return this._renderedViewLine && this._renderedViewLine.domNode ? this._renderedViewLine.domNode.domNode : null;
        }
        setDomNode(e) {
          if (this._renderedViewLine) this._renderedViewLine.domNode = St(e);
          else throw new Error("I have no rendered view line to set the dom node to...");
        }
        onContentChanged() {
          this._isMaybeInvalid = true;
        }
        onTokensChanged() {
          this._isMaybeInvalid = true;
        }
        onDecorationsChanged() {
          this._isMaybeInvalid = true;
        }
        onOptionsChanged(e) {
          this._isMaybeInvalid = true, this._options = e;
        }
        onSelectionChanged() {
          return Bf(this._options.themeType) || this._options.renderWhitespace === "selection" ? (this._isMaybeInvalid = true, true) : false;
        }
        renderLine(e, t, i, n, o) {
          if (this._isMaybeInvalid === false) return false;
          this._isMaybeInvalid = false;
          const r = n.getViewLineRenderingData(e), a = this._options, l = dr.filter(r.inlineDecorations, e, r.minColumn, r.maxColumn);
          let u = null;
          if (Bf(a.themeType) || this._options.renderWhitespace === "selection") {
            const _ = n.selections;
            for (const b of _) {
              if (b.endLineNumber < e || b.startLineNumber > e) continue;
              const v = b.startLineNumber === e ? b.startColumn : r.minColumn, y = b.endLineNumber === e ? b.endColumn : r.maxColumn;
              v < y && (Bf(a.themeType) && l.push(new dr(v, y, "inline-selected-text", 0)), this._options.renderWhitespace === "selection" && (u || (u = []), u.push(new pF(v - 1, y - 1))));
            }
          }
          const d = new Ag(a.useMonospaceOptimizations, a.canUseHalfwidthRightwardsArrow, r.content, r.continuesWithWrappedLine, r.isBasicASCII, r.containsRTL, r.minColumn - 1, r.tokens, l, r.tabSize, r.startVisibleColumn, a.spaceWidth, a.middotWidth, a.wsmiddotWidth, a.stopRenderingLineAfter, a.renderWhitespace, a.renderControlCharacters, a.fontLigatures !== Fr.OFF, u);
          if (this._renderedViewLine && this._renderedViewLine.input.equals(d)) return false;
          o.appendString('<div style="top:'), o.appendString(String(t)), o.appendString("px;height:"), o.appendString(String(i)), o.appendString('px;" class="'), o.appendString(_Tl.CLASS_NAME), o.appendString('">');
          const f = qN(d, o);
          o.appendString("</div>");
          let m = null;
          return Zf && fle && r.isBasicASCII && a.useMonospaceOptimizations && f.containsForeignElements === 0 && (m = new n0(this._renderedViewLine ? this._renderedViewLine.domNode : null, d, f.characterMapping)), m || (m = kF(this._renderedViewLine ? this._renderedViewLine.domNode : null, d, f.characterMapping, f.containsRTL, f.containsForeignElements)), this._renderedViewLine = m, true;
        }
        layoutLine(e, t, i) {
          this._renderedViewLine && this._renderedViewLine.domNode && (this._renderedViewLine.domNode.setTop(t), this._renderedViewLine.domNode.setHeight(i));
        }
        getWidth(e) {
          return this._renderedViewLine ? this._renderedViewLine.getWidth(e) : 0;
        }
        getWidthIsFast() {
          return this._renderedViewLine ? this._renderedViewLine.getWidthIsFast() : true;
        }
        needsMonospaceFontCheck() {
          return this._renderedViewLine ? this._renderedViewLine instanceof n0 : false;
        }
        monospaceAssumptionsAreValid() {
          return this._renderedViewLine && this._renderedViewLine instanceof n0 ? this._renderedViewLine.monospaceAssumptionsAreValid() : Zf;
        }
        onMonospaceAssumptionsInvalidated() {
          this._renderedViewLine && this._renderedViewLine instanceof n0 && (this._renderedViewLine = this._renderedViewLine.toSlowRenderedLine());
        }
        getVisibleRangesForRange(e, t, i, n) {
          if (!this._renderedViewLine) return null;
          t = Math.min(this._renderedViewLine.input.lineContent.length + 1, Math.max(1, t)), i = Math.min(this._renderedViewLine.input.lineContent.length + 1, Math.max(1, i));
          const o = this._renderedViewLine.input.stopRenderingLineAfter;
          if (o !== -1 && t > o + 1 && i > o + 1) return new N3(true, [
            new Eh(this.getWidth(n), 0)
          ]);
          o !== -1 && t > o + 1 && (t = o + 1), o !== -1 && i > o + 1 && (i = o + 1);
          const r = this._renderedViewLine.getVisibleRangesForRange(e, t, i, n);
          return r && r.length > 0 ? new N3(false, r) : null;
        }
        getColumnOfNodeOffset(e, t) {
          return this._renderedViewLine ? this._renderedViewLine.getColumnOfNodeOffset(e, t) : 1;
        }
      };
      _Tl.CLASS_NAME = "view-line";
      let Tl = _Tl;
      class n0 {
        constructor(e, t, i) {
          this._cachedWidth = -1, this.domNode = e, this.input = t;
          const n = Math.floor(t.lineContent.length / 300);
          if (n > 0) {
            this._keyColumnPixelOffsetCache = new Float32Array(n);
            for (let o = 0; o < n; o++) this._keyColumnPixelOffsetCache[o] = -1;
          } else this._keyColumnPixelOffsetCache = null;
          this._characterMapping = i, this._charWidth = t.spaceWidth;
        }
        getWidth(e) {
          if (!this.domNode || this.input.lineContent.length < 300) {
            const t = this._characterMapping.getHorizontalOffset(this._characterMapping.length);
            return Math.round(this._charWidth * t);
          }
          return this._cachedWidth === -1 && (this._cachedWidth = this._getReadingTarget(this.domNode).offsetWidth, e == null ? void 0 : e.markDidDomLayout()), this._cachedWidth;
        }
        getWidthIsFast() {
          return this.input.lineContent.length < 300 || this._cachedWidth !== -1;
        }
        monospaceAssumptionsAreValid() {
          if (!this.domNode) return Zf;
          if (this.input.lineContent.length < 300) {
            const e = this.getWidth(null), t = this.domNode.domNode.firstChild.offsetWidth;
            Math.abs(e - t) >= 2 && (console.warn("monospace assumptions have been violated, therefore disabling monospace optimizations!"), Zf = false);
          }
          return Zf;
        }
        toSlowRenderedLine() {
          return kF(this.domNode, this.input, this._characterMapping, false, 0);
        }
        getVisibleRangesForRange(e, t, i, n) {
          const o = this._getColumnPixelOffset(e, t, n), r = this._getColumnPixelOffset(e, i, n);
          return [
            new Eh(o, r - o)
          ];
        }
        _getColumnPixelOffset(e, t, i) {
          if (t <= 300) {
            const u = this._characterMapping.getHorizontalOffset(t);
            return this._charWidth * u;
          }
          const n = Math.floor((t - 1) / 300) - 1, o = (n + 1) * 300 + 1;
          let r = -1;
          if (this._keyColumnPixelOffsetCache && (r = this._keyColumnPixelOffsetCache[n], r === -1 && (r = this._actualReadPixelOffset(e, o, i), this._keyColumnPixelOffsetCache[n] = r)), r === -1) {
            const u = this._characterMapping.getHorizontalOffset(t);
            return this._charWidth * u;
          }
          const a = this._characterMapping.getHorizontalOffset(o), l = this._characterMapping.getHorizontalOffset(t);
          return r + this._charWidth * (l - a);
        }
        _getReadingTarget(e) {
          return e.domNode.firstChild;
        }
        _actualReadPixelOffset(e, t, i) {
          if (!this.domNode) return -1;
          const n = this._characterMapping.getDomPosition(t), o = B0.readHorizontalRanges(this._getReadingTarget(this.domNode), n.partIndex, n.charIndex, n.partIndex, n.charIndex, i);
          return !o || o.length === 0 ? -1 : o[0].left;
        }
        getColumnOfNodeOffset(e, t) {
          return DF(this._characterMapping, e, t);
        }
      }
      class xF {
        constructor(e, t, i, n, o) {
          if (this.domNode = e, this.input = t, this._characterMapping = i, this._isWhitespaceOnly = /^\s*$/.test(t.lineContent), this._containsForeignElements = o, this._cachedWidth = -1, this._pixelOffsetCache = null, !n || this._characterMapping.length === 0) {
            this._pixelOffsetCache = new Float32Array(Math.max(2, this._characterMapping.length + 1));
            for (let r = 0, a = this._characterMapping.length; r <= a; r++) this._pixelOffsetCache[r] = -1;
          }
        }
        _getReadingTarget(e) {
          return e.domNode.firstChild;
        }
        getWidth(e) {
          return this.domNode ? (this._cachedWidth === -1 && (this._cachedWidth = this._getReadingTarget(this.domNode).offsetWidth, e == null ? void 0 : e.markDidDomLayout()), this._cachedWidth) : 0;
        }
        getWidthIsFast() {
          return this._cachedWidth !== -1;
        }
        getVisibleRangesForRange(e, t, i, n) {
          if (!this.domNode) return null;
          if (this._pixelOffsetCache !== null) {
            const o = this._readPixelOffset(this.domNode, e, t, n);
            if (o === -1) return null;
            const r = this._readPixelOffset(this.domNode, e, i, n);
            return r === -1 ? null : [
              new Eh(o, r - o)
            ];
          }
          return this._readVisibleRangesForRange(this.domNode, e, t, i, n);
        }
        _readVisibleRangesForRange(e, t, i, n, o) {
          if (i === n) {
            const r = this._readPixelOffset(e, t, i, o);
            return r === -1 ? null : [
              new Eh(r, 0)
            ];
          } else return this._readRawVisibleRangesForRange(e, i, n, o);
        }
        _readPixelOffset(e, t, i, n) {
          if (this._characterMapping.length === 0) {
            if (this._containsForeignElements === 0 || this._containsForeignElements === 2) return 0;
            if (this._containsForeignElements === 1) return this.getWidth(n);
            const o = this._getReadingTarget(e);
            return o.firstChild ? (n.markDidDomLayout(), o.firstChild.offsetWidth) : 0;
          }
          if (this._pixelOffsetCache !== null) {
            const o = this._pixelOffsetCache[i];
            if (o !== -1) return o;
            const r = this._actualReadPixelOffset(e, t, i, n);
            return this._pixelOffsetCache[i] = r, r;
          }
          return this._actualReadPixelOffset(e, t, i, n);
        }
        _actualReadPixelOffset(e, t, i, n) {
          if (this._characterMapping.length === 0) {
            const l = B0.readHorizontalRanges(this._getReadingTarget(e), 0, 0, 0, 0, n);
            return !l || l.length === 0 ? -1 : l[0].left;
          }
          if (i === this._characterMapping.length && this._isWhitespaceOnly && this._containsForeignElements === 0) return this.getWidth(n);
          const o = this._characterMapping.getDomPosition(i), r = B0.readHorizontalRanges(this._getReadingTarget(e), o.partIndex, o.charIndex, o.partIndex, o.charIndex, n);
          if (!r || r.length === 0) return -1;
          const a = r[0].left;
          if (this.input.isBasicASCII) {
            const l = this._characterMapping.getHorizontalOffset(i), u = Math.round(this.input.spaceWidth * l);
            if (Math.abs(u - a) <= 1) return u;
          }
          return a;
        }
        _readRawVisibleRangesForRange(e, t, i, n) {
          if (t === 1 && i === this._characterMapping.length) return [
            new Eh(0, this.getWidth(n))
          ];
          const o = this._characterMapping.getDomPosition(t), r = this._characterMapping.getDomPosition(i);
          return B0.readHorizontalRanges(this._getReadingTarget(e), o.partIndex, o.charIndex, r.partIndex, r.charIndex, n);
        }
        getColumnOfNodeOffset(e, t) {
          return DF(this._characterMapping, e, t);
        }
      }
      class gle extends xF {
        _readVisibleRangesForRange(e, t, i, n, o) {
          const r = super._readVisibleRangesForRange(e, t, i, n, o);
          if (!r || r.length === 0 || i === n || i === 1 && n === this._characterMapping.length) return r;
          if (!this.input.containsRTL) {
            const a = this._readPixelOffset(e, t, n, o);
            if (a !== -1) {
              const l = r[r.length - 1];
              l.left < a && (l.width = a - l.left);
            }
          }
          return r;
        }
      }
      const kF = /* @__PURE__ */ function() {
        return HC ? mle : ple;
      }();
      function mle(s, e, t, i, n) {
        return new gle(s, e, t, i, n);
      }
      function ple(s, e, t, i, n) {
        return new xF(s, e, t, i, n);
      }
      function DF(s, e, t) {
        const i = e.textContent.length;
        let n = -1;
        for (; e; ) e = e.previousSibling, n++;
        return s.getColumn(new _F(n, t), i);
      }
      class x_ {
        static whitespaceVisibleColumn(e, t, i) {
          const n = e.length;
          let o = 0, r = -1, a = -1;
          for (let l = 0; l < n; l++) {
            if (l === t) return [
              r,
              a,
              o
            ];
            switch (o % i === 0 && (r = l, a = o), e.charCodeAt(l)) {
              case 32:
                o += 1;
                break;
              case 9:
                o = Gi.nextRenderTabStop(o, i);
                break;
              default:
                return [
                  -1,
                  -1,
                  -1
                ];
            }
          }
          return t === n ? [
            r,
            a,
            o
          ] : [
            -1,
            -1,
            -1
          ];
        }
        static atomicPosition(e, t, i, n) {
          const o = e.length, [r, a, l] = x_.whitespaceVisibleColumn(e, t, i);
          if (l === -1) return -1;
          let u;
          switch (n) {
            case 0:
              u = true;
              break;
            case 1:
              u = false;
              break;
            case 2:
              if (l % i === 0) return t;
              u = l % i <= i / 2;
              break;
          }
          if (u) {
            if (r === -1) return -1;
            let m = a;
            for (let _ = r; _ < o; ++_) {
              if (m === a + i) return r;
              switch (e.charCodeAt(_)) {
                case 32:
                  m += 1;
                  break;
                case 9:
                  m = Gi.nextRenderTabStop(m, i);
                  break;
                default:
                  return -1;
              }
            }
            return m === a + i ? r : -1;
          }
          const d = Gi.nextRenderTabStop(l, i);
          let f = l;
          for (let m = t; m < o; m++) {
            if (f === d) return m;
            switch (e.charCodeAt(m)) {
              case 32:
                f += 1;
                break;
              case 9:
                f = Gi.nextRenderTabStop(f, i);
                break;
              default:
                return -1;
            }
          }
          return f === d ? o : -1;
        }
      }
      class kc {
        constructor(e = null) {
          this.hitTarget = e, this.type = 0;
        }
      }
      class EF {
        get hitTarget() {
          return this.spanNode;
        }
        constructor(e, t, i) {
          this.position = e, this.spanNode = t, this.injectedText = i, this.type = 1;
        }
      }
      var ah;
      (function(s) {
        function e(t, i, n) {
          const o = t.getPositionFromDOMInfo(i, n);
          return o ? new EF(o, i, null) : new kc(i);
        }
        s.createFromDOMInfo = e;
      })(ah || (ah = {}));
      class _le {
        constructor(e, t) {
          this.lastViewCursorsRenderData = e, this.lastTextareaPosition = t;
        }
      }
      class es {
        static _deduceRage(e, t = null) {
          return !t && e ? new z(e.lineNumber, e.column, e.lineNumber, e.column) : t ?? null;
        }
        static createUnknown(e, t, i) {
          return {
            type: 0,
            element: e,
            mouseColumn: t,
            position: i,
            range: this._deduceRage(i)
          };
        }
        static createTextarea(e, t) {
          return {
            type: 1,
            element: e,
            mouseColumn: t,
            position: null,
            range: null
          };
        }
        static createMargin(e, t, i, n, o, r) {
          return {
            type: e,
            element: t,
            mouseColumn: i,
            position: n,
            range: o,
            detail: r
          };
        }
        static createViewZone(e, t, i, n, o) {
          return {
            type: e,
            element: t,
            mouseColumn: i,
            position: n,
            range: this._deduceRage(n),
            detail: o
          };
        }
        static createContentText(e, t, i, n, o) {
          return {
            type: 6,
            element: e,
            mouseColumn: t,
            position: i,
            range: this._deduceRage(i, n),
            detail: o
          };
        }
        static createContentEmpty(e, t, i, n) {
          return {
            type: 7,
            element: e,
            mouseColumn: t,
            position: i,
            range: this._deduceRage(i),
            detail: n
          };
        }
        static createContentWidget(e, t, i) {
          return {
            type: 9,
            element: e,
            mouseColumn: t,
            position: null,
            range: null,
            detail: i
          };
        }
        static createScrollbar(e, t, i) {
          return {
            type: 11,
            element: e,
            mouseColumn: t,
            position: i,
            range: this._deduceRage(i)
          };
        }
        static createOverlayWidget(e, t, i) {
          return {
            type: 12,
            element: e,
            mouseColumn: t,
            position: null,
            range: null,
            detail: i
          };
        }
        static createOutsideEditor(e, t, i, n) {
          return {
            type: 13,
            element: null,
            mouseColumn: e,
            position: t,
            range: this._deduceRage(t),
            outsidePosition: i,
            outsideDistance: n
          };
        }
        static _typeToString(e) {
          return e === 1 ? "TEXTAREA" : e === 2 ? "GUTTER_GLYPH_MARGIN" : e === 3 ? "GUTTER_LINE_NUMBERS" : e === 4 ? "GUTTER_LINE_DECORATIONS" : e === 5 ? "GUTTER_VIEW_ZONE" : e === 6 ? "CONTENT_TEXT" : e === 7 ? "CONTENT_EMPTY" : e === 8 ? "CONTENT_VIEW_ZONE" : e === 9 ? "CONTENT_WIDGET" : e === 10 ? "OVERVIEW_RULER" : e === 11 ? "SCROLLBAR" : e === 12 ? "OVERLAY_WIDGET" : "UNKNOWN";
        }
        static toString(e) {
          return this._typeToString(e.type) + ": " + e.position + " - " + e.range + " - " + JSON.stringify(e.detail);
        }
      }
      class cs {
        static isTextArea(e) {
          return e.length === 2 && e[0] === 3 && e[1] === 7;
        }
        static isChildOfViewLines(e) {
          return e.length >= 4 && e[0] === 3 && e[3] === 8;
        }
        static isStrictChildOfViewLines(e) {
          return e.length > 4 && e[0] === 3 && e[3] === 8;
        }
        static isChildOfScrollableElement(e) {
          return e.length >= 2 && e[0] === 3 && e[1] === 6;
        }
        static isChildOfMinimap(e) {
          return e.length >= 2 && e[0] === 3 && e[1] === 9;
        }
        static isChildOfContentWidgets(e) {
          return e.length >= 4 && e[0] === 3 && e[3] === 1;
        }
        static isChildOfOverflowGuard(e) {
          return e.length >= 1 && e[0] === 3;
        }
        static isChildOfOverflowingContentWidgets(e) {
          return e.length >= 1 && e[0] === 2;
        }
        static isChildOfOverlayWidgets(e) {
          return e.length >= 2 && e[0] === 3 && e[1] === 4;
        }
        static isChildOfOverflowingOverlayWidgets(e) {
          return e.length >= 1 && e[0] === 5;
        }
      }
      class Cg {
        constructor(e, t, i) {
          this.viewModel = e.viewModel;
          const n = e.configuration.options;
          this.layoutInfo = n.get(146), this.viewDomNode = t.viewDomNode, this.lineHeight = n.get(67), this.stickyTabStops = n.get(117), this.typicalHalfwidthCharacterWidth = n.get(50).typicalHalfwidthCharacterWidth, this.lastRenderData = i, this._context = e, this._viewHelper = t;
        }
        getZoneAtCoord(e) {
          return Cg.getZoneAtCoord(this._context, e);
        }
        static getZoneAtCoord(e, t) {
          const i = e.viewLayout.getWhitespaceAtVerticalOffset(t);
          if (i) {
            const n = i.verticalOffset + i.height / 2, o = e.viewModel.getLineCount();
            let r = null, a, l = null;
            return i.afterLineNumber !== o && (l = new X(i.afterLineNumber + 1, 1)), i.afterLineNumber > 0 && (r = new X(i.afterLineNumber, e.viewModel.getLineMaxColumn(i.afterLineNumber))), l === null ? a = r : r === null ? a = l : t < n ? a = r : a = l, {
              viewZoneId: i.id,
              afterLineNumber: i.afterLineNumber,
              positionBefore: r,
              positionAfter: l,
              position: a
            };
          }
          return null;
        }
        getFullLineRangeAtCoord(e) {
          if (this._context.viewLayout.isAfterLines(e)) {
            const n = this._context.viewModel.getLineCount(), o = this._context.viewModel.getLineMaxColumn(n);
            return {
              range: new z(n, o, n, o),
              isAfterLines: true
            };
          }
          const t = this._context.viewLayout.getLineNumberAtVerticalOffset(e), i = this._context.viewModel.getLineMaxColumn(t);
          return {
            range: new z(t, 1, t, i),
            isAfterLines: false
          };
        }
        getLineNumberAtVerticalOffset(e) {
          return this._context.viewLayout.getLineNumberAtVerticalOffset(e);
        }
        isAfterLines(e) {
          return this._context.viewLayout.isAfterLines(e);
        }
        isInTopPadding(e) {
          return this._context.viewLayout.isInTopPadding(e);
        }
        isInBottomPadding(e) {
          return this._context.viewLayout.isInBottomPadding(e);
        }
        getVerticalOffsetForLineNumber(e) {
          return this._context.viewLayout.getVerticalOffsetForLineNumber(e);
        }
        findAttribute(e, t) {
          return Cg._findAttribute(e, t, this._viewHelper.viewDomNode);
        }
        static _findAttribute(e, t, i) {
          for (; e && e !== e.ownerDocument.body; ) {
            if (e.hasAttribute && e.hasAttribute(t)) return e.getAttribute(t);
            if (e === i) return null;
            e = e.parentNode;
          }
          return null;
        }
        getLineWidth(e) {
          return this._viewHelper.getLineWidth(e);
        }
        visibleRangeForPosition(e, t) {
          return this._viewHelper.visibleRangeForPosition(e, t);
        }
        getPositionFromDOMInfo(e, t) {
          return this._viewHelper.getPositionFromDOMInfo(e, t);
        }
        getCurrentScrollTop() {
          return this._context.viewLayout.getCurrentScrollTop();
        }
        getCurrentScrollLeft() {
          return this._context.viewLayout.getCurrentScrollLeft();
        }
      }
      class ble {
        constructor(e, t, i, n) {
          this.editorPos = t, this.pos = i, this.relativePos = n, this.mouseVerticalOffset = Math.max(0, e.getCurrentScrollTop() + this.relativePos.y), this.mouseContentHorizontalOffset = e.getCurrentScrollLeft() + this.relativePos.x - e.layoutInfo.contentLeft, this.isInMarginArea = this.relativePos.x < e.layoutInfo.contentLeft && this.relativePos.x >= e.layoutInfo.glyphMarginLeft, this.isInContentArea = !this.isInMarginArea, this.mouseColumn = Math.max(0, Jn._getMouseColumn(this.mouseContentHorizontalOffset, e.typicalHalfwidthCharacterWidth));
        }
      }
      class vle extends ble {
        get target() {
          return this._useHitTestTarget ? this.hitTestResult.value.hitTarget : this._eventTarget;
        }
        get targetPath() {
          return this._targetPathCacheElement !== this.target && (this._targetPathCacheElement = this.target, this._targetPathCacheValue = Yr.collect(this.target, this._ctx.viewDomNode)), this._targetPathCacheValue;
        }
        constructor(e, t, i, n, o) {
          super(e, t, i, n), this.hitTestResult = new iu(() => Jn.doHitTest(this._ctx, this)), this._targetPathCacheElement = null, this._targetPathCacheValue = new Uint8Array(0), this._ctx = e, this._eventTarget = o;
          const r = !!this._eventTarget;
          this._useHitTestTarget = !r;
        }
        toString() {
          return `pos(${this.pos.x},${this.pos.y}), editorPos(${this.editorPos.x},${this.editorPos.y}), relativePos(${this.relativePos.x},${this.relativePos.y}), mouseVerticalOffset: ${this.mouseVerticalOffset}, mouseContentHorizontalOffset: ${this.mouseContentHorizontalOffset}
	target: ${this.target ? this.target.outerHTML : null}`;
        }
        get wouldBenefitFromHitTestTargetSwitch() {
          return !this._useHitTestTarget && this.hitTestResult.value.hitTarget !== null && this.target !== this.hitTestResult.value.hitTarget;
        }
        switchToHitTestTarget() {
          this._useHitTestTarget = true;
        }
        _getMouseColumn(e = null) {
          return e && e.column < this._ctx.viewModel.getLineMaxColumn(e.lineNumber) ? Gi.visibleColumnFromColumn(this._ctx.viewModel.getLineContent(e.lineNumber), e.column, this._ctx.viewModel.model.getOptions().tabSize) + 1 : this.mouseColumn;
        }
        fulfillUnknown(e = null) {
          return es.createUnknown(this.target, this._getMouseColumn(e), e);
        }
        fulfillTextarea() {
          return es.createTextarea(this.target, this._getMouseColumn());
        }
        fulfillMargin(e, t, i, n) {
          return es.createMargin(e, this.target, this._getMouseColumn(t), t, i, n);
        }
        fulfillViewZone(e, t, i) {
          return es.createViewZone(e, this.target, this._getMouseColumn(t), t, i);
        }
        fulfillContentText(e, t, i) {
          return es.createContentText(this.target, this._getMouseColumn(e), e, t, i);
        }
        fulfillContentEmpty(e, t) {
          return es.createContentEmpty(this.target, this._getMouseColumn(e), e, t);
        }
        fulfillContentWidget(e) {
          return es.createContentWidget(this.target, this._getMouseColumn(), e);
        }
        fulfillScrollbar(e) {
          return es.createScrollbar(this.target, this._getMouseColumn(e), e);
        }
        fulfillOverlayWidget(e) {
          return es.createOverlayWidget(this.target, this._getMouseColumn(), e);
        }
      }
      const M3 = {
        isAfterLines: true
      };
      function _x(s) {
        return {
          isAfterLines: false,
          horizontalDistanceToText: s
        };
      }
      class Jn {
        constructor(e, t) {
          this._context = e, this._viewHelper = t;
        }
        mouseTargetIsWidget(e) {
          const t = e.target, i = Yr.collect(t, this._viewHelper.viewDomNode);
          return !!(cs.isChildOfContentWidgets(i) || cs.isChildOfOverflowingContentWidgets(i) || cs.isChildOfOverlayWidgets(i) || cs.isChildOfOverflowingOverlayWidgets(i));
        }
        createMouseTarget(e, t, i, n, o) {
          const r = new Cg(this._context, this._viewHelper, e), a = new vle(r, t, i, n, o);
          try {
            const l = Jn._createMouseTarget(r, a);
            if (l.type === 6 && r.stickyTabStops && l.position !== null) {
              const u = Jn._snapToSoftTabBoundary(l.position, r.viewModel), d = z.fromPositions(u, u).plusRange(l.range);
              return a.fulfillContentText(u, d, l.detail);
            }
            return l;
          } catch {
            return a.fulfillUnknown();
          }
        }
        static _createMouseTarget(e, t) {
          if (t.target === null) return t.fulfillUnknown();
          const i = t;
          let n = null;
          return !cs.isChildOfOverflowGuard(t.targetPath) && !cs.isChildOfOverflowingContentWidgets(t.targetPath) && !cs.isChildOfOverflowingOverlayWidgets(t.targetPath) && (n = n || t.fulfillUnknown()), n = n || Jn._hitTestContentWidget(e, i), n = n || Jn._hitTestOverlayWidget(e, i), n = n || Jn._hitTestMinimap(e, i), n = n || Jn._hitTestScrollbarSlider(e, i), n = n || Jn._hitTestViewZone(e, i), n = n || Jn._hitTestMargin(e, i), n = n || Jn._hitTestViewCursor(e, i), n = n || Jn._hitTestTextArea(e, i), n = n || Jn._hitTestViewLines(e, i), n = n || Jn._hitTestScrollbar(e, i), n || t.fulfillUnknown();
        }
        static _hitTestContentWidget(e, t) {
          if (cs.isChildOfContentWidgets(t.targetPath) || cs.isChildOfOverflowingContentWidgets(t.targetPath)) {
            const i = e.findAttribute(t.target, "widgetId");
            return i ? t.fulfillContentWidget(i) : t.fulfillUnknown();
          }
          return null;
        }
        static _hitTestOverlayWidget(e, t) {
          if (cs.isChildOfOverlayWidgets(t.targetPath) || cs.isChildOfOverflowingOverlayWidgets(t.targetPath)) {
            const i = e.findAttribute(t.target, "widgetId");
            return i ? t.fulfillOverlayWidget(i) : t.fulfillUnknown();
          }
          return null;
        }
        static _hitTestViewCursor(e, t) {
          if (t.target) {
            const i = e.lastRenderData.lastViewCursorsRenderData;
            for (const n of i) if (t.target === n.domNode) return t.fulfillContentText(n.position, null, {
              mightBeForeignElement: false,
              injectedText: null
            });
          }
          if (t.isInContentArea) {
            const i = e.lastRenderData.lastViewCursorsRenderData, n = t.mouseContentHorizontalOffset, o = t.mouseVerticalOffset;
            for (const r of i) {
              if (n < r.contentLeft || n > r.contentLeft + r.width) continue;
              const a = e.getVerticalOffsetForLineNumber(r.position.lineNumber);
              if (a <= o && o <= a + r.height) return t.fulfillContentText(r.position, null, {
                mightBeForeignElement: false,
                injectedText: null
              });
            }
          }
          return null;
        }
        static _hitTestViewZone(e, t) {
          const i = e.getZoneAtCoord(t.mouseVerticalOffset);
          if (i) {
            const n = t.isInContentArea ? 8 : 5;
            return t.fulfillViewZone(n, i.position, i);
          }
          return null;
        }
        static _hitTestTextArea(e, t) {
          return cs.isTextArea(t.targetPath) ? e.lastRenderData.lastTextareaPosition ? t.fulfillContentText(e.lastRenderData.lastTextareaPosition, null, {
            mightBeForeignElement: false,
            injectedText: null
          }) : t.fulfillTextarea() : null;
        }
        static _hitTestMargin(e, t) {
          if (t.isInMarginArea) {
            const i = e.getFullLineRangeAtCoord(t.mouseVerticalOffset), n = i.range.getStartPosition();
            let o = Math.abs(t.relativePos.x);
            const r = {
              isAfterLines: i.isAfterLines,
              glyphMarginLeft: e.layoutInfo.glyphMarginLeft,
              glyphMarginWidth: e.layoutInfo.glyphMarginWidth,
              lineNumbersWidth: e.layoutInfo.lineNumbersWidth,
              offsetX: o
            };
            if (o -= e.layoutInfo.glyphMarginLeft, o <= e.layoutInfo.glyphMarginWidth) {
              const a = e.viewModel.coordinatesConverter.convertViewPositionToModelPosition(i.range.getStartPosition()), l = e.viewModel.glyphLanes.getLanesAtLine(a.lineNumber);
              return r.glyphMarginLane = l[Math.floor(o / e.lineHeight)], t.fulfillMargin(2, n, i.range, r);
            }
            return o -= e.layoutInfo.glyphMarginWidth, o <= e.layoutInfo.lineNumbersWidth ? t.fulfillMargin(3, n, i.range, r) : (o -= e.layoutInfo.lineNumbersWidth, t.fulfillMargin(4, n, i.range, r));
          }
          return null;
        }
        static _hitTestViewLines(e, t) {
          if (!cs.isChildOfViewLines(t.targetPath)) return null;
          if (e.isInTopPadding(t.mouseVerticalOffset)) return t.fulfillContentEmpty(new X(1, 1), M3);
          if (e.isAfterLines(t.mouseVerticalOffset) || e.isInBottomPadding(t.mouseVerticalOffset)) {
            const n = e.viewModel.getLineCount(), o = e.viewModel.getLineMaxColumn(n);
            return t.fulfillContentEmpty(new X(n, o), M3);
          }
          if (cs.isStrictChildOfViewLines(t.targetPath)) {
            const n = e.getLineNumberAtVerticalOffset(t.mouseVerticalOffset);
            if (e.viewModel.getLineLength(n) === 0) {
              const r = e.getLineWidth(n), a = _x(t.mouseContentHorizontalOffset - r);
              return t.fulfillContentEmpty(new X(n, 1), a);
            }
            const o = e.getLineWidth(n);
            if (t.mouseContentHorizontalOffset >= o) {
              const r = _x(t.mouseContentHorizontalOffset - o), a = new X(n, e.viewModel.getLineMaxColumn(n));
              return t.fulfillContentEmpty(a, r);
            }
          }
          const i = t.hitTestResult.value;
          return i.type === 1 ? Jn.createMouseTargetFromHitTestPosition(e, t, i.spanNode, i.position, i.injectedText) : t.wouldBenefitFromHitTestTargetSwitch ? (t.switchToHitTestTarget(), this._createMouseTarget(e, t)) : t.fulfillUnknown();
        }
        static _hitTestMinimap(e, t) {
          if (cs.isChildOfMinimap(t.targetPath)) {
            const i = e.getLineNumberAtVerticalOffset(t.mouseVerticalOffset), n = e.viewModel.getLineMaxColumn(i);
            return t.fulfillScrollbar(new X(i, n));
          }
          return null;
        }
        static _hitTestScrollbarSlider(e, t) {
          if (cs.isChildOfScrollableElement(t.targetPath) && t.target && t.target.nodeType === 1) {
            const i = t.target.className;
            if (i && /\b(slider|scrollbar)\b/.test(i)) {
              const n = e.getLineNumberAtVerticalOffset(t.mouseVerticalOffset), o = e.viewModel.getLineMaxColumn(n);
              return t.fulfillScrollbar(new X(n, o));
            }
          }
          return null;
        }
        static _hitTestScrollbar(e, t) {
          if (cs.isChildOfScrollableElement(t.targetPath)) {
            const i = e.getLineNumberAtVerticalOffset(t.mouseVerticalOffset), n = e.viewModel.getLineMaxColumn(i);
            return t.fulfillScrollbar(new X(i, n));
          }
          return null;
        }
        getMouseColumn(e) {
          const t = this._context.configuration.options, i = t.get(146), n = this._context.viewLayout.getCurrentScrollLeft() + e.x - i.contentLeft;
          return Jn._getMouseColumn(n, t.get(50).typicalHalfwidthCharacterWidth);
        }
        static _getMouseColumn(e, t) {
          return e < 0 ? 1 : Math.round(e / t) + 1;
        }
        static createMouseTargetFromHitTestPosition(e, t, i, n, o) {
          const r = n.lineNumber, a = n.column, l = e.getLineWidth(r);
          if (t.mouseContentHorizontalOffset > l) {
            const x = _x(t.mouseContentHorizontalOffset - l);
            return t.fulfillContentEmpty(n, x);
          }
          const u = e.visibleRangeForPosition(r, a);
          if (!u) return t.fulfillUnknown(n);
          const d = u.left;
          if (Math.abs(t.mouseContentHorizontalOffset - d) < 1) return t.fulfillContentText(n, null, {
            mightBeForeignElement: !!o,
            injectedText: o
          });
          const f = [];
          if (f.push({
            offset: u.left,
            column: a
          }), a > 1) {
            const x = e.visibleRangeForPosition(r, a - 1);
            x && f.push({
              offset: x.left,
              column: a - 1
            });
          }
          const m = e.viewModel.getLineMaxColumn(r);
          if (a < m) {
            const x = e.visibleRangeForPosition(r, a + 1);
            x && f.push({
              offset: x.left,
              column: a + 1
            });
          }
          f.sort((x, L) => x.offset - L.offset);
          const _ = t.pos.toClientCoordinates(Oe(e.viewDomNode)), b = i.getBoundingClientRect(), v = b.left <= _.clientX && _.clientX <= b.right;
          let y = null;
          for (let x = 1; x < f.length; x++) {
            const L = f[x - 1], D = f[x];
            if (L.offset <= t.mouseContentHorizontalOffset && t.mouseContentHorizontalOffset <= D.offset) {
              y = new z(r, L.column, r, D.column);
              const k = Math.abs(L.offset - t.mouseContentHorizontalOffset), T = Math.abs(D.offset - t.mouseContentHorizontalOffset);
              n = k < T ? new X(r, L.column) : new X(r, D.column);
              break;
            }
          }
          return t.fulfillContentText(n, y, {
            mightBeForeignElement: !v || !!o,
            injectedText: o
          });
        }
        static _doHitTestWithCaretRangeFromPoint(e, t) {
          const i = e.getLineNumberAtVerticalOffset(t.mouseVerticalOffset), n = e.getVerticalOffsetForLineNumber(i), o = n + e.lineHeight;
          if (!(i === e.viewModel.getLineCount() && t.mouseVerticalOffset > o)) {
            const a = Math.floor((n + o) / 2);
            let l = t.pos.y + (a - t.mouseVerticalOffset);
            l <= t.editorPos.y && (l = t.editorPos.y + 1), l >= t.editorPos.y + t.editorPos.height && (l = t.editorPos.y + t.editorPos.height - 1);
            const u = new Ww(t.pos.x, l), d = this._actualDoHitTestWithCaretRangeFromPoint(e, u.toClientCoordinates(Oe(e.viewDomNode)));
            if (d.type === 1) return d;
          }
          return this._actualDoHitTestWithCaretRangeFromPoint(e, t.pos.toClientCoordinates(Oe(e.viewDomNode)));
        }
        static _actualDoHitTestWithCaretRangeFromPoint(e, t) {
          const i = ng(e.viewDomNode);
          let n;
          if (i ? typeof i.caretRangeFromPoint > "u" ? n = Cle(i, t.clientX, t.clientY) : n = i.caretRangeFromPoint(t.clientX, t.clientY) : n = e.viewDomNode.ownerDocument.caretRangeFromPoint(t.clientX, t.clientY), !n || !n.startContainer) return new kc();
          const o = n.startContainer;
          if (o.nodeType === o.TEXT_NODE) {
            const r = o.parentNode, a = r ? r.parentNode : null, l = a ? a.parentNode : null;
            return (l && l.nodeType === l.ELEMENT_NODE ? l.className : null) === Tl.CLASS_NAME ? ah.createFromDOMInfo(e, r, n.startOffset) : new kc(o.parentNode);
          } else if (o.nodeType === o.ELEMENT_NODE) {
            const r = o.parentNode, a = r ? r.parentNode : null;
            return (a && a.nodeType === a.ELEMENT_NODE ? a.className : null) === Tl.CLASS_NAME ? ah.createFromDOMInfo(e, o, o.textContent.length) : new kc(o);
          }
          return new kc();
        }
        static _doHitTestWithCaretPositionFromPoint(e, t) {
          const i = e.viewDomNode.ownerDocument.caretPositionFromPoint(t.clientX, t.clientY);
          if (i.offsetNode.nodeType === i.offsetNode.TEXT_NODE) {
            const n = i.offsetNode.parentNode, o = n ? n.parentNode : null, r = o ? o.parentNode : null;
            return (r && r.nodeType === r.ELEMENT_NODE ? r.className : null) === Tl.CLASS_NAME ? ah.createFromDOMInfo(e, i.offsetNode.parentNode, i.offset) : new kc(i.offsetNode.parentNode);
          }
          if (i.offsetNode.nodeType === i.offsetNode.ELEMENT_NODE) {
            const n = i.offsetNode.parentNode, o = n && n.nodeType === n.ELEMENT_NODE ? n.className : null, r = n ? n.parentNode : null, a = r && r.nodeType === r.ELEMENT_NODE ? r.className : null;
            if (o === Tl.CLASS_NAME) {
              const l = i.offsetNode.childNodes[Math.min(i.offset, i.offsetNode.childNodes.length - 1)];
              if (l) return ah.createFromDOMInfo(e, l, 0);
            } else if (a === Tl.CLASS_NAME) return ah.createFromDOMInfo(e, i.offsetNode, 0);
          }
          return new kc(i.offsetNode);
        }
        static _snapToSoftTabBoundary(e, t) {
          const i = t.getLineContent(e.lineNumber), { tabSize: n } = t.model.getOptions(), o = x_.atomicPosition(i, e.column - 1, n, 2);
          return o !== -1 ? new X(e.lineNumber, o + 1) : e;
        }
        static doHitTest(e, t) {
          let i = new kc();
          if (typeof e.viewDomNode.ownerDocument.caretRangeFromPoint == "function" ? i = this._doHitTestWithCaretRangeFromPoint(e, t) : e.viewDomNode.ownerDocument.caretPositionFromPoint && (i = this._doHitTestWithCaretPositionFromPoint(e, t.pos.toClientCoordinates(Oe(e.viewDomNode)))), i.type === 1) {
            const n = e.viewModel.getInjectedTextAt(i.position), o = e.viewModel.normalizePosition(i.position, 2);
            (n || !o.equals(i.position)) && (i = new EF(o, i.spanNode, n));
          }
          return i;
        }
      }
      function Cle(s, e, t) {
        const i = document.createRange();
        let n = s.elementFromPoint(e, t);
        if (n !== null) {
          for (; n && n.firstChild && n.firstChild.nodeType !== n.firstChild.TEXT_NODE && n.lastChild && n.lastChild.firstChild; ) n = n.lastChild;
          const o = n.getBoundingClientRect(), r = Oe(n), a = r.getComputedStyle(n, null).getPropertyValue("font-style"), l = r.getComputedStyle(n, null).getPropertyValue("font-variant"), u = r.getComputedStyle(n, null).getPropertyValue("font-weight"), d = r.getComputedStyle(n, null).getPropertyValue("font-size"), f = r.getComputedStyle(n, null).getPropertyValue("line-height"), m = r.getComputedStyle(n, null).getPropertyValue("font-family"), _ = `${a} ${l} ${u} ${d}/${f} ${m}`, b = n.innerText;
          let v = o.left, y = 0, x;
          if (e > o.left + o.width) y = b.length;
          else {
            const L = Lf.getInstance();
            for (let D = 0; D < b.length + 1; D++) {
              if (x = L.getCharWidth(b.charAt(D), _) / 2, v += x, e < v) {
                y = D;
                break;
              }
              v += x;
            }
          }
          i.setStart(n.firstChild, y), i.setEnd(n.firstChild, y);
        }
        return i;
      }
      const _Lf = class _Lf {
        static getInstance() {
          return _Lf._INSTANCE || (_Lf._INSTANCE = new _Lf()), _Lf._INSTANCE;
        }
        constructor() {
          this._cache = {}, this._canvas = document.createElement("canvas");
        }
        getCharWidth(e, t) {
          const i = e + t;
          if (this._cache[i]) return this._cache[i];
          const n = this._canvas.getContext("2d");
          n.font = t;
          const r = n.measureText(e).width;
          return this._cache[i] = r, r;
        }
      };
      _Lf._INSTANCE = null;
      let Lf = _Lf;
      class ZN extends a1 {
        constructor(e, t, i) {
          super(), this._mouseLeaveMonitor = null, this._context = e, this.viewController = t, this.viewHelper = i, this.mouseTargetFactory = new Jn(this._context, i), this._mouseDownOperation = this._register(new wle(this._context, this.viewController, this.viewHelper, this.mouseTargetFactory, (r, a) => this._createMouseTarget(r, a), (r) => this._getMouseColumn(r))), this.lastMouseLeaveTime = -1, this._height = this._context.configuration.options.get(146).height;
          const n = new sle(this.viewHelper.viewDomNode);
          this._register(n.onContextMenu(this.viewHelper.viewDomNode, (r) => this._onContextMenu(r, true))), this._register(n.onMouseMove(this.viewHelper.viewDomNode, (r) => {
            this._onMouseMove(r), this._mouseLeaveMonitor || (this._mouseLeaveMonitor = re(this.viewHelper.viewDomNode.ownerDocument, "mousemove", (a) => {
              this.viewHelper.viewDomNode.contains(a.target) || this._onMouseLeave(new cu(a, false, this.viewHelper.viewDomNode));
            }));
          })), this._register(n.onMouseUp(this.viewHelper.viewDomNode, (r) => this._onMouseUp(r))), this._register(n.onMouseLeave(this.viewHelper.viewDomNode, (r) => this._onMouseLeave(r)));
          let o = 0;
          this._register(n.onPointerDown(this.viewHelper.viewDomNode, (r, a) => {
            o = a;
          })), this._register(re(this.viewHelper.viewDomNode, Ce.POINTER_UP, (r) => {
            this._mouseDownOperation.onPointerUp();
          })), this._register(n.onMouseDown(this.viewHelper.viewDomNode, (r) => this._onMouseDown(r, o))), this._setupMouseWheelZoomListener(), this._context.addEventHandler(this);
        }
        _setupMouseWheelZoomListener() {
          const e = hw.INSTANCE;
          let t = 0, i = Ic.getZoomLevel(), n = false, o = 0;
          const r = (l) => {
            if (this.viewController.emitMouseWheel(l), !this._context.configuration.options.get(76)) return;
            const u = new Ah(l);
            if (e.acceptStandardWheelEvent(u), e.isPhysicalMouseWheel()) {
              if (a(l)) {
                const d = Ic.getZoomLevel(), f = u.deltaY > 0 ? 1 : -1;
                Ic.setZoomLevel(d + f), u.preventDefault(), u.stopPropagation();
              }
            } else Date.now() - t > 50 && (i = Ic.getZoomLevel(), n = a(l), o = 0), t = Date.now(), o += u.deltaY, n && (Ic.setZoomLevel(i + o / 5), u.preventDefault(), u.stopPropagation());
          };
          this._register(re(this.viewHelper.viewDomNode, Ce.MOUSE_WHEEL, r, {
            capture: true,
            passive: false
          }));
          function a(l) {
            return _t ? (l.metaKey || l.ctrlKey) && !l.shiftKey && !l.altKey : l.ctrlKey && !l.metaKey && !l.shiftKey && !l.altKey;
          }
        }
        dispose() {
          this._context.removeEventHandler(this), this._mouseLeaveMonitor && (this._mouseLeaveMonitor.dispose(), this._mouseLeaveMonitor = null), super.dispose();
        }
        onConfigurationChanged(e) {
          if (e.hasChanged(146)) {
            const t = this._context.configuration.options.get(146).height;
            this._height !== t && (this._height = t, this._mouseDownOperation.onHeightChanged());
          }
          return false;
        }
        onCursorStateChanged(e) {
          return this._mouseDownOperation.onCursorStateChanged(e), false;
        }
        onFocusChanged(e) {
          return false;
        }
        getTargetAtClientPoint(e, t) {
          const n = new SF(e, t).toPageCoordinates(Oe(this.viewHelper.viewDomNode)), o = GN(this.viewHelper.viewDomNode);
          if (n.y < o.y || n.y > o.y + o.height || n.x < o.x || n.x > o.x + o.width) return null;
          const r = YN(this.viewHelper.viewDomNode, o, n);
          return this.mouseTargetFactory.createMouseTarget(this.viewHelper.getLastRenderData(), o, n, r, null);
        }
        _createMouseTarget(e, t) {
          let i = e.target;
          if (!this.viewHelper.viewDomNode.contains(i)) {
            const n = ng(this.viewHelper.viewDomNode);
            n && (i = n.elementsFromPoint(e.posx, e.posy).find((o) => this.viewHelper.viewDomNode.contains(o)));
          }
          return this.mouseTargetFactory.createMouseTarget(this.viewHelper.getLastRenderData(), e.editorPos, e.pos, e.relativePos, t ? i : null);
        }
        _getMouseColumn(e) {
          return this.mouseTargetFactory.getMouseColumn(e.relativePos);
        }
        _onContextMenu(e, t) {
          this.viewController.emitContextMenu({
            event: e,
            target: this._createMouseTarget(e, t)
          });
        }
        _onMouseMove(e) {
          this.mouseTargetFactory.mouseTargetIsWidget(e) || e.preventDefault(), !(this._mouseDownOperation.isActive() || e.timestamp < this.lastMouseLeaveTime) && this.viewController.emitMouseMove({
            event: e,
            target: this._createMouseTarget(e, true)
          });
        }
        _onMouseLeave(e) {
          this._mouseLeaveMonitor && (this._mouseLeaveMonitor.dispose(), this._mouseLeaveMonitor = null), this.lastMouseLeaveTime = (/* @__PURE__ */ new Date()).getTime(), this.viewController.emitMouseLeave({
            event: e,
            target: null
          });
        }
        _onMouseUp(e) {
          this.viewController.emitMouseUp({
            event: e,
            target: this._createMouseTarget(e, true)
          });
        }
        _onMouseDown(e, t) {
          const i = this._createMouseTarget(e, true), n = i.type === 6 || i.type === 7, o = i.type === 2 || i.type === 3 || i.type === 4, r = i.type === 3, a = this._context.configuration.options.get(110), l = i.type === 8 || i.type === 5, u = i.type === 9;
          let d = e.leftButton || e.middleButton;
          _t && e.leftButton && e.ctrlKey && (d = false);
          const f = () => {
            e.preventDefault(), this.viewHelper.focusTextArea();
          };
          if (d && (n || r && a)) f(), this._mouseDownOperation.start(i.type, e, t);
          else if (o) e.preventDefault();
          else if (l) {
            const m = i.detail;
            d && this.viewHelper.shouldSuppressMouseDownOnViewZone(m.viewZoneId) && (f(), this._mouseDownOperation.start(i.type, e, t), e.preventDefault());
          } else u && this.viewHelper.shouldSuppressMouseDownOnWidget(i.detail) && (f(), e.preventDefault());
          this.viewController.emitMouseDown({
            event: e,
            target: i
          });
        }
      }
      class wle extends he {
        constructor(e, t, i, n, o, r) {
          super(), this._context = e, this._viewController = t, this._viewHelper = i, this._mouseTargetFactory = n, this._createMouseTarget = o, this._getMouseColumn = r, this._mouseMoveMonitor = this._register(new rle(this._viewHelper.viewDomNode)), this._topBottomDragScrolling = this._register(new yle(this._context, this._viewHelper, this._mouseTargetFactory, (a, l, u) => this._dispatchMouse(a, l, u))), this._mouseState = new QN(), this._currentSelection = new mt(1, 1, 1, 1), this._isActive = false, this._lastMouseEvent = null;
        }
        dispose() {
          super.dispose();
        }
        isActive() {
          return this._isActive;
        }
        _onMouseDownThenMove(e) {
          this._lastMouseEvent = e, this._mouseState.setModifiers(e);
          const t = this._findMousePosition(e, false);
          t && (this._mouseState.isDragAndDrop ? this._viewController.emitMouseDrag({
            event: e,
            target: t
          }) : t.type === 13 && (t.outsidePosition === "above" || t.outsidePosition === "below") ? this._topBottomDragScrolling.start(t, e) : (this._topBottomDragScrolling.stop(), this._dispatchMouse(t, true, 1)));
        }
        start(e, t, i) {
          this._lastMouseEvent = t, this._mouseState.setStartedOnLineNumbers(e === 3), this._mouseState.setStartButtons(t), this._mouseState.setModifiers(t);
          const n = this._findMousePosition(t, true);
          if (!n || !n.position) return;
          this._mouseState.trySetCount(t.detail, n.position), t.detail = this._mouseState.count;
          const o = this._context.configuration.options;
          if (!o.get(92) && o.get(35) && !o.get(22) && !this._mouseState.altKey && t.detail < 2 && !this._isActive && !this._currentSelection.isEmpty() && n.type === 6 && n.position && this._currentSelection.containsPosition(n.position)) {
            this._mouseState.isDragAndDrop = true, this._isActive = true, this._mouseMoveMonitor.startMonitoring(this._viewHelper.viewLinesDomNode, i, t.buttons, (r) => this._onMouseDownThenMove(r), (r) => {
              const a = this._findMousePosition(this._lastMouseEvent, false);
              Cl(r) ? this._viewController.emitMouseDropCanceled() : this._viewController.emitMouseDrop({
                event: this._lastMouseEvent,
                target: a ? this._createMouseTarget(this._lastMouseEvent, true) : null
              }), this._stop();
            });
            return;
          }
          this._mouseState.isDragAndDrop = false, this._dispatchMouse(n, t.shiftKey, 1), this._isActive || (this._isActive = true, this._mouseMoveMonitor.startMonitoring(this._viewHelper.viewLinesDomNode, i, t.buttons, (r) => this._onMouseDownThenMove(r), () => this._stop()));
        }
        _stop() {
          this._isActive = false, this._topBottomDragScrolling.stop();
        }
        onHeightChanged() {
          this._mouseMoveMonitor.stopMonitoring();
        }
        onPointerUp() {
          this._mouseMoveMonitor.stopMonitoring();
        }
        onCursorStateChanged(e) {
          this._currentSelection = e.selections[0];
        }
        _getPositionOutsideEditor(e) {
          const t = e.editorPos, i = this._context.viewModel, n = this._context.viewLayout, o = this._getMouseColumn(e);
          if (e.posy < t.y) {
            const a = t.y - e.posy, l = Math.max(n.getCurrentScrollTop() - a, 0), u = Cg.getZoneAtCoord(this._context, l);
            if (u) {
              const f = this._helpPositionJumpOverViewZone(u);
              if (f) return es.createOutsideEditor(o, f, "above", a);
            }
            const d = n.getLineNumberAtVerticalOffset(l);
            return es.createOutsideEditor(o, new X(d, 1), "above", a);
          }
          if (e.posy > t.y + t.height) {
            const a = e.posy - t.y - t.height, l = n.getCurrentScrollTop() + e.relativePos.y, u = Cg.getZoneAtCoord(this._context, l);
            if (u) {
              const f = this._helpPositionJumpOverViewZone(u);
              if (f) return es.createOutsideEditor(o, f, "below", a);
            }
            const d = n.getLineNumberAtVerticalOffset(l);
            return es.createOutsideEditor(o, new X(d, i.getLineMaxColumn(d)), "below", a);
          }
          const r = n.getLineNumberAtVerticalOffset(n.getCurrentScrollTop() + e.relativePos.y);
          if (e.posx < t.x) {
            const a = t.x - e.posx;
            return es.createOutsideEditor(o, new X(r, 1), "left", a);
          }
          if (e.posx > t.x + t.width) {
            const a = e.posx - t.x - t.width;
            return es.createOutsideEditor(o, new X(r, i.getLineMaxColumn(r)), "right", a);
          }
          return null;
        }
        _findMousePosition(e, t) {
          const i = this._getPositionOutsideEditor(e);
          if (i) return i;
          const n = this._createMouseTarget(e, t);
          if (!n.position) return null;
          if (n.type === 8 || n.type === 5) {
            const r = this._helpPositionJumpOverViewZone(n.detail);
            if (r) return es.createViewZone(n.type, n.element, n.mouseColumn, r, n.detail);
          }
          return n;
        }
        _helpPositionJumpOverViewZone(e) {
          const t = new X(this._currentSelection.selectionStartLineNumber, this._currentSelection.selectionStartColumn), i = e.positionBefore, n = e.positionAfter;
          return i && n ? i.isBefore(t) ? i : n : null;
        }
        _dispatchMouse(e, t, i) {
          e.position && this._viewController.dispatchMouse({
            position: e.position,
            mouseColumn: e.mouseColumn,
            startedOnLineNumbers: this._mouseState.startedOnLineNumbers,
            revealType: i,
            inSelectionMode: t,
            mouseDownCount: this._mouseState.count,
            altKey: this._mouseState.altKey,
            ctrlKey: this._mouseState.ctrlKey,
            metaKey: this._mouseState.metaKey,
            shiftKey: this._mouseState.shiftKey,
            leftButton: this._mouseState.leftButton,
            middleButton: this._mouseState.middleButton,
            onInjectedText: e.type === 6 && e.detail.injectedText !== null
          });
        }
      }
      class yle extends he {
        constructor(e, t, i, n) {
          super(), this._context = e, this._viewHelper = t, this._mouseTargetFactory = i, this._dispatchMouse = n, this._operation = null;
        }
        dispose() {
          super.dispose(), this.stop();
        }
        start(e, t) {
          this._operation ? this._operation.setPosition(e, t) : this._operation = new Sle(this._context, this._viewHelper, this._mouseTargetFactory, this._dispatchMouse, e, t);
        }
        stop() {
          this._operation && (this._operation.dispose(), this._operation = null);
        }
      }
      class Sle extends he {
        constructor(e, t, i, n, o, r) {
          super(), this._context = e, this._viewHelper = t, this._mouseTargetFactory = i, this._dispatchMouse = n, this._position = o, this._mouseEvent = r, this._lastTime = Date.now(), this._animationFrameDisposable = Gs(Oe(r.browserEvent), () => this._execute());
        }
        dispose() {
          this._animationFrameDisposable.dispose(), super.dispose();
        }
        setPosition(e, t) {
          this._position = e, this._mouseEvent = t;
        }
        _tick() {
          const e = Date.now(), t = e - this._lastTime;
          return this._lastTime = e, t;
        }
        _getScrollSpeed() {
          const e = this._context.configuration.options.get(67), t = this._context.configuration.options.get(146).height / e, i = this._position.outsideDistance / e;
          return i <= 1.5 ? Math.max(30, t * (1 + i)) : i <= 3 ? Math.max(60, t * (2 + i)) : Math.max(200, t * (7 + i));
        }
        _execute() {
          const e = this._context.configuration.options.get(67), t = this._getScrollSpeed(), i = this._tick(), n = t * (i / 1e3) * e, o = this._position.outsidePosition === "above" ? -n : n;
          this._context.viewModel.viewLayout.deltaScrollNow(0, o), this._viewHelper.renderNow();
          const r = this._context.viewLayout.getLinesViewportData(), a = this._position.outsidePosition === "above" ? r.startLineNumber : r.endLineNumber;
          let l;
          {
            const u = GN(this._viewHelper.viewDomNode), d = this._context.configuration.options.get(146).horizontalScrollbarHeight, f = new Ww(this._mouseEvent.pos.x, u.y + u.height - d - 0.1), m = YN(this._viewHelper.viewDomNode, u, f);
            l = this._mouseTargetFactory.createMouseTarget(this._viewHelper.getLastRenderData(), u, f, m, null);
          }
          (!l.position || l.position.lineNumber !== a) && (this._position.outsidePosition === "above" ? l = es.createOutsideEditor(this._position.mouseColumn, new X(a, 1), "above", this._position.outsideDistance) : l = es.createOutsideEditor(this._position.mouseColumn, new X(a, this._context.viewModel.getLineMaxColumn(a)), "below", this._position.outsideDistance)), this._dispatchMouse(l, true, 2), this._animationFrameDisposable = Gs(Oe(l.element), () => this._execute());
        }
      }
      const _QN = class _QN {
        get altKey() {
          return this._altKey;
        }
        get ctrlKey() {
          return this._ctrlKey;
        }
        get metaKey() {
          return this._metaKey;
        }
        get shiftKey() {
          return this._shiftKey;
        }
        get leftButton() {
          return this._leftButton;
        }
        get middleButton() {
          return this._middleButton;
        }
        get startedOnLineNumbers() {
          return this._startedOnLineNumbers;
        }
        constructor() {
          this._altKey = false, this._ctrlKey = false, this._metaKey = false, this._shiftKey = false, this._leftButton = false, this._middleButton = false, this._startedOnLineNumbers = false, this._lastMouseDownPosition = null, this._lastMouseDownPositionEqualCount = 0, this._lastMouseDownCount = 0, this._lastSetMouseDownCountTime = 0, this.isDragAndDrop = false;
        }
        get count() {
          return this._lastMouseDownCount;
        }
        setModifiers(e) {
          this._altKey = e.altKey, this._ctrlKey = e.ctrlKey, this._metaKey = e.metaKey, this._shiftKey = e.shiftKey;
        }
        setStartButtons(e) {
          this._leftButton = e.leftButton, this._middleButton = e.middleButton;
        }
        setStartedOnLineNumbers(e) {
          this._startedOnLineNumbers = e;
        }
        trySetCount(e, t) {
          const i = (/* @__PURE__ */ new Date()).getTime();
          i - this._lastSetMouseDownCountTime > _QN.CLEAR_MOUSE_DOWN_COUNT_TIME && (e = 1), this._lastSetMouseDownCountTime = i, e > this._lastMouseDownCount + 1 && (e = this._lastMouseDownCount + 1), this._lastMouseDownPosition && this._lastMouseDownPosition.equals(t) ? this._lastMouseDownPositionEqualCount++ : this._lastMouseDownPositionEqualCount = 1, this._lastMouseDownPosition = t, this._lastMouseDownCount = Math.min(e, this._lastMouseDownPositionEqualCount);
        }
      };
      _QN.CLEAR_MOUSE_DOWN_COUNT_TIME = 400;
      let QN = _QN;
      const _An = class _An {
        constructor(e, t, i, n, o) {
          this.value = e, this.selectionStart = t, this.selectionEnd = i, this.selection = n, this.newlineCountBeforeSelection = o;
        }
        toString() {
          return `[ <${this.value}>, selectionStart: ${this.selectionStart}, selectionEnd: ${this.selectionEnd}]`;
        }
        static readFromTextArea(e, t) {
          const i = e.getValue(), n = e.getSelectionStart(), o = e.getSelectionEnd();
          let r;
          if (t) {
            const a = i.substring(0, n), l = t.value.substring(0, t.selectionStart);
            a === l && (r = t.newlineCountBeforeSelection);
          }
          return new _An(i, n, o, null, r);
        }
        collapseSelection() {
          return this.selectionStart === this.value.length ? this : new _An(this.value, this.value.length, this.value.length, null, void 0);
        }
        writeToTextArea(e, t, i) {
          t.setValue(e, this.value), i && t.setSelectionRange(e, this.selectionStart, this.selectionEnd);
        }
        deduceEditorPosition(e) {
          var _a3, _b3, _c2, _d2;
          if (e <= this.selectionStart) {
            const n = this.value.substring(e, this.selectionStart);
            return this._finishDeduceEditorPosition(((_a3 = this.selection) == null ? void 0 : _a3.getStartPosition()) ?? null, n, -1);
          }
          if (e >= this.selectionEnd) {
            const n = this.value.substring(this.selectionEnd, e);
            return this._finishDeduceEditorPosition(((_b3 = this.selection) == null ? void 0 : _b3.getEndPosition()) ?? null, n, 1);
          }
          const t = this.value.substring(this.selectionStart, e);
          if (t.indexOf("\u2026") === -1) return this._finishDeduceEditorPosition(((_c2 = this.selection) == null ? void 0 : _c2.getStartPosition()) ?? null, t, 1);
          const i = this.value.substring(e, this.selectionEnd);
          return this._finishDeduceEditorPosition(((_d2 = this.selection) == null ? void 0 : _d2.getEndPosition()) ?? null, i, -1);
        }
        _finishDeduceEditorPosition(e, t, i) {
          let n = 0, o = -1;
          for (; (o = t.indexOf(`
`, o + 1)) !== -1; ) n++;
          return [
            e,
            i * t.length,
            n
          ];
        }
        static deduceInput(e, t, i) {
          if (!e) return {
            text: "",
            replacePrevCharCnt: 0,
            replaceNextCharCnt: 0,
            positionDelta: 0
          };
          const n = Math.min(Ok(e.value, t.value), e.selectionStart, t.selectionStart), o = Math.min(Pk(e.value, t.value), e.value.length - e.selectionEnd, t.value.length - t.selectionEnd);
          e.value.substring(n, e.value.length - o);
          const r = t.value.substring(n, t.value.length - o), a = e.selectionStart - n, l = e.selectionEnd - n, u = t.selectionStart - n, d = t.selectionEnd - n;
          if (u === d) {
            const m = e.selectionStart - n;
            return {
              text: r,
              replacePrevCharCnt: m,
              replaceNextCharCnt: 0,
              positionDelta: 0
            };
          }
          const f = l - a;
          return {
            text: r,
            replacePrevCharCnt: f,
            replaceNextCharCnt: 0,
            positionDelta: 0
          };
        }
        static deduceAndroidCompositionInput(e, t) {
          if (!e) return {
            text: "",
            replacePrevCharCnt: 0,
            replaceNextCharCnt: 0,
            positionDelta: 0
          };
          if (e.value === t.value) return {
            text: "",
            replacePrevCharCnt: 0,
            replaceNextCharCnt: 0,
            positionDelta: t.selectionEnd - e.selectionEnd
          };
          const i = Math.min(Ok(e.value, t.value), e.selectionEnd), n = Math.min(Pk(e.value, t.value), e.value.length - e.selectionEnd), o = e.value.substring(i, e.value.length - n), r = t.value.substring(i, t.value.length - n);
          e.selectionStart - i;
          const a = e.selectionEnd - i;
          t.selectionStart - i;
          const l = t.selectionEnd - i;
          return {
            text: r,
            replacePrevCharCnt: a,
            replaceNextCharCnt: o.length - a,
            positionDelta: l - r.length
          };
        }
      };
      _An.EMPTY = new _An("", 0, 0, null, void 0);
      let An = _An;
      class xf {
        static _getPageOfLine(e, t) {
          return Math.floor((e - 1) / t);
        }
        static _getRangeForPage(e, t) {
          const i = e * t, n = i + 1, o = i + t;
          return new z(n, 1, o + 1, 1);
        }
        static fromEditorSelection(e, t, i, n) {
          const r = xf._getPageOfLine(t.startLineNumber, i), a = xf._getRangeForPage(r, i), l = xf._getPageOfLine(t.endLineNumber, i), u = xf._getRangeForPage(l, i);
          let d = a.intersectRanges(new z(1, 1, t.startLineNumber, t.startColumn));
          if (n && e.getValueLengthInRange(d, 1) > 500) {
            const x = e.modifyPosition(d.getEndPosition(), -500);
            d = z.fromPositions(x, d.getEndPosition());
          }
          const f = e.getValueInRange(d, 1), m = e.getLineCount(), _ = e.getLineMaxColumn(m);
          let b = u.intersectRanges(new z(t.endLineNumber, t.endColumn, m, _));
          if (n && e.getValueLengthInRange(b, 1) > 500) {
            const x = e.modifyPosition(b.getStartPosition(), 500);
            b = z.fromPositions(b.getStartPosition(), x);
          }
          const v = e.getValueInRange(b, 1);
          let y;
          if (r === l || r + 1 === l) y = e.getValueInRange(t, 1);
          else {
            const x = a.intersectRanges(t), L = u.intersectRanges(t);
            y = e.getValueInRange(x, 1) + "\u2026" + e.getValueInRange(L, 1);
          }
          return n && y.length > 2 * 500 && (y = y.substring(0, 500) + "\u2026" + y.substring(y.length - 500, y.length)), new An(f + y + v, f.length, f.length + y.length, t, d.endLineNumber - d.startLineNumber);
        }
      }
      var Lle = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      }, A3 = function(s, e) {
        return function(t, i) {
          e(t, i, s);
        };
      }, gC;
      (function(s) {
        s.Tap = "-monaco-textarea-synthetic-tap";
      })(gC || (gC = {}));
      const _mC = class _mC {
        constructor() {
          this._lastState = null;
        }
        set(e, t) {
          this._lastState = {
            lastCopiedValue: e,
            data: t
          };
        }
        get(e) {
          return this._lastState && this._lastState.lastCopiedValue === e ? this._lastState.data : (this._lastState = null, null);
        }
      };
      _mC.INSTANCE = new _mC();
      let mC = _mC;
      class xle {
        constructor() {
          this._lastTypeTextLength = 0;
        }
        handleCompositionUpdate(e) {
          e = e || "";
          const t = {
            text: e,
            replacePrevCharCnt: this._lastTypeTextLength,
            replaceNextCharCnt: 0,
            positionDelta: 0
          };
          return this._lastTypeTextLength = e.length, t;
        }
      }
      let G2 = class extends he {
        get textAreaState() {
          return this._textAreaState;
        }
        constructor(e, t, i, n, o, r) {
          super(), this._host = e, this._textArea = t, this._OS = i, this._browser = n, this._accessibilityService = o, this._logService = r, this._onFocus = this._register(new G()), this.onFocus = this._onFocus.event, this._onBlur = this._register(new G()), this.onBlur = this._onBlur.event, this._onKeyDown = this._register(new G()), this.onKeyDown = this._onKeyDown.event, this._onKeyUp = this._register(new G()), this.onKeyUp = this._onKeyUp.event, this._onCut = this._register(new G()), this.onCut = this._onCut.event, this._onPaste = this._register(new G()), this.onPaste = this._onPaste.event, this._onType = this._register(new G()), this.onType = this._onType.event, this._onCompositionStart = this._register(new G()), this.onCompositionStart = this._onCompositionStart.event, this._onCompositionUpdate = this._register(new G()), this.onCompositionUpdate = this._onCompositionUpdate.event, this._onCompositionEnd = this._register(new G()), this.onCompositionEnd = this._onCompositionEnd.event, this._onSelectionChangeRequest = this._register(new G()), this.onSelectionChangeRequest = this._onSelectionChangeRequest.event, this._asyncFocusGainWriteScreenReaderContent = this._register(new Ul()), this._asyncTriggerCut = this._register(new ns(() => this._onCut.fire(), 0)), this._textAreaState = An.EMPTY, this._selectionChangeListener = null, this._accessibilityService.isScreenReaderOptimized() && this.writeNativeTextAreaContent("ctor"), this._register(be.runAndSubscribe(this._accessibilityService.onDidChangeScreenReaderOptimized, () => {
            this._accessibilityService.isScreenReaderOptimized() && !this._asyncFocusGainWriteScreenReaderContent.value ? this._asyncFocusGainWriteScreenReaderContent.value = this._register(new ns(() => this.writeNativeTextAreaContent("asyncFocusGain"), 0)) : this._asyncFocusGainWriteScreenReaderContent.clear();
          })), this._hasFocus = false, this._currentComposition = null;
          let a = null;
          this._register(this._textArea.onKeyDown((l) => {
            const u = new si(l);
            (u.keyCode === 114 || this._currentComposition && u.keyCode === 1) && u.stopPropagation(), u.equals(9) && u.preventDefault(), a = u, this._onKeyDown.fire(u);
          })), this._register(this._textArea.onKeyUp((l) => {
            const u = new si(l);
            this._onKeyUp.fire(u);
          })), this._register(this._textArea.onCompositionStart((l) => {
            const u = new xle();
            if (this._currentComposition) {
              this._currentComposition = u;
              return;
            }
            if (this._currentComposition = u, this._OS === 2 && a && a.equals(114) && this._textAreaState.selectionStart === this._textAreaState.selectionEnd && this._textAreaState.selectionStart > 0 && this._textAreaState.value.substr(this._textAreaState.selectionStart - 1, 1) === l.data && (a.code === "ArrowRight" || a.code === "ArrowLeft")) {
              u.handleCompositionUpdate("x"), this._onCompositionStart.fire({
                data: l.data
              });
              return;
            }
            if (this._browser.isAndroid) {
              this._onCompositionStart.fire({
                data: l.data
              });
              return;
            }
            this._onCompositionStart.fire({
              data: l.data
            });
          })), this._register(this._textArea.onCompositionUpdate((l) => {
            const u = this._currentComposition;
            if (!u) return;
            if (this._browser.isAndroid) {
              const f = An.readFromTextArea(this._textArea, this._textAreaState), m = An.deduceAndroidCompositionInput(this._textAreaState, f);
              this._textAreaState = f, this._onType.fire(m), this._onCompositionUpdate.fire(l);
              return;
            }
            const d = u.handleCompositionUpdate(l.data);
            this._textAreaState = An.readFromTextArea(this._textArea, this._textAreaState), this._onType.fire(d), this._onCompositionUpdate.fire(l);
          })), this._register(this._textArea.onCompositionEnd((l) => {
            const u = this._currentComposition;
            if (!u) return;
            if (this._currentComposition = null, this._browser.isAndroid) {
              const f = An.readFromTextArea(this._textArea, this._textAreaState), m = An.deduceAndroidCompositionInput(this._textAreaState, f);
              this._textAreaState = f, this._onType.fire(m), this._onCompositionEnd.fire();
              return;
            }
            const d = u.handleCompositionUpdate(l.data);
            this._textAreaState = An.readFromTextArea(this._textArea, this._textAreaState), this._onType.fire(d), this._onCompositionEnd.fire();
          })), this._register(this._textArea.onInput((l) => {
            if (this._textArea.setIgnoreSelectionChangeTime("received input event"), this._currentComposition) return;
            const u = An.readFromTextArea(this._textArea, this._textAreaState), d = An.deduceInput(this._textAreaState, u, this._OS === 2);
            d.replacePrevCharCnt === 0 && d.text.length === 1 && (on(d.text.charCodeAt(0)) || d.text.charCodeAt(0) === 127) || (this._textAreaState = u, (d.text !== "" || d.replacePrevCharCnt !== 0 || d.replaceNextCharCnt !== 0 || d.positionDelta !== 0) && this._onType.fire(d));
          })), this._register(this._textArea.onCut((l) => {
            this._textArea.setIgnoreSelectionChangeTime("received cut event"), this._ensureClipboardGetsEditorSelection(l), this._asyncTriggerCut.schedule();
          })), this._register(this._textArea.onCopy((l) => {
            this._ensureClipboardGetsEditorSelection(l);
          })), this._register(this._textArea.onPaste((l) => {
            if (this._textArea.setIgnoreSelectionChangeTime("received paste event"), l.preventDefault(), !l.clipboardData) return;
            let [u, d] = R3.getTextData(l.clipboardData);
            u && (d = d || mC.INSTANCE.get(u), this._onPaste.fire({
              text: u,
              metadata: d
            }));
          })), this._register(this._textArea.onFocus(() => {
            const l = this._hasFocus;
            this._setHasFocus(true), this._accessibilityService.isScreenReaderOptimized() && this._browser.isSafari && !l && this._hasFocus && (this._asyncFocusGainWriteScreenReaderContent.value || (this._asyncFocusGainWriteScreenReaderContent.value = new ns(() => this.writeNativeTextAreaContent("asyncFocusGain"), 0)), this._asyncFocusGainWriteScreenReaderContent.value.schedule());
          })), this._register(this._textArea.onBlur(() => {
            this._currentComposition && (this._currentComposition = null, this.writeNativeTextAreaContent("blurWithoutCompositionEnd"), this._onCompositionEnd.fire()), this._setHasFocus(false);
          })), this._register(this._textArea.onSyntheticTap(() => {
            this._browser.isAndroid && this._currentComposition && (this._currentComposition = null, this.writeNativeTextAreaContent("tapWithoutCompositionEnd"), this._onCompositionEnd.fire());
          }));
        }
        _installSelectionChangeListener() {
          let e = 0;
          return re(this._textArea.ownerDocument, "selectionchange", (t) => {
            if (Kc.onSelectionChange(), !this._hasFocus || this._currentComposition || !this._browser.isChrome) return;
            const i = Date.now(), n = i - e;
            if (e = i, n < 5) return;
            const o = i - this._textArea.getIgnoreSelectionChangeTime();
            if (this._textArea.resetSelectionChangeTime(), o < 100 || !this._textAreaState.selection) return;
            const r = this._textArea.getValue();
            if (this._textAreaState.value !== r) return;
            const a = this._textArea.getSelectionStart(), l = this._textArea.getSelectionEnd();
            if (this._textAreaState.selectionStart === a && this._textAreaState.selectionEnd === l) return;
            const u = this._textAreaState.deduceEditorPosition(a), d = this._host.deduceModelPosition(u[0], u[1], u[2]), f = this._textAreaState.deduceEditorPosition(l), m = this._host.deduceModelPosition(f[0], f[1], f[2]), _ = new mt(d.lineNumber, d.column, m.lineNumber, m.column);
            this._onSelectionChangeRequest.fire(_);
          });
        }
        dispose() {
          super.dispose(), this._selectionChangeListener && (this._selectionChangeListener.dispose(), this._selectionChangeListener = null);
        }
        focusTextArea() {
          this._setHasFocus(true), this.refreshFocusState();
        }
        isFocused() {
          return this._hasFocus;
        }
        refreshFocusState() {
          this._setHasFocus(this._textArea.hasFocus());
        }
        _setHasFocus(e) {
          this._hasFocus !== e && (this._hasFocus = e, this._selectionChangeListener && (this._selectionChangeListener.dispose(), this._selectionChangeListener = null), this._hasFocus && (this._selectionChangeListener = this._installSelectionChangeListener()), this._hasFocus && this.writeNativeTextAreaContent("focusgain"), this._hasFocus ? this._onFocus.fire() : this._onBlur.fire());
        }
        _setAndWriteTextAreaState(e, t) {
          this._hasFocus || (t = t.collapseSelection()), t.writeToTextArea(e, this._textArea, this._hasFocus), this._textAreaState = t;
        }
        writeNativeTextAreaContent(e) {
          !this._accessibilityService.isScreenReaderOptimized() && e === "render" || this._currentComposition || (this._logService.trace(`writeTextAreaState(reason: ${e})`), this._setAndWriteTextAreaState(e, this._host.getScreenReaderContent()));
        }
        _ensureClipboardGetsEditorSelection(e) {
          const t = this._host.getDataToCopy(), i = {
            version: 1,
            isFromEmptySelection: t.isFromEmptySelection,
            multicursorText: t.multicursorText,
            mode: t.mode
          };
          mC.INSTANCE.set(this._browser.isFirefox ? t.text.replace(/\r\n/g, `
`) : t.text, i), e.preventDefault(), e.clipboardData && R3.setTextData(e.clipboardData, t.text, t.html, i);
        }
      };
      G2 = Lle([
        A3(4, ea),
        A3(5, Xr)
      ], G2);
      const R3 = {
        getTextData(s) {
          const e = s.getData(kl.text);
          let t = null;
          const i = s.getData("vscode-editor-data");
          if (typeof i == "string") try {
            t = JSON.parse(i), t.version !== 1 && (t = null);
          } catch {
          }
          return e.length === 0 && t === null && s.files.length > 0 ? [
            Array.prototype.slice.call(s.files, 0).map((o) => o.name).join(`
`),
            null
          ] : [
            e,
            t
          ];
        },
        setTextData(s, e, t, i) {
          s.setData(kl.text, e), typeof t == "string" && s.setData("text/html", t), s.setData("vscode-editor-data", JSON.stringify(i));
        }
      };
      class kle extends he {
        get ownerDocument() {
          return this._actual.ownerDocument;
        }
        constructor(e) {
          super(), this._actual = e, this.onKeyDown = this._register(new ot(this._actual, "keydown")).event, this.onKeyUp = this._register(new ot(this._actual, "keyup")).event, this.onCompositionStart = this._register(new ot(this._actual, "compositionstart")).event, this.onCompositionUpdate = this._register(new ot(this._actual, "compositionupdate")).event, this.onCompositionEnd = this._register(new ot(this._actual, "compositionend")).event, this.onBeforeInput = this._register(new ot(this._actual, "beforeinput")).event, this.onInput = this._register(new ot(this._actual, "input")).event, this.onCut = this._register(new ot(this._actual, "cut")).event, this.onCopy = this._register(new ot(this._actual, "copy")).event, this.onPaste = this._register(new ot(this._actual, "paste")).event, this.onFocus = this._register(new ot(this._actual, "focus")).event, this.onBlur = this._register(new ot(this._actual, "blur")).event, this._onSyntheticTap = this._register(new G()), this.onSyntheticTap = this._onSyntheticTap.event, this._ignoreSelectionChangeTime = 0, this._register(this.onKeyDown(() => Kc.onKeyDown())), this._register(this.onBeforeInput(() => Kc.onBeforeInput())), this._register(this.onInput(() => Kc.onInput())), this._register(this.onKeyUp(() => Kc.onKeyUp())), this._register(re(this._actual, gC.Tap, () => this._onSyntheticTap.fire()));
        }
        hasFocus() {
          const e = ng(this._actual);
          return e ? e.activeElement === this._actual : this._actual.isConnected ? ss() === this._actual : false;
        }
        setIgnoreSelectionChangeTime(e) {
          this._ignoreSelectionChangeTime = Date.now();
        }
        getIgnoreSelectionChangeTime() {
          return this._ignoreSelectionChangeTime;
        }
        resetSelectionChangeTime() {
          this._ignoreSelectionChangeTime = 0;
        }
        getValue() {
          return this._actual.value;
        }
        setValue(e, t) {
          const i = this._actual;
          i.value !== t && (this.setIgnoreSelectionChangeTime("setValue"), i.value = t);
        }
        getSelectionStart() {
          return this._actual.selectionDirection === "backward" ? this._actual.selectionEnd : this._actual.selectionStart;
        }
        getSelectionEnd() {
          return this._actual.selectionDirection === "backward" ? this._actual.selectionStart : this._actual.selectionEnd;
        }
        setSelectionRange(e, t, i) {
          const n = this._actual;
          let o = null;
          const r = ng(n);
          r ? o = r.activeElement : o = ss();
          const a = Oe(o), l = o === n, u = n.selectionStart, d = n.selectionEnd;
          if (l && u === t && d === i) {
            pr && a.parent !== a && n.focus();
            return;
          }
          if (l) {
            this.setIgnoreSelectionChangeTime("setSelectionRange"), n.setSelectionRange(t, i), pr && a.parent !== a && n.focus();
            return;
          }
          try {
            const f = zK(n);
            this.setIgnoreSelectionChangeTime("setSelectionRange"), n.focus(), n.setSelectionRange(t, i), UK(n, f);
          } catch {
          }
        }
      }
      class Dle extends ZN {
        constructor(e, t, i) {
          super(e, t, i), this._register(ui.addTarget(this.viewHelper.linesContentDomNode)), this._register(re(this.viewHelper.linesContentDomNode, Qt.Tap, (o) => this.onTap(o))), this._register(re(this.viewHelper.linesContentDomNode, Qt.Change, (o) => this.onChange(o))), this._register(re(this.viewHelper.linesContentDomNode, Qt.Contextmenu, (o) => this._onContextMenu(new cu(o, false, this.viewHelper.viewDomNode), false))), this._lastPointerType = "mouse", this._register(re(this.viewHelper.linesContentDomNode, "pointerdown", (o) => {
            const r = o.pointerType;
            if (r === "mouse") {
              this._lastPointerType = "mouse";
              return;
            } else r === "touch" ? this._lastPointerType = "touch" : this._lastPointerType = "pen";
          }));
          const n = new ole(this.viewHelper.viewDomNode);
          this._register(n.onPointerMove(this.viewHelper.viewDomNode, (o) => this._onMouseMove(o))), this._register(n.onPointerUp(this.viewHelper.viewDomNode, (o) => this._onMouseUp(o))), this._register(n.onPointerLeave(this.viewHelper.viewDomNode, (o) => this._onMouseLeave(o))), this._register(n.onPointerDown(this.viewHelper.viewDomNode, (o, r) => this._onMouseDown(o, r)));
        }
        onTap(e) {
          !e.initialTarget || !this.viewHelper.linesContentDomNode.contains(e.initialTarget) || (e.preventDefault(), this.viewHelper.focusTextArea(), this._dispatchGesture(e, false));
        }
        onChange(e) {
          this._lastPointerType === "touch" && this._context.viewModel.viewLayout.deltaScrollNow(-e.translationX, -e.translationY), this._lastPointerType === "pen" && this._dispatchGesture(e, true);
        }
        _dispatchGesture(e, t) {
          const i = this._createMouseTarget(new cu(e, false, this.viewHelper.viewDomNode), false);
          i.position && this.viewController.dispatchMouse({
            position: i.position,
            mouseColumn: i.position.column,
            startedOnLineNumbers: false,
            revealType: 1,
            mouseDownCount: e.tapCount,
            inSelectionMode: t,
            altKey: false,
            ctrlKey: false,
            metaKey: false,
            shiftKey: false,
            leftButton: false,
            middleButton: false,
            onInjectedText: i.type === 6 && i.detail.injectedText !== null
          });
        }
        _onMouseDown(e, t) {
          e.browserEvent.pointerType !== "touch" && super._onMouseDown(e, t);
        }
      }
      class Ele extends ZN {
        constructor(e, t, i) {
          super(e, t, i), this._register(ui.addTarget(this.viewHelper.linesContentDomNode)), this._register(re(this.viewHelper.linesContentDomNode, Qt.Tap, (n) => this.onTap(n))), this._register(re(this.viewHelper.linesContentDomNode, Qt.Change, (n) => this.onChange(n))), this._register(re(this.viewHelper.linesContentDomNode, Qt.Contextmenu, (n) => this._onContextMenu(new cu(n, false, this.viewHelper.viewDomNode), false)));
        }
        onTap(e) {
          e.preventDefault(), this.viewHelper.focusTextArea();
          const t = this._createMouseTarget(new cu(e, false, this.viewHelper.viewDomNode), false);
          if (t.position) {
            const i = document.createEvent("CustomEvent");
            i.initEvent(gC.Tap, false, true), this.viewHelper.dispatchTextAreaEvent(i), this.viewController.moveTo(t.position, 1);
          }
        }
        onChange(e) {
          this._context.viewModel.viewLayout.deltaScrollNow(-e.translationX, -e.translationY);
        }
      }
      class Tle extends he {
        constructor(e, t, i) {
          super(), (Ih || WU && e9) && I9.pointerEvents ? this.handler = this._register(new Dle(e, t, i)) : Kt.TouchEvent ? this.handler = this._register(new Ele(e, t, i)) : this.handler = this._register(new ZN(e, t, i));
        }
        getTargetAtClientPoint(e, t) {
          return this.handler.getTargetAtClientPoint(e, t);
        }
      }
      class sd extends a1 {
      }
      const _zw = class _zw extends sd {
        constructor(e) {
          super(), this._context = e, this._readConfig(), this._lastCursorModelPosition = new X(1, 1), this._renderResult = null, this._activeLineNumber = 1, this._context.addEventHandler(this);
        }
        _readConfig() {
          const e = this._context.configuration.options;
          this._lineHeight = e.get(67);
          const t = e.get(68);
          this._renderLineNumbers = t.renderType, this._renderCustomLineNumbers = t.renderFn, this._renderFinalNewline = e.get(96);
          const i = e.get(146);
          this._lineNumbersLeft = i.lineNumbersLeft, this._lineNumbersWidth = i.lineNumbersWidth;
        }
        dispose() {
          this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
        }
        onConfigurationChanged(e) {
          return this._readConfig(), true;
        }
        onCursorStateChanged(e) {
          const t = e.selections[0].getPosition();
          this._lastCursorModelPosition = this._context.viewModel.coordinatesConverter.convertViewPositionToModelPosition(t);
          let i = false;
          return this._activeLineNumber !== t.lineNumber && (this._activeLineNumber = t.lineNumber, i = true), (this._renderLineNumbers === 2 || this._renderLineNumbers === 3) && (i = true), i;
        }
        onFlushed(e) {
          return true;
        }
        onLinesChanged(e) {
          return true;
        }
        onLinesDeleted(e) {
          return true;
        }
        onLinesInserted(e) {
          return true;
        }
        onScrollChanged(e) {
          return e.scrollTopChanged;
        }
        onZonesChanged(e) {
          return true;
        }
        onDecorationsChanged(e) {
          return e.affectsLineNumber;
        }
        _getLineRenderLineNumber(e) {
          const t = this._context.viewModel.coordinatesConverter.convertViewPositionToModelPosition(new X(e, 1));
          if (t.column !== 1) return "";
          const i = t.lineNumber;
          if (this._renderCustomLineNumbers) return this._renderCustomLineNumbers(i);
          if (this._renderLineNumbers === 2) {
            const n = Math.abs(this._lastCursorModelPosition.lineNumber - i);
            return n === 0 ? '<span class="relative-current-line-number">' + i + "</span>" : String(n);
          }
          if (this._renderLineNumbers === 3) {
            if (this._lastCursorModelPosition.lineNumber === i || i % 10 === 0) return String(i);
            const n = this._context.viewModel.getLineCount();
            return i === n ? String(i) : "";
          }
          return String(i);
        }
        prepareRender(e) {
          if (this._renderLineNumbers === 0) {
            this._renderResult = null;
            return;
          }
          const t = Is ? this._lineHeight % 2 === 0 ? " lh-even" : " lh-odd" : "", i = e.visibleRange.startLineNumber, n = e.visibleRange.endLineNumber, o = this._context.viewModel.getDecorationsInViewport(e.visibleRange).filter((u) => !!u.options.lineNumberClassName);
          o.sort((u, d) => z.compareRangesUsingEnds(u.range, d.range));
          let r = 0;
          const a = this._context.viewModel.getLineCount(), l = [];
          for (let u = i; u <= n; u++) {
            const d = u - i;
            let f = this._getLineRenderLineNumber(u), m = "";
            for (; r < o.length && o[r].range.endLineNumber < u; ) r++;
            for (let _ = r; _ < o.length; _++) {
              const { range: b, options: v } = o[_];
              b.startLineNumber <= u && (m += " " + v.lineNumberClassName);
            }
            if (!f && !m) {
              l[d] = "";
              continue;
            }
            u === a && this._context.viewModel.getLineLength(u) === 0 && (this._renderFinalNewline === "off" && (f = ""), this._renderFinalNewline === "dimmed" && (m += " dimmed-line-number")), u === this._activeLineNumber && (m += " active-line-number"), l[d] = `<div class="${_zw.CLASS_NAME}${t}${m}" style="left:${this._lineNumbersLeft}px;width:${this._lineNumbersWidth}px;">${f}</div>`;
          }
          this._renderResult = l;
        }
        render(e, t) {
          if (!this._renderResult) return "";
          const i = t - e;
          return i < 0 || i >= this._renderResult.length ? "" : this._renderResult[i];
        }
      };
      _zw.CLASS_NAME = "line-numbers";
      let zw = _zw;
      jl((s, e) => {
        const t = s.getColor(oie), i = s.getColor(vie);
        i ? e.addRule(`.monaco-editor .line-numbers.dimmed-line-number { color: ${i}; }`) : t && e.addRule(`.monaco-editor .line-numbers.dimmed-line-number { color: ${t.transparent(0.4)}; }`);
      });
      const _k_ = class _k_ extends Zs {
        constructor(e) {
          super(e);
          const t = this._context.configuration.options, i = t.get(146);
          this._canUseLayerHinting = !t.get(32), this._contentLeft = i.contentLeft, this._glyphMarginLeft = i.glyphMarginLeft, this._glyphMarginWidth = i.glyphMarginWidth, this._domNode = St(document.createElement("div")), this._domNode.setClassName(_k_.OUTER_CLASS_NAME), this._domNode.setPosition("absolute"), this._domNode.setAttribute("role", "presentation"), this._domNode.setAttribute("aria-hidden", "true"), this._glyphMarginBackgroundDomNode = St(document.createElement("div")), this._glyphMarginBackgroundDomNode.setClassName(_k_.CLASS_NAME), this._domNode.appendChild(this._glyphMarginBackgroundDomNode);
        }
        dispose() {
          super.dispose();
        }
        getDomNode() {
          return this._domNode;
        }
        onConfigurationChanged(e) {
          const t = this._context.configuration.options, i = t.get(146);
          return this._canUseLayerHinting = !t.get(32), this._contentLeft = i.contentLeft, this._glyphMarginLeft = i.glyphMarginLeft, this._glyphMarginWidth = i.glyphMarginWidth, true;
        }
        onScrollChanged(e) {
          return super.onScrollChanged(e) || e.scrollTopChanged;
        }
        prepareRender(e) {
        }
        render(e) {
          this._domNode.setLayerHinting(this._canUseLayerHinting), this._domNode.setContain("strict");
          const t = e.scrollTop - e.bigNumbersDelta;
          this._domNode.setTop(-t);
          const i = Math.min(e.scrollHeight, 1e6);
          this._domNode.setHeight(i), this._domNode.setWidth(this._contentLeft), this._glyphMarginBackgroundDomNode.setLeft(this._glyphMarginLeft), this._glyphMarginBackgroundDomNode.setWidth(this._glyphMarginWidth), this._glyphMarginBackgroundDomNode.setHeight(i);
        }
      };
      _k_.CLASS_NAME = "glyph-margin";
      _k_.OUTER_CLASS_NAME = "margin";
      let k_ = _k_;
      const Qf = "monaco-mouse-cursor-text";
      var Nle = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      }, O3 = function(s, e) {
        return function(t, i) {
          e(t, i, s);
        };
      };
      class Ile {
        constructor(e, t, i, n, o) {
          this._context = e, this.modelLineNumber = t, this.distanceToModelLineStart = i, this.widthOfHiddenLineTextBefore = n, this.distanceToModelLineEnd = o, this._visibleTextAreaBrand = void 0, this.startPosition = null, this.endPosition = null, this.visibleTextareaStart = null, this.visibleTextareaEnd = null, this._previousPresentation = null;
        }
        prepareRender(e) {
          const t = new X(this.modelLineNumber, this.distanceToModelLineStart + 1), i = new X(this.modelLineNumber, this._context.viewModel.model.getLineMaxColumn(this.modelLineNumber) - this.distanceToModelLineEnd);
          this.startPosition = this._context.viewModel.coordinatesConverter.convertModelPositionToViewPosition(t), this.endPosition = this._context.viewModel.coordinatesConverter.convertModelPositionToViewPosition(i), this.startPosition.lineNumber === this.endPosition.lineNumber ? (this.visibleTextareaStart = e.visibleRangeForPosition(this.startPosition), this.visibleTextareaEnd = e.visibleRangeForPosition(this.endPosition)) : (this.visibleTextareaStart = null, this.visibleTextareaEnd = null);
        }
        definePresentation(e) {
          return this._previousPresentation || (e ? this._previousPresentation = e : this._previousPresentation = {
            foreground: 1,
            italic: false,
            bold: false,
            underline: false,
            strikethrough: false
          }), this._previousPresentation;
        }
      }
      const bx = pr;
      let Y2 = class extends Zs {
        constructor(e, t, i, n, o) {
          super(e), this._keybindingService = n, this._instantiationService = o, this._primaryCursorPosition = new X(1, 1), this._primaryCursorVisibleRange = null, this._viewController = t, this._visibleRangeProvider = i, this._scrollLeft = 0, this._scrollTop = 0;
          const r = this._context.configuration.options, a = r.get(146);
          this._setAccessibilityOptions(r), this._contentLeft = a.contentLeft, this._contentWidth = a.contentWidth, this._contentHeight = a.height, this._fontInfo = r.get(50), this._lineHeight = r.get(67), this._emptySelectionClipboard = r.get(37), this._copyWithSyntaxHighlighting = r.get(25), this._visibleTextArea = null, this._selections = [
            new mt(1, 1, 1, 1)
          ], this._modelSelections = [
            new mt(1, 1, 1, 1)
          ], this._lastRenderPosition = null, this.textArea = St(document.createElement("textarea")), Yr.write(this.textArea, 7), this.textArea.setClassName(`inputarea ${Qf}`), this.textArea.setAttribute("wrap", this._textAreaWrapping && !this._visibleTextArea ? "on" : "off");
          const { tabSize: l } = this._context.viewModel.model.getOptions();
          this.textArea.domNode.style.tabSize = `${l * this._fontInfo.spaceWidth}px`, this.textArea.setAttribute("autocorrect", "off"), this.textArea.setAttribute("autocapitalize", "off"), this.textArea.setAttribute("autocomplete", "off"), this.textArea.setAttribute("spellcheck", "false"), this.textArea.setAttribute("aria-label", this._getAriaLabel(r)), this.textArea.setAttribute("aria-required", r.get(5) ? "true" : "false"), this.textArea.setAttribute("tabindex", String(r.get(125))), this.textArea.setAttribute("role", "textbox"), this.textArea.setAttribute("aria-roledescription", C("editor", "editor")), this.textArea.setAttribute("aria-multiline", "true"), this.textArea.setAttribute("aria-autocomplete", r.get(92) ? "none" : "both"), this._ensureReadOnlyAttribute(), this.textAreaCover = St(document.createElement("div")), this.textAreaCover.setPosition("absolute");
          const u = {
            getLineCount: () => this._context.viewModel.getLineCount(),
            getLineMaxColumn: (m) => this._context.viewModel.getLineMaxColumn(m),
            getValueInRange: (m, _) => this._context.viewModel.getValueInRange(m, _),
            getValueLengthInRange: (m, _) => this._context.viewModel.getValueLengthInRange(m, _),
            modifyPosition: (m, _) => this._context.viewModel.modifyPosition(m, _)
          }, d = {
            getDataToCopy: () => {
              const m = this._context.viewModel.getPlainTextToCopy(this._modelSelections, this._emptySelectionClipboard, Ks), _ = this._context.viewModel.model.getEOL(), b = this._emptySelectionClipboard && this._modelSelections.length === 1 && this._modelSelections[0].isEmpty(), v = Array.isArray(m) ? m : null, y = Array.isArray(m) ? m.join(_) : m;
              let x, L = null;
              if (this._copyWithSyntaxHighlighting && y.length < 65536) {
                const D = this._context.viewModel.getRichTextToCopy(this._modelSelections, this._emptySelectionClipboard);
                D && (x = D.html, L = D.mode);
              }
              return {
                isFromEmptySelection: b,
                multicursorText: v,
                text: y,
                html: x,
                mode: L
              };
            },
            getScreenReaderContent: () => {
              if (this._accessibilitySupport === 1) {
                const m = this._selections[0];
                if (_t && m.isEmpty()) {
                  const b = m.getStartPosition();
                  let v = this._getWordBeforePosition(b);
                  if (v.length === 0 && (v = this._getCharacterBeforePosition(b)), v.length > 0) return new An(v, v.length, v.length, z.fromPositions(b), 0);
                }
                if (_t && !m.isEmpty() && u.getValueLengthInRange(m, 0) < 500) {
                  const b = u.getValueInRange(m, 0);
                  return new An(b, 0, b.length, m, 0);
                }
                if (su && !m.isEmpty()) {
                  const b = "vscode-placeholder";
                  return new An(b, 0, b.length, null, void 0);
                }
                return An.EMPTY;
              }
              if (G4) {
                const m = this._selections[0];
                if (m.isEmpty()) {
                  const _ = m.getStartPosition(), [b, v] = this._getAndroidWordAtPosition(_);
                  if (b.length > 0) return new An(b, v, v, z.fromPositions(_), 0);
                }
                return An.EMPTY;
              }
              return xf.fromEditorSelection(u, this._selections[0], this._accessibilityPageSize, this._accessibilitySupport === 0);
            },
            deduceModelPosition: (m, _, b) => this._context.viewModel.deduceModelPositionRelativeToViewPosition(m, _, b)
          }, f = this._register(new kle(this.textArea.domNode));
          this._textAreaInput = this._register(this._instantiationService.createInstance(G2, d, f, ur, {
            isAndroid: G4,
            isChrome: V_,
            isFirefox: pr,
            isSafari: su
          })), this._register(this._textAreaInput.onKeyDown((m) => {
            this._viewController.emitKeyDown(m);
          })), this._register(this._textAreaInput.onKeyUp((m) => {
            this._viewController.emitKeyUp(m);
          })), this._register(this._textAreaInput.onPaste((m) => {
            let _ = false, b = null, v = null;
            m.metadata && (_ = this._emptySelectionClipboard && !!m.metadata.isFromEmptySelection, b = typeof m.metadata.multicursorText < "u" ? m.metadata.multicursorText : null, v = m.metadata.mode), this._viewController.paste(m.text, _, b, v);
          })), this._register(this._textAreaInput.onCut(() => {
            this._viewController.cut();
          })), this._register(this._textAreaInput.onType((m) => {
            m.replacePrevCharCnt || m.replaceNextCharCnt || m.positionDelta ? this._viewController.compositionType(m.text, m.replacePrevCharCnt, m.replaceNextCharCnt, m.positionDelta) : this._viewController.type(m.text);
          })), this._register(this._textAreaInput.onSelectionChangeRequest((m) => {
            this._viewController.setSelection(m);
          })), this._register(this._textAreaInput.onCompositionStart((m) => {
            const _ = this.textArea.domNode, b = this._modelSelections[0], { distanceToModelLineStart: v, widthOfHiddenTextBefore: y } = (() => {
              const L = _.value.substring(0, Math.min(_.selectionStart, _.selectionEnd)), D = L.lastIndexOf(`
`), k = L.substring(D + 1), T = k.lastIndexOf("	"), M = k.length - T - 1, I = b.getStartPosition(), R = Math.min(I.column - 1, M), A = I.column - 1 - R, Y = k.substring(0, k.length - R), { tabSize: U } = this._context.viewModel.model.getOptions(), j = Mle(this.textArea.domNode.ownerDocument, Y, this._fontInfo, U);
              return {
                distanceToModelLineStart: A,
                widthOfHiddenTextBefore: j
              };
            })(), { distanceToModelLineEnd: x } = (() => {
              const L = _.value.substring(Math.max(_.selectionStart, _.selectionEnd)), D = L.indexOf(`
`), k = D === -1 ? L : L.substring(0, D), T = k.indexOf("	"), M = T === -1 ? k.length : k.length - T - 1, I = b.getEndPosition(), R = Math.min(this._context.viewModel.model.getLineMaxColumn(I.lineNumber) - I.column, M);
              return {
                distanceToModelLineEnd: this._context.viewModel.model.getLineMaxColumn(I.lineNumber) - I.column - R
              };
            })();
            this._context.viewModel.revealRange("keyboard", true, z.fromPositions(this._selections[0].getStartPosition()), 0, 1), this._visibleTextArea = new Ile(this._context, b.startLineNumber, v, y, x), this.textArea.setAttribute("wrap", this._textAreaWrapping && !this._visibleTextArea ? "on" : "off"), this._visibleTextArea.prepareRender(this._visibleRangeProvider), this._render(), this.textArea.setClassName(`inputarea ${Qf} ime-input`), this._viewController.compositionStart(), this._context.viewModel.onCompositionStart();
          })), this._register(this._textAreaInput.onCompositionUpdate((m) => {
            this._visibleTextArea && (this._visibleTextArea.prepareRender(this._visibleRangeProvider), this._render());
          })), this._register(this._textAreaInput.onCompositionEnd(() => {
            this._visibleTextArea = null, this.textArea.setAttribute("wrap", this._textAreaWrapping && !this._visibleTextArea ? "on" : "off"), this._render(), this.textArea.setClassName(`inputarea ${Qf}`), this._viewController.compositionEnd(), this._context.viewModel.onCompositionEnd();
          })), this._register(this._textAreaInput.onFocus(() => {
            this._context.viewModel.setHasFocus(true);
          })), this._register(this._textAreaInput.onBlur(() => {
            this._context.viewModel.setHasFocus(false);
          })), this._register(wp.onDidChange(() => {
            this._ensureReadOnlyAttribute();
          }));
        }
        writeScreenReaderContent(e) {
          this._textAreaInput.writeNativeTextAreaContent(e);
        }
        dispose() {
          super.dispose();
        }
        _getAndroidWordAtPosition(e) {
          const t = '`~!@#$%^&*()-=+[{]}\\|;:",.<>/?', i = this._context.viewModel.getLineContent(e.lineNumber), n = rg(t, []);
          let o = true, r = e.column, a = true, l = e.column, u = 0;
          for (; u < 50 && (o || a); ) {
            if (o && r <= 1 && (o = false), o) {
              const d = i.charCodeAt(r - 2);
              n.get(d) !== 0 ? o = false : r--;
            }
            if (a && l > i.length && (a = false), a) {
              const d = i.charCodeAt(l - 1);
              n.get(d) !== 0 ? a = false : l++;
            }
            u++;
          }
          return [
            i.substring(r - 1, l - 1),
            e.column - r
          ];
        }
        _getWordBeforePosition(e) {
          const t = this._context.viewModel.getLineContent(e.lineNumber), i = rg(this._context.configuration.options.get(132), []);
          let n = e.column, o = 0;
          for (; n > 1; ) {
            const r = t.charCodeAt(n - 2);
            if (i.get(r) !== 0 || o > 50) return t.substring(n - 1, e.column - 1);
            o++, n--;
          }
          return t.substring(0, e.column - 1);
        }
        _getCharacterBeforePosition(e) {
          if (e.column > 1) {
            const i = this._context.viewModel.getLineContent(e.lineNumber).charAt(e.column - 2);
            if (!on(i.charCodeAt(0))) return i;
          }
          return "";
        }
        _getAriaLabel(e) {
          var _a3, _b3, _c2;
          if (e.get(2) === 1) {
            const i = (_a3 = this._keybindingService.lookupKeybinding("editor.action.toggleScreenReaderAccessibilityMode")) == null ? void 0 : _a3.getAriaLabel(), n = (_b3 = this._keybindingService.lookupKeybinding("workbench.action.showCommands")) == null ? void 0 : _b3.getAriaLabel(), o = (_c2 = this._keybindingService.lookupKeybinding("workbench.action.openGlobalKeybindings")) == null ? void 0 : _c2.getAriaLabel(), r = C("accessibilityModeOff", "The editor is not accessible at this time.");
            return i ? C("accessibilityOffAriaLabel", "{0} To enable screen reader optimized mode, use {1}", r, i) : n ? C("accessibilityOffAriaLabelNoKb", "{0} To enable screen reader optimized mode, open the quick pick with {1} and run the command Toggle Screen Reader Accessibility Mode, which is currently not triggerable via keyboard.", r, n) : o ? C("accessibilityOffAriaLabelNoKbs", "{0} Please assign a keybinding for the command Toggle Screen Reader Accessibility Mode by accessing the keybindings editor with {1} and run it.", r, o) : r;
          }
          return e.get(4);
        }
        _setAccessibilityOptions(e) {
          this._accessibilitySupport = e.get(2);
          const t = e.get(3);
          this._accessibilitySupport === 2 && t === Uh.accessibilityPageSize.defaultValue ? this._accessibilityPageSize = 500 : this._accessibilityPageSize = t;
          const n = e.get(146).wrappingColumn;
          if (n !== -1 && this._accessibilitySupport !== 1) {
            const o = e.get(50);
            this._textAreaWrapping = true, this._textAreaWidth = Math.round(n * o.typicalHalfwidthCharacterWidth);
          } else this._textAreaWrapping = false, this._textAreaWidth = bx ? 0 : 1;
        }
        onConfigurationChanged(e) {
          const t = this._context.configuration.options, i = t.get(146);
          this._setAccessibilityOptions(t), this._contentLeft = i.contentLeft, this._contentWidth = i.contentWidth, this._contentHeight = i.height, this._fontInfo = t.get(50), this._lineHeight = t.get(67), this._emptySelectionClipboard = t.get(37), this._copyWithSyntaxHighlighting = t.get(25), this.textArea.setAttribute("wrap", this._textAreaWrapping && !this._visibleTextArea ? "on" : "off");
          const { tabSize: n } = this._context.viewModel.model.getOptions();
          return this.textArea.domNode.style.tabSize = `${n * this._fontInfo.spaceWidth}px`, this.textArea.setAttribute("aria-label", this._getAriaLabel(t)), this.textArea.setAttribute("aria-required", t.get(5) ? "true" : "false"), this.textArea.setAttribute("tabindex", String(t.get(125))), (e.hasChanged(34) || e.hasChanged(92)) && this._ensureReadOnlyAttribute(), e.hasChanged(2) && this._textAreaInput.writeNativeTextAreaContent("strategy changed"), true;
        }
        onCursorStateChanged(e) {
          return this._selections = e.selections.slice(0), this._modelSelections = e.modelSelections.slice(0), this._textAreaInput.writeNativeTextAreaContent("selection changed"), true;
        }
        onDecorationsChanged(e) {
          return true;
        }
        onFlushed(e) {
          return true;
        }
        onLinesChanged(e) {
          return true;
        }
        onLinesDeleted(e) {
          return true;
        }
        onLinesInserted(e) {
          return true;
        }
        onScrollChanged(e) {
          return this._scrollLeft = e.scrollLeft, this._scrollTop = e.scrollTop, true;
        }
        onZonesChanged(e) {
          return true;
        }
        isFocused() {
          return this._textAreaInput.isFocused();
        }
        focusTextArea() {
          this._textAreaInput.focusTextArea();
        }
        getLastRenderData() {
          return this._lastRenderPosition;
        }
        setAriaOptions(e) {
          e.activeDescendant ? (this.textArea.setAttribute("aria-haspopup", "true"), this.textArea.setAttribute("aria-autocomplete", "list"), this.textArea.setAttribute("aria-activedescendant", e.activeDescendant)) : (this.textArea.setAttribute("aria-haspopup", "false"), this.textArea.setAttribute("aria-autocomplete", "both"), this.textArea.removeAttribute("aria-activedescendant")), e.role && this.textArea.setAttribute("role", e.role);
        }
        _ensureReadOnlyAttribute() {
          const e = this._context.configuration.options;
          !wp.enabled || e.get(34) && e.get(92) ? this.textArea.setAttribute("readonly", "true") : this.textArea.removeAttribute("readonly");
        }
        prepareRender(e) {
          var _a3;
          this._primaryCursorPosition = new X(this._selections[0].positionLineNumber, this._selections[0].positionColumn), this._primaryCursorVisibleRange = e.visibleRangeForPosition(this._primaryCursorPosition), (_a3 = this._visibleTextArea) == null ? void 0 : _a3.prepareRender(e);
        }
        render(e) {
          this._textAreaInput.writeNativeTextAreaContent("render"), this._render();
        }
        _render() {
          if (this._visibleTextArea) {
            const i = this._visibleTextArea.visibleTextareaStart, n = this._visibleTextArea.visibleTextareaEnd, o = this._visibleTextArea.startPosition, r = this._visibleTextArea.endPosition;
            if (o && r && i && n && n.left >= this._scrollLeft && i.left <= this._scrollLeft + this._contentWidth) {
              const a = this._context.viewLayout.getVerticalOffsetForLineNumber(this._primaryCursorPosition.lineNumber) - this._scrollTop, l = this._newlinecount(this.textArea.domNode.value.substr(0, this.textArea.domNode.selectionStart));
              let u = this._visibleTextArea.widthOfHiddenLineTextBefore, d = this._contentLeft + i.left - this._scrollLeft, f = n.left - i.left + 1;
              if (d < this._contentLeft) {
                const x = this._contentLeft - d;
                d += x, u += x, f -= x;
              }
              f > this._contentWidth && (f = this._contentWidth);
              const m = this._context.viewModel.getViewLineData(o.lineNumber), _ = m.tokens.findTokenIndexAtOffset(o.column - 1), b = m.tokens.findTokenIndexAtOffset(r.column - 1), v = _ === b, y = this._visibleTextArea.definePresentation(v ? m.tokens.getPresentation(_) : null);
              this.textArea.domNode.scrollTop = l * this._lineHeight, this.textArea.domNode.scrollLeft = u, this._doRender({
                lastRenderPosition: null,
                top: a,
                left: d,
                width: f,
                height: this._lineHeight,
                useCover: false,
                color: (Bi.getColorMap() || [])[y.foreground],
                italic: y.italic,
                bold: y.bold,
                underline: y.underline,
                strikethrough: y.strikethrough
              });
            }
            return;
          }
          if (!this._primaryCursorVisibleRange) {
            this._renderAtTopLeft();
            return;
          }
          const e = this._contentLeft + this._primaryCursorVisibleRange.left - this._scrollLeft;
          if (e < this._contentLeft || e > this._contentLeft + this._contentWidth) {
            this._renderAtTopLeft();
            return;
          }
          const t = this._context.viewLayout.getVerticalOffsetForLineNumber(this._selections[0].positionLineNumber) - this._scrollTop;
          if (t < 0 || t > this._contentHeight) {
            this._renderAtTopLeft();
            return;
          }
          if (_t || this._accessibilitySupport === 2) {
            this._doRender({
              lastRenderPosition: this._primaryCursorPosition,
              top: t,
              left: this._textAreaWrapping ? this._contentLeft : e,
              width: this._textAreaWidth,
              height: this._lineHeight,
              useCover: false
            }), this.textArea.domNode.scrollLeft = this._primaryCursorVisibleRange.left;
            const i = this._textAreaInput.textAreaState.newlineCountBeforeSelection ?? this._newlinecount(this.textArea.domNode.value.substr(0, this.textArea.domNode.selectionStart));
            this.textArea.domNode.scrollTop = i * this._lineHeight;
            return;
          }
          this._doRender({
            lastRenderPosition: this._primaryCursorPosition,
            top: t,
            left: this._textAreaWrapping ? this._contentLeft : e,
            width: this._textAreaWidth,
            height: bx ? 0 : 1,
            useCover: false
          });
        }
        _newlinecount(e) {
          let t = 0, i = -1;
          do {
            if (i = e.indexOf(`
`, i + 1), i === -1) break;
            t++;
          } while (true);
          return t;
        }
        _renderAtTopLeft() {
          this._doRender({
            lastRenderPosition: null,
            top: 0,
            left: 0,
            width: this._textAreaWidth,
            height: bx ? 0 : 1,
            useCover: true
          });
        }
        _doRender(e) {
          this._lastRenderPosition = e.lastRenderPosition;
          const t = this.textArea, i = this.textAreaCover;
          Un(t, this._fontInfo), t.setTop(e.top), t.setLeft(e.left), t.setWidth(e.width), t.setHeight(e.height), t.setColor(e.color ? le.Format.CSS.formatHex(e.color) : ""), t.setFontStyle(e.italic ? "italic" : ""), e.bold && t.setFontWeight("bold"), t.setTextDecoration(`${e.underline ? " underline" : ""}${e.strikethrough ? " line-through" : ""}`), i.setTop(e.useCover ? e.top : 0), i.setLeft(e.useCover ? e.left : 0), i.setWidth(e.useCover ? e.width : 0), i.setHeight(e.useCover ? e.height : 0);
          const n = this._context.configuration.options;
          n.get(57) ? i.setClassName("monaco-editor-background textAreaCover " + k_.OUTER_CLASS_NAME) : n.get(68).renderType !== 0 ? i.setClassName("monaco-editor-background textAreaCover " + zw.CLASS_NAME) : i.setClassName("monaco-editor-background textAreaCover");
        }
      };
      Y2 = Nle([
        O3(3, Pn),
        O3(4, Ft)
      ], Y2);
      function Mle(s, e, t, i) {
        if (e.length === 0) return 0;
        const n = s.createElement("div");
        n.style.position = "absolute", n.style.top = "-50000px", n.style.width = "50000px";
        const o = s.createElement("span");
        Un(o, t), o.style.whiteSpace = "pre", o.style.tabSize = `${i * t.spaceWidth}px`, o.append(e), n.appendChild(o), s.body.appendChild(n);
        const r = o.offsetWidth;
        return n.remove(), r;
      }
      const Ale = () => true, Rle = () => false, Ole = (s) => s === " " || s === "	";
      class tf {
        static shouldRecreate(e) {
          return e.hasChanged(146) || e.hasChanged(132) || e.hasChanged(37) || e.hasChanged(77) || e.hasChanged(79) || e.hasChanged(80) || e.hasChanged(6) || e.hasChanged(7) || e.hasChanged(11) || e.hasChanged(9) || e.hasChanged(10) || e.hasChanged(14) || e.hasChanged(129) || e.hasChanged(50) || e.hasChanged(92) || e.hasChanged(131);
        }
        constructor(e, t, i, n) {
          this.languageConfigurationService = n, this._cursorMoveConfigurationBrand = void 0, this._languageId = e;
          const o = i.options, r = o.get(146), a = o.get(50);
          this.readOnly = o.get(92), this.tabSize = t.tabSize, this.indentSize = t.indentSize, this.insertSpaces = t.insertSpaces, this.stickyTabStops = o.get(117), this.lineHeight = a.lineHeight, this.typicalHalfwidthCharacterWidth = a.typicalHalfwidthCharacterWidth, this.pageSize = Math.max(1, Math.floor(r.height / this.lineHeight) - 2), this.useTabStops = o.get(129), this.wordSeparators = o.get(132), this.emptySelectionClipboard = o.get(37), this.copyWithSyntaxHighlighting = o.get(25), this.multiCursorMergeOverlapping = o.get(77), this.multiCursorPaste = o.get(79), this.multiCursorLimit = o.get(80), this.autoClosingBrackets = o.get(6), this.autoClosingComments = o.get(7), this.autoClosingQuotes = o.get(11), this.autoClosingDelete = o.get(9), this.autoClosingOvertype = o.get(10), this.autoSurround = o.get(14), this.autoIndent = o.get(12), this.wordSegmenterLocales = o.get(131), this.surroundingPairs = {}, this._electricChars = null, this.shouldAutoCloseBefore = {
            quote: this._getShouldAutoClose(e, this.autoClosingQuotes, true),
            comment: this._getShouldAutoClose(e, this.autoClosingComments, false),
            bracket: this._getShouldAutoClose(e, this.autoClosingBrackets, false)
          }, this.autoClosingPairs = this.languageConfigurationService.getLanguageConfiguration(e).getAutoClosingPairs();
          const l = this.languageConfigurationService.getLanguageConfiguration(e).getSurroundingPairs();
          if (l) for (const d of l) this.surroundingPairs[d.open] = d.close;
          const u = this.languageConfigurationService.getLanguageConfiguration(e).comments;
          this.blockCommentStartToken = (u == null ? void 0 : u.blockCommentStartToken) ?? null;
        }
        get electricChars() {
          var _a3;
          if (!this._electricChars) {
            this._electricChars = {};
            const e = (_a3 = this.languageConfigurationService.getLanguageConfiguration(this._languageId).electricCharacter) == null ? void 0 : _a3.getElectricCharacters();
            if (e) for (const t of e) this._electricChars[t] = true;
          }
          return this._electricChars;
        }
        onElectricCharacter(e, t, i) {
          const n = gh(t, i - 1), o = this.languageConfigurationService.getLanguageConfiguration(n.languageId).electricCharacter;
          return o ? o.onElectricCharacter(e, n, i - n.firstCharOffset) : null;
        }
        normalizeIndentation(e) {
          return pB(e, this.indentSize, this.insertSpaces);
        }
        _getShouldAutoClose(e, t, i) {
          switch (t) {
            case "beforeWhitespace":
              return Ole;
            case "languageDefined":
              return this._getLanguageDefinedShouldAutoClose(e, i);
            case "always":
              return Ale;
            case "never":
              return Rle;
          }
        }
        _getLanguageDefinedShouldAutoClose(e, t) {
          const i = this.languageConfigurationService.getLanguageConfiguration(e).getAutoCloseBeforeSet(t);
          return (n) => i.indexOf(n) !== -1;
        }
        visibleColumnFromColumn(e, t) {
          return Gi.visibleColumnFromColumn(e.getLineContent(t.lineNumber), t.column, this.tabSize);
        }
        columnFromVisibleColumn(e, t, i) {
          const n = Gi.columnFromVisibleColumn(e.getLineContent(t), i, this.tabSize), o = e.getLineMinColumn(t);
          if (n < o) return o;
          const r = e.getLineMaxColumn(t);
          return n > r ? r : n;
        }
      }
      class lt {
        static fromModelState(e) {
          return new Ple(e);
        }
        static fromViewState(e) {
          return new Ble(e);
        }
        static fromModelSelection(e) {
          const t = mt.liftSelection(e), i = new bn(z.fromPositions(t.getSelectionStart()), 0, 0, t.getPosition(), 0);
          return lt.fromModelState(i);
        }
        static fromModelSelections(e) {
          const t = [];
          for (let i = 0, n = e.length; i < n; i++) t[i] = this.fromModelSelection(e[i]);
          return t;
        }
        constructor(e, t) {
          this._cursorStateBrand = void 0, this.modelState = e, this.viewState = t;
        }
        equals(e) {
          return this.viewState.equals(e.viewState) && this.modelState.equals(e.modelState);
        }
      }
      class Ple {
        constructor(e) {
          this.modelState = e, this.viewState = null;
        }
      }
      class Ble {
        constructor(e) {
          this.modelState = null, this.viewState = e;
        }
      }
      class bn {
        constructor(e, t, i, n, o) {
          this.selectionStart = e, this.selectionStartKind = t, this.selectionStartLeftoverVisibleColumns = i, this.position = n, this.leftoverVisibleColumns = o, this._singleCursorStateBrand = void 0, this.selection = bn._computeSelection(this.selectionStart, this.position);
        }
        equals(e) {
          return this.selectionStartLeftoverVisibleColumns === e.selectionStartLeftoverVisibleColumns && this.leftoverVisibleColumns === e.leftoverVisibleColumns && this.selectionStartKind === e.selectionStartKind && this.position.equals(e.position) && this.selectionStart.equalsRange(e.selectionStart);
        }
        hasSelection() {
          return !this.selection.isEmpty() || !this.selectionStart.isEmpty();
        }
        move(e, t, i, n) {
          return e ? new bn(this.selectionStart, this.selectionStartKind, this.selectionStartLeftoverVisibleColumns, new X(t, i), n) : new bn(new z(t, i, t, i), 0, n, new X(t, i), n);
        }
        static _computeSelection(e, t) {
          return e.isEmpty() || !t.isBeforeOrEqual(e.getStartPosition()) ? mt.fromPositions(e.getStartPosition(), t) : mt.fromPositions(e.getEndPosition(), t);
        }
      }
      class As {
        constructor(e, t, i) {
          this._editOperationResultBrand = void 0, this.type = e, this.commands = t, this.shouldPushStackElementBefore = i.shouldPushStackElementBefore, this.shouldPushStackElementAfter = i.shouldPushStackElementAfter;
        }
      }
      function uu(s) {
        return s === "'" || s === '"' || s === "`";
      }
      class lh {
        static columnSelect(e, t, i, n, o, r) {
          const a = Math.abs(o - i) + 1, l = i > o, u = n > r, d = n < r, f = [];
          for (let m = 0; m < a; m++) {
            const _ = i + (l ? -m : m), b = e.columnFromVisibleColumn(t, _, n), v = e.columnFromVisibleColumn(t, _, r), y = e.visibleColumnFromColumn(t, new X(_, b)), x = e.visibleColumnFromColumn(t, new X(_, v));
            d && (y > r || x < n) || u && (x > n || y < r) || f.push(new bn(new z(_, b, _, b), 0, 0, new X(_, v), 0));
          }
          if (f.length === 0) for (let m = 0; m < a; m++) {
            const _ = i + (l ? -m : m), b = t.getLineMaxColumn(_);
            f.push(new bn(new z(_, b, _, b), 0, 0, new X(_, b), 0));
          }
          return {
            viewStates: f,
            reversed: l,
            fromLineNumber: i,
            fromVisualColumn: n,
            toLineNumber: o,
            toVisualColumn: r
          };
        }
        static columnSelectLeft(e, t, i) {
          let n = i.toViewVisualColumn;
          return n > 0 && n--, lh.columnSelect(e, t, i.fromViewLineNumber, i.fromViewVisualColumn, i.toViewLineNumber, n);
        }
        static columnSelectRight(e, t, i) {
          let n = 0;
          const o = Math.min(i.fromViewLineNumber, i.toViewLineNumber), r = Math.max(i.fromViewLineNumber, i.toViewLineNumber);
          for (let l = o; l <= r; l++) {
            const u = t.getLineMaxColumn(l), d = e.visibleColumnFromColumn(t, new X(l, u));
            n = Math.max(n, d);
          }
          let a = i.toViewVisualColumn;
          return a < n && a++, this.columnSelect(e, t, i.fromViewLineNumber, i.fromViewVisualColumn, i.toViewLineNumber, a);
        }
        static columnSelectUp(e, t, i, n) {
          const o = n ? e.pageSize : 1, r = Math.max(1, i.toViewLineNumber - o);
          return this.columnSelect(e, t, i.fromViewLineNumber, i.fromViewVisualColumn, r, i.toViewVisualColumn);
        }
        static columnSelectDown(e, t, i, n) {
          const o = n ? e.pageSize : 1, r = Math.min(t.getLineCount(), i.toViewLineNumber + o);
          return this.columnSelect(e, t, i.fromViewLineNumber, i.fromViewVisualColumn, r, i.toViewVisualColumn);
        }
      }
      class zs {
        constructor(e, t, i = false) {
          this._range = e, this._text = t, this.insertsAutoWhitespace = i;
        }
        getEditOperations(e, t) {
          t.addTrackedEditOperation(this._range, this._text);
        }
        computeCursorState(e, t) {
          const n = t.getInverseEditOperations()[0].range;
          return mt.fromPositions(n.getEndPosition());
        }
      }
      class F0 {
        constructor(e, t, i = false) {
          this._range = e, this._text = t, this.insertsAutoWhitespace = i;
        }
        getEditOperations(e, t) {
          t.addTrackedEditOperation(this._range, this._text);
        }
        computeCursorState(e, t) {
          const n = t.getInverseEditOperations()[0].range;
          return mt.fromPositions(n.getStartPosition());
        }
      }
      class pC {
        constructor(e, t, i, n, o = false) {
          this._range = e, this._text = t, this._columnDeltaOffset = n, this._lineNumberDeltaOffset = i, this.insertsAutoWhitespace = o;
        }
        getEditOperations(e, t) {
          t.addTrackedEditOperation(this._range, this._text);
        }
        computeCursorState(e, t) {
          const n = t.getInverseEditOperations()[0].range;
          return mt.fromPositions(n.getEndPosition().delta(this._lineNumberDeltaOffset, this._columnDeltaOffset));
        }
      }
      class Fle {
        constructor(e, t, i, n = false) {
          this._range = e, this._text = t, this._initialSelection = i, this._forceMoveMarkers = n, this._selectionId = null;
        }
        getEditOperations(e, t) {
          t.addTrackedEditOperation(this._range, this._text, this._forceMoveMarkers), this._selectionId = t.trackSelection(this._initialSelection);
        }
        computeCursorState(e, t) {
          return t.getTrackedSelection(this._selectionId);
        }
      }
      class vx {
        constructor(e, t, i) {
          this._cursorPositionBrand = void 0, this.lineNumber = e, this.column = t, this.leftoverVisibleColumns = i;
        }
      }
      class Rt {
        static leftPosition(e, t) {
          if (t.column > e.getLineMinColumn(t.lineNumber)) return t.delta(void 0, -x9(e.getLineContent(t.lineNumber), t.column - 1));
          if (t.lineNumber > 1) {
            const i = t.lineNumber - 1;
            return new X(i, e.getLineMaxColumn(i));
          } else return t;
        }
        static leftPositionAtomicSoftTabs(e, t, i) {
          if (t.column <= e.getLineIndentColumn(t.lineNumber)) {
            const n = e.getLineMinColumn(t.lineNumber), o = e.getLineContent(t.lineNumber), r = x_.atomicPosition(o, t.column - 1, i, 0);
            if (r !== -1 && r + 1 >= n) return new X(t.lineNumber, r + 1);
          }
          return this.leftPosition(e, t);
        }
        static left(e, t, i) {
          const n = e.stickyTabStops ? Rt.leftPositionAtomicSoftTabs(t, i, e.tabSize) : Rt.leftPosition(t, i);
          return new vx(n.lineNumber, n.column, 0);
        }
        static moveLeft(e, t, i, n, o) {
          let r, a;
          if (i.hasSelection() && !n) r = i.selection.startLineNumber, a = i.selection.startColumn;
          else {
            const l = i.position.delta(void 0, -(o - 1)), u = t.normalizePosition(Rt.clipPositionColumn(l, t), 0), d = Rt.left(e, t, u);
            r = d.lineNumber, a = d.column;
          }
          return i.move(n, r, a, 0);
        }
        static clipPositionColumn(e, t) {
          return new X(e.lineNumber, Rt.clipRange(e.column, t.getLineMinColumn(e.lineNumber), t.getLineMaxColumn(e.lineNumber)));
        }
        static clipRange(e, t, i) {
          return e < t ? t : e > i ? i : e;
        }
        static rightPosition(e, t, i) {
          return i < e.getLineMaxColumn(t) ? i = i + YE(e.getLineContent(t), i - 1) : t < e.getLineCount() && (t = t + 1, i = e.getLineMinColumn(t)), new X(t, i);
        }
        static rightPositionAtomicSoftTabs(e, t, i, n, o) {
          if (i < e.getLineIndentColumn(t)) {
            const r = e.getLineContent(t), a = x_.atomicPosition(r, i - 1, n, 1);
            if (a !== -1) return new X(t, a + 1);
          }
          return this.rightPosition(e, t, i);
        }
        static right(e, t, i) {
          const n = e.stickyTabStops ? Rt.rightPositionAtomicSoftTabs(t, i.lineNumber, i.column, e.tabSize, e.indentSize) : Rt.rightPosition(t, i.lineNumber, i.column);
          return new vx(n.lineNumber, n.column, 0);
        }
        static moveRight(e, t, i, n, o) {
          let r, a;
          if (i.hasSelection() && !n) r = i.selection.endLineNumber, a = i.selection.endColumn;
          else {
            const l = i.position.delta(void 0, o - 1), u = t.normalizePosition(Rt.clipPositionColumn(l, t), 1), d = Rt.right(e, t, u);
            r = d.lineNumber, a = d.column;
          }
          return i.move(n, r, a, 0);
        }
        static vertical(e, t, i, n, o, r, a, l) {
          const u = Gi.visibleColumnFromColumn(t.getLineContent(i), n, e.tabSize) + o, d = t.getLineCount(), f = i === 1 && n === 1, m = i === d && n === t.getLineMaxColumn(i), _ = r < i ? f : m;
          if (i = r, i < 1 ? (i = 1, a ? n = t.getLineMinColumn(i) : n = Math.min(t.getLineMaxColumn(i), n)) : i > d ? (i = d, a ? n = t.getLineMaxColumn(i) : n = Math.min(t.getLineMaxColumn(i), n)) : n = e.columnFromVisibleColumn(t, i, u), _ ? o = 0 : o = u - Gi.visibleColumnFromColumn(t.getLineContent(i), n, e.tabSize), l !== void 0) {
            const b = new X(i, n), v = t.normalizePosition(b, l);
            o = o + (n - v.column), i = v.lineNumber, n = v.column;
          }
          return new vx(i, n, o);
        }
        static down(e, t, i, n, o, r, a) {
          return this.vertical(e, t, i, n, o, i + r, a, 4);
        }
        static moveDown(e, t, i, n, o) {
          let r, a;
          i.hasSelection() && !n ? (r = i.selection.endLineNumber, a = i.selection.endColumn) : (r = i.position.lineNumber, a = i.position.column);
          let l = 0, u;
          do
            if (u = Rt.down(e, t, r + l, a, i.leftoverVisibleColumns, o, true), t.normalizePosition(new X(u.lineNumber, u.column), 2).lineNumber > r) break;
          while (l++ < 10 && r + l < t.getLineCount());
          return i.move(n, u.lineNumber, u.column, u.leftoverVisibleColumns);
        }
        static translateDown(e, t, i) {
          const n = i.selection, o = Rt.down(e, t, n.selectionStartLineNumber, n.selectionStartColumn, i.selectionStartLeftoverVisibleColumns, 1, false), r = Rt.down(e, t, n.positionLineNumber, n.positionColumn, i.leftoverVisibleColumns, 1, false);
          return new bn(new z(o.lineNumber, o.column, o.lineNumber, o.column), 0, o.leftoverVisibleColumns, new X(r.lineNumber, r.column), r.leftoverVisibleColumns);
        }
        static up(e, t, i, n, o, r, a) {
          return this.vertical(e, t, i, n, o, i - r, a, 3);
        }
        static moveUp(e, t, i, n, o) {
          let r, a;
          i.hasSelection() && !n ? (r = i.selection.startLineNumber, a = i.selection.startColumn) : (r = i.position.lineNumber, a = i.position.column);
          const l = Rt.up(e, t, r, a, i.leftoverVisibleColumns, o, true);
          return i.move(n, l.lineNumber, l.column, l.leftoverVisibleColumns);
        }
        static translateUp(e, t, i) {
          const n = i.selection, o = Rt.up(e, t, n.selectionStartLineNumber, n.selectionStartColumn, i.selectionStartLeftoverVisibleColumns, 1, false), r = Rt.up(e, t, n.positionLineNumber, n.positionColumn, i.leftoverVisibleColumns, 1, false);
          return new bn(new z(o.lineNumber, o.column, o.lineNumber, o.column), 0, o.leftoverVisibleColumns, new X(r.lineNumber, r.column), r.leftoverVisibleColumns);
        }
        static _isBlankLine(e, t) {
          return e.getLineFirstNonWhitespaceColumn(t) === 0;
        }
        static moveToPrevBlankLine(e, t, i, n) {
          let o = i.position.lineNumber;
          for (; o > 1 && this._isBlankLine(t, o); ) o--;
          for (; o > 1 && !this._isBlankLine(t, o); ) o--;
          return i.move(n, o, t.getLineMinColumn(o), 0);
        }
        static moveToNextBlankLine(e, t, i, n) {
          const o = t.getLineCount();
          let r = i.position.lineNumber;
          for (; r < o && this._isBlankLine(t, r); ) r++;
          for (; r < o && !this._isBlankLine(t, r); ) r++;
          return i.move(n, r, t.getLineMinColumn(r), 0);
        }
        static moveToBeginningOfLine(e, t, i, n) {
          const o = i.position.lineNumber, r = t.getLineMinColumn(o), a = t.getLineFirstNonWhitespaceColumn(o) || r;
          let l;
          return i.position.column === a ? l = r : l = a, i.move(n, o, l, 0);
        }
        static moveToEndOfLine(e, t, i, n, o) {
          const r = i.position.lineNumber, a = t.getLineMaxColumn(r);
          return i.move(n, r, a, o ? 1073741824 - a : 0);
        }
        static moveToBeginningOfBuffer(e, t, i, n) {
          return i.move(n, 1, 1, 0);
        }
        static moveToEndOfBuffer(e, t, i, n) {
          const o = t.getLineCount(), r = t.getLineMaxColumn(o);
          return i.move(n, o, r, 0);
        }
      }
      class Hh {
        static deleteRight(e, t, i, n) {
          const o = [];
          let r = e !== 3;
          for (let a = 0, l = n.length; a < l; a++) {
            const u = n[a];
            let d = u;
            if (d.isEmpty()) {
              const f = u.getPosition(), m = Rt.right(t, i, f);
              d = new z(m.lineNumber, m.column, f.lineNumber, f.column);
            }
            if (d.isEmpty()) {
              o[a] = null;
              continue;
            }
            d.startLineNumber !== d.endLineNumber && (r = true), o[a] = new zs(d, "");
          }
          return [
            r,
            o
          ];
        }
        static isAutoClosingPairDelete(e, t, i, n, o, r, a) {
          if (t === "never" && i === "never" || e === "never") return false;
          for (let l = 0, u = r.length; l < u; l++) {
            const d = r[l], f = d.getPosition();
            if (!d.isEmpty()) return false;
            const m = o.getLineContent(f.lineNumber);
            if (f.column < 2 || f.column >= m.length + 1) return false;
            const _ = m.charAt(f.column - 2), b = n.get(_);
            if (!b) return false;
            if (uu(_)) {
              if (i === "never") return false;
            } else if (t === "never") return false;
            const v = m.charAt(f.column - 1);
            let y = false;
            for (const x of b) x.open === _ && x.close === v && (y = true);
            if (!y) return false;
            if (e === "auto") {
              let x = false;
              for (let L = 0, D = a.length; L < D; L++) {
                const k = a[L];
                if (f.lineNumber === k.startLineNumber && f.column === k.startColumn) {
                  x = true;
                  break;
                }
              }
              if (!x) return false;
            }
          }
          return true;
        }
        static _runAutoClosingPairDelete(e, t, i) {
          const n = [];
          for (let o = 0, r = i.length; o < r; o++) {
            const a = i[o].getPosition(), l = new z(a.lineNumber, a.column - 1, a.lineNumber, a.column + 1);
            n[o] = new zs(l, "");
          }
          return [
            true,
            n
          ];
        }
        static deleteLeft(e, t, i, n, o) {
          if (this.isAutoClosingPairDelete(t.autoClosingDelete, t.autoClosingBrackets, t.autoClosingQuotes, t.autoClosingPairs.autoClosingPairsOpenByEnd, i, n, o)) return this._runAutoClosingPairDelete(t, i, n);
          const r = [];
          let a = e !== 2;
          for (let l = 0, u = n.length; l < u; l++) {
            const d = Hh.getDeleteRange(n[l], i, t);
            if (d.isEmpty()) {
              r[l] = null;
              continue;
            }
            d.startLineNumber !== d.endLineNumber && (a = true), r[l] = new zs(d, "");
          }
          return [
            a,
            r
          ];
        }
        static getDeleteRange(e, t, i) {
          if (!e.isEmpty()) return e;
          const n = e.getPosition();
          if (i.useTabStops && n.column > 1) {
            const o = t.getLineContent(n.lineNumber), r = qs(o), a = r === -1 ? o.length + 1 : r + 1;
            if (n.column <= a) {
              const l = i.visibleColumnFromColumn(t, n), u = Gi.prevIndentTabStop(l, i.indentSize), d = i.columnFromVisibleColumn(t, n.lineNumber, u);
              return new z(n.lineNumber, d, n.lineNumber, n.column);
            }
          }
          return z.fromPositions(Hh.getPositionAfterDeleteLeft(n, t), n);
        }
        static getPositionAfterDeleteLeft(e, t) {
          if (e.column > 1) {
            const i = Bq(e.column - 1, t.getLineContent(e.lineNumber));
            return e.with(void 0, i + 1);
          } else if (e.lineNumber > 1) {
            const i = e.lineNumber - 1;
            return new X(i, t.getLineMaxColumn(i));
          } else return e;
        }
        static cut(e, t, i) {
          const n = [];
          let o = null;
          i.sort((r, a) => X.compare(r.getStartPosition(), a.getEndPosition()));
          for (let r = 0, a = i.length; r < a; r++) {
            const l = i[r];
            if (l.isEmpty()) if (e.emptySelectionClipboard) {
              const u = l.getPosition();
              let d, f, m, _;
              u.lineNumber < t.getLineCount() ? (d = u.lineNumber, f = 1, m = u.lineNumber + 1, _ = 1) : u.lineNumber > 1 && (o == null ? void 0 : o.endLineNumber) !== u.lineNumber ? (d = u.lineNumber - 1, f = t.getLineMaxColumn(u.lineNumber - 1), m = u.lineNumber, _ = t.getLineMaxColumn(u.lineNumber)) : (d = u.lineNumber, f = 1, m = u.lineNumber, _ = t.getLineMaxColumn(u.lineNumber));
              const b = new z(d, f, m, _);
              o = b, b.isEmpty() ? n[r] = null : n[r] = new zs(b, "");
            } else n[r] = null;
            else n[r] = new zs(l, "");
          }
          return new As(0, n, {
            shouldPushStackElementBefore: true,
            shouldPushStackElementAfter: true
          });
        }
      }
      class Ti {
        static _createWord(e, t, i, n, o) {
          return {
            start: n,
            end: o,
            wordType: t,
            nextCharClass: i
          };
        }
        static _createIntlWord(e, t) {
          return {
            start: e.index,
            end: e.index + e.segment.length,
            wordType: 1,
            nextCharClass: t
          };
        }
        static _findPreviousWordOnLine(e, t, i) {
          const n = t.getLineContent(i.lineNumber);
          return this._doFindPreviousWordOnLine(n, e, i);
        }
        static _doFindPreviousWordOnLine(e, t, i) {
          let n = 0;
          const o = t.findPrevIntlWordBeforeOrAtOffset(e, i.column - 2);
          for (let r = i.column - 2; r >= 0; r--) {
            const a = e.charCodeAt(r), l = t.get(a);
            if (o && r === o.index) return this._createIntlWord(o, l);
            if (l === 0) {
              if (n === 2) return this._createWord(e, n, l, r + 1, this._findEndOfWord(e, t, n, r + 1));
              n = 1;
            } else if (l === 2) {
              if (n === 1) return this._createWord(e, n, l, r + 1, this._findEndOfWord(e, t, n, r + 1));
              n = 2;
            } else if (l === 1 && n !== 0) return this._createWord(e, n, l, r + 1, this._findEndOfWord(e, t, n, r + 1));
          }
          return n !== 0 ? this._createWord(e, n, 1, 0, this._findEndOfWord(e, t, n, 0)) : null;
        }
        static _findEndOfWord(e, t, i, n) {
          const o = t.findNextIntlWordAtOrAfterOffset(e, n), r = e.length;
          for (let a = n; a < r; a++) {
            const l = e.charCodeAt(a), u = t.get(l);
            if (o && a === o.index + o.segment.length || u === 1 || i === 1 && u === 2 || i === 2 && u === 0) return a;
          }
          return r;
        }
        static _findNextWordOnLine(e, t, i) {
          const n = t.getLineContent(i.lineNumber);
          return this._doFindNextWordOnLine(n, e, i);
        }
        static _doFindNextWordOnLine(e, t, i) {
          let n = 0;
          const o = e.length, r = t.findNextIntlWordAtOrAfterOffset(e, i.column - 1);
          for (let a = i.column - 1; a < o; a++) {
            const l = e.charCodeAt(a), u = t.get(l);
            if (r && a === r.index) return this._createIntlWord(r, u);
            if (u === 0) {
              if (n === 2) return this._createWord(e, n, u, this._findStartOfWord(e, t, n, a - 1), a);
              n = 1;
            } else if (u === 2) {
              if (n === 1) return this._createWord(e, n, u, this._findStartOfWord(e, t, n, a - 1), a);
              n = 2;
            } else if (u === 1 && n !== 0) return this._createWord(e, n, u, this._findStartOfWord(e, t, n, a - 1), a);
          }
          return n !== 0 ? this._createWord(e, n, 1, this._findStartOfWord(e, t, n, o - 1), o) : null;
        }
        static _findStartOfWord(e, t, i, n) {
          const o = t.findPrevIntlWordBeforeOrAtOffset(e, n);
          for (let r = n; r >= 0; r--) {
            const a = e.charCodeAt(r), l = t.get(a);
            if (o && r === o.index) return r;
            if (l === 1 || i === 1 && l === 2 || i === 2 && l === 0) return r + 1;
          }
          return 0;
        }
        static moveWordLeft(e, t, i, n, o) {
          let r = i.lineNumber, a = i.column;
          a === 1 && r > 1 && (r = r - 1, a = t.getLineMaxColumn(r));
          let l = Ti._findPreviousWordOnLine(e, t, new X(r, a));
          if (n === 0) return new X(r, l ? l.start + 1 : 1);
          if (n === 1) return !o && l && l.wordType === 2 && l.end - l.start === 1 && l.nextCharClass === 0 && (l = Ti._findPreviousWordOnLine(e, t, new X(r, l.start + 1))), new X(r, l ? l.start + 1 : 1);
          if (n === 3) {
            for (; l && l.wordType === 2; ) l = Ti._findPreviousWordOnLine(e, t, new X(r, l.start + 1));
            return new X(r, l ? l.start + 1 : 1);
          }
          return l && a <= l.end + 1 && (l = Ti._findPreviousWordOnLine(e, t, new X(r, l.start + 1))), new X(r, l ? l.end + 1 : 1);
        }
        static _moveWordPartLeft(e, t) {
          const i = t.lineNumber, n = e.getLineMaxColumn(i);
          if (t.column === 1) return i > 1 ? new X(i - 1, e.getLineMaxColumn(i - 1)) : t;
          const o = e.getLineContent(i);
          for (let r = t.column - 1; r > 1; r--) {
            const a = o.charCodeAt(r - 2), l = o.charCodeAt(r - 1);
            if (a === 95 && l !== 95) return new X(i, r);
            if (a === 45 && l !== 45) return new X(i, r);
            if ((cf(a) || Sb(a)) && Ec(l)) return new X(i, r);
            if (Ec(a) && Ec(l) && r + 1 < n) {
              const u = o.charCodeAt(r);
              if (cf(u) || Sb(u)) return new X(i, r);
            }
          }
          return new X(i, 1);
        }
        static moveWordRight(e, t, i, n) {
          let o = i.lineNumber, r = i.column, a = false;
          r === t.getLineMaxColumn(o) && o < t.getLineCount() && (a = true, o = o + 1, r = 1);
          let l = Ti._findNextWordOnLine(e, t, new X(o, r));
          if (n === 2) l && l.wordType === 2 && l.end - l.start === 1 && l.nextCharClass === 0 && (l = Ti._findNextWordOnLine(e, t, new X(o, l.end + 1))), l ? r = l.end + 1 : r = t.getLineMaxColumn(o);
          else if (n === 3) {
            for (a && (r = 0); l && (l.wordType === 2 || l.start + 1 <= r); ) l = Ti._findNextWordOnLine(e, t, new X(o, l.end + 1));
            l ? r = l.start + 1 : r = t.getLineMaxColumn(o);
          } else l && !a && r >= l.start + 1 && (l = Ti._findNextWordOnLine(e, t, new X(o, l.end + 1))), l ? r = l.start + 1 : r = t.getLineMaxColumn(o);
          return new X(o, r);
        }
        static _moveWordPartRight(e, t) {
          const i = t.lineNumber, n = e.getLineMaxColumn(i);
          if (t.column === n) return i < e.getLineCount() ? new X(i + 1, 1) : t;
          const o = e.getLineContent(i);
          for (let r = t.column + 1; r < n; r++) {
            const a = o.charCodeAt(r - 2), l = o.charCodeAt(r - 1);
            if (a !== 95 && l === 95) return new X(i, r);
            if (a !== 45 && l === 45) return new X(i, r);
            if ((cf(a) || Sb(a)) && Ec(l)) return new X(i, r);
            if (Ec(a) && Ec(l) && r + 1 < n) {
              const u = o.charCodeAt(r);
              if (cf(u) || Sb(u)) return new X(i, r);
            }
          }
          return new X(i, n);
        }
        static _deleteWordLeftWhitespace(e, t) {
          const i = e.getLineContent(t.lineNumber), n = t.column - 2, o = qh(i, n);
          return o + 1 < n ? new z(t.lineNumber, o + 2, t.lineNumber, t.column) : null;
        }
        static deleteWordLeft(e, t) {
          const i = e.wordSeparators, n = e.model, o = e.selection, r = e.whitespaceHeuristics;
          if (!o.isEmpty()) return o;
          if (Hh.isAutoClosingPairDelete(e.autoClosingDelete, e.autoClosingBrackets, e.autoClosingQuotes, e.autoClosingPairs.autoClosingPairsOpenByEnd, e.model, [
            e.selection
          ], e.autoClosedCharacters)) {
            const f = e.selection.getPosition();
            return new z(f.lineNumber, f.column - 1, f.lineNumber, f.column + 1);
          }
          const a = new X(o.positionLineNumber, o.positionColumn);
          let l = a.lineNumber, u = a.column;
          if (l === 1 && u === 1) return null;
          if (r) {
            const f = this._deleteWordLeftWhitespace(n, a);
            if (f) return f;
          }
          let d = Ti._findPreviousWordOnLine(i, n, a);
          return t === 0 ? d ? u = d.start + 1 : u > 1 ? u = 1 : (l--, u = n.getLineMaxColumn(l)) : (d && u <= d.end + 1 && (d = Ti._findPreviousWordOnLine(i, n, new X(l, d.start + 1))), d ? u = d.end + 1 : u > 1 ? u = 1 : (l--, u = n.getLineMaxColumn(l))), new z(l, u, a.lineNumber, a.column);
        }
        static deleteInsideWord(e, t, i) {
          if (!i.isEmpty()) return i;
          const n = new X(i.positionLineNumber, i.positionColumn), o = this._deleteInsideWordWhitespace(t, n);
          return o || this._deleteInsideWordDetermineDeleteRange(e, t, n);
        }
        static _charAtIsWhitespace(e, t) {
          const i = e.charCodeAt(t);
          return i === 32 || i === 9;
        }
        static _deleteInsideWordWhitespace(e, t) {
          const i = e.getLineContent(t.lineNumber), n = i.length;
          if (n === 0) return null;
          let o = Math.max(t.column - 2, 0);
          if (!this._charAtIsWhitespace(i, o)) return null;
          let r = Math.min(t.column - 1, n - 1);
          if (!this._charAtIsWhitespace(i, r)) return null;
          for (; o > 0 && this._charAtIsWhitespace(i, o - 1); ) o--;
          for (; r + 1 < n && this._charAtIsWhitespace(i, r + 1); ) r++;
          return new z(t.lineNumber, o + 1, t.lineNumber, r + 2);
        }
        static _deleteInsideWordDetermineDeleteRange(e, t, i) {
          const n = t.getLineContent(i.lineNumber), o = n.length;
          if (o === 0) return i.lineNumber > 1 ? new z(i.lineNumber - 1, t.getLineMaxColumn(i.lineNumber - 1), i.lineNumber, 1) : i.lineNumber < t.getLineCount() ? new z(i.lineNumber, 1, i.lineNumber + 1, 1) : new z(i.lineNumber, 1, i.lineNumber, 1);
          const r = (f) => f.start + 1 <= i.column && i.column <= f.end + 1, a = (f, m) => (f = Math.min(f, i.column), m = Math.max(m, i.column), new z(i.lineNumber, f, i.lineNumber, m)), l = (f) => {
            let m = f.start + 1, _ = f.end + 1, b = false;
            for (; _ - 1 < o && this._charAtIsWhitespace(n, _ - 1); ) b = true, _++;
            if (!b) for (; m > 1 && this._charAtIsWhitespace(n, m - 2); ) m--;
            return a(m, _);
          }, u = Ti._findPreviousWordOnLine(e, t, i);
          if (u && r(u)) return l(u);
          const d = Ti._findNextWordOnLine(e, t, i);
          return d && r(d) ? l(d) : u && d ? a(u.end + 1, d.start + 1) : u ? a(u.start + 1, u.end + 1) : d ? a(d.start + 1, d.end + 1) : a(1, o + 1);
        }
        static _deleteWordPartLeft(e, t) {
          if (!t.isEmpty()) return t;
          const i = t.getPosition(), n = Ti._moveWordPartLeft(e, i);
          return new z(i.lineNumber, i.column, n.lineNumber, n.column);
        }
        static _findFirstNonWhitespaceChar(e, t) {
          const i = e.length;
          for (let n = t; n < i; n++) {
            const o = e.charAt(n);
            if (o !== " " && o !== "	") return n;
          }
          return i;
        }
        static _deleteWordRightWhitespace(e, t) {
          const i = e.getLineContent(t.lineNumber), n = t.column - 1, o = this._findFirstNonWhitespaceChar(i, n);
          return n + 1 < o ? new z(t.lineNumber, t.column, t.lineNumber, o + 1) : null;
        }
        static deleteWordRight(e, t) {
          const i = e.wordSeparators, n = e.model, o = e.selection, r = e.whitespaceHeuristics;
          if (!o.isEmpty()) return o;
          const a = new X(o.positionLineNumber, o.positionColumn);
          let l = a.lineNumber, u = a.column;
          const d = n.getLineCount(), f = n.getLineMaxColumn(l);
          if (l === d && u === f) return null;
          if (r) {
            const _ = this._deleteWordRightWhitespace(n, a);
            if (_) return _;
          }
          let m = Ti._findNextWordOnLine(i, n, a);
          return t === 2 ? m ? u = m.end + 1 : u < f || l === d ? u = f : (l++, m = Ti._findNextWordOnLine(i, n, new X(l, 1)), m ? u = m.start + 1 : u = n.getLineMaxColumn(l)) : (m && u >= m.start + 1 && (m = Ti._findNextWordOnLine(i, n, new X(l, m.end + 1))), m ? u = m.start + 1 : u < f || l === d ? u = f : (l++, m = Ti._findNextWordOnLine(i, n, new X(l, 1)), m ? u = m.start + 1 : u = n.getLineMaxColumn(l))), new z(l, u, a.lineNumber, a.column);
        }
        static _deleteWordPartRight(e, t) {
          if (!t.isEmpty()) return t;
          const i = t.getPosition(), n = Ti._moveWordPartRight(e, i);
          return new z(i.lineNumber, i.column, n.lineNumber, n.column);
        }
        static _createWordAtPosition(e, t, i) {
          const n = new z(t, i.start + 1, t, i.end + 1);
          return {
            word: e.getValueInRange(n),
            startColumn: n.startColumn,
            endColumn: n.endColumn
          };
        }
        static getWordAtPosition(e, t, i, n) {
          const o = rg(t, i), r = Ti._findPreviousWordOnLine(o, e, n);
          if (r && r.wordType === 1 && r.start <= n.column - 1 && n.column - 1 <= r.end) return Ti._createWordAtPosition(e, n.lineNumber, r);
          const a = Ti._findNextWordOnLine(o, e, n);
          return a && a.wordType === 1 && a.start <= n.column - 1 && n.column - 1 <= a.end ? Ti._createWordAtPosition(e, n.lineNumber, a) : null;
        }
        static word(e, t, i, n, o) {
          const r = rg(e.wordSeparators, e.wordSegmenterLocales), a = Ti._findPreviousWordOnLine(r, t, o), l = Ti._findNextWordOnLine(r, t, o);
          if (!n) {
            let _, b;
            return a && a.wordType === 1 && a.start <= o.column - 1 && o.column - 1 <= a.end ? (_ = a.start + 1, b = a.end + 1) : l && l.wordType === 1 && l.start <= o.column - 1 && o.column - 1 <= l.end ? (_ = l.start + 1, b = l.end + 1) : (a ? _ = a.end + 1 : _ = 1, l ? b = l.start + 1 : b = t.getLineMaxColumn(o.lineNumber)), new bn(new z(o.lineNumber, _, o.lineNumber, b), 1, 0, new X(o.lineNumber, b), 0);
          }
          let u, d;
          a && a.wordType === 1 && a.start < o.column - 1 && o.column - 1 < a.end ? (u = a.start + 1, d = a.end + 1) : l && l.wordType === 1 && l.start < o.column - 1 && o.column - 1 < l.end ? (u = l.start + 1, d = l.end + 1) : (u = o.column, d = o.column);
          const f = o.lineNumber;
          let m;
          if (i.selectionStart.containsPosition(o)) m = i.selectionStart.endColumn;
          else if (o.isBeforeOrEqual(i.selectionStart.getStartPosition())) {
            m = u;
            const _ = new X(f, m);
            i.selectionStart.containsPosition(_) && (m = i.selectionStart.endColumn);
          } else {
            m = d;
            const _ = new X(f, m);
            i.selectionStart.containsPosition(_) && (m = i.selectionStart.startColumn);
          }
          return i.move(true, f, m, 0);
        }
      }
      class Zn {
        static addCursorDown(e, t, i) {
          const n = [];
          let o = 0;
          for (let r = 0, a = t.length; r < a; r++) {
            const l = t[r];
            n[o++] = new lt(l.modelState, l.viewState), i ? n[o++] = lt.fromModelState(Rt.translateDown(e.cursorConfig, e.model, l.modelState)) : n[o++] = lt.fromViewState(Rt.translateDown(e.cursorConfig, e, l.viewState));
          }
          return n;
        }
        static addCursorUp(e, t, i) {
          const n = [];
          let o = 0;
          for (let r = 0, a = t.length; r < a; r++) {
            const l = t[r];
            n[o++] = new lt(l.modelState, l.viewState), i ? n[o++] = lt.fromModelState(Rt.translateUp(e.cursorConfig, e.model, l.modelState)) : n[o++] = lt.fromViewState(Rt.translateUp(e.cursorConfig, e, l.viewState));
          }
          return n;
        }
        static moveToBeginningOfLine(e, t, i) {
          const n = [];
          for (let o = 0, r = t.length; o < r; o++) {
            const a = t[o];
            n[o] = this._moveToLineStart(e, a, i);
          }
          return n;
        }
        static _moveToLineStart(e, t, i) {
          const n = t.viewState.position.column, o = t.modelState.position.column, r = n === o, a = t.viewState.position.lineNumber, l = e.getLineFirstNonWhitespaceColumn(a);
          return !r && !(n === l) ? this._moveToLineStartByView(e, t, i) : this._moveToLineStartByModel(e, t, i);
        }
        static _moveToLineStartByView(e, t, i) {
          return lt.fromViewState(Rt.moveToBeginningOfLine(e.cursorConfig, e, t.viewState, i));
        }
        static _moveToLineStartByModel(e, t, i) {
          return lt.fromModelState(Rt.moveToBeginningOfLine(e.cursorConfig, e.model, t.modelState, i));
        }
        static moveToEndOfLine(e, t, i, n) {
          const o = [];
          for (let r = 0, a = t.length; r < a; r++) {
            const l = t[r];
            o[r] = this._moveToLineEnd(e, l, i, n);
          }
          return o;
        }
        static _moveToLineEnd(e, t, i, n) {
          const o = t.viewState.position, r = e.getLineMaxColumn(o.lineNumber), a = o.column === r, l = t.modelState.position, u = e.model.getLineMaxColumn(l.lineNumber), d = r - o.column === u - l.column;
          return a || d ? this._moveToLineEndByModel(e, t, i, n) : this._moveToLineEndByView(e, t, i, n);
        }
        static _moveToLineEndByView(e, t, i, n) {
          return lt.fromViewState(Rt.moveToEndOfLine(e.cursorConfig, e, t.viewState, i, n));
        }
        static _moveToLineEndByModel(e, t, i, n) {
          return lt.fromModelState(Rt.moveToEndOfLine(e.cursorConfig, e.model, t.modelState, i, n));
        }
        static expandLineSelection(e, t) {
          const i = [];
          for (let n = 0, o = t.length; n < o; n++) {
            const r = t[n], a = r.modelState.selection.startLineNumber, l = e.model.getLineCount();
            let u = r.modelState.selection.endLineNumber, d;
            u === l ? d = e.model.getLineMaxColumn(l) : (u++, d = 1), i[n] = lt.fromModelState(new bn(new z(a, 1, a, 1), 0, 0, new X(u, d), 0));
          }
          return i;
        }
        static moveToBeginningOfBuffer(e, t, i) {
          const n = [];
          for (let o = 0, r = t.length; o < r; o++) {
            const a = t[o];
            n[o] = lt.fromModelState(Rt.moveToBeginningOfBuffer(e.cursorConfig, e.model, a.modelState, i));
          }
          return n;
        }
        static moveToEndOfBuffer(e, t, i) {
          const n = [];
          for (let o = 0, r = t.length; o < r; o++) {
            const a = t[o];
            n[o] = lt.fromModelState(Rt.moveToEndOfBuffer(e.cursorConfig, e.model, a.modelState, i));
          }
          return n;
        }
        static selectAll(e, t) {
          const i = e.model.getLineCount(), n = e.model.getLineMaxColumn(i);
          return lt.fromModelState(new bn(new z(1, 1, 1, 1), 0, 0, new X(i, n), 0));
        }
        static line(e, t, i, n, o) {
          const r = e.model.validatePosition(n), a = o ? e.coordinatesConverter.validateViewPosition(new X(o.lineNumber, o.column), r) : e.coordinatesConverter.convertModelPositionToViewPosition(r);
          if (!i) {
            const u = e.model.getLineCount();
            let d = r.lineNumber + 1, f = 1;
            return d > u && (d = u, f = e.model.getLineMaxColumn(d)), lt.fromModelState(new bn(new z(r.lineNumber, 1, d, f), 2, 0, new X(d, f), 0));
          }
          const l = t.modelState.selectionStart.getStartPosition().lineNumber;
          if (r.lineNumber < l) return lt.fromViewState(t.viewState.move(true, a.lineNumber, 1, 0));
          if (r.lineNumber > l) {
            const u = e.getLineCount();
            let d = a.lineNumber + 1, f = 1;
            return d > u && (d = u, f = e.getLineMaxColumn(d)), lt.fromViewState(t.viewState.move(true, d, f, 0));
          } else {
            const u = t.modelState.selectionStart.getEndPosition();
            return lt.fromModelState(t.modelState.move(true, u.lineNumber, u.column, 0));
          }
        }
        static word(e, t, i, n) {
          const o = e.model.validatePosition(n);
          return lt.fromModelState(Ti.word(e.cursorConfig, e.model, t.modelState, i, o));
        }
        static cancelSelection(e, t) {
          if (!t.modelState.hasSelection()) return new lt(t.modelState, t.viewState);
          const i = t.viewState.position.lineNumber, n = t.viewState.position.column;
          return lt.fromViewState(new bn(new z(i, n, i, n), 0, 0, new X(i, n), 0));
        }
        static moveTo(e, t, i, n, o) {
          if (i) {
            if (t.modelState.selectionStartKind === 1) return this.word(e, t, i, n);
            if (t.modelState.selectionStartKind === 2) return this.line(e, t, i, n, o);
          }
          const r = e.model.validatePosition(n), a = o ? e.coordinatesConverter.validateViewPosition(new X(o.lineNumber, o.column), r) : e.coordinatesConverter.convertModelPositionToViewPosition(r);
          return lt.fromViewState(t.viewState.move(i, a.lineNumber, a.column, 0));
        }
        static simpleMove(e, t, i, n, o, r) {
          switch (i) {
            case 0:
              return r === 4 ? this._moveHalfLineLeft(e, t, n) : this._moveLeft(e, t, n, o);
            case 1:
              return r === 4 ? this._moveHalfLineRight(e, t, n) : this._moveRight(e, t, n, o);
            case 2:
              return r === 2 ? this._moveUpByViewLines(e, t, n, o) : this._moveUpByModelLines(e, t, n, o);
            case 3:
              return r === 2 ? this._moveDownByViewLines(e, t, n, o) : this._moveDownByModelLines(e, t, n, o);
            case 4:
              return r === 2 ? t.map((a) => lt.fromViewState(Rt.moveToPrevBlankLine(e.cursorConfig, e, a.viewState, n))) : t.map((a) => lt.fromModelState(Rt.moveToPrevBlankLine(e.cursorConfig, e.model, a.modelState, n)));
            case 5:
              return r === 2 ? t.map((a) => lt.fromViewState(Rt.moveToNextBlankLine(e.cursorConfig, e, a.viewState, n))) : t.map((a) => lt.fromModelState(Rt.moveToNextBlankLine(e.cursorConfig, e.model, a.modelState, n)));
            case 6:
              return this._moveToViewMinColumn(e, t, n);
            case 7:
              return this._moveToViewFirstNonWhitespaceColumn(e, t, n);
            case 8:
              return this._moveToViewCenterColumn(e, t, n);
            case 9:
              return this._moveToViewMaxColumn(e, t, n);
            case 10:
              return this._moveToViewLastNonWhitespaceColumn(e, t, n);
            default:
              return null;
          }
        }
        static viewportMove(e, t, i, n, o) {
          const r = e.getCompletelyVisibleViewRange(), a = e.coordinatesConverter.convertViewRangeToModelRange(r);
          switch (i) {
            case 11: {
              const l = this._firstLineNumberInRange(e.model, a, o), u = e.model.getLineFirstNonWhitespaceColumn(l);
              return [
                this._moveToModelPosition(e, t[0], n, l, u)
              ];
            }
            case 13: {
              const l = this._lastLineNumberInRange(e.model, a, o), u = e.model.getLineFirstNonWhitespaceColumn(l);
              return [
                this._moveToModelPosition(e, t[0], n, l, u)
              ];
            }
            case 12: {
              const l = Math.round((a.startLineNumber + a.endLineNumber) / 2), u = e.model.getLineFirstNonWhitespaceColumn(l);
              return [
                this._moveToModelPosition(e, t[0], n, l, u)
              ];
            }
            case 14: {
              const l = [];
              for (let u = 0, d = t.length; u < d; u++) {
                const f = t[u];
                l[u] = this.findPositionInViewportIfOutside(e, f, r, n);
              }
              return l;
            }
            default:
              return null;
          }
        }
        static findPositionInViewportIfOutside(e, t, i, n) {
          const o = t.viewState.position.lineNumber;
          if (i.startLineNumber <= o && o <= i.endLineNumber - 1) return new lt(t.modelState, t.viewState);
          {
            let r;
            o > i.endLineNumber - 1 ? r = i.endLineNumber - 1 : o < i.startLineNumber ? r = i.startLineNumber : r = o;
            const a = Rt.vertical(e.cursorConfig, e, o, t.viewState.position.column, t.viewState.leftoverVisibleColumns, r, false);
            return lt.fromViewState(t.viewState.move(n, a.lineNumber, a.column, a.leftoverVisibleColumns));
          }
        }
        static _firstLineNumberInRange(e, t, i) {
          let n = t.startLineNumber;
          return t.startColumn !== e.getLineMinColumn(n) && n++, Math.min(t.endLineNumber, n + i - 1);
        }
        static _lastLineNumberInRange(e, t, i) {
          let n = t.startLineNumber;
          return t.startColumn !== e.getLineMinColumn(n) && n++, Math.max(n, t.endLineNumber - i + 1);
        }
        static _moveLeft(e, t, i, n) {
          return t.map((o) => lt.fromViewState(Rt.moveLeft(e.cursorConfig, e, o.viewState, i, n)));
        }
        static _moveHalfLineLeft(e, t, i) {
          const n = [];
          for (let o = 0, r = t.length; o < r; o++) {
            const a = t[o], l = a.viewState.position.lineNumber, u = Math.round(e.getLineLength(l) / 2);
            n[o] = lt.fromViewState(Rt.moveLeft(e.cursorConfig, e, a.viewState, i, u));
          }
          return n;
        }
        static _moveRight(e, t, i, n) {
          return t.map((o) => lt.fromViewState(Rt.moveRight(e.cursorConfig, e, o.viewState, i, n)));
        }
        static _moveHalfLineRight(e, t, i) {
          const n = [];
          for (let o = 0, r = t.length; o < r; o++) {
            const a = t[o], l = a.viewState.position.lineNumber, u = Math.round(e.getLineLength(l) / 2);
            n[o] = lt.fromViewState(Rt.moveRight(e.cursorConfig, e, a.viewState, i, u));
          }
          return n;
        }
        static _moveDownByViewLines(e, t, i, n) {
          const o = [];
          for (let r = 0, a = t.length; r < a; r++) {
            const l = t[r];
            o[r] = lt.fromViewState(Rt.moveDown(e.cursorConfig, e, l.viewState, i, n));
          }
          return o;
        }
        static _moveDownByModelLines(e, t, i, n) {
          const o = [];
          for (let r = 0, a = t.length; r < a; r++) {
            const l = t[r];
            o[r] = lt.fromModelState(Rt.moveDown(e.cursorConfig, e.model, l.modelState, i, n));
          }
          return o;
        }
        static _moveUpByViewLines(e, t, i, n) {
          const o = [];
          for (let r = 0, a = t.length; r < a; r++) {
            const l = t[r];
            o[r] = lt.fromViewState(Rt.moveUp(e.cursorConfig, e, l.viewState, i, n));
          }
          return o;
        }
        static _moveUpByModelLines(e, t, i, n) {
          const o = [];
          for (let r = 0, a = t.length; r < a; r++) {
            const l = t[r];
            o[r] = lt.fromModelState(Rt.moveUp(e.cursorConfig, e.model, l.modelState, i, n));
          }
          return o;
        }
        static _moveToViewPosition(e, t, i, n, o) {
          return lt.fromViewState(t.viewState.move(i, n, o, 0));
        }
        static _moveToModelPosition(e, t, i, n, o) {
          return lt.fromModelState(t.modelState.move(i, n, o, 0));
        }
        static _moveToViewMinColumn(e, t, i) {
          const n = [];
          for (let o = 0, r = t.length; o < r; o++) {
            const a = t[o], l = a.viewState.position.lineNumber, u = e.getLineMinColumn(l);
            n[o] = this._moveToViewPosition(e, a, i, l, u);
          }
          return n;
        }
        static _moveToViewFirstNonWhitespaceColumn(e, t, i) {
          const n = [];
          for (let o = 0, r = t.length; o < r; o++) {
            const a = t[o], l = a.viewState.position.lineNumber, u = e.getLineFirstNonWhitespaceColumn(l);
            n[o] = this._moveToViewPosition(e, a, i, l, u);
          }
          return n;
        }
        static _moveToViewCenterColumn(e, t, i) {
          const n = [];
          for (let o = 0, r = t.length; o < r; o++) {
            const a = t[o], l = a.viewState.position.lineNumber, u = Math.round((e.getLineMaxColumn(l) + e.getLineMinColumn(l)) / 2);
            n[o] = this._moveToViewPosition(e, a, i, l, u);
          }
          return n;
        }
        static _moveToViewMaxColumn(e, t, i) {
          const n = [];
          for (let o = 0, r = t.length; o < r; o++) {
            const a = t[o], l = a.viewState.position.lineNumber, u = e.getLineMaxColumn(l);
            n[o] = this._moveToViewPosition(e, a, i, l, u);
          }
          return n;
        }
        static _moveToViewLastNonWhitespaceColumn(e, t, i) {
          const n = [];
          for (let o = 0, r = t.length; o < r; o++) {
            const a = t[o], l = a.viewState.position.lineNumber, u = e.getLineLastNonWhitespaceColumn(l);
            n[o] = this._moveToViewPosition(e, a, i, l, u);
          }
          return n;
        }
      }
      var _C;
      (function(s) {
        const e = function(i) {
          if (!Es(i)) return false;
          const n = i;
          return !(!ho(n.to) || !Po(n.select) && !j7(n.select) || !Po(n.by) && !ho(n.by) || !Po(n.value) && !wg(n.value));
        };
        s.metadata = {
          description: "Move cursor to a logical position in the view",
          args: [
            {
              name: "Cursor move argument object",
              description: `Property-value pairs that can be passed through this argument:
					* 'to': A mandatory logical position value providing where to move the cursor.
						\`\`\`
						'left', 'right', 'up', 'down', 'prevBlankLine', 'nextBlankLine',
						'wrappedLineStart', 'wrappedLineEnd', 'wrappedLineColumnCenter'
						'wrappedLineFirstNonWhitespaceCharacter', 'wrappedLineLastNonWhitespaceCharacter'
						'viewPortTop', 'viewPortCenter', 'viewPortBottom', 'viewPortIfOutside'
						\`\`\`
					* 'by': Unit to move. Default is computed based on 'to' value.
						\`\`\`
						'line', 'wrappedLine', 'character', 'halfLine'
						\`\`\`
					* 'value': Number of units to move. Default is '1'.
					* 'select': If 'true' makes the selection. Default is 'false'.
				`,
              constraint: e,
              schema: {
                type: "object",
                required: [
                  "to"
                ],
                properties: {
                  to: {
                    type: "string",
                    enum: [
                      "left",
                      "right",
                      "up",
                      "down",
                      "prevBlankLine",
                      "nextBlankLine",
                      "wrappedLineStart",
                      "wrappedLineEnd",
                      "wrappedLineColumnCenter",
                      "wrappedLineFirstNonWhitespaceCharacter",
                      "wrappedLineLastNonWhitespaceCharacter",
                      "viewPortTop",
                      "viewPortCenter",
                      "viewPortBottom",
                      "viewPortIfOutside"
                    ]
                  },
                  by: {
                    type: "string",
                    enum: [
                      "line",
                      "wrappedLine",
                      "character",
                      "halfLine"
                    ]
                  },
                  value: {
                    type: "number",
                    default: 1
                  },
                  select: {
                    type: "boolean",
                    default: false
                  }
                }
              }
            }
          ]
        }, s.RawDirection = {
          Left: "left",
          Right: "right",
          Up: "up",
          Down: "down",
          PrevBlankLine: "prevBlankLine",
          NextBlankLine: "nextBlankLine",
          WrappedLineStart: "wrappedLineStart",
          WrappedLineFirstNonWhitespaceCharacter: "wrappedLineFirstNonWhitespaceCharacter",
          WrappedLineColumnCenter: "wrappedLineColumnCenter",
          WrappedLineEnd: "wrappedLineEnd",
          WrappedLineLastNonWhitespaceCharacter: "wrappedLineLastNonWhitespaceCharacter",
          ViewPortTop: "viewPortTop",
          ViewPortCenter: "viewPortCenter",
          ViewPortBottom: "viewPortBottom",
          ViewPortIfOutside: "viewPortIfOutside"
        }, s.RawUnit = {
          Line: "line",
          WrappedLine: "wrappedLine",
          Character: "character",
          HalfLine: "halfLine"
        };
        function t(i) {
          if (!i.to) return null;
          let n;
          switch (i.to) {
            case s.RawDirection.Left:
              n = 0;
              break;
            case s.RawDirection.Right:
              n = 1;
              break;
            case s.RawDirection.Up:
              n = 2;
              break;
            case s.RawDirection.Down:
              n = 3;
              break;
            case s.RawDirection.PrevBlankLine:
              n = 4;
              break;
            case s.RawDirection.NextBlankLine:
              n = 5;
              break;
            case s.RawDirection.WrappedLineStart:
              n = 6;
              break;
            case s.RawDirection.WrappedLineFirstNonWhitespaceCharacter:
              n = 7;
              break;
            case s.RawDirection.WrappedLineColumnCenter:
              n = 8;
              break;
            case s.RawDirection.WrappedLineEnd:
              n = 9;
              break;
            case s.RawDirection.WrappedLineLastNonWhitespaceCharacter:
              n = 10;
              break;
            case s.RawDirection.ViewPortTop:
              n = 11;
              break;
            case s.RawDirection.ViewPortBottom:
              n = 13;
              break;
            case s.RawDirection.ViewPortCenter:
              n = 12;
              break;
            case s.RawDirection.ViewPortIfOutside:
              n = 14;
              break;
            default:
              return null;
          }
          let o = 0;
          switch (i.by) {
            case s.RawUnit.Line:
              o = 1;
              break;
            case s.RawUnit.WrappedLine:
              o = 2;
              break;
            case s.RawUnit.Character:
              o = 3;
              break;
            case s.RawUnit.HalfLine:
              o = 4;
              break;
          }
          return {
            direction: n,
            unit: o,
            select: !!i.select,
            value: i.value || 1
          };
        }
        s.parse = t;
      })(_C || (_C = {}));
      class Vle {
        constructor(e, t, i) {
          this._indentRulesSupport = t, this._indentationLineProcessor = new TF(e, i);
        }
        shouldIncrease(e, t) {
          const i = this._indentationLineProcessor.getProcessedLine(e, t);
          return this._indentRulesSupport.shouldIncrease(i);
        }
        shouldDecrease(e, t) {
          const i = this._indentationLineProcessor.getProcessedLine(e, t);
          return this._indentRulesSupport.shouldDecrease(i);
        }
        shouldIgnore(e, t) {
          const i = this._indentationLineProcessor.getProcessedLine(e, t);
          return this._indentRulesSupport.shouldIgnore(i);
        }
        shouldIndentNextLine(e, t) {
          const i = this._indentationLineProcessor.getProcessedLine(e, t);
          return this._indentRulesSupport.shouldIndentNextLine(i);
        }
      }
      class XN {
        constructor(e, t) {
          this.model = e, this.indentationLineProcessor = new TF(e, t);
        }
        getProcessedTokenContextAroundRange(e) {
          const t = this._getProcessedTokensBeforeRange(e), i = this._getProcessedTokensAfterRange(e), n = this._getProcessedPreviousLineTokens(e);
          return {
            beforeRangeProcessedTokens: t,
            afterRangeProcessedTokens: i,
            previousLineProcessedTokens: n
          };
        }
        _getProcessedTokensBeforeRange(e) {
          this.model.tokenization.forceTokenization(e.startLineNumber);
          const t = this.model.tokenization.getLineTokens(e.startLineNumber), i = gh(t, e.startColumn - 1);
          let n;
          if (JN(this.model, e.getStartPosition())) {
            const r = e.startColumn - 1 - i.firstCharOffset, a = i.firstCharOffset, l = a + r;
            n = t.sliceAndInflate(a, l, 0);
          } else {
            const r = e.startColumn - 1;
            n = t.sliceAndInflate(0, r, 0);
          }
          return this.indentationLineProcessor.getProcessedTokens(n);
        }
        _getProcessedTokensAfterRange(e) {
          const t = e.isEmpty() ? e.getStartPosition() : e.getEndPosition();
          this.model.tokenization.forceTokenization(t.lineNumber);
          const i = this.model.tokenization.getLineTokens(t.lineNumber), n = gh(i, t.column - 1), o = t.column - 1 - n.firstCharOffset, r = n.firstCharOffset + o, a = n.firstCharOffset + n.getLineLength(), l = i.sliceAndInflate(r, a, 0);
          return this.indentationLineProcessor.getProcessedTokens(l);
        }
        _getProcessedPreviousLineTokens(e) {
          const t = (_) => {
            this.model.tokenization.forceTokenization(_);
            const b = this.model.tokenization.getLineTokens(_), v = this.model.getLineMaxColumn(_) - 1;
            return gh(b, v);
          };
          this.model.tokenization.forceTokenization(e.startLineNumber);
          const i = this.model.tokenization.getLineTokens(e.startLineNumber), n = gh(i, e.startColumn - 1), o = Fi.createEmpty("", n.languageIdCodec), r = e.startLineNumber - 1;
          if (r === 0 || !(n.firstCharOffset === 0)) return o;
          const u = t(r);
          if (!(n.languageId === u.languageId)) return o;
          const f = u.toIViewLineTokens();
          return this.indentationLineProcessor.getProcessedTokens(f);
        }
      }
      class TF {
        constructor(e, t) {
          this.model = e, this.languageConfigurationService = t;
        }
        getProcessedLine(e, t) {
          var _a3, _b3;
          const i = (r, a) => {
            const l = us(r);
            return a + r.substring(l.length);
          };
          (_b3 = (_a3 = this.model.tokenization).forceTokenization) == null ? void 0 : _b3.call(_a3, e);
          const n = this.model.tokenization.getLineTokens(e);
          let o = this.getProcessedTokens(n).getLineContent();
          return t !== void 0 && (o = i(o, t)), o;
        }
        getProcessedTokens(e) {
          const t = (l) => l === 2 || l === 3 || l === 1, i = e.getLanguageId(0), o = this.languageConfigurationService.getLanguageConfiguration(i).bracketsNew.getBracketRegExp({
            global: true
          }), r = [];
          return e.forEach((l) => {
            const u = e.getStandardTokenType(l);
            let d = e.getTokenText(l);
            t(u) && (d = d.replace(o, ""));
            const f = e.getMetadata(l);
            r.push({
              text: d,
              metadata: f
            });
          }), Fi.createFromTextAndMetadata(r, e.languageIdCodec);
        }
      }
      function JN(s, e) {
        s.tokenization.forceTokenization(e.lineNumber);
        const t = s.tokenization.getLineTokens(e.lineNumber), i = gh(t, e.column - 1), n = i.firstCharOffset === 0, o = t.getLanguageId(0) === i.languageId;
        return !n && !o;
      }
      function eI(s, e, t, i) {
        e.tokenization.forceTokenization(t.startLineNumber);
        const n = e.getLanguageIdAtPosition(t.startLineNumber, t.startColumn), o = i.getLanguageConfiguration(n);
        if (!o) return null;
        const a = new XN(e, i).getProcessedTokenContextAroundRange(t), l = a.previousLineProcessedTokens.getLineContent(), u = a.beforeRangeProcessedTokens.getLineContent(), d = a.afterRangeProcessedTokens.getLineContent(), f = o.onEnter(s, l, u, d);
        if (!f) return null;
        const m = f.indentAction;
        let _ = f.appendText;
        const b = f.removeText || 0;
        _ ? m === ds.Indent && (_ = "	" + _) : m === ds.Indent || m === ds.IndentOutdent ? _ = "	" : _ = "";
        let v = y8(e, t.startLineNumber, t.startColumn);
        return b && (v = v.substring(0, v.length - b)), {
          indentAction: m,
          appendText: _,
          removeText: b,
          indentation: v
        };
      }
      var Wle = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      }, Hle = function(s, e) {
        return function(t, i) {
          e(t, i, s);
        };
      }, V0;
      const Cx = /* @__PURE__ */ Object.create(null);
      function Hu(s, e) {
        if (e <= 0) return "";
        Cx[s] || (Cx[s] = [
          "",
          s
        ]);
        const t = Cx[s];
        for (let i = t.length; i <= e; i++) t[i] = t[i - 1] + s;
        return t[e];
      }
      let zh = V0 = class {
        static unshiftIndent(e, t, i, n, o) {
          const r = Gi.visibleColumnFromColumn(e, t, i);
          if (o) {
            const a = Hu(" ", n), u = Gi.prevIndentTabStop(r, n) / n;
            return Hu(a, u);
          } else {
            const a = "	", u = Gi.prevRenderTabStop(r, i) / i;
            return Hu(a, u);
          }
        }
        static shiftIndent(e, t, i, n, o) {
          const r = Gi.visibleColumnFromColumn(e, t, i);
          if (o) {
            const a = Hu(" ", n), u = Gi.nextIndentTabStop(r, n) / n;
            return Hu(a, u);
          } else {
            const a = "	", u = Gi.nextRenderTabStop(r, i) / i;
            return Hu(a, u);
          }
        }
        constructor(e, t, i) {
          this._languageConfigurationService = i, this._opts = t, this._selection = e, this._selectionId = null, this._useLastEditRangeForCursorEndPosition = false, this._selectionStartColumnStaysPut = false;
        }
        _addEditOperation(e, t, i) {
          this._useLastEditRangeForCursorEndPosition ? e.addTrackedEditOperation(t, i) : e.addEditOperation(t, i);
        }
        getEditOperations(e, t) {
          const i = this._selection.startLineNumber;
          let n = this._selection.endLineNumber;
          this._selection.endColumn === 1 && i !== n && (n = n - 1);
          const { tabSize: o, indentSize: r, insertSpaces: a } = this._opts, l = i === n;
          if (this._opts.useTabStops) {
            this._selection.isEmpty() && /^\s*$/.test(e.getLineContent(i)) && (this._useLastEditRangeForCursorEndPosition = true);
            let u = 0, d = 0;
            for (let f = i; f <= n; f++, u = d) {
              d = 0;
              const m = e.getLineContent(f);
              let _ = qs(m);
              if (this._opts.isUnshift && (m.length === 0 || _ === 0) || !l && !this._opts.isUnshift && m.length === 0) continue;
              if (_ === -1 && (_ = m.length), f > 1 && Gi.visibleColumnFromColumn(m, _ + 1, o) % r !== 0 && e.tokenization.isCheapToTokenize(f - 1)) {
                const y = eI(this._opts.autoIndent, e, new z(f - 1, e.getLineMaxColumn(f - 1), f - 1, e.getLineMaxColumn(f - 1)), this._languageConfigurationService);
                if (y) {
                  if (d = u, y.appendText) for (let x = 0, L = y.appendText.length; x < L && d < r && y.appendText.charCodeAt(x) === 32; x++) d++;
                  y.removeText && (d = Math.max(0, d - y.removeText));
                  for (let x = 0; x < d && !(_ === 0 || m.charCodeAt(_ - 1) !== 32); x++) _--;
                }
              }
              if (this._opts.isUnshift && _ === 0) continue;
              let b;
              this._opts.isUnshift ? b = V0.unshiftIndent(m, _ + 1, o, r, a) : b = V0.shiftIndent(m, _ + 1, o, r, a), this._addEditOperation(t, new z(f, 1, f, _ + 1), b), f === i && !this._selection.isEmpty() && (this._selectionStartColumnStaysPut = this._selection.startColumn <= _ + 1);
            }
          } else {
            !this._opts.isUnshift && this._selection.isEmpty() && e.getLineLength(i) === 0 && (this._useLastEditRangeForCursorEndPosition = true);
            const u = a ? Hu(" ", r) : "	";
            for (let d = i; d <= n; d++) {
              const f = e.getLineContent(d);
              let m = qs(f);
              if (!(this._opts.isUnshift && (f.length === 0 || m === 0)) && !(!l && !this._opts.isUnshift && f.length === 0) && (m === -1 && (m = f.length), !(this._opts.isUnshift && m === 0))) if (this._opts.isUnshift) {
                m = Math.min(m, r);
                for (let _ = 0; _ < m; _++) if (f.charCodeAt(_) === 9) {
                  m = _ + 1;
                  break;
                }
                this._addEditOperation(t, new z(d, 1, d, m + 1), "");
              } else this._addEditOperation(t, new z(d, 1, d, 1), u), d === i && !this._selection.isEmpty() && (this._selectionStartColumnStaysPut = this._selection.startColumn === 1);
            }
          }
          this._selectionId = t.trackSelection(this._selection);
        }
        computeCursorState(e, t) {
          if (this._useLastEditRangeForCursorEndPosition) {
            const n = t.getInverseEditOperations()[0];
            return new mt(n.range.endLineNumber, n.range.endColumn, n.range.endLineNumber, n.range.endColumn);
          }
          const i = t.getTrackedSelection(this._selectionId);
          if (this._selectionStartColumnStaysPut) {
            const n = this._selection.startColumn;
            return i.startColumn <= n ? i : i.getDirection() === 0 ? new mt(i.startLineNumber, n, i.endLineNumber, i.endColumn) : new mt(i.endLineNumber, i.endColumn, i.startLineNumber, n);
          }
          return i;
        }
      };
      zh = V0 = Wle([
        Hle(2, Pa)
      ], zh);
      class zle {
        constructor(e, t, i) {
          this._range = e, this._charBeforeSelection = t, this._charAfterSelection = i;
        }
        getEditOperations(e, t) {
          t.addTrackedEditOperation(new z(this._range.startLineNumber, this._range.startColumn, this._range.startLineNumber, this._range.startColumn), this._charBeforeSelection), t.addTrackedEditOperation(new z(this._range.endLineNumber, this._range.endColumn, this._range.endLineNumber, this._range.endColumn), this._charAfterSelection);
        }
        computeCursorState(e, t) {
          const i = t.getInverseEditOperations(), n = i[0].range, o = i[1].range;
          return new mt(n.endLineNumber, n.endColumn, o.endLineNumber, o.endColumn - this._charAfterSelection.length);
        }
      }
      class Ule {
        constructor(e, t, i) {
          this._position = e, this._text = t, this._charAfter = i;
        }
        getEditOperations(e, t) {
          t.addTrackedEditOperation(new z(this._position.lineNumber, this._position.column, this._position.lineNumber, this._position.column), this._text + this._charAfter);
        }
        computeCursorState(e, t) {
          const n = t.getInverseEditOperations()[0].range;
          return new mt(n.endLineNumber, n.startColumn, n.endLineNumber, n.endColumn - this._charAfter.length);
        }
      }
      function $le(s, e, t) {
        const i = s.tokenization.getLanguageIdAtPosition(e, 0);
        if (e > 1) {
          let n, o = -1;
          for (n = e - 1; n >= 1; n--) {
            if (s.tokenization.getLanguageIdAtPosition(n, 0) !== i) return o;
            const r = s.getLineContent(n);
            if (t.shouldIgnore(n) || /^\s+$/.test(r) || r === "") {
              o = n;
              continue;
            }
            return n;
          }
        }
        return -1;
      }
      function bC(s, e, t, i = true, n) {
        if (s < 4) return null;
        const o = n.getLanguageConfiguration(e.tokenization.getLanguageId()).indentRulesSupport;
        if (!o) return null;
        const r = new Vle(e, o, n);
        if (t <= 1) return {
          indentation: "",
          action: null
        };
        for (let l = t - 1; l > 0 && e.getLineContent(l) === ""; l--) if (l === 1) return {
          indentation: "",
          action: null
        };
        const a = $le(e, t, r);
        if (a < 0) return null;
        if (a < 1) return {
          indentation: "",
          action: null
        };
        if (r.shouldIncrease(a) || r.shouldIndentNextLine(a)) {
          const l = e.getLineContent(a);
          return {
            indentation: us(l),
            action: ds.Indent,
            line: a
          };
        } else if (r.shouldDecrease(a)) {
          const l = e.getLineContent(a);
          return {
            indentation: us(l),
            action: null,
            line: a
          };
        } else {
          if (a === 1) return {
            indentation: us(e.getLineContent(a)),
            action: null,
            line: a
          };
          const l = a - 1, u = o.getIndentMetadata(e.getLineContent(l));
          if (!(u & 3) && u & 4) {
            let d = 0;
            for (let f = l - 1; f > 0; f--) if (!r.shouldIndentNextLine(f)) {
              d = f;
              break;
            }
            return {
              indentation: us(e.getLineContent(d + 1)),
              action: null,
              line: d + 1
            };
          }
          if (i) return {
            indentation: us(e.getLineContent(a)),
            action: null,
            line: a
          };
          for (let d = a; d > 0; d--) {
            if (r.shouldIncrease(d)) return {
              indentation: us(e.getLineContent(d)),
              action: ds.Indent,
              line: d
            };
            if (r.shouldIndentNextLine(d)) {
              let f = 0;
              for (let m = d - 1; m > 0; m--) if (!r.shouldIndentNextLine(d)) {
                f = m;
                break;
              }
              return {
                indentation: us(e.getLineContent(f + 1)),
                action: null,
                line: f + 1
              };
            } else if (r.shouldDecrease(d)) return {
              indentation: us(e.getLineContent(d)),
              action: null,
              line: d
            };
          }
          return {
            indentation: us(e.getLineContent(1)),
            action: null,
            line: 1
          };
        }
      }
      function qle(s, e, t, i, n) {
        if (s < 4) return null;
        const o = e.getLanguageIdAtPosition(t.startLineNumber, t.startColumn), r = n.getLanguageConfiguration(o).indentRulesSupport;
        if (!r) return null;
        e.tokenization.forceTokenization(t.startLineNumber);
        const l = new XN(e, n).getProcessedTokenContextAroundRange(t), u = l.afterRangeProcessedTokens, d = l.beforeRangeProcessedTokens, f = us(d.getLineContent()), m = jle(e, t.startLineNumber, d), _ = JN(e, t.getStartPosition()), b = e.getLineContent(t.startLineNumber), v = us(b), y = bC(s, m, t.startLineNumber + 1, void 0, n);
        if (!y) {
          const L = _ ? v : f;
          return {
            beforeEnter: L,
            afterEnter: L
          };
        }
        let x = _ ? v : y.indentation;
        return y.action === ds.Indent && (x = i.shiftIndent(x)), r.shouldDecrease(u.getLineContent()) && (x = i.unshiftIndent(x)), {
          beforeEnter: _ ? v : f,
          afterEnter: x
        };
      }
      function Kle(s, e, t, i, n, o) {
        var _a3;
        const r = s.autoIndent;
        if (r < 4 || JN(e, t.getStartPosition())) return null;
        const l = e.getLanguageIdAtPosition(t.startLineNumber, t.startColumn), u = o.getLanguageConfiguration(l).indentRulesSupport;
        if (!u) return null;
        const f = new XN(e, o).getProcessedTokenContextAroundRange(t), m = f.beforeRangeProcessedTokens.getLineContent(), _ = f.afterRangeProcessedTokens.getLineContent(), b = m + _, v = m + i + _;
        if (!u.shouldDecrease(b) && u.shouldDecrease(v)) {
          const x = bC(r, e, t.startLineNumber, false, o);
          if (!x) return null;
          let L = x.indentation;
          return x.action !== ds.Indent && (L = n.unshiftIndent(L)), L;
        }
        const y = t.startLineNumber - 1;
        if (y > 0) {
          const x = e.getLineContent(y);
          if (u.shouldIndentNextLine(x) && u.shouldIncrease(v)) {
            const D = (_a3 = bC(r, e, t.startLineNumber, false, o)) == null ? void 0 : _a3.indentation;
            if (D !== void 0) {
              const k = e.getLineContent(t.startLineNumber), T = us(k), I = n.shiftIndent(D) === T, R = /^\s*$/.test(b), A = s.autoClosingPairs.autoClosingPairsOpenByEnd.get(i), U = A && A.length > 0 && R;
              if (I && U) return D;
            }
          }
        }
        return null;
      }
      function jle(s, e, t) {
        return {
          tokenization: {
            getLineTokens: (n) => n === e ? t : s.tokenization.getLineTokens(n),
            getLanguageId: () => s.getLanguageId(),
            getLanguageIdAtPosition: (n, o) => s.getLanguageIdAtPosition(n, o)
          },
          getLineContent: (n) => n === e ? t.getLineContent() : s.getLineContent(n)
        };
      }
      class Gle {
        static getEdits(e, t, i, n, o) {
          if (!o && this._isAutoIndentType(e, t, i)) {
            const r = [];
            for (const l of i) {
              const u = this._findActualIndentationForSelection(e, t, l, n);
              if (u === null) return;
              r.push({
                selection: l,
                indentation: u
              });
            }
            const a = Z2.getAutoClosingPairClose(e, t, i, n, false);
            return this._getIndentationAndAutoClosingPairEdits(e, t, r, n, a);
          }
        }
        static _isAutoIndentType(e, t, i) {
          if (e.autoIndent < 4) return false;
          for (let n = 0, o = i.length; n < o; n++) if (!t.tokenization.isCheapToTokenize(i[n].getEndPosition().lineNumber)) return false;
          return true;
        }
        static _findActualIndentationForSelection(e, t, i, n) {
          const o = Kle(e, t, i, n, {
            shiftIndent: (a) => nI(e, a),
            unshiftIndent: (a) => vC(e, a)
          }, e.languageConfigurationService);
          if (o === null) return null;
          const r = y8(t, i.startLineNumber, i.startColumn);
          return o === e.normalizeIndentation(r) ? null : o;
        }
        static _getIndentationAndAutoClosingPairEdits(e, t, i, n, o) {
          const r = i.map(({ selection: l, indentation: u }) => {
            if (o !== null) {
              const d = this._getEditFromIndentationAndSelection(e, t, u, l, n, false);
              return new oce(d, l, n, o);
            } else {
              const d = this._getEditFromIndentationAndSelection(e, t, u, l, n, true);
              return Gu(d.range, d.text, false);
            }
          }), a = {
            shouldPushStackElementBefore: true,
            shouldPushStackElementAfter: false
          };
          return new As(4, r, a);
        }
        static _getEditFromIndentationAndSelection(e, t, i, n, o, r = true) {
          const a = n.startLineNumber, l = t.getLineFirstNonWhitespaceColumn(a);
          let u = e.normalizeIndentation(i);
          if (l !== 0) {
            const f = t.getLineContent(a);
            u += f.substring(l - 1, n.startColumn - 1);
          }
          return u += r ? o : "", {
            range: new z(a, 1, n.endLineNumber, n.endColumn),
            text: u
          };
        }
      }
      class Yle {
        static getEdits(e, t, i, n, o, r) {
          if (IF(t, i, n, o, r)) return this._runAutoClosingOvertype(e, n, r);
        }
        static _runAutoClosingOvertype(e, t, i) {
          const n = [];
          for (let o = 0, r = t.length; o < r; o++) {
            const l = t[o].getPosition(), u = new z(l.lineNumber, l.column, l.lineNumber, l.column + 1);
            n[o] = new zs(u, i);
          }
          return new As(4, n, {
            shouldPushStackElementBefore: Uw(e, 4),
            shouldPushStackElementAfter: false
          });
        }
      }
      class Zle {
        static getEdits(e, t, i, n, o) {
          if (IF(e, t, i, n, o)) {
            const r = i.map((a) => new zs(new z(a.positionLineNumber, a.positionColumn, a.positionLineNumber, a.positionColumn + 1), "", false));
            return new As(4, r, {
              shouldPushStackElementBefore: true,
              shouldPushStackElementAfter: false
            });
          }
        }
      }
      class Z2 {
        static getEdits(e, t, i, n, o, r) {
          if (!r) {
            const a = this.getAutoClosingPairClose(e, t, i, n, o);
            if (a !== null) return this._runAutoClosingOpenCharType(i, n, o, a);
          }
        }
        static _runAutoClosingOpenCharType(e, t, i, n) {
          const o = [];
          for (let r = 0, a = e.length; r < a; r++) {
            const l = e[r];
            o[r] = new sce(l, t, !i, n);
          }
          return new As(4, o, {
            shouldPushStackElementBefore: true,
            shouldPushStackElementAfter: false
          });
        }
        static getAutoClosingPairClose(e, t, i, n, o) {
          for (const b of i) if (!b.isEmpty()) return null;
          const r = i.map((b) => {
            const v = b.getPosition();
            return o ? {
              lineNumber: v.lineNumber,
              beforeColumn: v.column - n.length,
              afterColumn: v.column
            } : {
              lineNumber: v.lineNumber,
              beforeColumn: v.column,
              afterColumn: v.column
            };
          }), a = this._findAutoClosingPairOpen(e, t, r.map((b) => new X(b.lineNumber, b.beforeColumn)), n);
          if (!a) return null;
          let l, u;
          if (uu(n) ? (l = e.autoClosingQuotes, u = e.shouldAutoCloseBefore.quote) : (e.blockCommentStartToken ? a.open.includes(e.blockCommentStartToken) : false) ? (l = e.autoClosingComments, u = e.shouldAutoCloseBefore.comment) : (l = e.autoClosingBrackets, u = e.shouldAutoCloseBefore.bracket), l === "never") return null;
          const f = this._findContainedAutoClosingPair(e, a), m = f ? f.close : "";
          let _ = true;
          for (const b of r) {
            const { lineNumber: v, beforeColumn: y, afterColumn: x } = b, L = t.getLineContent(v), D = L.substring(0, y - 1), k = L.substring(x - 1);
            if (k.startsWith(m) || (_ = false), k.length > 0) {
              const R = k.charAt(0);
              if (!this._isBeforeClosingBrace(e, k) && !u(R)) return null;
            }
            if (a.open.length === 1 && (n === "'" || n === '"') && l !== "always") {
              const R = rg(e.wordSeparators, []);
              if (D.length > 0) {
                const A = D.charCodeAt(D.length - 1);
                if (R.get(A) === 0) return null;
              }
            }
            if (!t.tokenization.isCheapToTokenize(v)) return null;
            t.tokenization.forceTokenization(v);
            const T = t.tokenization.getLineTokens(v), M = gh(T, y - 1);
            if (!a.shouldAutoClose(M, y - M.firstCharOffset)) return null;
            const I = a.findNeutralCharacter();
            if (I) {
              const R = t.tokenization.getTokenTypeIfInsertingCharacter(v, y, I);
              if (!a.isOK(R)) return null;
            }
          }
          return _ ? a.close.substring(0, a.close.length - m.length) : a.close;
        }
        static _findContainedAutoClosingPair(e, t) {
          if (t.open.length <= 1) return null;
          const i = t.close.charAt(t.close.length - 1), n = e.autoClosingPairs.autoClosingPairsCloseByEnd.get(i) || [];
          let o = null;
          for (const r of n) r.open !== t.open && t.open.includes(r.open) && t.close.endsWith(r.close) && (!o || r.open.length > o.open.length) && (o = r);
          return o;
        }
        static _findAutoClosingPairOpen(e, t, i, n) {
          const o = e.autoClosingPairs.autoClosingPairsOpenByEnd.get(n);
          if (!o) return null;
          let r = null;
          for (const a of o) if (r === null || a.open.length > r.open.length) {
            let l = true;
            for (const u of i) if (t.getValueInRange(new z(u.lineNumber, u.column - a.open.length + 1, u.lineNumber, u.column)) + n !== a.open) {
              l = false;
              break;
            }
            l && (r = a);
          }
          return r;
        }
        static _isBeforeClosingBrace(e, t) {
          const i = t.charAt(0), n = e.autoClosingPairs.autoClosingPairsOpenByStart.get(i) || [], o = e.autoClosingPairs.autoClosingPairsCloseByStart.get(i) || [], r = n.some((l) => t.startsWith(l.open)), a = o.some((l) => t.startsWith(l.close));
          return !r && a;
        }
      }
      class Qle {
        static getEdits(e, t, i, n, o) {
          if (!o && this._isSurroundSelectionType(e, t, i, n)) return this._runSurroundSelectionType(e, i, n);
        }
        static _runSurroundSelectionType(e, t, i) {
          const n = [];
          for (let o = 0, r = t.length; o < r; o++) {
            const a = t[o], l = e.surroundingPairs[i];
            n[o] = new zle(a, i, l);
          }
          return new As(0, n, {
            shouldPushStackElementBefore: true,
            shouldPushStackElementAfter: true
          });
        }
        static _isSurroundSelectionType(e, t, i, n) {
          if (!MF(e, n) || !e.surroundingPairs.hasOwnProperty(n)) return false;
          const o = uu(n);
          for (const r of i) {
            if (r.isEmpty()) return false;
            let a = true;
            for (let l = r.startLineNumber; l <= r.endLineNumber; l++) {
              const u = t.getLineContent(l), d = l === r.startLineNumber ? r.startColumn - 1 : 0, f = l === r.endLineNumber ? r.endColumn - 1 : u.length, m = u.substring(d, f);
              if (/[^ \t]/.test(m)) {
                a = false;
                break;
              }
            }
            if (a) return false;
            if (o && r.startLineNumber === r.endLineNumber && r.startColumn + 1 === r.endColumn) {
              const l = t.getValueInRange(r);
              if (uu(l)) return false;
            }
          }
          return true;
        }
      }
      class Xle {
        static getEdits(e, t, i, n, o, r) {
          if (!r && this._isTypeInterceptorElectricChar(t, i, n)) {
            const a = this._typeInterceptorElectricChar(e, t, i, n[0], o);
            if (a) return a;
          }
        }
        static _isTypeInterceptorElectricChar(e, t, i) {
          return !!(i.length === 1 && t.tokenization.isCheapToTokenize(i[0].getEndPosition().lineNumber));
        }
        static _typeInterceptorElectricChar(e, t, i, n, o) {
          if (!t.electricChars.hasOwnProperty(o) || !n.isEmpty()) return null;
          const r = n.getPosition();
          i.tokenization.forceTokenization(r.lineNumber);
          const a = i.tokenization.getLineTokens(r.lineNumber);
          let l;
          try {
            l = t.onElectricCharacter(o, a, r.column);
          } catch (u) {
            return qt(u), null;
          }
          if (!l) return null;
          if (l.matchOpenBracket) {
            const u = (a.getLineContent() + o).lastIndexOf(l.matchOpenBracket) + 1, d = i.bracketPairs.findMatchingBracketUp(l.matchOpenBracket, {
              lineNumber: r.lineNumber,
              column: u
            }, 500);
            if (d) {
              if (d.startLineNumber === r.lineNumber) return null;
              const f = i.getLineContent(d.startLineNumber), m = us(f), _ = t.normalizeIndentation(m), b = i.getLineContent(r.lineNumber), v = i.getLineFirstNonWhitespaceColumn(r.lineNumber) || r.column, y = b.substring(v - 1, r.column - 1), x = _ + y + o, L = new z(r.lineNumber, 1, r.lineNumber, r.column), D = new zs(L, x);
              return new As(iI(x, e), [
                D
              ], {
                shouldPushStackElementBefore: false,
                shouldPushStackElementAfter: true
              });
            }
          }
          return null;
        }
      }
      class Jle {
        static getEdits(e, t, i) {
          const n = [];
          for (let r = 0, a = t.length; r < a; r++) n[r] = new zs(t[r], i);
          const o = iI(i, e);
          return new As(o, n, {
            shouldPushStackElementBefore: Uw(e, o),
            shouldPushStackElementAfter: false
          });
        }
      }
      class NF {
        static getEdits(e, t, i, n, o) {
          if (!o && n === `
`) {
            const r = [];
            for (let a = 0, l = i.length; a < l; a++) r[a] = this._enter(e, t, false, i[a]);
            return new As(4, r, {
              shouldPushStackElementBefore: true,
              shouldPushStackElementAfter: false
            });
          }
        }
        static _enter(e, t, i, n) {
          if (e.autoIndent === 0) return Gu(n, `
`, i);
          if (!t.tokenization.isCheapToTokenize(n.getStartPosition().lineNumber) || e.autoIndent === 1) {
            const l = t.getLineContent(n.startLineNumber), u = us(l).substring(0, n.startColumn - 1);
            return Gu(n, `
` + e.normalizeIndentation(u), i);
          }
          const o = eI(e.autoIndent, t, n, e.languageConfigurationService);
          if (o) {
            if (o.indentAction === ds.None) return Gu(n, `
` + e.normalizeIndentation(o.indentation + o.appendText), i);
            if (o.indentAction === ds.Indent) return Gu(n, `
` + e.normalizeIndentation(o.indentation + o.appendText), i);
            if (o.indentAction === ds.IndentOutdent) {
              const l = e.normalizeIndentation(o.indentation), u = e.normalizeIndentation(o.indentation + o.appendText), d = `
` + u + `
` + l;
              return i ? new F0(n, d, true) : new pC(n, d, -1, u.length - l.length, true);
            } else if (o.indentAction === ds.Outdent) {
              const l = vC(e, o.indentation);
              return Gu(n, `
` + e.normalizeIndentation(l + o.appendText), i);
            }
          }
          const r = t.getLineContent(n.startLineNumber), a = us(r).substring(0, n.startColumn - 1);
          if (e.autoIndent >= 4) {
            const l = qle(e.autoIndent, t, n, {
              unshiftIndent: (u) => vC(e, u),
              shiftIndent: (u) => nI(e, u),
              normalizeIndentation: (u) => e.normalizeIndentation(u)
            }, e.languageConfigurationService);
            if (l) {
              let u = e.visibleColumnFromColumn(t, n.getEndPosition());
              const d = n.endColumn, f = t.getLineContent(n.endLineNumber), m = qs(f);
              if (m >= 0 ? n = n.setEndPosition(n.endLineNumber, Math.max(n.endColumn, m + 1)) : n = n.setEndPosition(n.endLineNumber, t.getLineMaxColumn(n.endLineNumber)), i) return new F0(n, `
` + e.normalizeIndentation(l.afterEnter), true);
              {
                let _ = 0;
                return d <= m + 1 && (e.insertSpaces || (u = Math.ceil(u / e.indentSize)), _ = Math.min(u + 1 - e.normalizeIndentation(l.afterEnter).length - 1, 0)), new pC(n, `
` + e.normalizeIndentation(l.afterEnter), 0, _, true);
              }
            }
          }
          return Gu(n, `
` + e.normalizeIndentation(a), i);
        }
        static lineInsertBefore(e, t, i) {
          if (t === null || i === null) return [];
          const n = [];
          for (let o = 0, r = i.length; o < r; o++) {
            let a = i[o].positionLineNumber;
            if (a === 1) n[o] = new F0(new z(1, 1, 1, 1), `
`);
            else {
              a--;
              const l = t.getLineMaxColumn(a);
              n[o] = this._enter(e, t, false, new z(a, l, a, l));
            }
          }
          return n;
        }
        static lineInsertAfter(e, t, i) {
          if (t === null || i === null) return [];
          const n = [];
          for (let o = 0, r = i.length; o < r; o++) {
            const a = i[o].positionLineNumber, l = t.getLineMaxColumn(a);
            n[o] = this._enter(e, t, false, new z(a, l, a, l));
          }
          return n;
        }
        static lineBreakInsert(e, t, i) {
          const n = [];
          for (let o = 0, r = i.length; o < r; o++) n[o] = this._enter(e, t, true, i[o]);
          return n;
        }
      }
      class ece {
        static getEdits(e, t, i, n, o, r) {
          const a = this._distributePasteToCursors(e, i, n, o, r);
          return a ? (i = i.sort(z.compareRangesUsingStarts), this._distributedPaste(e, t, i, a)) : this._simplePaste(e, t, i, n, o);
        }
        static _distributePasteToCursors(e, t, i, n, o) {
          if (n || t.length === 1) return null;
          if (o && o.length === t.length) return o;
          if (e.multiCursorPaste === "spread") {
            i.charCodeAt(i.length - 1) === 10 && (i = i.substring(0, i.length - 1)), i.charCodeAt(i.length - 1) === 13 && (i = i.substring(0, i.length - 1));
            const r = xg(i);
            if (r.length === t.length) return r;
          }
          return null;
        }
        static _distributedPaste(e, t, i, n) {
          const o = [];
          for (let r = 0, a = i.length; r < a; r++) o[r] = new zs(i[r], n[r]);
          return new As(0, o, {
            shouldPushStackElementBefore: true,
            shouldPushStackElementAfter: true
          });
        }
        static _simplePaste(e, t, i, n, o) {
          const r = [];
          for (let a = 0, l = i.length; a < l; a++) {
            const u = i[a], d = u.getPosition();
            if (o && !u.isEmpty() && (o = false), o && n.indexOf(`
`) !== n.length - 1 && (o = false), o) {
              const f = new z(d.lineNumber, 1, d.lineNumber, 1);
              r[a] = new Fle(f, n, u, true);
            } else r[a] = new zs(u, n);
          }
          return new As(0, r, {
            shouldPushStackElementBefore: true,
            shouldPushStackElementAfter: true
          });
        }
      }
      class tce {
        static getEdits(e, t, i, n, o, r, a, l) {
          const u = n.map((d) => this._compositionType(i, d, o, r, a, l));
          return new As(4, u, {
            shouldPushStackElementBefore: Uw(e, 4),
            shouldPushStackElementAfter: false
          });
        }
        static _compositionType(e, t, i, n, o, r) {
          if (!t.isEmpty()) return null;
          const a = t.getPosition(), l = Math.max(1, a.column - n), u = Math.min(e.getLineMaxColumn(a.lineNumber), a.column + o), d = new z(a.lineNumber, l, a.lineNumber, u);
          return e.getValueInRange(d) === i && r === 0 ? null : new pC(d, i, 0, r);
        }
      }
      class ice {
        static getEdits(e, t, i) {
          const n = [];
          for (let r = 0, a = t.length; r < a; r++) n[r] = new zs(t[r], i);
          const o = iI(i, e);
          return new As(o, n, {
            shouldPushStackElementBefore: Uw(e, o),
            shouldPushStackElementAfter: false
          });
        }
      }
      class nce {
        static getCommands(e, t, i) {
          const n = [];
          for (let o = 0, r = i.length; o < r; o++) {
            const a = i[o];
            if (a.isEmpty()) {
              const l = t.getLineContent(a.startLineNumber);
              if (/^\s*$/.test(l) && t.tokenization.isCheapToTokenize(a.startLineNumber)) {
                let u = this._goodIndentForLine(e, t, a.startLineNumber);
                u = u || "	";
                const d = e.normalizeIndentation(u);
                if (!l.startsWith(d)) {
                  n[o] = new zs(new z(a.startLineNumber, 1, a.startLineNumber, l.length + 1), d, true);
                  continue;
                }
              }
              n[o] = this._replaceJumpToNextIndent(e, t, a, true);
            } else {
              if (a.startLineNumber === a.endLineNumber) {
                const l = t.getLineMaxColumn(a.startLineNumber);
                if (a.startColumn !== 1 || a.endColumn !== l) {
                  n[o] = this._replaceJumpToNextIndent(e, t, a, false);
                  continue;
                }
              }
              n[o] = new zh(a, {
                isUnshift: false,
                tabSize: e.tabSize,
                indentSize: e.indentSize,
                insertSpaces: e.insertSpaces,
                useTabStops: e.useTabStops,
                autoIndent: e.autoIndent
              }, e.languageConfigurationService);
            }
          }
          return n;
        }
        static _goodIndentForLine(e, t, i) {
          let n = null, o = "";
          const r = bC(e.autoIndent, t, i, false, e.languageConfigurationService);
          if (r) n = r.action, o = r.indentation;
          else if (i > 1) {
            let a;
            for (a = i - 1; a >= 1; a--) {
              const d = t.getLineContent(a);
              if (qh(d) >= 0) break;
            }
            if (a < 1) return null;
            const l = t.getLineMaxColumn(a), u = eI(e.autoIndent, t, new z(a, l, a, l), e.languageConfigurationService);
            u && (o = u.indentation + u.appendText);
          }
          return n && (n === ds.Indent && (o = nI(e, o)), n === ds.Outdent && (o = vC(e, o)), o = e.normalizeIndentation(o)), o || null;
        }
        static _replaceJumpToNextIndent(e, t, i, n) {
          let o = "";
          const r = i.getStartPosition();
          if (e.insertSpaces) {
            const a = e.visibleColumnFromColumn(t, r), l = e.indentSize, u = l - a % l;
            for (let d = 0; d < u; d++) o += " ";
          } else o = "	";
          return new zs(i, o, n);
        }
      }
      class tI extends pC {
        constructor(e, t, i, n, o, r) {
          super(e, t, i, n), this._openCharacter = o, this._closeCharacter = r, this.closeCharacterRange = null, this.enclosingRange = null;
        }
        _computeCursorStateWithRange(e, t, i) {
          return this.closeCharacterRange = new z(t.startLineNumber, t.endColumn - this._closeCharacter.length, t.endLineNumber, t.endColumn), this.enclosingRange = new z(t.startLineNumber, t.endColumn - this._openCharacter.length - this._closeCharacter.length, t.endLineNumber, t.endColumn), super.computeCursorState(e, i);
        }
      }
      class sce extends tI {
        constructor(e, t, i, n) {
          const o = (i ? t : "") + n, r = 0, a = -n.length;
          super(e, o, r, a, t, n);
        }
        computeCursorState(e, t) {
          const n = t.getInverseEditOperations()[0].range;
          return this._computeCursorStateWithRange(e, n, t);
        }
      }
      class oce extends tI {
        constructor(e, t, i, n) {
          const o = i + n, r = 0, a = i.length;
          super(t, o, r, a, i, n), this._autoIndentationEdit = e, this._autoClosingEdit = {
            range: t,
            text: o
          };
        }
        getEditOperations(e, t) {
          t.addTrackedEditOperation(this._autoIndentationEdit.range, this._autoIndentationEdit.text), t.addTrackedEditOperation(this._autoClosingEdit.range, this._autoClosingEdit.text);
        }
        computeCursorState(e, t) {
          const i = t.getInverseEditOperations();
          if (i.length !== 2) throw new Error("There should be two inverse edit operations!");
          const n = i[0].range, o = i[1].range, r = n.plusRange(o);
          return this._computeCursorStateWithRange(e, r, t);
        }
      }
      function iI(s, e) {
        return s === " " ? e === 5 || e === 6 ? 6 : 5 : 4;
      }
      function Uw(s, e) {
        return B3(s) && !B3(e) ? true : s === 5 ? false : P3(s) !== P3(e);
      }
      function P3(s) {
        return s === 6 || s === 5 ? "space" : s;
      }
      function B3(s) {
        return s === 4 || s === 5 || s === 6;
      }
      function IF(s, e, t, i, n) {
        if (s.autoClosingOvertype === "never" || !s.autoClosingPairs.autoClosingPairsCloseSingleChar.has(n)) return false;
        for (let o = 0, r = t.length; o < r; o++) {
          const a = t[o];
          if (!a.isEmpty()) return false;
          const l = a.getPosition(), u = e.getLineContent(l.lineNumber);
          if (u.charAt(l.column - 1) !== n) return false;
          const f = uu(n);
          if ((l.column > 2 ? u.charCodeAt(l.column - 2) : 0) === 92 && f) return false;
          if (s.autoClosingOvertype === "auto") {
            let _ = false;
            for (let b = 0, v = i.length; b < v; b++) {
              const y = i[b];
              if (l.lineNumber === y.startLineNumber && l.column === y.startColumn) {
                _ = true;
                break;
              }
            }
            if (!_) return false;
          }
        }
        return true;
      }
      function Gu(s, e, t) {
        return t ? new F0(s, e, true) : new zs(s, e, true);
      }
      function nI(s, e, t) {
        return t = t || 1, zh.shiftIndent(e, e.length + t, s.tabSize, s.indentSize, s.insertSpaces);
      }
      function vC(s, e, t) {
        return t = t || 1, zh.unshiftIndent(e, e.length + t, s.tabSize, s.indentSize, s.insertSpaces);
      }
      function MF(s, e) {
        return uu(e) ? s.autoSurround === "quotes" || s.autoSurround === "languageDefined" : s.autoSurround === "brackets" || s.autoSurround === "languageDefined";
      }
      class ch {
        static indent(e, t, i) {
          if (t === null || i === null) return [];
          const n = [];
          for (let o = 0, r = i.length; o < r; o++) n[o] = new zh(i[o], {
            isUnshift: false,
            tabSize: e.tabSize,
            indentSize: e.indentSize,
            insertSpaces: e.insertSpaces,
            useTabStops: e.useTabStops,
            autoIndent: e.autoIndent
          }, e.languageConfigurationService);
          return n;
        }
        static outdent(e, t, i) {
          const n = [];
          for (let o = 0, r = i.length; o < r; o++) n[o] = new zh(i[o], {
            isUnshift: true,
            tabSize: e.tabSize,
            indentSize: e.indentSize,
            insertSpaces: e.insertSpaces,
            useTabStops: e.useTabStops,
            autoIndent: e.autoIndent
          }, e.languageConfigurationService);
          return n;
        }
        static paste(e, t, i, n, o, r) {
          return ece.getEdits(e, t, i, n, o, r);
        }
        static tab(e, t, i) {
          return nce.getCommands(e, t, i);
        }
        static compositionType(e, t, i, n, o, r, a, l) {
          return tce.getEdits(e, t, i, n, o, r, a, l);
        }
        static compositionEndWithInterceptors(e, t, i, n, o, r) {
          if (!n) return null;
          let a = null;
          for (const m of n) if (a === null) a = m.insertedText;
          else if (a !== m.insertedText) return null;
          if (!a || a.length !== 1) return null;
          const l = a;
          let u = false;
          for (const m of n) if (m.deletedText.length !== 0) {
            u = true;
            break;
          }
          if (u) {
            if (!MF(t, l) || !t.surroundingPairs.hasOwnProperty(l)) return null;
            const m = uu(l);
            for (const v of n) if (v.deletedSelectionStart !== 0 || v.deletedSelectionEnd !== v.deletedText.length || /^[ \t]+$/.test(v.deletedText) || m && uu(v.deletedText)) return null;
            const _ = [];
            for (const v of o) {
              if (!v.isEmpty()) return null;
              _.push(v.getPosition());
            }
            if (_.length !== n.length) return null;
            const b = [];
            for (let v = 0, y = _.length; v < y; v++) b.push(new Ule(_[v], n[v].deletedText, t.surroundingPairs[l]));
            return new As(4, b, {
              shouldPushStackElementBefore: true,
              shouldPushStackElementAfter: false
            });
          }
          const d = Zle.getEdits(t, i, o, r, l);
          if (d !== void 0) return d;
          const f = Z2.getEdits(t, i, o, l, true, false);
          return f !== void 0 ? f : null;
        }
        static typeWithInterceptors(e, t, i, n, o, r, a) {
          const l = NF.getEdits(i, n, o, a, e);
          if (l !== void 0) return l;
          const u = Gle.getEdits(i, n, o, a, e);
          if (u !== void 0) return u;
          const d = Yle.getEdits(t, i, n, o, r, a);
          if (d !== void 0) return d;
          const f = Z2.getEdits(i, n, o, a, false, e);
          if (f !== void 0) return f;
          const m = Qle.getEdits(i, n, o, a, e);
          if (m !== void 0) return m;
          const _ = Xle.getEdits(t, i, n, o, a, e);
          return _ !== void 0 ? _ : Jle.getEdits(t, o, a);
        }
        static typeWithoutInterceptors(e, t, i, n, o) {
          return ice.getEdits(e, n, o);
        }
      }
      class rce {
        constructor(e, t, i, n, o, r) {
          this.deletedText = e, this.deletedSelectionStart = t, this.deletedSelectionEnd = i, this.insertedText = n, this.insertedSelectionStart = o, this.insertedSelectionEnd = r;
        }
      }
      var ke;
      (function(s) {
        s.editorSimpleInput = new Ie("editorSimpleInput", false, true), s.editorTextFocus = new Ie("editorTextFocus", false, C("editorTextFocus", "Whether the editor text has focus (cursor is blinking)")), s.focus = new Ie("editorFocus", false, C("editorFocus", "Whether the editor or an editor widget has focus (e.g. focus is in the find widget)")), s.textInputFocus = new Ie("textInputFocus", false, C("textInputFocus", "Whether an editor or a rich text input has focus (cursor is blinking)")), s.readOnly = new Ie("editorReadonly", false, C("editorReadonly", "Whether the editor is read-only")), s.inDiffEditor = new Ie("inDiffEditor", false, C("inDiffEditor", "Whether the context is a diff editor")), s.isEmbeddedDiffEditor = new Ie("isEmbeddedDiffEditor", false, C("isEmbeddedDiffEditor", "Whether the context is an embedded diff editor")), s.inMultiDiffEditor = new Ie("inMultiDiffEditor", false, C("inMultiDiffEditor", "Whether the context is a multi diff editor")), s.multiDiffEditorAllCollapsed = new Ie("multiDiffEditorAllCollapsed", void 0, C("multiDiffEditorAllCollapsed", "Whether all files in multi diff editor are collapsed")), s.hasChanges = new Ie("diffEditorHasChanges", false, C("diffEditorHasChanges", "Whether the diff editor has changes")), s.comparingMovedCode = new Ie("comparingMovedCode", false, C("comparingMovedCode", "Whether a moved code block is selected for comparison")), s.accessibleDiffViewerVisible = new Ie("accessibleDiffViewerVisible", false, C("accessibleDiffViewerVisible", "Whether the accessible diff viewer is visible")), s.diffEditorRenderSideBySideInlineBreakpointReached = new Ie("diffEditorRenderSideBySideInlineBreakpointReached", false, C("diffEditorRenderSideBySideInlineBreakpointReached", "Whether the diff editor render side by side inline breakpoint is reached")), s.diffEditorInlineMode = new Ie("diffEditorInlineMode", false, C("diffEditorInlineMode", "Whether inline mode is active")), s.diffEditorOriginalWritable = new Ie("diffEditorOriginalWritable", false, C("diffEditorOriginalWritable", "Whether modified is writable in the diff editor")), s.diffEditorModifiedWritable = new Ie("diffEditorModifiedWritable", false, C("diffEditorModifiedWritable", "Whether modified is writable in the diff editor")), s.diffEditorOriginalUri = new Ie("diffEditorOriginalUri", "", C("diffEditorOriginalUri", "The uri of the original document")), s.diffEditorModifiedUri = new Ie("diffEditorModifiedUri", "", C("diffEditorModifiedUri", "The uri of the modified document")), s.columnSelection = new Ie("editorColumnSelection", false, C("editorColumnSelection", "Whether `editor.columnSelection` is enabled")), s.writable = s.readOnly.toNegated(), s.hasNonEmptySelection = new Ie("editorHasSelection", false, C("editorHasSelection", "Whether the editor has text selected")), s.hasOnlyEmptySelection = s.hasNonEmptySelection.toNegated(), s.hasMultipleSelections = new Ie("editorHasMultipleSelections", false, C("editorHasMultipleSelections", "Whether the editor has multiple selections")), s.hasSingleSelection = s.hasMultipleSelections.toNegated(), s.tabMovesFocus = new Ie("editorTabMovesFocus", false, C("editorTabMovesFocus", "Whether `Tab` will move focus out of the editor")), s.tabDoesNotMoveFocus = s.tabMovesFocus.toNegated(), s.isInEmbeddedEditor = new Ie("isInEmbeddedEditor", false, true), s.canUndo = new Ie("canUndo", false, true), s.canRedo = new Ie("canRedo", false, true), s.hoverVisible = new Ie("editorHoverVisible", false, C("editorHoverVisible", "Whether the editor hover is visible")), s.hoverFocused = new Ie("editorHoverFocused", false, C("editorHoverFocused", "Whether the editor hover is focused")), s.stickyScrollFocused = new Ie("stickyScrollFocused", false, C("stickyScrollFocused", "Whether the sticky scroll is focused")), s.stickyScrollVisible = new Ie("stickyScrollVisible", false, C("stickyScrollVisible", "Whether the sticky scroll is visible")), s.standaloneColorPickerVisible = new Ie("standaloneColorPickerVisible", false, C("standaloneColorPickerVisible", "Whether the standalone color picker is visible")), s.standaloneColorPickerFocused = new Ie("standaloneColorPickerFocused", false, C("standaloneColorPickerFocused", "Whether the standalone color picker is focused")), s.inCompositeEditor = new Ie("inCompositeEditor", void 0, C("inCompositeEditor", "Whether the editor is part of a larger editor (e.g. notebooks)")), s.notInCompositeEditor = s.inCompositeEditor.toNegated(), s.languageId = new Ie("editorLangId", "", C("editorLangId", "The language identifier of the editor")), s.hasCompletionItemProvider = new Ie("editorHasCompletionItemProvider", false, C("editorHasCompletionItemProvider", "Whether the editor has a completion item provider")), s.hasCodeActionsProvider = new Ie("editorHasCodeActionsProvider", false, C("editorHasCodeActionsProvider", "Whether the editor has a code actions provider")), s.hasCodeLensProvider = new Ie("editorHasCodeLensProvider", false, C("editorHasCodeLensProvider", "Whether the editor has a code lens provider")), s.hasDefinitionProvider = new Ie("editorHasDefinitionProvider", false, C("editorHasDefinitionProvider", "Whether the editor has a definition provider")), s.hasDeclarationProvider = new Ie("editorHasDeclarationProvider", false, C("editorHasDeclarationProvider", "Whether the editor has a declaration provider")), s.hasImplementationProvider = new Ie("editorHasImplementationProvider", false, C("editorHasImplementationProvider", "Whether the editor has an implementation provider")), s.hasTypeDefinitionProvider = new Ie("editorHasTypeDefinitionProvider", false, C("editorHasTypeDefinitionProvider", "Whether the editor has a type definition provider")), s.hasHoverProvider = new Ie("editorHasHoverProvider", false, C("editorHasHoverProvider", "Whether the editor has a hover provider")), s.hasDocumentHighlightProvider = new Ie("editorHasDocumentHighlightProvider", false, C("editorHasDocumentHighlightProvider", "Whether the editor has a document highlight provider")), s.hasDocumentSymbolProvider = new Ie("editorHasDocumentSymbolProvider", false, C("editorHasDocumentSymbolProvider", "Whether the editor has a document symbol provider")), s.hasReferenceProvider = new Ie("editorHasReferenceProvider", false, C("editorHasReferenceProvider", "Whether the editor has a reference provider")), s.hasRenameProvider = new Ie("editorHasRenameProvider", false, C("editorHasRenameProvider", "Whether the editor has a rename provider")), s.hasSignatureHelpProvider = new Ie("editorHasSignatureHelpProvider", false, C("editorHasSignatureHelpProvider", "Whether the editor has a signature help provider")), s.hasInlayHintsProvider = new Ie("editorHasInlayHintsProvider", false, C("editorHasInlayHintsProvider", "Whether the editor has an inline hints provider")), s.hasDocumentFormattingProvider = new Ie("editorHasDocumentFormattingProvider", false, C("editorHasDocumentFormattingProvider", "Whether the editor has a document formatting provider")), s.hasDocumentSelectionFormattingProvider = new Ie("editorHasDocumentSelectionFormattingProvider", false, C("editorHasDocumentSelectionFormattingProvider", "Whether the editor has a document selection formatting provider")), s.hasMultipleDocumentFormattingProvider = new Ie("editorHasMultipleDocumentFormattingProvider", false, C("editorHasMultipleDocumentFormattingProvider", "Whether the editor has multiple document formatting providers")), s.hasMultipleDocumentSelectionFormattingProvider = new Ie("editorHasMultipleDocumentSelectionFormattingProvider", false, C("editorHasMultipleDocumentSelectionFormattingProvider", "Whether the editor has multiple document selection formatting providers"));
      })(ke || (ke = {}));
      const bt = 0;
      class pi extends Ph {
        runEditorCommand(e, t, i) {
          const n = t._getViewModel();
          n && this.runCoreEditorCommand(n, i || {});
        }
      }
      var In;
      (function(s) {
        const e = function(i) {
          if (!Es(i)) return false;
          const n = i;
          return !(!ho(n.to) || !Po(n.by) && !ho(n.by) || !Po(n.value) && !wg(n.value) || !Po(n.revealCursor) && !j7(n.revealCursor));
        };
        s.metadata = {
          description: "Scroll editor in the given direction",
          args: [
            {
              name: "Editor scroll argument object",
              description: "Property-value pairs that can be passed through this argument:\n					* 'to': A mandatory direction value.\n						```\n						'up', 'down'\n						```\n					* 'by': Unit to move. Default is computed based on 'to' value.\n						```\n						'line', 'wrappedLine', 'page', 'halfPage', 'editor'\n						```\n					* 'value': Number of units to move. Default is '1'.\n					* 'revealCursor': If 'true' reveals the cursor if it is outside view port.\n				",
              constraint: e,
              schema: {
                type: "object",
                required: [
                  "to"
                ],
                properties: {
                  to: {
                    type: "string",
                    enum: [
                      "up",
                      "down"
                    ]
                  },
                  by: {
                    type: "string",
                    enum: [
                      "line",
                      "wrappedLine",
                      "page",
                      "halfPage",
                      "editor"
                    ]
                  },
                  value: {
                    type: "number",
                    default: 1
                  },
                  revealCursor: {
                    type: "boolean"
                  }
                }
              }
            }
          ]
        }, s.RawDirection = {
          Up: "up",
          Right: "right",
          Down: "down",
          Left: "left"
        }, s.RawUnit = {
          Line: "line",
          WrappedLine: "wrappedLine",
          Page: "page",
          HalfPage: "halfPage",
          Editor: "editor",
          Column: "column"
        };
        function t(i) {
          let n;
          switch (i.to) {
            case s.RawDirection.Up:
              n = 1;
              break;
            case s.RawDirection.Right:
              n = 2;
              break;
            case s.RawDirection.Down:
              n = 3;
              break;
            case s.RawDirection.Left:
              n = 4;
              break;
            default:
              return null;
          }
          let o;
          switch (i.by) {
            case s.RawUnit.Line:
              o = 1;
              break;
            case s.RawUnit.WrappedLine:
              o = 2;
              break;
            case s.RawUnit.Page:
              o = 3;
              break;
            case s.RawUnit.HalfPage:
              o = 4;
              break;
            case s.RawUnit.Editor:
              o = 5;
              break;
            case s.RawUnit.Column:
              o = 6;
              break;
            default:
              o = 2;
          }
          const r = Math.floor(i.value || 1), a = !!i.revealCursor;
          return {
            direction: n,
            unit: o,
            value: r,
            revealCursor: a,
            select: !!i.select
          };
        }
        s.parse = t;
      })(In || (In = {}));
      var kf;
      (function(s) {
        const e = function(t) {
          if (!Es(t)) return false;
          const i = t;
          return !(!wg(i.lineNumber) && !ho(i.lineNumber) || !Po(i.at) && !ho(i.at));
        };
        s.metadata = {
          description: "Reveal the given line at the given logical position",
          args: [
            {
              name: "Reveal line argument object",
              description: "Property-value pairs that can be passed through this argument:\n					* 'lineNumber': A mandatory line number value.\n					* 'at': Logical position at which line has to be revealed.\n						```\n						'top', 'center', 'bottom'\n						```\n				",
              constraint: e,
              schema: {
                type: "object",
                required: [
                  "lineNumber"
                ],
                properties: {
                  lineNumber: {
                    type: [
                      "number",
                      "string"
                    ]
                  },
                  at: {
                    type: "string",
                    enum: [
                      "top",
                      "center",
                      "bottom"
                    ]
                  }
                }
              }
            }
          ]
        }, s.RawAtArgument = {
          Top: "top",
          Center: "center",
          Bottom: "bottom"
        };
      })(kf || (kf = {}));
      class Q2 {
        constructor(e) {
          e.addImplementation(1e4, "code-editor", (t, i) => {
            const n = t.get(Xi).getFocusedCodeEditor();
            return n && n.hasTextFocus() ? this._runEditorCommand(t, n, i) : false;
          }), e.addImplementation(1e3, "generic-dom-input-textarea", (t, i) => {
            const n = ss();
            return n && [
              "input",
              "textarea"
            ].indexOf(n.tagName.toLowerCase()) >= 0 ? (this.runDOMCommand(n), true) : false;
          }), e.addImplementation(0, "generic-dom", (t, i) => {
            const n = t.get(Xi).getActiveCodeEditor();
            return n ? (n.focus(), this._runEditorCommand(t, n, i)) : false;
          });
        }
        _runEditorCommand(e, t, i) {
          const n = this.runEditorCommand(e, t, i);
          return n || true;
        }
      }
      var tn;
      (function(s) {
        class e extends pi {
          constructor(L) {
            super(L), this._inSelectionMode = L.inSelectionMode;
          }
          runCoreEditorCommand(L, D) {
            if (!D.position) return;
            L.model.pushStackElement(), L.setCursorStates(D.source, 3, [
              Zn.moveTo(L, L.getPrimaryCursorState(), this._inSelectionMode, D.position, D.viewPosition)
            ]) && D.revealType !== 2 && L.revealAllCursors(D.source, true, true);
          }
        }
        s.MoveTo = Ge(new e({
          id: "_moveTo",
          inSelectionMode: false,
          precondition: void 0
        })), s.MoveToSelect = Ge(new e({
          id: "_moveToSelect",
          inSelectionMode: true,
          precondition: void 0
        }));
        class t extends pi {
          runCoreEditorCommand(L, D) {
            L.model.pushStackElement();
            const k = this._getColumnSelectResult(L, L.getPrimaryCursorState(), L.getCursorColumnSelectData(), D);
            k !== null && (L.setCursorStates(D.source, 3, k.viewStates.map((T) => lt.fromViewState(T))), L.setCursorColumnSelectData({
              isReal: true,
              fromViewLineNumber: k.fromLineNumber,
              fromViewVisualColumn: k.fromVisualColumn,
              toViewLineNumber: k.toLineNumber,
              toViewVisualColumn: k.toVisualColumn
            }), k.reversed ? L.revealTopMostCursor(D.source) : L.revealBottomMostCursor(D.source));
          }
        }
        s.ColumnSelect = Ge(new class extends t {
          constructor() {
            super({
              id: "columnSelect",
              precondition: void 0
            });
          }
          _getColumnSelectResult(x, L, D, k) {
            if (typeof k.position > "u" || typeof k.viewPosition > "u" || typeof k.mouseColumn > "u") return null;
            const T = x.model.validatePosition(k.position), M = x.coordinatesConverter.validateViewPosition(new X(k.viewPosition.lineNumber, k.viewPosition.column), T), I = k.doColumnSelect ? D.fromViewLineNumber : M.lineNumber, R = k.doColumnSelect ? D.fromViewVisualColumn : k.mouseColumn - 1;
            return lh.columnSelect(x.cursorConfig, x, I, R, M.lineNumber, k.mouseColumn - 1);
          }
        }()), s.CursorColumnSelectLeft = Ge(new class extends t {
          constructor() {
            super({
              id: "cursorColumnSelectLeft",
              precondition: void 0,
              kbOpts: {
                weight: bt,
                kbExpr: ke.textInputFocus,
                primary: 3599,
                linux: {
                  primary: 0
                }
              }
            });
          }
          _getColumnSelectResult(x, L, D, k) {
            return lh.columnSelectLeft(x.cursorConfig, x, D);
          }
        }()), s.CursorColumnSelectRight = Ge(new class extends t {
          constructor() {
            super({
              id: "cursorColumnSelectRight",
              precondition: void 0,
              kbOpts: {
                weight: bt,
                kbExpr: ke.textInputFocus,
                primary: 3601,
                linux: {
                  primary: 0
                }
              }
            });
          }
          _getColumnSelectResult(x, L, D, k) {
            return lh.columnSelectRight(x.cursorConfig, x, D);
          }
        }());
        class i extends t {
          constructor(L) {
            super(L), this._isPaged = L.isPaged;
          }
          _getColumnSelectResult(L, D, k, T) {
            return lh.columnSelectUp(L.cursorConfig, L, k, this._isPaged);
          }
        }
        s.CursorColumnSelectUp = Ge(new i({
          isPaged: false,
          id: "cursorColumnSelectUp",
          precondition: void 0,
          kbOpts: {
            weight: bt,
            kbExpr: ke.textInputFocus,
            primary: 3600,
            linux: {
              primary: 0
            }
          }
        })), s.CursorColumnSelectPageUp = Ge(new i({
          isPaged: true,
          id: "cursorColumnSelectPageUp",
          precondition: void 0,
          kbOpts: {
            weight: bt,
            kbExpr: ke.textInputFocus,
            primary: 3595,
            linux: {
              primary: 0
            }
          }
        }));
        class n extends t {
          constructor(L) {
            super(L), this._isPaged = L.isPaged;
          }
          _getColumnSelectResult(L, D, k, T) {
            return lh.columnSelectDown(L.cursorConfig, L, k, this._isPaged);
          }
        }
        s.CursorColumnSelectDown = Ge(new n({
          isPaged: false,
          id: "cursorColumnSelectDown",
          precondition: void 0,
          kbOpts: {
            weight: bt,
            kbExpr: ke.textInputFocus,
            primary: 3602,
            linux: {
              primary: 0
            }
          }
        })), s.CursorColumnSelectPageDown = Ge(new n({
          isPaged: true,
          id: "cursorColumnSelectPageDown",
          precondition: void 0,
          kbOpts: {
            weight: bt,
            kbExpr: ke.textInputFocus,
            primary: 3596,
            linux: {
              primary: 0
            }
          }
        }));
        class o extends pi {
          constructor() {
            super({
              id: "cursorMove",
              precondition: void 0,
              metadata: _C.metadata
            });
          }
          runCoreEditorCommand(L, D) {
            const k = _C.parse(D);
            k && this._runCursorMove(L, D.source, k);
          }
          _runCursorMove(L, D, k) {
            L.model.pushStackElement(), L.setCursorStates(D, 3, o._move(L, L.getCursorStates(), k)), L.revealAllCursors(D, true);
          }
          static _move(L, D, k) {
            const T = k.select, M = k.value;
            switch (k.direction) {
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
              case 7:
              case 8:
              case 9:
              case 10:
                return Zn.simpleMove(L, D, k.direction, T, M, k.unit);
              case 11:
              case 13:
              case 12:
              case 14:
                return Zn.viewportMove(L, D, k.direction, T, M);
              default:
                return null;
            }
          }
        }
        s.CursorMoveImpl = o, s.CursorMove = Ge(new o());
        class r extends pi {
          constructor(L) {
            super(L), this._staticArgs = L.args;
          }
          runCoreEditorCommand(L, D) {
            let k = this._staticArgs;
            this._staticArgs.value === -1 && (k = {
              direction: this._staticArgs.direction,
              unit: this._staticArgs.unit,
              select: this._staticArgs.select,
              value: D.pageSize || L.cursorConfig.pageSize
            }), L.model.pushStackElement(), L.setCursorStates(D.source, 3, Zn.simpleMove(L, L.getCursorStates(), k.direction, k.select, k.value, k.unit)), L.revealAllCursors(D.source, true);
          }
        }
        s.CursorLeft = Ge(new r({
          args: {
            direction: 0,
            unit: 0,
            select: false,
            value: 1
          },
          id: "cursorLeft",
          precondition: void 0,
          kbOpts: {
            weight: bt,
            kbExpr: ke.textInputFocus,
            primary: 15,
            mac: {
              primary: 15,
              secondary: [
                288
              ]
            }
          }
        })), s.CursorLeftSelect = Ge(new r({
          args: {
            direction: 0,
            unit: 0,
            select: true,
            value: 1
          },
          id: "cursorLeftSelect",
          precondition: void 0,
          kbOpts: {
            weight: bt,
            kbExpr: ke.textInputFocus,
            primary: 1039
          }
        })), s.CursorRight = Ge(new r({
          args: {
            direction: 1,
            unit: 0,
            select: false,
            value: 1
          },
          id: "cursorRight",
          precondition: void 0,
          kbOpts: {
            weight: bt,
            kbExpr: ke.textInputFocus,
            primary: 17,
            mac: {
              primary: 17,
              secondary: [
                292
              ]
            }
          }
        })), s.CursorRightSelect = Ge(new r({
          args: {
            direction: 1,
            unit: 0,
            select: true,
            value: 1
          },
          id: "cursorRightSelect",
          precondition: void 0,
          kbOpts: {
            weight: bt,
            kbExpr: ke.textInputFocus,
            primary: 1041
          }
        })), s.CursorUp = Ge(new r({
          args: {
            direction: 2,
            unit: 2,
            select: false,
            value: 1
          },
          id: "cursorUp",
          precondition: void 0,
          kbOpts: {
            weight: bt,
            kbExpr: ke.textInputFocus,
            primary: 16,
            mac: {
              primary: 16,
              secondary: [
                302
              ]
            }
          }
        })), s.CursorUpSelect = Ge(new r({
          args: {
            direction: 2,
            unit: 2,
            select: true,
            value: 1
          },
          id: "cursorUpSelect",
          precondition: void 0,
          kbOpts: {
            weight: bt,
            kbExpr: ke.textInputFocus,
            primary: 1040,
            secondary: [
              3088
            ],
            mac: {
              primary: 1040
            },
            linux: {
              primary: 1040
            }
          }
        })), s.CursorPageUp = Ge(new r({
          args: {
            direction: 2,
            unit: 2,
            select: false,
            value: -1
          },
          id: "cursorPageUp",
          precondition: void 0,
          kbOpts: {
            weight: bt,
            kbExpr: ke.textInputFocus,
            primary: 11
          }
        })), s.CursorPageUpSelect = Ge(new r({
          args: {
            direction: 2,
            unit: 2,
            select: true,
            value: -1
          },
          id: "cursorPageUpSelect",
          precondition: void 0,
          kbOpts: {
            weight: bt,
            kbExpr: ke.textInputFocus,
            primary: 1035
          }
        })), s.CursorDown = Ge(new r({
          args: {
            direction: 3,
            unit: 2,
            select: false,
            value: 1
          },
          id: "cursorDown",
          precondition: void 0,
          kbOpts: {
            weight: bt,
            kbExpr: ke.textInputFocus,
            primary: 18,
            mac: {
              primary: 18,
              secondary: [
                300
              ]
            }
          }
        })), s.CursorDownSelect = Ge(new r({
          args: {
            direction: 3,
            unit: 2,
            select: true,
            value: 1
          },
          id: "cursorDownSelect",
          precondition: void 0,
          kbOpts: {
            weight: bt,
            kbExpr: ke.textInputFocus,
            primary: 1042,
            secondary: [
              3090
            ],
            mac: {
              primary: 1042
            },
            linux: {
              primary: 1042
            }
          }
        })), s.CursorPageDown = Ge(new r({
          args: {
            direction: 3,
            unit: 2,
            select: false,
            value: -1
          },
          id: "cursorPageDown",
          precondition: void 0,
          kbOpts: {
            weight: bt,
            kbExpr: ke.textInputFocus,
            primary: 12
          }
        })), s.CursorPageDownSelect = Ge(new r({
          args: {
            direction: 3,
            unit: 2,
            select: true,
            value: -1
          },
          id: "cursorPageDownSelect",
          precondition: void 0,
          kbOpts: {
            weight: bt,
            kbExpr: ke.textInputFocus,
            primary: 1036
          }
        })), s.CreateCursor = Ge(new class extends pi {
          constructor() {
            super({
              id: "createCursor",
              precondition: void 0
            });
          }
          runCoreEditorCommand(x, L) {
            if (!L.position) return;
            let D;
            L.wholeLine ? D = Zn.line(x, x.getPrimaryCursorState(), false, L.position, L.viewPosition) : D = Zn.moveTo(x, x.getPrimaryCursorState(), false, L.position, L.viewPosition);
            const k = x.getCursorStates();
            if (k.length > 1) {
              const T = D.modelState ? D.modelState.position : null, M = D.viewState ? D.viewState.position : null;
              for (let I = 0, R = k.length; I < R; I++) {
                const A = k[I];
                if (!(T && !A.modelState.selection.containsPosition(T)) && !(M && !A.viewState.selection.containsPosition(M))) {
                  k.splice(I, 1), x.model.pushStackElement(), x.setCursorStates(L.source, 3, k);
                  return;
                }
              }
            }
            k.push(D), x.model.pushStackElement(), x.setCursorStates(L.source, 3, k);
          }
        }()), s.LastCursorMoveToSelect = Ge(new class extends pi {
          constructor() {
            super({
              id: "_lastCursorMoveToSelect",
              precondition: void 0
            });
          }
          runCoreEditorCommand(x, L) {
            if (!L.position) return;
            const D = x.getLastAddedCursorIndex(), k = x.getCursorStates(), T = k.slice(0);
            T[D] = Zn.moveTo(x, k[D], true, L.position, L.viewPosition), x.model.pushStackElement(), x.setCursorStates(L.source, 3, T);
          }
        }());
        class a extends pi {
          constructor(L) {
            super(L), this._inSelectionMode = L.inSelectionMode;
          }
          runCoreEditorCommand(L, D) {
            L.model.pushStackElement(), L.setCursorStates(D.source, 3, Zn.moveToBeginningOfLine(L, L.getCursorStates(), this._inSelectionMode)), L.revealAllCursors(D.source, true);
          }
        }
        s.CursorHome = Ge(new a({
          inSelectionMode: false,
          id: "cursorHome",
          precondition: void 0,
          kbOpts: {
            weight: bt,
            kbExpr: ke.textInputFocus,
            primary: 14,
            mac: {
              primary: 14,
              secondary: [
                2063
              ]
            }
          }
        })), s.CursorHomeSelect = Ge(new a({
          inSelectionMode: true,
          id: "cursorHomeSelect",
          precondition: void 0,
          kbOpts: {
            weight: bt,
            kbExpr: ke.textInputFocus,
            primary: 1038,
            mac: {
              primary: 1038,
              secondary: [
                3087
              ]
            }
          }
        }));
        class l extends pi {
          constructor(L) {
            super(L), this._inSelectionMode = L.inSelectionMode;
          }
          runCoreEditorCommand(L, D) {
            L.model.pushStackElement(), L.setCursorStates(D.source, 3, this._exec(L.getCursorStates())), L.revealAllCursors(D.source, true);
          }
          _exec(L) {
            const D = [];
            for (let k = 0, T = L.length; k < T; k++) {
              const M = L[k], I = M.modelState.position.lineNumber;
              D[k] = lt.fromModelState(M.modelState.move(this._inSelectionMode, I, 1, 0));
            }
            return D;
          }
        }
        s.CursorLineStart = Ge(new l({
          inSelectionMode: false,
          id: "cursorLineStart",
          precondition: void 0,
          kbOpts: {
            weight: bt,
            kbExpr: ke.textInputFocus,
            primary: 0,
            mac: {
              primary: 287
            }
          }
        })), s.CursorLineStartSelect = Ge(new l({
          inSelectionMode: true,
          id: "cursorLineStartSelect",
          precondition: void 0,
          kbOpts: {
            weight: bt,
            kbExpr: ke.textInputFocus,
            primary: 0,
            mac: {
              primary: 1311
            }
          }
        }));
        class u extends pi {
          constructor(L) {
            super(L), this._inSelectionMode = L.inSelectionMode;
          }
          runCoreEditorCommand(L, D) {
            L.model.pushStackElement(), L.setCursorStates(D.source, 3, Zn.moveToEndOfLine(L, L.getCursorStates(), this._inSelectionMode, D.sticky || false)), L.revealAllCursors(D.source, true);
          }
        }
        s.CursorEnd = Ge(new u({
          inSelectionMode: false,
          id: "cursorEnd",
          precondition: void 0,
          kbOpts: {
            args: {
              sticky: false
            },
            weight: bt,
            kbExpr: ke.textInputFocus,
            primary: 13,
            mac: {
              primary: 13,
              secondary: [
                2065
              ]
            }
          },
          metadata: {
            description: "Go to End",
            args: [
              {
                name: "args",
                schema: {
                  type: "object",
                  properties: {
                    sticky: {
                      description: C("stickydesc", "Stick to the end even when going to longer lines"),
                      type: "boolean",
                      default: false
                    }
                  }
                }
              }
            ]
          }
        })), s.CursorEndSelect = Ge(new u({
          inSelectionMode: true,
          id: "cursorEndSelect",
          precondition: void 0,
          kbOpts: {
            args: {
              sticky: false
            },
            weight: bt,
            kbExpr: ke.textInputFocus,
            primary: 1037,
            mac: {
              primary: 1037,
              secondary: [
                3089
              ]
            }
          },
          metadata: {
            description: "Select to End",
            args: [
              {
                name: "args",
                schema: {
                  type: "object",
                  properties: {
                    sticky: {
                      description: C("stickydesc", "Stick to the end even when going to longer lines"),
                      type: "boolean",
                      default: false
                    }
                  }
                }
              }
            ]
          }
        }));
        class d extends pi {
          constructor(L) {
            super(L), this._inSelectionMode = L.inSelectionMode;
          }
          runCoreEditorCommand(L, D) {
            L.model.pushStackElement(), L.setCursorStates(D.source, 3, this._exec(L, L.getCursorStates())), L.revealAllCursors(D.source, true);
          }
          _exec(L, D) {
            const k = [];
            for (let T = 0, M = D.length; T < M; T++) {
              const I = D[T], R = I.modelState.position.lineNumber, A = L.model.getLineMaxColumn(R);
              k[T] = lt.fromModelState(I.modelState.move(this._inSelectionMode, R, A, 0));
            }
            return k;
          }
        }
        s.CursorLineEnd = Ge(new d({
          inSelectionMode: false,
          id: "cursorLineEnd",
          precondition: void 0,
          kbOpts: {
            weight: bt,
            kbExpr: ke.textInputFocus,
            primary: 0,
            mac: {
              primary: 291
            }
          }
        })), s.CursorLineEndSelect = Ge(new d({
          inSelectionMode: true,
          id: "cursorLineEndSelect",
          precondition: void 0,
          kbOpts: {
            weight: bt,
            kbExpr: ke.textInputFocus,
            primary: 0,
            mac: {
              primary: 1315
            }
          }
        }));
        class f extends pi {
          constructor(L) {
            super(L), this._inSelectionMode = L.inSelectionMode;
          }
          runCoreEditorCommand(L, D) {
            L.model.pushStackElement(), L.setCursorStates(D.source, 3, Zn.moveToBeginningOfBuffer(L, L.getCursorStates(), this._inSelectionMode)), L.revealAllCursors(D.source, true);
          }
        }
        s.CursorTop = Ge(new f({
          inSelectionMode: false,
          id: "cursorTop",
          precondition: void 0,
          kbOpts: {
            weight: bt,
            kbExpr: ke.textInputFocus,
            primary: 2062,
            mac: {
              primary: 2064
            }
          }
        })), s.CursorTopSelect = Ge(new f({
          inSelectionMode: true,
          id: "cursorTopSelect",
          precondition: void 0,
          kbOpts: {
            weight: bt,
            kbExpr: ke.textInputFocus,
            primary: 3086,
            mac: {
              primary: 3088
            }
          }
        }));
        class m extends pi {
          constructor(L) {
            super(L), this._inSelectionMode = L.inSelectionMode;
          }
          runCoreEditorCommand(L, D) {
            L.model.pushStackElement(), L.setCursorStates(D.source, 3, Zn.moveToEndOfBuffer(L, L.getCursorStates(), this._inSelectionMode)), L.revealAllCursors(D.source, true);
          }
        }
        s.CursorBottom = Ge(new m({
          inSelectionMode: false,
          id: "cursorBottom",
          precondition: void 0,
          kbOpts: {
            weight: bt,
            kbExpr: ke.textInputFocus,
            primary: 2061,
            mac: {
              primary: 2066
            }
          }
        })), s.CursorBottomSelect = Ge(new m({
          inSelectionMode: true,
          id: "cursorBottomSelect",
          precondition: void 0,
          kbOpts: {
            weight: bt,
            kbExpr: ke.textInputFocus,
            primary: 3085,
            mac: {
              primary: 3090
            }
          }
        }));
        class _ extends pi {
          constructor() {
            super({
              id: "editorScroll",
              precondition: void 0,
              metadata: In.metadata
            });
          }
          determineScrollMethod(L) {
            const D = [
              6
            ], k = [
              1,
              2,
              3,
              4,
              5,
              6
            ], T = [
              4,
              2
            ], M = [
              1,
              3
            ];
            return D.includes(L.unit) && T.includes(L.direction) ? this._runHorizontalEditorScroll.bind(this) : k.includes(L.unit) && M.includes(L.direction) ? this._runVerticalEditorScroll.bind(this) : null;
          }
          runCoreEditorCommand(L, D) {
            const k = In.parse(D);
            if (!k) return;
            const T = this.determineScrollMethod(k);
            T && T(L, D.source, k);
          }
          _runVerticalEditorScroll(L, D, k) {
            const T = this._computeDesiredScrollTop(L, k);
            if (k.revealCursor) {
              const M = L.getCompletelyVisibleViewRangeAtScrollTop(T);
              L.setCursorStates(D, 3, [
                Zn.findPositionInViewportIfOutside(L, L.getPrimaryCursorState(), M, k.select)
              ]);
            }
            L.viewLayout.setScrollPosition({
              scrollTop: T
            }, 0);
          }
          _computeDesiredScrollTop(L, D) {
            if (D.unit === 1) {
              const M = L.viewLayout.getFutureViewport(), I = L.getCompletelyVisibleViewRangeAtScrollTop(M.top), R = L.coordinatesConverter.convertViewRangeToModelRange(I);
              let A;
              D.direction === 1 ? A = Math.max(1, R.startLineNumber - D.value) : A = Math.min(L.model.getLineCount(), R.startLineNumber + D.value);
              const Y = L.coordinatesConverter.convertModelPositionToViewPosition(new X(A, 1));
              return L.viewLayout.getVerticalOffsetForLineNumber(Y.lineNumber);
            }
            if (D.unit === 5) {
              let M = 0;
              return D.direction === 3 && (M = L.model.getLineCount() - L.cursorConfig.pageSize), L.viewLayout.getVerticalOffsetForLineNumber(M);
            }
            let k;
            D.unit === 3 ? k = L.cursorConfig.pageSize * D.value : D.unit === 4 ? k = Math.round(L.cursorConfig.pageSize / 2) * D.value : k = D.value;
            const T = (D.direction === 1 ? -1 : 1) * k;
            return L.viewLayout.getCurrentScrollTop() + T * L.cursorConfig.lineHeight;
          }
          _runHorizontalEditorScroll(L, D, k) {
            const T = this._computeDesiredScrollLeft(L, k);
            L.viewLayout.setScrollPosition({
              scrollLeft: T
            }, 0);
          }
          _computeDesiredScrollLeft(L, D) {
            const k = (D.direction === 4 ? -1 : 1) * D.value;
            return L.viewLayout.getCurrentScrollLeft() + k * L.cursorConfig.typicalHalfwidthCharacterWidth;
          }
        }
        s.EditorScrollImpl = _, s.EditorScroll = Ge(new _()), s.ScrollLineUp = Ge(new class extends pi {
          constructor() {
            super({
              id: "scrollLineUp",
              precondition: void 0,
              kbOpts: {
                weight: bt,
                kbExpr: ke.textInputFocus,
                primary: 2064,
                mac: {
                  primary: 267
                }
              }
            });
          }
          runCoreEditorCommand(x, L) {
            s.EditorScroll.runCoreEditorCommand(x, {
              to: In.RawDirection.Up,
              by: In.RawUnit.WrappedLine,
              value: 1,
              revealCursor: false,
              select: false,
              source: L.source
            });
          }
        }()), s.ScrollPageUp = Ge(new class extends pi {
          constructor() {
            super({
              id: "scrollPageUp",
              precondition: void 0,
              kbOpts: {
                weight: bt,
                kbExpr: ke.textInputFocus,
                primary: 2059,
                win: {
                  primary: 523
                },
                linux: {
                  primary: 523
                }
              }
            });
          }
          runCoreEditorCommand(x, L) {
            s.EditorScroll.runCoreEditorCommand(x, {
              to: In.RawDirection.Up,
              by: In.RawUnit.Page,
              value: 1,
              revealCursor: false,
              select: false,
              source: L.source
            });
          }
        }()), s.ScrollEditorTop = Ge(new class extends pi {
          constructor() {
            super({
              id: "scrollEditorTop",
              precondition: void 0,
              kbOpts: {
                weight: bt,
                kbExpr: ke.textInputFocus
              }
            });
          }
          runCoreEditorCommand(x, L) {
            s.EditorScroll.runCoreEditorCommand(x, {
              to: In.RawDirection.Up,
              by: In.RawUnit.Editor,
              value: 1,
              revealCursor: false,
              select: false,
              source: L.source
            });
          }
        }()), s.ScrollLineDown = Ge(new class extends pi {
          constructor() {
            super({
              id: "scrollLineDown",
              precondition: void 0,
              kbOpts: {
                weight: bt,
                kbExpr: ke.textInputFocus,
                primary: 2066,
                mac: {
                  primary: 268
                }
              }
            });
          }
          runCoreEditorCommand(x, L) {
            s.EditorScroll.runCoreEditorCommand(x, {
              to: In.RawDirection.Down,
              by: In.RawUnit.WrappedLine,
              value: 1,
              revealCursor: false,
              select: false,
              source: L.source
            });
          }
        }()), s.ScrollPageDown = Ge(new class extends pi {
          constructor() {
            super({
              id: "scrollPageDown",
              precondition: void 0,
              kbOpts: {
                weight: bt,
                kbExpr: ke.textInputFocus,
                primary: 2060,
                win: {
                  primary: 524
                },
                linux: {
                  primary: 524
                }
              }
            });
          }
          runCoreEditorCommand(x, L) {
            s.EditorScroll.runCoreEditorCommand(x, {
              to: In.RawDirection.Down,
              by: In.RawUnit.Page,
              value: 1,
              revealCursor: false,
              select: false,
              source: L.source
            });
          }
        }()), s.ScrollEditorBottom = Ge(new class extends pi {
          constructor() {
            super({
              id: "scrollEditorBottom",
              precondition: void 0,
              kbOpts: {
                weight: bt,
                kbExpr: ke.textInputFocus
              }
            });
          }
          runCoreEditorCommand(x, L) {
            s.EditorScroll.runCoreEditorCommand(x, {
              to: In.RawDirection.Down,
              by: In.RawUnit.Editor,
              value: 1,
              revealCursor: false,
              select: false,
              source: L.source
            });
          }
        }()), s.ScrollLeft = Ge(new class extends pi {
          constructor() {
            super({
              id: "scrollLeft",
              precondition: void 0,
              kbOpts: {
                weight: bt,
                kbExpr: ke.textInputFocus
              }
            });
          }
          runCoreEditorCommand(x, L) {
            s.EditorScroll.runCoreEditorCommand(x, {
              to: In.RawDirection.Left,
              by: In.RawUnit.Column,
              value: 2,
              revealCursor: false,
              select: false,
              source: L.source
            });
          }
        }()), s.ScrollRight = Ge(new class extends pi {
          constructor() {
            super({
              id: "scrollRight",
              precondition: void 0,
              kbOpts: {
                weight: bt,
                kbExpr: ke.textInputFocus
              }
            });
          }
          runCoreEditorCommand(x, L) {
            s.EditorScroll.runCoreEditorCommand(x, {
              to: In.RawDirection.Right,
              by: In.RawUnit.Column,
              value: 2,
              revealCursor: false,
              select: false,
              source: L.source
            });
          }
        }());
        class b extends pi {
          constructor(L) {
            super(L), this._inSelectionMode = L.inSelectionMode;
          }
          runCoreEditorCommand(L, D) {
            D.position && (L.model.pushStackElement(), L.setCursorStates(D.source, 3, [
              Zn.word(L, L.getPrimaryCursorState(), this._inSelectionMode, D.position)
            ]), D.revealType !== 2 && L.revealAllCursors(D.source, true, true));
          }
        }
        s.WordSelect = Ge(new b({
          inSelectionMode: false,
          id: "_wordSelect",
          precondition: void 0
        })), s.WordSelectDrag = Ge(new b({
          inSelectionMode: true,
          id: "_wordSelectDrag",
          precondition: void 0
        })), s.LastCursorWordSelect = Ge(new class extends pi {
          constructor() {
            super({
              id: "lastCursorWordSelect",
              precondition: void 0
            });
          }
          runCoreEditorCommand(x, L) {
            if (!L.position) return;
            const D = x.getLastAddedCursorIndex(), k = x.getCursorStates(), T = k.slice(0), M = k[D];
            T[D] = Zn.word(x, M, M.modelState.hasSelection(), L.position), x.model.pushStackElement(), x.setCursorStates(L.source, 3, T);
          }
        }());
        class v extends pi {
          constructor(L) {
            super(L), this._inSelectionMode = L.inSelectionMode;
          }
          runCoreEditorCommand(L, D) {
            D.position && (L.model.pushStackElement(), L.setCursorStates(D.source, 3, [
              Zn.line(L, L.getPrimaryCursorState(), this._inSelectionMode, D.position, D.viewPosition)
            ]), D.revealType !== 2 && L.revealAllCursors(D.source, false, true));
          }
        }
        s.LineSelect = Ge(new v({
          inSelectionMode: false,
          id: "_lineSelect",
          precondition: void 0
        })), s.LineSelectDrag = Ge(new v({
          inSelectionMode: true,
          id: "_lineSelectDrag",
          precondition: void 0
        }));
        class y extends pi {
          constructor(L) {
            super(L), this._inSelectionMode = L.inSelectionMode;
          }
          runCoreEditorCommand(L, D) {
            if (!D.position) return;
            const k = L.getLastAddedCursorIndex(), T = L.getCursorStates(), M = T.slice(0);
            M[k] = Zn.line(L, T[k], this._inSelectionMode, D.position, D.viewPosition), L.model.pushStackElement(), L.setCursorStates(D.source, 3, M);
          }
        }
        s.LastCursorLineSelect = Ge(new y({
          inSelectionMode: false,
          id: "lastCursorLineSelect",
          precondition: void 0
        })), s.LastCursorLineSelectDrag = Ge(new y({
          inSelectionMode: true,
          id: "lastCursorLineSelectDrag",
          precondition: void 0
        })), s.CancelSelection = Ge(new class extends pi {
          constructor() {
            super({
              id: "cancelSelection",
              precondition: ke.hasNonEmptySelection,
              kbOpts: {
                weight: bt,
                kbExpr: ke.textInputFocus,
                primary: 9,
                secondary: [
                  1033
                ]
              }
            });
          }
          runCoreEditorCommand(x, L) {
            x.model.pushStackElement(), x.setCursorStates(L.source, 3, [
              Zn.cancelSelection(x, x.getPrimaryCursorState())
            ]), x.revealAllCursors(L.source, true);
          }
        }()), s.RemoveSecondaryCursors = Ge(new class extends pi {
          constructor() {
            super({
              id: "removeSecondaryCursors",
              precondition: ke.hasMultipleSelections,
              kbOpts: {
                weight: bt + 1,
                kbExpr: ke.textInputFocus,
                primary: 9,
                secondary: [
                  1033
                ]
              }
            });
          }
          runCoreEditorCommand(x, L) {
            x.model.pushStackElement(), x.setCursorStates(L.source, 3, [
              x.getPrimaryCursorState()
            ]), x.revealAllCursors(L.source, true), Ev(C("removedCursor", "Removed secondary cursors"));
          }
        }()), s.RevealLine = Ge(new class extends pi {
          constructor() {
            super({
              id: "revealLine",
              precondition: void 0,
              metadata: kf.metadata
            });
          }
          runCoreEditorCommand(x, L) {
            const D = L, k = D.lineNumber || 0;
            let T = typeof k == "number" ? k + 1 : parseInt(k) + 1;
            T < 1 && (T = 1);
            const M = x.model.getLineCount();
            T > M && (T = M);
            const I = new z(T, 1, T, x.model.getLineMaxColumn(T));
            let R = 0;
            if (D.at) switch (D.at) {
              case kf.RawAtArgument.Top:
                R = 3;
                break;
              case kf.RawAtArgument.Center:
                R = 1;
                break;
              case kf.RawAtArgument.Bottom:
                R = 4;
                break;
            }
            const A = x.coordinatesConverter.convertModelRangeToViewRange(I);
            x.revealRange(L.source, false, A, R, 0);
          }
        }()), s.SelectAll = new class extends Q2 {
          constructor() {
            super(Tj);
          }
          runDOMCommand(x) {
            pr && (x.focus(), x.select()), x.ownerDocument.execCommand("selectAll");
          }
          runEditorCommand(x, L, D) {
            const k = L._getViewModel();
            k && this.runCoreEditorCommand(k, D);
          }
          runCoreEditorCommand(x, L) {
            x.model.pushStackElement(), x.setCursorStates("keyboard", 3, [
              Zn.selectAll(x, x.getPrimaryCursorState())
            ]);
          }
        }(), s.SetSelection = Ge(new class extends pi {
          constructor() {
            super({
              id: "setSelection",
              precondition: void 0
            });
          }
          runCoreEditorCommand(x, L) {
            L.selection && (x.model.pushStackElement(), x.setCursorStates(L.source, 3, [
              lt.fromModelSelection(L.selection)
            ]));
          }
        }());
      })(tn || (tn = {}));
      const ace = Ot.and(ke.textInputFocus, ke.columnSelection);
      function Rg(s, e) {
        z_.registerKeybindingRule({
          id: s,
          primary: e,
          when: ace,
          weight: bt + 1
        });
      }
      Rg(tn.CursorColumnSelectLeft.id, 1039);
      Rg(tn.CursorColumnSelectRight.id, 1041);
      Rg(tn.CursorColumnSelectUp.id, 1040);
      Rg(tn.CursorColumnSelectPageUp.id, 1035);
      Rg(tn.CursorColumnSelectDown.id, 1042);
      Rg(tn.CursorColumnSelectPageDown.id, 1036);
      function F3(s) {
        return s.register(), s;
      }
      var V3;
      (function(s) {
        class e extends Ph {
          runEditorCommand(i, n, o) {
            const r = n._getViewModel();
            r && this.runCoreEditingCommand(n, r, o || {});
          }
        }
        s.CoreEditingCommand = e, s.LineBreakInsert = Ge(new class extends e {
          constructor() {
            super({
              id: "lineBreakInsert",
              precondition: ke.writable,
              kbOpts: {
                weight: bt,
                kbExpr: ke.textInputFocus,
                primary: 0,
                mac: {
                  primary: 301
                }
              }
            });
          }
          runCoreEditingCommand(t, i, n) {
            t.pushUndoStop(), t.executeCommands(this.id, NF.lineBreakInsert(i.cursorConfig, i.model, i.getCursorStates().map((o) => o.modelState.selection)));
          }
        }()), s.Outdent = Ge(new class extends e {
          constructor() {
            super({
              id: "outdent",
              precondition: ke.writable,
              kbOpts: {
                weight: bt,
                kbExpr: Ot.and(ke.editorTextFocus, ke.tabDoesNotMoveFocus),
                primary: 1026
              }
            });
          }
          runCoreEditingCommand(t, i, n) {
            t.pushUndoStop(), t.executeCommands(this.id, ch.outdent(i.cursorConfig, i.model, i.getCursorStates().map((o) => o.modelState.selection))), t.pushUndoStop();
          }
        }()), s.Tab = Ge(new class extends e {
          constructor() {
            super({
              id: "tab",
              precondition: ke.writable,
              kbOpts: {
                weight: bt,
                kbExpr: Ot.and(ke.editorTextFocus, ke.tabDoesNotMoveFocus),
                primary: 2
              }
            });
          }
          runCoreEditingCommand(t, i, n) {
            t.pushUndoStop(), t.executeCommands(this.id, ch.tab(i.cursorConfig, i.model, i.getCursorStates().map((o) => o.modelState.selection))), t.pushUndoStop();
          }
        }()), s.DeleteLeft = Ge(new class extends e {
          constructor() {
            super({
              id: "deleteLeft",
              precondition: void 0,
              kbOpts: {
                weight: bt,
                kbExpr: ke.textInputFocus,
                primary: 1,
                secondary: [
                  1025
                ],
                mac: {
                  primary: 1,
                  secondary: [
                    1025,
                    294,
                    257
                  ]
                }
              }
            });
          }
          runCoreEditingCommand(t, i, n) {
            const [o, r] = Hh.deleteLeft(i.getPrevEditOperationType(), i.cursorConfig, i.model, i.getCursorStates().map((a) => a.modelState.selection), i.getCursorAutoClosedCharacters());
            o && t.pushUndoStop(), t.executeCommands(this.id, r), i.setPrevEditOperationType(2);
          }
        }()), s.DeleteRight = Ge(new class extends e {
          constructor() {
            super({
              id: "deleteRight",
              precondition: void 0,
              kbOpts: {
                weight: bt,
                kbExpr: ke.textInputFocus,
                primary: 20,
                mac: {
                  primary: 20,
                  secondary: [
                    290,
                    276
                  ]
                }
              }
            });
          }
          runCoreEditingCommand(t, i, n) {
            const [o, r] = Hh.deleteRight(i.getPrevEditOperationType(), i.cursorConfig, i.model, i.getCursorStates().map((a) => a.modelState.selection));
            o && t.pushUndoStop(), t.executeCommands(this.id, r), i.setPrevEditOperationType(3);
          }
        }()), s.Undo = new class extends Q2 {
          constructor() {
            super(c8);
          }
          runDOMCommand(t) {
            t.ownerDocument.execCommand("undo");
          }
          runEditorCommand(t, i, n) {
            if (!(!i.hasModel() || i.getOption(92) === true)) return i.getModel().undo();
          }
        }(), s.Redo = new class extends Q2 {
          constructor() {
            super(u8);
          }
          runDOMCommand(t) {
            t.ownerDocument.execCommand("redo");
          }
          runEditorCommand(t, i, n) {
            if (!(!i.hasModel() || i.getOption(92) === true)) return i.getModel().redo();
          }
        }();
      })(V3 || (V3 = {}));
      class W3 extends tw {
        constructor(e, t, i) {
          super({
            id: e,
            precondition: void 0,
            metadata: i
          }), this._handlerId = t;
        }
        runCommand(e, t) {
          const i = e.get(Xi).getFocusedCodeEditor();
          i && i.trigger("keyboard", this._handlerId, t);
        }
      }
      function od(s, e) {
        F3(new W3("default:" + s, s)), F3(new W3(s, s, e));
      }
      od("type", {
        description: "Type",
        args: [
          {
            name: "args",
            schema: {
              type: "object",
              required: [
                "text"
              ],
              properties: {
                text: {
                  type: "string"
                }
              }
            }
          }
        ]
      });
      od("replacePreviousChar");
      od("compositionType");
      od("compositionStart");
      od("compositionEnd");
      od("paste");
      od("cut");
      class lce {
        constructor(e, t, i, n) {
          this.configuration = e, this.viewModel = t, this.userInputEvents = i, this.commandDelegate = n;
        }
        paste(e, t, i, n) {
          this.commandDelegate.paste(e, t, i, n);
        }
        type(e) {
          this.commandDelegate.type(e);
        }
        compositionType(e, t, i, n) {
          this.commandDelegate.compositionType(e, t, i, n);
        }
        compositionStart() {
          this.commandDelegate.startComposition();
        }
        compositionEnd() {
          this.commandDelegate.endComposition();
        }
        cut() {
          this.commandDelegate.cut();
        }
        setSelection(e) {
          tn.SetSelection.runCoreEditorCommand(this.viewModel, {
            source: "keyboard",
            selection: e
          });
        }
        _validateViewColumn(e) {
          const t = this.viewModel.getLineMinColumn(e.lineNumber);
          return e.column < t ? new X(e.lineNumber, t) : e;
        }
        _hasMulticursorModifier(e) {
          switch (this.configuration.options.get(78)) {
            case "altKey":
              return e.altKey;
            case "ctrlKey":
              return e.ctrlKey;
            case "metaKey":
              return e.metaKey;
            default:
              return false;
          }
        }
        _hasNonMulticursorModifier(e) {
          switch (this.configuration.options.get(78)) {
            case "altKey":
              return e.ctrlKey || e.metaKey;
            case "ctrlKey":
              return e.altKey || e.metaKey;
            case "metaKey":
              return e.ctrlKey || e.altKey;
            default:
              return false;
          }
        }
        dispatchMouse(e) {
          const t = this.configuration.options, i = Is && t.get(108), n = t.get(22);
          e.middleButton && !i ? this._columnSelect(e.position, e.mouseColumn, e.inSelectionMode) : e.startedOnLineNumbers ? this._hasMulticursorModifier(e) ? e.inSelectionMode ? this._lastCursorLineSelect(e.position, e.revealType) : this._createCursor(e.position, true) : e.inSelectionMode ? this._lineSelectDrag(e.position, e.revealType) : this._lineSelect(e.position, e.revealType) : e.mouseDownCount >= 4 ? this._selectAll() : e.mouseDownCount === 3 ? this._hasMulticursorModifier(e) ? e.inSelectionMode ? this._lastCursorLineSelectDrag(e.position, e.revealType) : this._lastCursorLineSelect(e.position, e.revealType) : e.inSelectionMode ? this._lineSelectDrag(e.position, e.revealType) : this._lineSelect(e.position, e.revealType) : e.mouseDownCount === 2 ? e.onInjectedText || (this._hasMulticursorModifier(e) ? this._lastCursorWordSelect(e.position, e.revealType) : e.inSelectionMode ? this._wordSelectDrag(e.position, e.revealType) : this._wordSelect(e.position, e.revealType)) : this._hasMulticursorModifier(e) ? this._hasNonMulticursorModifier(e) || (e.shiftKey ? this._columnSelect(e.position, e.mouseColumn, true) : e.inSelectionMode ? this._lastCursorMoveToSelect(e.position, e.revealType) : this._createCursor(e.position, false)) : e.inSelectionMode ? e.altKey ? this._columnSelect(e.position, e.mouseColumn, true) : n ? this._columnSelect(e.position, e.mouseColumn, true) : this._moveToSelect(e.position, e.revealType) : this.moveTo(e.position, e.revealType);
        }
        _usualArgs(e, t) {
          return e = this._validateViewColumn(e), {
            source: "mouse",
            position: this._convertViewToModelPosition(e),
            viewPosition: e,
            revealType: t
          };
        }
        moveTo(e, t) {
          tn.MoveTo.runCoreEditorCommand(this.viewModel, this._usualArgs(e, t));
        }
        _moveToSelect(e, t) {
          tn.MoveToSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(e, t));
        }
        _columnSelect(e, t, i) {
          e = this._validateViewColumn(e), tn.ColumnSelect.runCoreEditorCommand(this.viewModel, {
            source: "mouse",
            position: this._convertViewToModelPosition(e),
            viewPosition: e,
            mouseColumn: t,
            doColumnSelect: i
          });
        }
        _createCursor(e, t) {
          e = this._validateViewColumn(e), tn.CreateCursor.runCoreEditorCommand(this.viewModel, {
            source: "mouse",
            position: this._convertViewToModelPosition(e),
            viewPosition: e,
            wholeLine: t
          });
        }
        _lastCursorMoveToSelect(e, t) {
          tn.LastCursorMoveToSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(e, t));
        }
        _wordSelect(e, t) {
          tn.WordSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(e, t));
        }
        _wordSelectDrag(e, t) {
          tn.WordSelectDrag.runCoreEditorCommand(this.viewModel, this._usualArgs(e, t));
        }
        _lastCursorWordSelect(e, t) {
          tn.LastCursorWordSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(e, t));
        }
        _lineSelect(e, t) {
          tn.LineSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(e, t));
        }
        _lineSelectDrag(e, t) {
          tn.LineSelectDrag.runCoreEditorCommand(this.viewModel, this._usualArgs(e, t));
        }
        _lastCursorLineSelect(e, t) {
          tn.LastCursorLineSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(e, t));
        }
        _lastCursorLineSelectDrag(e, t) {
          tn.LastCursorLineSelectDrag.runCoreEditorCommand(this.viewModel, this._usualArgs(e, t));
        }
        _selectAll() {
          tn.SelectAll.runCoreEditorCommand(this.viewModel, {
            source: "mouse"
          });
        }
        _convertViewToModelPosition(e) {
          return this.viewModel.coordinatesConverter.convertViewPositionToModelPosition(e);
        }
        emitKeyDown(e) {
          this.userInputEvents.emitKeyDown(e);
        }
        emitKeyUp(e) {
          this.userInputEvents.emitKeyUp(e);
        }
        emitContextMenu(e) {
          this.userInputEvents.emitContextMenu(e);
        }
        emitMouseMove(e) {
          this.userInputEvents.emitMouseMove(e);
        }
        emitMouseLeave(e) {
          this.userInputEvents.emitMouseLeave(e);
        }
        emitMouseUp(e) {
          this.userInputEvents.emitMouseUp(e);
        }
        emitMouseDown(e) {
          this.userInputEvents.emitMouseDown(e);
        }
        emitMouseDrag(e) {
          this.userInputEvents.emitMouseDrag(e);
        }
        emitMouseDrop(e) {
          this.userInputEvents.emitMouseDrop(e);
        }
        emitMouseDropCanceled() {
          this.userInputEvents.emitMouseDropCanceled();
        }
        emitMouseWheel(e) {
          this.userInputEvents.emitMouseWheel(e);
        }
      }
      class AF {
        constructor(e) {
          this._lineFactory = e, this._set(1, []);
        }
        flush() {
          this._set(1, []);
        }
        _set(e, t) {
          this._lines = t, this._rendLineNumberStart = e;
        }
        _get() {
          return {
            rendLineNumberStart: this._rendLineNumberStart,
            lines: this._lines
          };
        }
        getStartLineNumber() {
          return this._rendLineNumberStart;
        }
        getEndLineNumber() {
          return this._rendLineNumberStart + this._lines.length - 1;
        }
        getCount() {
          return this._lines.length;
        }
        getLine(e) {
          const t = e - this._rendLineNumberStart;
          if (t < 0 || t >= this._lines.length) throw new It("Illegal value for lineNumber");
          return this._lines[t];
        }
        onLinesDeleted(e, t) {
          if (this.getCount() === 0) return null;
          const i = this.getStartLineNumber(), n = this.getEndLineNumber();
          if (t < i) {
            const l = t - e + 1;
            return this._rendLineNumberStart -= l, null;
          }
          if (e > n) return null;
          let o = 0, r = 0;
          for (let l = i; l <= n; l++) {
            const u = l - this._rendLineNumberStart;
            e <= l && l <= t && (r === 0 ? (o = u, r = 1) : r++);
          }
          if (e < i) {
            let l = 0;
            t < i ? l = t - e + 1 : l = i - e, this._rendLineNumberStart -= l;
          }
          return this._lines.splice(o, r);
        }
        onLinesChanged(e, t) {
          const i = e + t - 1;
          if (this.getCount() === 0) return false;
          const n = this.getStartLineNumber(), o = this.getEndLineNumber();
          let r = false;
          for (let a = e; a <= i; a++) a >= n && a <= o && (this._lines[a - this._rendLineNumberStart].onContentChanged(), r = true);
          return r;
        }
        onLinesInserted(e, t) {
          if (this.getCount() === 0) return null;
          const i = t - e + 1, n = this.getStartLineNumber(), o = this.getEndLineNumber();
          if (e <= n) return this._rendLineNumberStart += i, null;
          if (e > o) return null;
          if (i + e > o) return this._lines.splice(e - this._rendLineNumberStart, o - e + 1);
          const r = [];
          for (let f = 0; f < i; f++) r[f] = this._lineFactory.createLine();
          const a = e - this._rendLineNumberStart, l = this._lines.slice(0, a), u = this._lines.slice(a, this._lines.length - i), d = this._lines.slice(this._lines.length - i, this._lines.length);
          return this._lines = l.concat(r).concat(u), d;
        }
        onTokensChanged(e) {
          if (this.getCount() === 0) return false;
          const t = this.getStartLineNumber(), i = this.getEndLineNumber();
          let n = false;
          for (let o = 0, r = e.length; o < r; o++) {
            const a = e[o];
            if (a.toLineNumber < t || a.fromLineNumber > i) continue;
            const l = Math.max(t, a.fromLineNumber), u = Math.min(i, a.toLineNumber);
            for (let d = l; d <= u; d++) {
              const f = d - this._rendLineNumberStart;
              this._lines[f].onTokensChanged(), n = true;
            }
          }
          return n;
        }
      }
      class RF {
        constructor(e) {
          this._lineFactory = e, this.domNode = this._createDomNode(), this._linesCollection = new AF(this._lineFactory);
        }
        _createDomNode() {
          const e = St(document.createElement("div"));
          return e.setClassName("view-layer"), e.setPosition("absolute"), e.domNode.setAttribute("role", "presentation"), e.domNode.setAttribute("aria-hidden", "true"), e;
        }
        onConfigurationChanged(e) {
          return !!e.hasChanged(146);
        }
        onFlushed(e) {
          return this._linesCollection.flush(), true;
        }
        onLinesChanged(e) {
          return this._linesCollection.onLinesChanged(e.fromLineNumber, e.count);
        }
        onLinesDeleted(e) {
          var _a3;
          const t = this._linesCollection.onLinesDeleted(e.fromLineNumber, e.toLineNumber);
          if (t) for (let i = 0, n = t.length; i < n; i++) (_a3 = t[i].getDomNode()) == null ? void 0 : _a3.remove();
          return true;
        }
        onLinesInserted(e) {
          var _a3;
          const t = this._linesCollection.onLinesInserted(e.fromLineNumber, e.toLineNumber);
          if (t) for (let i = 0, n = t.length; i < n; i++) (_a3 = t[i].getDomNode()) == null ? void 0 : _a3.remove();
          return true;
        }
        onScrollChanged(e) {
          return e.scrollTopChanged;
        }
        onTokensChanged(e) {
          return this._linesCollection.onTokensChanged(e.ranges);
        }
        onZonesChanged(e) {
          return true;
        }
        getStartLineNumber() {
          return this._linesCollection.getStartLineNumber();
        }
        getEndLineNumber() {
          return this._linesCollection.getEndLineNumber();
        }
        getVisibleLine(e) {
          return this._linesCollection.getLine(e);
        }
        renderLines(e) {
          const t = this._linesCollection._get(), i = new uh(this.domNode.domNode, this._lineFactory, e), n = {
            rendLineNumberStart: t.rendLineNumberStart,
            lines: t.lines,
            linesLength: t.lines.length
          }, o = i.render(n, e.startLineNumber, e.endLineNumber, e.relativeVerticalOffset);
          this._linesCollection._set(o.rendLineNumberStart, o.lines);
        }
      }
      const _uh = class _uh {
        constructor(e, t, i) {
          this._domNode = e, this._lineFactory = t, this._viewportData = i;
        }
        render(e, t, i, n) {
          const o = {
            rendLineNumberStart: e.rendLineNumberStart,
            lines: e.lines.slice(0),
            linesLength: e.linesLength
          };
          if (o.rendLineNumberStart + o.linesLength - 1 < t || i < o.rendLineNumberStart) {
            o.rendLineNumberStart = t, o.linesLength = i - t + 1, o.lines = [];
            for (let r = t; r <= i; r++) o.lines[r - t] = this._lineFactory.createLine();
            return this._finishRendering(o, true, n), o;
          }
          if (this._renderUntouchedLines(o, Math.max(t - o.rendLineNumberStart, 0), Math.min(i - o.rendLineNumberStart, o.linesLength - 1), n, t), o.rendLineNumberStart > t) {
            const r = t, a = Math.min(i, o.rendLineNumberStart - 1);
            r <= a && (this._insertLinesBefore(o, r, a, n, t), o.linesLength += a - r + 1);
          } else if (o.rendLineNumberStart < t) {
            const r = Math.min(o.linesLength, t - o.rendLineNumberStart);
            r > 0 && (this._removeLinesBefore(o, r), o.linesLength -= r);
          }
          if (o.rendLineNumberStart = t, o.rendLineNumberStart + o.linesLength - 1 < i) {
            const r = o.rendLineNumberStart + o.linesLength, a = i;
            r <= a && (this._insertLinesAfter(o, r, a, n, t), o.linesLength += a - r + 1);
          } else if (o.rendLineNumberStart + o.linesLength - 1 > i) {
            const r = Math.max(0, i - o.rendLineNumberStart + 1), l = o.linesLength - 1 - r + 1;
            l > 0 && (this._removeLinesAfter(o, l), o.linesLength -= l);
          }
          return this._finishRendering(o, false, n), o;
        }
        _renderUntouchedLines(e, t, i, n, o) {
          const r = e.rendLineNumberStart, a = e.lines;
          for (let l = t; l <= i; l++) {
            const u = r + l;
            a[l].layoutLine(u, n[u - o], this._viewportData.lineHeight);
          }
        }
        _insertLinesBefore(e, t, i, n, o) {
          const r = [];
          let a = 0;
          for (let l = t; l <= i; l++) r[a++] = this._lineFactory.createLine();
          e.lines = r.concat(e.lines);
        }
        _removeLinesBefore(e, t) {
          var _a3;
          for (let i = 0; i < t; i++) (_a3 = e.lines[i].getDomNode()) == null ? void 0 : _a3.remove();
          e.lines.splice(0, t);
        }
        _insertLinesAfter(e, t, i, n, o) {
          const r = [];
          let a = 0;
          for (let l = t; l <= i; l++) r[a++] = this._lineFactory.createLine();
          e.lines = e.lines.concat(r);
        }
        _removeLinesAfter(e, t) {
          var _a3;
          const i = e.linesLength - t;
          for (let n = 0; n < t; n++) (_a3 = e.lines[i + n].getDomNode()) == null ? void 0 : _a3.remove();
          e.lines.splice(i, t);
        }
        _finishRenderingNewLines(e, t, i, n) {
          _uh._ttPolicy && (i = _uh._ttPolicy.createHTML(i));
          const o = this._domNode.lastChild;
          t || !o ? this._domNode.innerHTML = i : o.insertAdjacentHTML("afterend", i);
          let r = this._domNode.lastChild;
          for (let a = e.linesLength - 1; a >= 0; a--) {
            const l = e.lines[a];
            n[a] && (l.setDomNode(r), r = r.previousSibling);
          }
        }
        _finishRenderingInvalidLines(e, t, i) {
          const n = document.createElement("div");
          _uh._ttPolicy && (t = _uh._ttPolicy.createHTML(t)), n.innerHTML = t;
          for (let o = 0; o < e.linesLength; o++) {
            const r = e.lines[o];
            if (i[o]) {
              const a = n.firstChild, l = r.getDomNode();
              l.parentNode.replaceChild(a, l), r.setDomNode(a);
            }
          }
        }
        _finishRendering(e, t, i) {
          const n = _uh._sb, o = e.linesLength, r = e.lines, a = e.rendLineNumberStart, l = [];
          {
            n.reset();
            let u = false;
            for (let d = 0; d < o; d++) {
              const f = r[d];
              l[d] = false, !(f.getDomNode() || !f.renderLine(d + a, i[d], this._viewportData.lineHeight, this._viewportData, n)) && (l[d] = true, u = true);
            }
            u && this._finishRenderingNewLines(e, t, n.build(), l);
          }
          {
            n.reset();
            let u = false;
            const d = [];
            for (let f = 0; f < o; f++) {
              const m = r[f];
              d[f] = false, !(l[f] || !m.renderLine(f + a, i[f], this._viewportData.lineHeight, this._viewportData, n)) && (d[f] = true, u = true);
            }
            u && this._finishRenderingInvalidLines(e, n.build(), d);
          }
        }
      };
      _uh._ttPolicy = Xh("editorViewLayer", {
        createHTML: (e) => e
      });
      _uh._sb = new iw(1e5);
      let uh = _uh;
      class OF extends Zs {
        constructor(e) {
          super(e), this._dynamicOverlays = [], this._isFocused = false, this._visibleLines = new RF({
            createLine: () => new cce(this._dynamicOverlays)
          }), this.domNode = this._visibleLines.domNode;
          const i = this._context.configuration.options.get(50);
          Un(this.domNode, i), this.domNode.setClassName("view-overlays");
        }
        shouldRender() {
          if (super.shouldRender()) return true;
          for (let e = 0, t = this._dynamicOverlays.length; e < t; e++) if (this._dynamicOverlays[e].shouldRender()) return true;
          return false;
        }
        dispose() {
          super.dispose();
          for (let e = 0, t = this._dynamicOverlays.length; e < t; e++) this._dynamicOverlays[e].dispose();
          this._dynamicOverlays = [];
        }
        getDomNode() {
          return this.domNode;
        }
        addDynamicOverlay(e) {
          this._dynamicOverlays.push(e);
        }
        onConfigurationChanged(e) {
          this._visibleLines.onConfigurationChanged(e);
          const i = this._context.configuration.options.get(50);
          return Un(this.domNode, i), true;
        }
        onFlushed(e) {
          return this._visibleLines.onFlushed(e);
        }
        onFocusChanged(e) {
          return this._isFocused = e.isFocused, true;
        }
        onLinesChanged(e) {
          return this._visibleLines.onLinesChanged(e);
        }
        onLinesDeleted(e) {
          return this._visibleLines.onLinesDeleted(e);
        }
        onLinesInserted(e) {
          return this._visibleLines.onLinesInserted(e);
        }
        onScrollChanged(e) {
          return this._visibleLines.onScrollChanged(e) || true;
        }
        onTokensChanged(e) {
          return this._visibleLines.onTokensChanged(e);
        }
        onZonesChanged(e) {
          return this._visibleLines.onZonesChanged(e);
        }
        prepareRender(e) {
          const t = this._dynamicOverlays.filter((i) => i.shouldRender());
          for (let i = 0, n = t.length; i < n; i++) {
            const o = t[i];
            o.prepareRender(e), o.onDidRender();
          }
        }
        render(e) {
          this._viewOverlaysRender(e), this.domNode.toggleClassName("focused", this._isFocused);
        }
        _viewOverlaysRender(e) {
          this._visibleLines.renderLines(e.viewportData);
        }
      }
      class cce {
        constructor(e) {
          this._dynamicOverlays = e, this._domNode = null, this._renderedContent = null;
        }
        getDomNode() {
          return this._domNode ? this._domNode.domNode : null;
        }
        setDomNode(e) {
          this._domNode = St(e);
        }
        onContentChanged() {
        }
        onTokensChanged() {
        }
        renderLine(e, t, i, n, o) {
          let r = "";
          for (let a = 0, l = this._dynamicOverlays.length; a < l; a++) {
            const u = this._dynamicOverlays[a];
            r += u.render(n.startLineNumber, e);
          }
          return this._renderedContent === r ? false : (this._renderedContent = r, o.appendString('<div style="top:'), o.appendString(String(t)), o.appendString("px;height:"), o.appendString(String(i)), o.appendString('px;">'), o.appendString(r), o.appendString("</div>"), true);
        }
        layoutLine(e, t, i) {
          this._domNode && (this._domNode.setTop(t), this._domNode.setHeight(i));
        }
      }
      class uce extends OF {
        constructor(e) {
          super(e);
          const i = this._context.configuration.options.get(146);
          this._contentWidth = i.contentWidth, this.domNode.setHeight(0);
        }
        onConfigurationChanged(e) {
          const i = this._context.configuration.options.get(146);
          return this._contentWidth = i.contentWidth, super.onConfigurationChanged(e) || true;
        }
        onScrollChanged(e) {
          return super.onScrollChanged(e) || e.scrollWidthChanged;
        }
        _viewOverlaysRender(e) {
          super._viewOverlaysRender(e), this.domNode.setWidth(Math.max(e.scrollWidth, this._contentWidth));
        }
      }
      class hce extends OF {
        constructor(e) {
          super(e);
          const t = this._context.configuration.options, i = t.get(146);
          this._contentLeft = i.contentLeft, this.domNode.setClassName("margin-view-overlays"), this.domNode.setWidth(1), Un(this.domNode, t.get(50));
        }
        onConfigurationChanged(e) {
          const t = this._context.configuration.options;
          Un(this.domNode, t.get(50));
          const i = t.get(146);
          return this._contentLeft = i.contentLeft, super.onConfigurationChanged(e) || true;
        }
        onScrollChanged(e) {
          return super.onScrollChanged(e) || e.scrollHeightChanged;
        }
        _viewOverlaysRender(e) {
          super._viewOverlaysRender(e);
          const t = Math.min(e.scrollHeight, 1e6);
          this.domNode.setHeight(t), this.domNode.setWidth(this._contentLeft);
        }
      }
      class $w {
        constructor(e) {
          this.onKeyDown = null, this.onKeyUp = null, this.onContextMenu = null, this.onMouseMove = null, this.onMouseLeave = null, this.onMouseDown = null, this.onMouseUp = null, this.onMouseDrag = null, this.onMouseDrop = null, this.onMouseDropCanceled = null, this.onMouseWheel = null, this._coordinatesConverter = e;
        }
        emitKeyDown(e) {
          var _a3;
          (_a3 = this.onKeyDown) == null ? void 0 : _a3.call(this, e);
        }
        emitKeyUp(e) {
          var _a3;
          (_a3 = this.onKeyUp) == null ? void 0 : _a3.call(this, e);
        }
        emitContextMenu(e) {
          var _a3;
          (_a3 = this.onContextMenu) == null ? void 0 : _a3.call(this, this._convertViewToModelMouseEvent(e));
        }
        emitMouseMove(e) {
          var _a3;
          (_a3 = this.onMouseMove) == null ? void 0 : _a3.call(this, this._convertViewToModelMouseEvent(e));
        }
        emitMouseLeave(e) {
          var _a3;
          (_a3 = this.onMouseLeave) == null ? void 0 : _a3.call(this, this._convertViewToModelMouseEvent(e));
        }
        emitMouseDown(e) {
          var _a3;
          (_a3 = this.onMouseDown) == null ? void 0 : _a3.call(this, this._convertViewToModelMouseEvent(e));
        }
        emitMouseUp(e) {
          var _a3;
          (_a3 = this.onMouseUp) == null ? void 0 : _a3.call(this, this._convertViewToModelMouseEvent(e));
        }
        emitMouseDrag(e) {
          var _a3;
          (_a3 = this.onMouseDrag) == null ? void 0 : _a3.call(this, this._convertViewToModelMouseEvent(e));
        }
        emitMouseDrop(e) {
          var _a3;
          (_a3 = this.onMouseDrop) == null ? void 0 : _a3.call(this, this._convertViewToModelMouseEvent(e));
        }
        emitMouseDropCanceled() {
          var _a3;
          (_a3 = this.onMouseDropCanceled) == null ? void 0 : _a3.call(this);
        }
        emitMouseWheel(e) {
          var _a3;
          (_a3 = this.onMouseWheel) == null ? void 0 : _a3.call(this, e);
        }
        _convertViewToModelMouseEvent(e) {
          return e.target ? {
            event: e.event,
            target: this._convertViewToModelMouseTarget(e.target)
          } : e;
        }
        _convertViewToModelMouseTarget(e) {
          return $w.convertViewToModelMouseTarget(e, this._coordinatesConverter);
        }
        static convertViewToModelMouseTarget(e, t) {
          const i = {
            ...e
          };
          return i.position && (i.position = t.convertViewPositionToModelPosition(i.position)), i.range && (i.range = t.convertViewRangeToModelRange(i.range)), (i.type === 5 || i.type === 8) && (i.detail = this.convertViewToModelViewZoneData(i.detail, t)), i;
        }
        static convertViewToModelViewZoneData(e, t) {
          return {
            viewZoneId: e.viewZoneId,
            positionBefore: e.positionBefore ? t.convertViewPositionToModelPosition(e.positionBefore) : e.positionBefore,
            positionAfter: e.positionAfter ? t.convertViewPositionToModelPosition(e.positionAfter) : e.positionAfter,
            position: t.convertViewPositionToModelPosition(e.position),
            afterLineNumber: t.convertViewPositionToModelPosition(new X(e.afterLineNumber, 1)).lineNumber
          };
        }
      }
      class dce extends Zs {
        constructor(e) {
          super(e), this.blocks = [], this.contentWidth = -1, this.contentLeft = 0, this.domNode = St(document.createElement("div")), this.domNode.setAttribute("role", "presentation"), this.domNode.setAttribute("aria-hidden", "true"), this.domNode.setClassName("blockDecorations-container"), this.update();
        }
        update() {
          let e = false;
          const i = this._context.configuration.options.get(146), n = i.contentWidth - i.verticalScrollbarWidth;
          this.contentWidth !== n && (this.contentWidth = n, e = true);
          const o = i.contentLeft;
          return this.contentLeft !== o && (this.contentLeft = o, e = true), e;
        }
        dispose() {
          super.dispose();
        }
        onConfigurationChanged(e) {
          return this.update();
        }
        onScrollChanged(e) {
          return e.scrollTopChanged || e.scrollLeftChanged;
        }
        onDecorationsChanged(e) {
          return true;
        }
        onZonesChanged(e) {
          return true;
        }
        prepareRender(e) {
        }
        render(e) {
          let t = 0;
          const i = e.getDecorationsInViewport();
          for (const n of i) {
            if (!n.options.blockClassName) continue;
            let o = this.blocks[t];
            o || (o = this.blocks[t] = St(document.createElement("div")), this.domNode.appendChild(o));
            let r, a;
            n.options.blockIsAfterEnd ? (r = e.getVerticalOffsetAfterLineNumber(n.range.endLineNumber, false), a = e.getVerticalOffsetAfterLineNumber(n.range.endLineNumber, true)) : (r = e.getVerticalOffsetForLineNumber(n.range.startLineNumber, true), a = n.range.isEmpty() && !n.options.blockDoesNotCollapse ? e.getVerticalOffsetForLineNumber(n.range.startLineNumber, false) : e.getVerticalOffsetAfterLineNumber(n.range.endLineNumber, true));
            const [l, u, d, f] = n.options.blockPadding ?? [
              0,
              0,
              0,
              0
            ];
            o.setClassName("blockDecorations-block " + n.options.blockClassName), o.setLeft(this.contentLeft - f), o.setWidth(this.contentWidth + f + u), o.setTop(r - e.scrollTop - l), o.setHeight(a - r + l + d), t++;
          }
          for (let n = t; n < this.blocks.length; n++) this.blocks[n].domNode.remove();
          this.blocks.length = t;
        }
      }
      class fce extends Zs {
        constructor(e, t) {
          super(e), this._viewDomNode = t, this._widgets = {}, this.domNode = St(document.createElement("div")), Yr.write(this.domNode, 1), this.domNode.setClassName("contentWidgets"), this.domNode.setPosition("absolute"), this.domNode.setTop(0), this.overflowingContentWidgetsDomNode = St(document.createElement("div")), Yr.write(this.overflowingContentWidgetsDomNode, 2), this.overflowingContentWidgetsDomNode.setClassName("overflowingContentWidgets");
        }
        dispose() {
          super.dispose(), this._widgets = {};
        }
        onConfigurationChanged(e) {
          const t = Object.keys(this._widgets);
          for (const i of t) this._widgets[i].onConfigurationChanged(e);
          return true;
        }
        onDecorationsChanged(e) {
          return true;
        }
        onFlushed(e) {
          return true;
        }
        onLineMappingChanged(e) {
          return this._updateAnchorsViewPositions(), true;
        }
        onLinesChanged(e) {
          return this._updateAnchorsViewPositions(), true;
        }
        onLinesDeleted(e) {
          return this._updateAnchorsViewPositions(), true;
        }
        onLinesInserted(e) {
          return this._updateAnchorsViewPositions(), true;
        }
        onScrollChanged(e) {
          return true;
        }
        onZonesChanged(e) {
          return true;
        }
        _updateAnchorsViewPositions() {
          const e = Object.keys(this._widgets);
          for (const t of e) this._widgets[t].updateAnchorViewPosition();
        }
        addWidget(e) {
          const t = new gce(this._context, this._viewDomNode, e);
          this._widgets[t.id] = t, t.allowEditorOverflow ? this.overflowingContentWidgetsDomNode.appendChild(t.domNode) : this.domNode.appendChild(t.domNode), this.setShouldRender();
        }
        setWidgetPosition(e, t, i, n, o) {
          this._widgets[e.getId()].setPosition(t, i, n, o), this.setShouldRender();
        }
        removeWidget(e) {
          const t = e.getId();
          if (this._widgets.hasOwnProperty(t)) {
            const i = this._widgets[t];
            delete this._widgets[t];
            const n = i.domNode.domNode;
            n.remove(), n.removeAttribute("monaco-visible-content-widget"), this.setShouldRender();
          }
        }
        shouldSuppressMouseDownOnWidget(e) {
          return this._widgets.hasOwnProperty(e) ? this._widgets[e].suppressMouseDown : false;
        }
        onBeforeRender(e) {
          const t = Object.keys(this._widgets);
          for (const i of t) this._widgets[i].onBeforeRender(e);
        }
        prepareRender(e) {
          const t = Object.keys(this._widgets);
          for (const i of t) this._widgets[i].prepareRender(e);
        }
        render(e) {
          const t = Object.keys(this._widgets);
          for (const i of t) this._widgets[i].render(e);
        }
      }
      class gce {
        constructor(e, t, i) {
          this._primaryAnchor = new Gm(null, null), this._secondaryAnchor = new Gm(null, null), this._context = e, this._viewDomNode = t, this._actual = i, this.domNode = St(this._actual.getDomNode()), this.id = this._actual.getId(), this.allowEditorOverflow = this._actual.allowEditorOverflow || false, this.suppressMouseDown = this._actual.suppressMouseDown || false;
          const n = this._context.configuration.options, o = n.get(146);
          this._fixedOverflowWidgets = n.get(42), this._contentWidth = o.contentWidth, this._contentLeft = o.contentLeft, this._lineHeight = n.get(67), this._affinity = null, this._preference = [], this._cachedDomNodeOffsetWidth = -1, this._cachedDomNodeOffsetHeight = -1, this._maxWidth = this._getMaxWidth(), this._isVisible = false, this._renderData = null, this.domNode.setPosition(this._fixedOverflowWidgets && this.allowEditorOverflow ? "fixed" : "absolute"), this.domNode.setDisplay("none"), this.domNode.setVisibility("hidden"), this.domNode.setAttribute("widgetId", this.id), this.domNode.setMaxWidth(this._maxWidth);
        }
        onConfigurationChanged(e) {
          const t = this._context.configuration.options;
          if (this._lineHeight = t.get(67), e.hasChanged(146)) {
            const i = t.get(146);
            this._contentLeft = i.contentLeft, this._contentWidth = i.contentWidth, this._maxWidth = this._getMaxWidth();
          }
        }
        updateAnchorViewPosition() {
          this._setPosition(this._affinity, this._primaryAnchor.modelPosition, this._secondaryAnchor.modelPosition);
        }
        _setPosition(e, t, i) {
          this._affinity = e, this._primaryAnchor = n(t, this._context.viewModel, this._affinity), this._secondaryAnchor = n(i, this._context.viewModel, this._affinity);
          function n(o, r, a) {
            if (!o) return new Gm(null, null);
            const l = r.model.validatePosition(o);
            if (r.coordinatesConverter.modelPositionIsVisible(l)) {
              const u = r.coordinatesConverter.convertModelPositionToViewPosition(l, a ?? void 0);
              return new Gm(o, u);
            }
            return new Gm(o, null);
          }
        }
        _getMaxWidth() {
          const e = this.domNode.domNode.ownerDocument, t = e.defaultView;
          return this.allowEditorOverflow ? (t == null ? void 0 : t.innerWidth) || e.documentElement.offsetWidth || e.body.offsetWidth : this._contentWidth;
        }
        setPosition(e, t, i, n) {
          this._setPosition(n, e, t), this._preference = i, this._primaryAnchor.viewPosition && this._preference && this._preference.length > 0 ? this.domNode.setDisplay("block") : this.domNode.setDisplay("none"), this._cachedDomNodeOffsetWidth = -1, this._cachedDomNodeOffsetHeight = -1;
        }
        _layoutBoxInViewport(e, t, i, n) {
          const o = e.top, r = o, a = e.top + e.height, l = n.viewportHeight - a, u = o - i, d = r >= i, f = a, m = l >= i;
          let _ = e.left;
          return _ + t > n.scrollLeft + n.viewportWidth && (_ = n.scrollLeft + n.viewportWidth - t), _ < n.scrollLeft && (_ = n.scrollLeft), {
            fitsAbove: d,
            aboveTop: u,
            fitsBelow: m,
            belowTop: f,
            left: _
          };
        }
        _layoutHorizontalSegmentInPage(e, t, i, n) {
          const a = Math.max(15, t.left - n), l = Math.min(t.left + t.width + n, e.width - 15), d = this._viewDomNode.domNode.ownerDocument.defaultView;
          let f = t.left + i - ((d == null ? void 0 : d.scrollX) ?? 0);
          if (f + n > l) {
            const m = f - (l - n);
            f -= m, i -= m;
          }
          if (f < a) {
            const m = f - a;
            f -= m, i -= m;
          }
          return [
            i,
            f
          ];
        }
        _layoutBoxInPage(e, t, i, n) {
          const o = e.top - i, r = e.top + e.height, a = Bo(this._viewDomNode.domNode), l = this._viewDomNode.domNode.ownerDocument, u = l.defaultView, d = a.top + o - ((u == null ? void 0 : u.scrollY) ?? 0), f = a.top + r - ((u == null ? void 0 : u.scrollY) ?? 0), m = $k(l.body), [_, b] = this._layoutHorizontalSegmentInPage(m, a, e.left - n.scrollLeft + this._contentLeft, t), v = 22, y = 22, x = d >= v, L = f + i <= m.height - y;
          return this._fixedOverflowWidgets ? {
            fitsAbove: x,
            aboveTop: Math.max(d, v),
            fitsBelow: L,
            belowTop: f,
            left: b
          } : {
            fitsAbove: x,
            aboveTop: o,
            fitsBelow: L,
            belowTop: r,
            left: _
          };
        }
        _prepareRenderWidgetAtExactPositionOverflowing(e) {
          return new Ym(e.top, e.left + this._contentLeft);
        }
        _getAnchorsCoordinates(e) {
          var _a3, _b3;
          const t = o(this._primaryAnchor.viewPosition, this._affinity, this._lineHeight), i = ((_a3 = this._secondaryAnchor.viewPosition) == null ? void 0 : _a3.lineNumber) === ((_b3 = this._primaryAnchor.viewPosition) == null ? void 0 : _b3.lineNumber) ? this._secondaryAnchor.viewPosition : null, n = o(i, this._affinity, this._lineHeight);
          return {
            primary: t,
            secondary: n
          };
          function o(r, a, l) {
            if (!r) return null;
            const u = e.visibleRangeForPosition(r);
            if (!u) return null;
            const d = r.column === 1 && a === 3 ? 0 : u.left, f = e.getVerticalOffsetForLineNumber(r.lineNumber) - e.scrollTop;
            return new H3(f, d, l);
          }
        }
        _reduceAnchorCoordinates(e, t, i) {
          if (!t) return e;
          const n = this._context.configuration.options.get(50);
          let o = t.left;
          return o < e.left ? o = Math.max(o, e.left - i + n.typicalFullwidthCharacterWidth) : o = Math.min(o, e.left + i - n.typicalFullwidthCharacterWidth), new H3(e.top, o, e.height);
        }
        _prepareRenderWidget(e) {
          if (!this._preference || this._preference.length === 0) return null;
          const { primary: t, secondary: i } = this._getAnchorsCoordinates(e);
          if (!t) return {
            kind: "offViewport",
            preserveFocus: this.domNode.domNode.contains(this.domNode.domNode.ownerDocument.activeElement)
          };
          if (this._cachedDomNodeOffsetWidth === -1 || this._cachedDomNodeOffsetHeight === -1) {
            let r = null;
            if (typeof this._actual.beforeRender == "function" && (r = wx(this._actual.beforeRender, this._actual)), r) this._cachedDomNodeOffsetWidth = r.width, this._cachedDomNodeOffsetHeight = r.height;
            else {
              const l = this.domNode.domNode.getBoundingClientRect();
              this._cachedDomNodeOffsetWidth = Math.round(l.width), this._cachedDomNodeOffsetHeight = Math.round(l.height);
            }
          }
          const n = this._reduceAnchorCoordinates(t, i, this._cachedDomNodeOffsetWidth);
          let o;
          this.allowEditorOverflow ? o = this._layoutBoxInPage(n, this._cachedDomNodeOffsetWidth, this._cachedDomNodeOffsetHeight, e) : o = this._layoutBoxInViewport(n, this._cachedDomNodeOffsetWidth, this._cachedDomNodeOffsetHeight, e);
          for (let r = 1; r <= 2; r++) for (const a of this._preference) if (a === 1) {
            if (!o) return null;
            if (r === 2 || o.fitsAbove) return {
              kind: "inViewport",
              coordinate: new Ym(o.aboveTop, o.left),
              position: 1
            };
          } else if (a === 2) {
            if (!o) return null;
            if (r === 2 || o.fitsBelow) return {
              kind: "inViewport",
              coordinate: new Ym(o.belowTop, o.left),
              position: 2
            };
          } else return this.allowEditorOverflow ? {
            kind: "inViewport",
            coordinate: this._prepareRenderWidgetAtExactPositionOverflowing(new Ym(n.top, n.left)),
            position: 0
          } : {
            kind: "inViewport",
            coordinate: new Ym(n.top, n.left),
            position: 0
          };
          return null;
        }
        onBeforeRender(e) {
          !this._primaryAnchor.viewPosition || !this._preference || this._primaryAnchor.viewPosition.lineNumber < e.startLineNumber || this._primaryAnchor.viewPosition.lineNumber > e.endLineNumber || this.domNode.setMaxWidth(this._maxWidth);
        }
        prepareRender(e) {
          this._renderData = this._prepareRenderWidget(e);
        }
        render(e) {
          var _a3;
          if (!this._renderData || this._renderData.kind === "offViewport") {
            this._isVisible && (this.domNode.removeAttribute("monaco-visible-content-widget"), this._isVisible = false, ((_a3 = this._renderData) == null ? void 0 : _a3.kind) === "offViewport" && this._renderData.preserveFocus ? this.domNode.setTop(-1e3) : this.domNode.setVisibility("hidden")), typeof this._actual.afterRender == "function" && wx(this._actual.afterRender, this._actual, null);
            return;
          }
          this.allowEditorOverflow ? (this.domNode.setTop(this._renderData.coordinate.top), this.domNode.setLeft(this._renderData.coordinate.left)) : (this.domNode.setTop(this._renderData.coordinate.top + e.scrollTop - e.bigNumbersDelta), this.domNode.setLeft(this._renderData.coordinate.left)), this._isVisible || (this.domNode.setVisibility("inherit"), this.domNode.setAttribute("monaco-visible-content-widget", "true"), this._isVisible = true), typeof this._actual.afterRender == "function" && wx(this._actual.afterRender, this._actual, this._renderData.position);
        }
      }
      class Gm {
        constructor(e, t) {
          this.modelPosition = e, this.viewPosition = t;
        }
      }
      class Ym {
        constructor(e, t) {
          this.top = e, this.left = t, this._coordinateBrand = void 0;
        }
      }
      class H3 {
        constructor(e, t, i) {
          this.top = e, this.left = t, this.height = i, this._anchorCoordinateBrand = void 0;
        }
      }
      function wx(s, e, ...t) {
        try {
          return s.call(e, ...t);
        } catch {
          return null;
        }
      }
      class PF extends sd {
        constructor(e) {
          super(), this._context = e;
          const t = this._context.configuration.options, i = t.get(146);
          this._renderLineHighlight = t.get(97), this._renderLineHighlightOnlyWhenFocus = t.get(98), this._wordWrap = i.isViewportWrapping, this._contentLeft = i.contentLeft, this._contentWidth = i.contentWidth, this._selectionIsEmpty = true, this._focused = false, this._cursorLineNumbers = [
            1
          ], this._selections = [
            new mt(1, 1, 1, 1)
          ], this._renderData = null, this._context.addEventHandler(this);
        }
        dispose() {
          this._context.removeEventHandler(this), super.dispose();
        }
        _readFromSelections() {
          let e = false;
          const t = /* @__PURE__ */ new Set();
          for (const o of this._selections) t.add(o.positionLineNumber);
          const i = Array.from(t);
          i.sort((o, r) => o - r), Qi(this._cursorLineNumbers, i) || (this._cursorLineNumbers = i, e = true);
          const n = this._selections.every((o) => o.isEmpty());
          return this._selectionIsEmpty !== n && (this._selectionIsEmpty = n, e = true), e;
        }
        onThemeChanged(e) {
          return this._readFromSelections();
        }
        onConfigurationChanged(e) {
          const t = this._context.configuration.options, i = t.get(146);
          return this._renderLineHighlight = t.get(97), this._renderLineHighlightOnlyWhenFocus = t.get(98), this._wordWrap = i.isViewportWrapping, this._contentLeft = i.contentLeft, this._contentWidth = i.contentWidth, true;
        }
        onCursorStateChanged(e) {
          return this._selections = e.selections, this._readFromSelections();
        }
        onFlushed(e) {
          return true;
        }
        onLinesDeleted(e) {
          return true;
        }
        onLinesInserted(e) {
          return true;
        }
        onScrollChanged(e) {
          return e.scrollWidthChanged || e.scrollTopChanged;
        }
        onZonesChanged(e) {
          return true;
        }
        onFocusChanged(e) {
          return this._renderLineHighlightOnlyWhenFocus ? (this._focused = e.isFocused, true) : false;
        }
        prepareRender(e) {
          if (!this._shouldRenderThis()) {
            this._renderData = null;
            return;
          }
          const t = e.visibleRange.startLineNumber, i = e.visibleRange.endLineNumber, n = [];
          for (let r = t; r <= i; r++) {
            const a = r - t;
            n[a] = "";
          }
          if (this._wordWrap) {
            const r = this._renderOne(e, false);
            for (const a of this._cursorLineNumbers) {
              const l = this._context.viewModel.coordinatesConverter, u = l.convertViewPositionToModelPosition(new X(a, 1)).lineNumber, d = l.convertModelPositionToViewPosition(new X(u, 1)).lineNumber, f = l.convertModelPositionToViewPosition(new X(u, this._context.viewModel.model.getLineMaxColumn(u))).lineNumber, m = Math.max(d, t), _ = Math.min(f, i);
              for (let b = m; b <= _; b++) {
                const v = b - t;
                n[v] = r;
              }
            }
          }
          const o = this._renderOne(e, true);
          for (const r of this._cursorLineNumbers) {
            if (r < t || r > i) continue;
            const a = r - t;
            n[a] = o;
          }
          this._renderData = n;
        }
        render(e, t) {
          if (!this._renderData) return "";
          const i = t - e;
          return i >= this._renderData.length ? "" : this._renderData[i];
        }
        _shouldRenderInMargin() {
          return (this._renderLineHighlight === "gutter" || this._renderLineHighlight === "all") && (!this._renderLineHighlightOnlyWhenFocus || this._focused);
        }
        _shouldRenderInContent() {
          return (this._renderLineHighlight === "line" || this._renderLineHighlight === "all") && this._selectionIsEmpty && (!this._renderLineHighlightOnlyWhenFocus || this._focused);
        }
      }
      class mce extends PF {
        _renderOne(e, t) {
          return `<div class="${"current-line" + (this._shouldRenderInMargin() ? " current-line-both" : "") + (t ? " current-line-exact" : "")}" style="width:${Math.max(e.scrollWidth, this._contentWidth)}px;"></div>`;
        }
        _shouldRenderThis() {
          return this._shouldRenderInContent();
        }
        _shouldRenderOther() {
          return this._shouldRenderInMargin();
        }
      }
      class pce extends PF {
        _renderOne(e, t) {
          return `<div class="${"current-line" + (this._shouldRenderInMargin() ? " current-line-margin" : "") + (this._shouldRenderOther() ? " current-line-margin-both" : "") + (this._shouldRenderInMargin() && t ? " current-line-exact-margin" : "")}" style="width:${this._contentLeft}px"></div>`;
        }
        _shouldRenderThis() {
          return true;
        }
        _shouldRenderOther() {
          return this._shouldRenderInContent();
        }
      }
      jl((s, e) => {
        const t = s.getColor(rB);
        if (t && (e.addRule(`.monaco-editor .view-overlays .current-line { background-color: ${t}; }`), e.addRule(`.monaco-editor .margin-view-overlays .current-line-margin { background-color: ${t}; border: none; }`)), !t || t.isTransparent() || s.defines(CP)) {
          const i = s.getColor(CP);
          i && (e.addRule(`.monaco-editor .view-overlays .current-line-exact { border: 2px solid ${i}; }`), e.addRule(`.monaco-editor .margin-view-overlays .current-line-exact-margin { border: 2px solid ${i}; }`), Bf(s.type) && (e.addRule(".monaco-editor .view-overlays .current-line-exact { border-width: 1px; }"), e.addRule(".monaco-editor .margin-view-overlays .current-line-exact-margin { border-width: 1px; }")));
        }
      });
      class _ce extends sd {
        constructor(e) {
          super(), this._context = e;
          const t = this._context.configuration.options;
          this._typicalHalfwidthCharacterWidth = t.get(50).typicalHalfwidthCharacterWidth, this._renderResult = null, this._context.addEventHandler(this);
        }
        dispose() {
          this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
        }
        onConfigurationChanged(e) {
          const t = this._context.configuration.options;
          return this._typicalHalfwidthCharacterWidth = t.get(50).typicalHalfwidthCharacterWidth, true;
        }
        onDecorationsChanged(e) {
          return true;
        }
        onFlushed(e) {
          return true;
        }
        onLinesChanged(e) {
          return true;
        }
        onLinesDeleted(e) {
          return true;
        }
        onLinesInserted(e) {
          return true;
        }
        onScrollChanged(e) {
          return e.scrollTopChanged || e.scrollWidthChanged;
        }
        onZonesChanged(e) {
          return true;
        }
        prepareRender(e) {
          const t = e.getDecorationsInViewport();
          let i = [], n = 0;
          for (let l = 0, u = t.length; l < u; l++) {
            const d = t[l];
            d.options.className && (i[n++] = d);
          }
          i = i.sort((l, u) => {
            if (l.options.zIndex < u.options.zIndex) return -1;
            if (l.options.zIndex > u.options.zIndex) return 1;
            const d = l.options.className, f = u.options.className;
            return d < f ? -1 : d > f ? 1 : z.compareRangesUsingStarts(l.range, u.range);
          });
          const o = e.visibleRange.startLineNumber, r = e.visibleRange.endLineNumber, a = [];
          for (let l = o; l <= r; l++) {
            const u = l - o;
            a[u] = "";
          }
          this._renderWholeLineDecorations(e, i, a), this._renderNormalDecorations(e, i, a), this._renderResult = a;
        }
        _renderWholeLineDecorations(e, t, i) {
          const n = e.visibleRange.startLineNumber, o = e.visibleRange.endLineNumber;
          for (let r = 0, a = t.length; r < a; r++) {
            const l = t[r];
            if (!l.options.isWholeLine) continue;
            const u = '<div class="cdr ' + l.options.className + '" style="left:0;width:100%;"></div>', d = Math.max(l.range.startLineNumber, n), f = Math.min(l.range.endLineNumber, o);
            for (let m = d; m <= f; m++) {
              const _ = m - n;
              i[_] += u;
            }
          }
        }
        _renderNormalDecorations(e, t, i) {
          const n = e.visibleRange.startLineNumber;
          let o = null, r = false, a = null, l = false;
          for (let u = 0, d = t.length; u < d; u++) {
            const f = t[u];
            if (f.options.isWholeLine) continue;
            const m = f.options.className, _ = !!f.options.showIfCollapsed;
            let b = f.range;
            if (_ && b.endColumn === 1 && b.endLineNumber !== b.startLineNumber && (b = new z(b.startLineNumber, b.startColumn, b.endLineNumber - 1, this._context.viewModel.getLineMaxColumn(b.endLineNumber - 1))), o === m && r === _ && z.areIntersectingOrTouching(a, b)) {
              a = z.plusRange(a, b);
              continue;
            }
            o !== null && this._renderNormalDecoration(e, a, o, l, r, n, i), o = m, r = _, a = b, l = f.options.shouldFillLineOnLineBreak ?? false;
          }
          o !== null && this._renderNormalDecoration(e, a, o, l, r, n, i);
        }
        _renderNormalDecoration(e, t, i, n, o, r, a) {
          const l = e.linesVisibleRangesForRange(t, i === "findMatch");
          if (l) for (let u = 0, d = l.length; u < d; u++) {
            const f = l[u];
            if (f.outsideRenderedLine) continue;
            const m = f.lineNumber - r;
            if (o && f.ranges.length === 1) {
              const _ = f.ranges[0];
              if (_.width < this._typicalHalfwidthCharacterWidth) {
                const b = Math.round(_.left + _.width / 2), v = Math.max(0, Math.round(b - this._typicalHalfwidthCharacterWidth / 2));
                f.ranges[0] = new Hw(v, this._typicalHalfwidthCharacterWidth);
              }
            }
            for (let _ = 0, b = f.ranges.length; _ < b; _++) {
              const v = n && f.continuesOnNextLine && b === 1, y = f.ranges[_], x = '<div class="cdr ' + i + '" style="left:' + String(y.left) + "px;width:" + (v ? "100%;" : String(y.width) + "px;") + '"></div>';
              a[m] += x;
            }
          }
        }
        render(e, t) {
          if (!this._renderResult) return "";
          const i = t - e;
          return i < 0 || i >= this._renderResult.length ? "" : this._renderResult[i];
        }
      }
      class bce extends Zs {
        constructor(e, t, i, n) {
          super(e);
          const o = this._context.configuration.options, r = o.get(104), a = o.get(75), l = o.get(40), u = o.get(107), d = {
            listenOnDomNode: i.domNode,
            className: "editor-scrollable " + lD(e.theme.type),
            useShadows: false,
            lazyRender: true,
            vertical: r.vertical,
            horizontal: r.horizontal,
            verticalHasArrows: r.verticalHasArrows,
            horizontalHasArrows: r.horizontalHasArrows,
            verticalScrollbarSize: r.verticalScrollbarSize,
            verticalSliderSize: r.verticalSliderSize,
            horizontalScrollbarSize: r.horizontalScrollbarSize,
            horizontalSliderSize: r.horizontalSliderSize,
            handleMouseWheel: r.handleMouseWheel,
            alwaysConsumeMouseWheel: r.alwaysConsumeMouseWheel,
            arrowSize: r.arrowSize,
            mouseWheelScrollSensitivity: a,
            fastScrollSensitivity: l,
            scrollPredominantAxis: u,
            scrollByPage: r.scrollByPage
          };
          this.scrollbar = this._register(new dw(t.domNode, d, this._context.viewLayout.getScrollable())), Yr.write(this.scrollbar.getDomNode(), 6), this.scrollbarDomNode = St(this.scrollbar.getDomNode()), this.scrollbarDomNode.setPosition("absolute"), this._setLayout();
          const f = (m, _, b) => {
            const v = {};
            {
              const y = m.scrollTop;
              y && (v.scrollTop = this._context.viewLayout.getCurrentScrollTop() + y, m.scrollTop = 0);
            }
            if (b) {
              const y = m.scrollLeft;
              y && (v.scrollLeft = this._context.viewLayout.getCurrentScrollLeft() + y, m.scrollLeft = 0);
            }
            this._context.viewModel.viewLayout.setScrollPosition(v, 1);
          };
          this._register(re(i.domNode, "scroll", (m) => f(i.domNode, true, true))), this._register(re(t.domNode, "scroll", (m) => f(t.domNode, true, false))), this._register(re(n.domNode, "scroll", (m) => f(n.domNode, true, false))), this._register(re(this.scrollbarDomNode.domNode, "scroll", (m) => f(this.scrollbarDomNode.domNode, true, false)));
        }
        dispose() {
          super.dispose();
        }
        _setLayout() {
          const e = this._context.configuration.options, t = e.get(146);
          this.scrollbarDomNode.setLeft(t.contentLeft), e.get(73).side === "right" ? this.scrollbarDomNode.setWidth(t.contentWidth + t.minimap.minimapWidth) : this.scrollbarDomNode.setWidth(t.contentWidth), this.scrollbarDomNode.setHeight(t.height);
        }
        getOverviewRulerLayoutInfo() {
          return this.scrollbar.getOverviewRulerLayoutInfo();
        }
        getDomNode() {
          return this.scrollbarDomNode;
        }
        delegateVerticalScrollbarPointerDown(e) {
          this.scrollbar.delegateVerticalScrollbarPointerDown(e);
        }
        delegateScrollFromMouseWheelEvent(e) {
          this.scrollbar.delegateScrollFromMouseWheelEvent(e);
        }
        onConfigurationChanged(e) {
          if (e.hasChanged(104) || e.hasChanged(75) || e.hasChanged(40)) {
            const t = this._context.configuration.options, i = t.get(104), n = t.get(75), o = t.get(40), r = t.get(107), a = {
              vertical: i.vertical,
              horizontal: i.horizontal,
              verticalScrollbarSize: i.verticalScrollbarSize,
              horizontalScrollbarSize: i.horizontalScrollbarSize,
              scrollByPage: i.scrollByPage,
              handleMouseWheel: i.handleMouseWheel,
              mouseWheelScrollSensitivity: n,
              fastScrollSensitivity: o,
              scrollPredominantAxis: r
            };
            this.scrollbar.updateOptions(a);
          }
          return e.hasChanged(146) && this._setLayout(), true;
        }
        onScrollChanged(e) {
          return true;
        }
        onThemeChanged(e) {
          return this.scrollbar.updateClassName("editor-scrollable " + lD(this._context.theme.type)), true;
        }
        prepareRender(e) {
        }
        render(e) {
          this.scrollbar.renderNow();
        }
      }
      class X2 {
        constructor(e, t, i, n, o) {
          this.startLineNumber = e, this.endLineNumber = t, this.className = i, this.tooltip = n, this._decorationToRenderBrand = void 0, this.zIndex = o ?? 0;
        }
      }
      class vce {
        constructor(e, t, i) {
          this.className = e, this.zIndex = t, this.tooltip = i;
        }
      }
      class Cce {
        constructor() {
          this.decorations = [];
        }
        add(e) {
          this.decorations.push(e);
        }
        getDecorations() {
          return this.decorations;
        }
      }
      class BF extends sd {
        _render(e, t, i) {
          const n = [];
          for (let a = e; a <= t; a++) {
            const l = a - e;
            n[l] = new Cce();
          }
          if (i.length === 0) return n;
          i.sort((a, l) => a.className === l.className ? a.startLineNumber === l.startLineNumber ? a.endLineNumber - l.endLineNumber : a.startLineNumber - l.startLineNumber : a.className < l.className ? -1 : 1);
          let o = null, r = 0;
          for (let a = 0, l = i.length; a < l; a++) {
            const u = i[a], d = u.className, f = u.zIndex;
            let m = Math.max(u.startLineNumber, e) - e;
            const _ = Math.min(u.endLineNumber, t) - e;
            o === d ? (m = Math.max(r + 1, m), r = Math.max(r, _)) : (o = d, r = _);
            for (let b = m; b <= r; b++) n[b].add(new vce(d, f, u.tooltip));
          }
          return n;
        }
      }
      class wce extends Zs {
        constructor(e) {
          super(e), this._widgets = {}, this._context = e;
          const t = this._context.configuration.options, i = t.get(146);
          this.domNode = St(document.createElement("div")), this.domNode.setClassName("glyph-margin-widgets"), this.domNode.setPosition("absolute"), this.domNode.setTop(0), this._lineHeight = t.get(67), this._glyphMargin = t.get(57), this._glyphMarginLeft = i.glyphMarginLeft, this._glyphMarginWidth = i.glyphMarginWidth, this._glyphMarginDecorationLaneCount = i.glyphMarginDecorationLaneCount, this._managedDomNodes = [], this._decorationGlyphsToRender = [];
        }
        dispose() {
          this._managedDomNodes = [], this._decorationGlyphsToRender = [], this._widgets = {}, super.dispose();
        }
        getWidgets() {
          return Object.values(this._widgets);
        }
        onConfigurationChanged(e) {
          const t = this._context.configuration.options, i = t.get(146);
          return this._lineHeight = t.get(67), this._glyphMargin = t.get(57), this._glyphMarginLeft = i.glyphMarginLeft, this._glyphMarginWidth = i.glyphMarginWidth, this._glyphMarginDecorationLaneCount = i.glyphMarginDecorationLaneCount, true;
        }
        onDecorationsChanged(e) {
          return true;
        }
        onFlushed(e) {
          return true;
        }
        onLinesChanged(e) {
          return true;
        }
        onLinesDeleted(e) {
          return true;
        }
        onLinesInserted(e) {
          return true;
        }
        onScrollChanged(e) {
          return e.scrollTopChanged;
        }
        onZonesChanged(e) {
          return true;
        }
        addWidget(e) {
          const t = St(e.getDomNode());
          this._widgets[e.getId()] = {
            widget: e,
            preference: e.getPosition(),
            domNode: t,
            renderInfo: null
          }, t.setPosition("absolute"), t.setDisplay("none"), t.setAttribute("widgetId", e.getId()), this.domNode.appendChild(t), this.setShouldRender();
        }
        setWidgetPosition(e, t) {
          const i = this._widgets[e.getId()];
          return i.preference.lane === t.lane && i.preference.zIndex === t.zIndex && z.equalsRange(i.preference.range, t.range) ? false : (i.preference = t, this.setShouldRender(), true);
        }
        removeWidget(e) {
          const t = e.getId();
          if (this._widgets[t]) {
            const n = this._widgets[t].domNode.domNode;
            delete this._widgets[t], n.remove(), this.setShouldRender();
          }
        }
        _collectDecorationBasedGlyphRenderRequest(e, t) {
          var _a3;
          const i = e.visibleRange.startLineNumber, n = e.visibleRange.endLineNumber, o = e.getDecorationsInViewport();
          for (const r of o) {
            const a = r.options.glyphMarginClassName;
            if (!a) continue;
            const l = Math.max(r.range.startLineNumber, i), u = Math.min(r.range.endLineNumber, n), d = ((_a3 = r.options.glyphMargin) == null ? void 0 : _a3.position) ?? ru.Center, f = r.options.zIndex ?? 0;
            for (let m = l; m <= u; m++) {
              const _ = this._context.viewModel.coordinatesConverter.convertViewPositionToModelPosition(new X(m, 0)), b = this._context.viewModel.glyphLanes.getLanesAtLine(_.lineNumber).indexOf(d);
              t.push(new yce(m, b, f, a));
            }
          }
        }
        _collectWidgetBasedGlyphRenderRequest(e, t) {
          const i = e.visibleRange.startLineNumber, n = e.visibleRange.endLineNumber;
          for (const o of Object.values(this._widgets)) {
            const r = o.preference.range, { startLineNumber: a, endLineNumber: l } = this._context.viewModel.coordinatesConverter.convertModelRangeToViewRange(z.lift(r));
            if (!a || !l || l < i || a > n) continue;
            const u = Math.max(a, i), d = this._context.viewModel.coordinatesConverter.convertViewPositionToModelPosition(new X(u, 0)), f = this._context.viewModel.glyphLanes.getLanesAtLine(d.lineNumber).indexOf(o.preference.lane);
            t.push(new Sce(u, f, o.preference.zIndex, o));
          }
        }
        _collectSortedGlyphRenderRequests(e) {
          const t = [];
          return this._collectDecorationBasedGlyphRenderRequest(e, t), this._collectWidgetBasedGlyphRenderRequest(e, t), t.sort((i, n) => i.lineNumber === n.lineNumber ? i.laneIndex === n.laneIndex ? i.zIndex === n.zIndex ? n.type === i.type ? i.type === 0 && n.type === 0 ? i.className < n.className ? -1 : 1 : 0 : n.type - i.type : n.zIndex - i.zIndex : i.laneIndex - n.laneIndex : i.lineNumber - n.lineNumber), t;
        }
        prepareRender(e) {
          if (!this._glyphMargin) {
            this._decorationGlyphsToRender = [];
            return;
          }
          for (const n of Object.values(this._widgets)) n.renderInfo = null;
          const t = new zl(this._collectSortedGlyphRenderRequests(e)), i = [];
          for (; t.length > 0; ) {
            const n = t.peek();
            if (!n) break;
            const o = t.takeWhile((a) => a.lineNumber === n.lineNumber && a.laneIndex === n.laneIndex);
            if (!o || o.length === 0) break;
            const r = o[0];
            if (r.type === 0) {
              const a = [];
              for (const l of o) {
                if (l.zIndex !== r.zIndex || l.type !== r.type) break;
                (a.length === 0 || a[a.length - 1] !== l.className) && a.push(l.className);
              }
              i.push(r.accept(a.join(" ")));
            } else r.widget.renderInfo = {
              lineNumber: r.lineNumber,
              laneIndex: r.laneIndex
            };
          }
          this._decorationGlyphsToRender = i;
        }
        render(e) {
          var _a3, _b3;
          if (!this._glyphMargin) {
            for (const i of Object.values(this._widgets)) i.domNode.setDisplay("none");
            for (; this._managedDomNodes.length > 0; ) (_a3 = this._managedDomNodes.pop()) == null ? void 0 : _a3.domNode.remove();
            return;
          }
          const t = Math.round(this._glyphMarginWidth / this._glyphMarginDecorationLaneCount);
          for (const i of Object.values(this._widgets)) if (!i.renderInfo) i.domNode.setDisplay("none");
          else {
            const n = e.viewportData.relativeVerticalOffset[i.renderInfo.lineNumber - e.viewportData.startLineNumber], o = this._glyphMarginLeft + i.renderInfo.laneIndex * this._lineHeight;
            i.domNode.setDisplay("block"), i.domNode.setTop(n), i.domNode.setLeft(o), i.domNode.setWidth(t), i.domNode.setHeight(this._lineHeight);
          }
          for (let i = 0; i < this._decorationGlyphsToRender.length; i++) {
            const n = this._decorationGlyphsToRender[i], o = e.viewportData.relativeVerticalOffset[n.lineNumber - e.viewportData.startLineNumber], r = this._glyphMarginLeft + n.laneIndex * this._lineHeight;
            let a;
            i < this._managedDomNodes.length ? a = this._managedDomNodes[i] : (a = St(document.createElement("div")), this._managedDomNodes.push(a), this.domNode.appendChild(a)), a.setClassName("cgmr codicon " + n.combinedClassName), a.setPosition("absolute"), a.setTop(o), a.setLeft(r), a.setWidth(t), a.setHeight(this._lineHeight);
          }
          for (; this._managedDomNodes.length > this._decorationGlyphsToRender.length; ) (_b3 = this._managedDomNodes.pop()) == null ? void 0 : _b3.domNode.remove();
        }
      }
      class yce {
        constructor(e, t, i, n) {
          this.lineNumber = e, this.laneIndex = t, this.zIndex = i, this.className = n, this.type = 0;
        }
        accept(e) {
          return new Lce(this.lineNumber, this.laneIndex, e);
        }
      }
      class Sce {
        constructor(e, t, i, n) {
          this.lineNumber = e, this.laneIndex = t, this.zIndex = i, this.widget = n, this.type = 1;
        }
      }
      class Lce {
        constructor(e, t, i) {
          this.lineNumber = e, this.laneIndex = t, this.combinedClassName = i;
        }
      }
      class xce extends sd {
        constructor(e) {
          super(), this._context = e, this._primaryPosition = null;
          const t = this._context.configuration.options, i = t.get(147), n = t.get(50);
          this._spaceWidth = n.spaceWidth, this._maxIndentLeft = i.wrappingColumn === -1 ? -1 : i.wrappingColumn * n.typicalHalfwidthCharacterWidth, this._bracketPairGuideOptions = t.get(16), this._renderResult = null, this._context.addEventHandler(this);
        }
        dispose() {
          this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
        }
        onConfigurationChanged(e) {
          const t = this._context.configuration.options, i = t.get(147), n = t.get(50);
          return this._spaceWidth = n.spaceWidth, this._maxIndentLeft = i.wrappingColumn === -1 ? -1 : i.wrappingColumn * n.typicalHalfwidthCharacterWidth, this._bracketPairGuideOptions = t.get(16), true;
        }
        onCursorStateChanged(e) {
          var _a3;
          const i = e.selections[0].getPosition();
          return ((_a3 = this._primaryPosition) == null ? void 0 : _a3.equals(i)) ? false : (this._primaryPosition = i, true);
        }
        onDecorationsChanged(e) {
          return true;
        }
        onFlushed(e) {
          return true;
        }
        onLinesChanged(e) {
          return true;
        }
        onLinesDeleted(e) {
          return true;
        }
        onLinesInserted(e) {
          return true;
        }
        onScrollChanged(e) {
          return e.scrollTopChanged;
        }
        onZonesChanged(e) {
          return true;
        }
        onLanguageConfigurationChanged(e) {
          return true;
        }
        prepareRender(e) {
          var _a3, _b3;
          if (!this._bracketPairGuideOptions.indentation && this._bracketPairGuideOptions.bracketPairs === false) {
            this._renderResult = null;
            return;
          }
          const t = e.visibleRange.startLineNumber, i = e.visibleRange.endLineNumber, n = e.scrollWidth, o = this._primaryPosition, r = this.getGuidesByLine(t, Math.min(i + 1, this._context.viewModel.getLineCount()), o), a = [];
          for (let l = t; l <= i; l++) {
            const u = l - t, d = r[u];
            let f = "";
            const m = ((_a3 = e.visibleRangeForPosition(new X(l, 1))) == null ? void 0 : _a3.left) ?? 0;
            for (const _ of d) {
              const b = _.column === -1 ? m + (_.visibleColumn - 1) * this._spaceWidth : e.visibleRangeForPosition(new X(l, _.column)).left;
              if (b > n || this._maxIndentLeft > 0 && b > this._maxIndentLeft) break;
              const v = _.horizontalLine ? _.horizontalLine.top ? "horizontal-top" : "horizontal-bottom" : "vertical", y = _.horizontalLine ? (((_b3 = e.visibleRangeForPosition(new X(l, _.horizontalLine.endColumn))) == null ? void 0 : _b3.left) ?? b + this._spaceWidth) - b : this._spaceWidth;
              f += `<div class="core-guide ${_.className} ${v}" style="left:${b}px;width:${y}px"></div>`;
            }
            a[u] = f;
          }
          this._renderResult = a;
        }
        getGuidesByLine(e, t, i) {
          const n = this._bracketPairGuideOptions.bracketPairs !== false ? this._context.viewModel.getBracketGuidesInRangeByLine(e, t, i, {
            highlightActive: this._bracketPairGuideOptions.highlightActiveBracketPair,
            horizontalGuides: this._bracketPairGuideOptions.bracketPairsHorizontal === true ? Lh.Enabled : this._bracketPairGuideOptions.bracketPairsHorizontal === "active" ? Lh.EnabledForActive : Lh.Disabled,
            includeInactive: this._bracketPairGuideOptions.bracketPairs === true
          }) : null, o = this._bracketPairGuideOptions.indentation ? this._context.viewModel.getLinesIndentGuides(e, t) : null;
          let r = 0, a = 0, l = 0;
          if (this._bracketPairGuideOptions.highlightActiveIndentation !== false && i) {
            const f = this._context.viewModel.getActiveIndentGuide(i.lineNumber, e, t);
            r = f.startLineNumber, a = f.endLineNumber, l = f.indent;
          }
          const { indentSize: u } = this._context.viewModel.model.getOptions(), d = [];
          for (let f = e; f <= t; f++) {
            const m = new Array();
            d.push(m);
            const _ = n ? n[f - e] : [], b = new zl(_), v = o ? o[f - e] : 0;
            for (let y = 1; y <= v; y++) {
              const x = (y - 1) * u + 1, L = (this._bracketPairGuideOptions.highlightActiveIndentation === "always" || _.length === 0) && r <= f && f <= a && y === l;
              m.push(...b.takeWhile((k) => k.visibleColumn < x) || []);
              const D = b.peek();
              (!D || D.visibleColumn !== x || D.horizontalLine) && m.push(new ph(x, -1, `core-guide-indent lvl-${(y - 1) % 30}` + (L ? " indent-active" : ""), null, -1, -1));
            }
            m.push(...b.takeWhile((y) => true) || []);
          }
          return d;
        }
        render(e, t) {
          if (!this._renderResult) return "";
          const i = t - e;
          return i < 0 || i >= this._renderResult.length ? "" : this._renderResult[i];
        }
      }
      function nf(s) {
        if (!(s && s.isTransparent())) return s;
      }
      jl((s, e) => {
        const t = [
          {
            bracketColor: cB,
            guideColor: Eie,
            guideColorActive: Rie
          },
          {
            bracketColor: uB,
            guideColor: Tie,
            guideColorActive: Oie
          },
          {
            bracketColor: hB,
            guideColor: Nie,
            guideColorActive: Pie
          },
          {
            bracketColor: dB,
            guideColor: Iie,
            guideColorActive: Bie
          },
          {
            bracketColor: fB,
            guideColor: Mie,
            guideColorActive: Fie
          },
          {
            bracketColor: gB,
            guideColor: Aie,
            guideColorActive: Vie
          }
        ], i = new LB(), n = [
          {
            indentColor: s1,
            indentColorActive: o1
          },
          {
            indentColor: lie,
            indentColorActive: fie
          },
          {
            indentColor: cie,
            indentColorActive: gie
          },
          {
            indentColor: uie,
            indentColorActive: mie
          },
          {
            indentColor: hie,
            indentColorActive: pie
          },
          {
            indentColor: die,
            indentColorActive: _ie
          }
        ], o = t.map((a) => {
          const l = s.getColor(a.bracketColor), u = s.getColor(a.guideColor), d = s.getColor(a.guideColorActive), f = nf(nf(u) ?? (l == null ? void 0 : l.transparent(0.3))), m = nf(nf(d) ?? l);
          if (!(!f || !m)) return {
            guideColor: f,
            guideColorActive: m
          };
        }).filter(Jf), r = n.map((a) => {
          const l = s.getColor(a.indentColor), u = s.getColor(a.indentColorActive), d = nf(l), f = nf(u);
          if (!(!d || !f)) return {
            indentColor: d,
            indentColorActive: f
          };
        }).filter(Jf);
        if (o.length > 0) {
          for (let a = 0; a < 30; a++) {
            const l = o[a % o.length];
            e.addRule(`.monaco-editor .${i.getInlineClassNameOfLevel(a).replace(/ /g, ".")} { --guide-color: ${l.guideColor}; --guide-color-active: ${l.guideColorActive}; }`);
          }
          e.addRule(".monaco-editor .vertical { box-shadow: 1px 0 0 0 var(--guide-color) inset; }"), e.addRule(".monaco-editor .horizontal-top { border-top: 1px solid var(--guide-color); }"), e.addRule(".monaco-editor .horizontal-bottom { border-bottom: 1px solid var(--guide-color); }"), e.addRule(`.monaco-editor .vertical.${i.activeClassName} { box-shadow: 1px 0 0 0 var(--guide-color-active) inset; }`), e.addRule(`.monaco-editor .horizontal-top.${i.activeClassName} { border-top: 1px solid var(--guide-color-active); }`), e.addRule(`.monaco-editor .horizontal-bottom.${i.activeClassName} { border-bottom: 1px solid var(--guide-color-active); }`);
        }
        if (r.length > 0) {
          for (let a = 0; a < 30; a++) {
            const l = r[a % r.length];
            e.addRule(`.monaco-editor .lines-content .core-guide-indent.lvl-${a} { --indent-color: ${l.indentColor}; --indent-color-active: ${l.indentColorActive}; }`);
          }
          e.addRule(".monaco-editor .lines-content .core-guide-indent { box-shadow: 1px 0 0 0 var(--indent-color) inset; }"), e.addRule(".monaco-editor .lines-content .core-guide-indent.indent-active { box-shadow: 1px 0 0 0 var(--indent-color-active) inset; }");
        }
      });
      class yx {
        get didDomLayout() {
          return this._didDomLayout;
        }
        readClientRect() {
          if (!this._clientRectRead) {
            this._clientRectRead = true;
            const e = this._domNode.getBoundingClientRect();
            this.markDidDomLayout(), this._clientRectDeltaLeft = e.left, this._clientRectScale = e.width / this._domNode.offsetWidth;
          }
        }
        get clientRectDeltaLeft() {
          return this._clientRectRead || this.readClientRect(), this._clientRectDeltaLeft;
        }
        get clientRectScale() {
          return this._clientRectRead || this.readClientRect(), this._clientRectScale;
        }
        constructor(e, t) {
          this._domNode = e, this.endNode = t, this._didDomLayout = false, this._clientRectDeltaLeft = 0, this._clientRectScale = 1, this._clientRectRead = false;
        }
        markDidDomLayout() {
          this._didDomLayout = true;
        }
      }
      class kce {
        constructor() {
          this._currentVisibleRange = new z(1, 1, 1, 1);
        }
        getCurrentVisibleRange() {
          return this._currentVisibleRange;
        }
        setCurrentVisibleRange(e) {
          this._currentVisibleRange = e;
        }
      }
      class Dce {
        constructor(e, t, i, n, o, r, a) {
          this.minimalReveal = e, this.lineNumber = t, this.startColumn = i, this.endColumn = n, this.startScrollTop = o, this.stopScrollTop = r, this.scrollType = a, this.type = "range", this.minLineNumber = t, this.maxLineNumber = t;
        }
      }
      class Ece {
        constructor(e, t, i, n, o) {
          this.minimalReveal = e, this.selections = t, this.startScrollTop = i, this.stopScrollTop = n, this.scrollType = o, this.type = "selections";
          let r = t[0].startLineNumber, a = t[0].endLineNumber;
          for (let l = 1, u = t.length; l < u; l++) {
            const d = t[l];
            r = Math.min(r, d.startLineNumber), a = Math.max(a, d.endLineNumber);
          }
          this.minLineNumber = r, this.maxLineNumber = a;
        }
      }
      const _sI = class _sI extends Zs {
        constructor(e, t) {
          super(e);
          const i = this._context.configuration, n = this._context.configuration.options, o = n.get(50), r = n.get(147);
          this._lineHeight = n.get(67), this._typicalHalfwidthCharacterWidth = o.typicalHalfwidthCharacterWidth, this._isViewportWrapping = r.isViewportWrapping, this._revealHorizontalRightPadding = n.get(101), this._cursorSurroundingLines = n.get(29), this._cursorSurroundingLinesStyle = n.get(30), this._canUseLayerHinting = !n.get(32), this._viewLineOptions = new I3(i, this._context.theme.type), this._linesContent = t, this._textRangeRestingSpot = document.createElement("div"), this._visibleLines = new RF({
            createLine: () => new Tl(this._viewLineOptions)
          }), this.domNode = this._visibleLines.domNode, Yr.write(this.domNode, 8), this.domNode.setClassName(`view-lines ${Qf}`), Un(this.domNode, o), this._maxLineWidth = 0, this._asyncUpdateLineWidths = new ns(() => {
            this._updateLineWidthsSlow();
          }, 200), this._asyncCheckMonospaceFontAssumptions = new ns(() => {
            this._checkMonospaceFontAssumptions();
          }, 2e3), this._lastRenderedData = new kce(), this._horizontalRevealRequest = null, this._stickyScrollEnabled = n.get(116).enabled, this._maxNumberStickyLines = n.get(116).maxLineCount;
        }
        dispose() {
          this._asyncUpdateLineWidths.dispose(), this._asyncCheckMonospaceFontAssumptions.dispose(), super.dispose();
        }
        getDomNode() {
          return this.domNode;
        }
        onConfigurationChanged(e) {
          this._visibleLines.onConfigurationChanged(e), e.hasChanged(147) && (this._maxLineWidth = 0);
          const t = this._context.configuration.options, i = t.get(50), n = t.get(147);
          return this._lineHeight = t.get(67), this._typicalHalfwidthCharacterWidth = i.typicalHalfwidthCharacterWidth, this._isViewportWrapping = n.isViewportWrapping, this._revealHorizontalRightPadding = t.get(101), this._cursorSurroundingLines = t.get(29), this._cursorSurroundingLinesStyle = t.get(30), this._canUseLayerHinting = !t.get(32), this._stickyScrollEnabled = t.get(116).enabled, this._maxNumberStickyLines = t.get(116).maxLineCount, Un(this.domNode, i), this._onOptionsMaybeChanged(), e.hasChanged(146) && (this._maxLineWidth = 0), true;
        }
        _onOptionsMaybeChanged() {
          const e = this._context.configuration, t = new I3(e, this._context.theme.type);
          if (!this._viewLineOptions.equals(t)) {
            this._viewLineOptions = t;
            const i = this._visibleLines.getStartLineNumber(), n = this._visibleLines.getEndLineNumber();
            for (let o = i; o <= n; o++) this._visibleLines.getVisibleLine(o).onOptionsChanged(this._viewLineOptions);
            return true;
          }
          return false;
        }
        onCursorStateChanged(e) {
          const t = this._visibleLines.getStartLineNumber(), i = this._visibleLines.getEndLineNumber();
          let n = false;
          for (let o = t; o <= i; o++) n = this._visibleLines.getVisibleLine(o).onSelectionChanged() || n;
          return n;
        }
        onDecorationsChanged(e) {
          {
            const t = this._visibleLines.getStartLineNumber(), i = this._visibleLines.getEndLineNumber();
            for (let n = t; n <= i; n++) this._visibleLines.getVisibleLine(n).onDecorationsChanged();
          }
          return true;
        }
        onFlushed(e) {
          const t = this._visibleLines.onFlushed(e);
          return this._maxLineWidth = 0, t;
        }
        onLinesChanged(e) {
          return this._visibleLines.onLinesChanged(e);
        }
        onLinesDeleted(e) {
          return this._visibleLines.onLinesDeleted(e);
        }
        onLinesInserted(e) {
          return this._visibleLines.onLinesInserted(e);
        }
        onRevealRangeRequest(e) {
          const t = this._computeScrollTopToRevealRange(this._context.viewLayout.getFutureViewport(), e.source, e.minimalReveal, e.range, e.selections, e.verticalType);
          if (t === -1) return false;
          let i = this._context.viewLayout.validateScrollPosition({
            scrollTop: t
          });
          e.revealHorizontal ? e.range && e.range.startLineNumber !== e.range.endLineNumber ? i = {
            scrollTop: i.scrollTop,
            scrollLeft: 0
          } : e.range ? this._horizontalRevealRequest = new Dce(e.minimalReveal, e.range.startLineNumber, e.range.startColumn, e.range.endColumn, this._context.viewLayout.getCurrentScrollTop(), i.scrollTop, e.scrollType) : e.selections && e.selections.length > 0 && (this._horizontalRevealRequest = new Ece(e.minimalReveal, e.selections, this._context.viewLayout.getCurrentScrollTop(), i.scrollTop, e.scrollType)) : this._horizontalRevealRequest = null;
          const o = Math.abs(this._context.viewLayout.getCurrentScrollTop() - i.scrollTop) <= this._lineHeight ? 1 : e.scrollType;
          return this._context.viewModel.viewLayout.setScrollPosition(i, o), true;
        }
        onScrollChanged(e) {
          if (this._horizontalRevealRequest && e.scrollLeftChanged && (this._horizontalRevealRequest = null), this._horizontalRevealRequest && e.scrollTopChanged) {
            const t = Math.min(this._horizontalRevealRequest.startScrollTop, this._horizontalRevealRequest.stopScrollTop), i = Math.max(this._horizontalRevealRequest.startScrollTop, this._horizontalRevealRequest.stopScrollTop);
            (e.scrollTop < t || e.scrollTop > i) && (this._horizontalRevealRequest = null);
          }
          return this.domNode.setWidth(e.scrollWidth), this._visibleLines.onScrollChanged(e) || true;
        }
        onTokensChanged(e) {
          return this._visibleLines.onTokensChanged(e);
        }
        onZonesChanged(e) {
          return this._context.viewModel.viewLayout.setMaxLineWidth(this._maxLineWidth), this._visibleLines.onZonesChanged(e);
        }
        onThemeChanged(e) {
          return this._onOptionsMaybeChanged();
        }
        getPositionFromDOMInfo(e, t) {
          const i = this._getViewLineDomNode(e);
          if (i === null) return null;
          const n = this._getLineNumberFor(i);
          if (n === -1 || n < 1 || n > this._context.viewModel.getLineCount()) return null;
          if (this._context.viewModel.getLineMaxColumn(n) === 1) return new X(n, 1);
          const o = this._visibleLines.getStartLineNumber(), r = this._visibleLines.getEndLineNumber();
          if (n < o || n > r) return null;
          let a = this._visibleLines.getVisibleLine(n).getColumnOfNodeOffset(e, t);
          const l = this._context.viewModel.getLineMinColumn(n);
          return a < l && (a = l), new X(n, a);
        }
        _getViewLineDomNode(e) {
          for (; e && e.nodeType === 1; ) {
            if (e.className === Tl.CLASS_NAME) return e;
            e = e.parentElement;
          }
          return null;
        }
        _getLineNumberFor(e) {
          const t = this._visibleLines.getStartLineNumber(), i = this._visibleLines.getEndLineNumber();
          for (let n = t; n <= i; n++) {
            const o = this._visibleLines.getVisibleLine(n);
            if (e === o.getDomNode()) return n;
          }
          return -1;
        }
        getLineWidth(e) {
          const t = this._visibleLines.getStartLineNumber(), i = this._visibleLines.getEndLineNumber();
          if (e < t || e > i) return -1;
          const n = new yx(this.domNode.domNode, this._textRangeRestingSpot), o = this._visibleLines.getVisibleLine(e).getWidth(n);
          return this._updateLineWidthsSlowIfDomDidLayout(n), o;
        }
        linesVisibleRangesForRange(e, t) {
          if (this.shouldRender()) return null;
          const i = e.endLineNumber, n = z.intersectRanges(e, this._lastRenderedData.getCurrentVisibleRange());
          if (!n) return null;
          const o = [];
          let r = 0;
          const a = new yx(this.domNode.domNode, this._textRangeRestingSpot);
          let l = 0;
          t && (l = this._context.viewModel.coordinatesConverter.convertViewPositionToModelPosition(new X(n.startLineNumber, 1)).lineNumber);
          const u = this._visibleLines.getStartLineNumber(), d = this._visibleLines.getEndLineNumber();
          for (let f = n.startLineNumber; f <= n.endLineNumber; f++) {
            if (f < u || f > d) continue;
            const m = f === n.startLineNumber ? n.startColumn : 1, _ = f !== n.endLineNumber, b = _ ? this._context.viewModel.getLineMaxColumn(f) : n.endColumn, v = this._visibleLines.getVisibleLine(f).getVisibleRangesForRange(f, m, b, a);
            if (v) {
              if (t && f < i) {
                const y = l;
                l = this._context.viewModel.coordinatesConverter.convertViewPositionToModelPosition(new X(f + 1, 1)).lineNumber, y !== l && (v.ranges[v.ranges.length - 1].width += this._typicalHalfwidthCharacterWidth);
              }
              o[r++] = new hle(v.outsideRenderedLine, f, Hw.from(v.ranges), _);
            }
          }
          return this._updateLineWidthsSlowIfDomDidLayout(a), r === 0 ? null : o;
        }
        _visibleRangesForLineRange(e, t, i) {
          if (this.shouldRender() || e < this._visibleLines.getStartLineNumber() || e > this._visibleLines.getEndLineNumber()) return null;
          const n = new yx(this.domNode.domNode, this._textRangeRestingSpot), o = this._visibleLines.getVisibleLine(e).getVisibleRangesForRange(e, t, i, n);
          return this._updateLineWidthsSlowIfDomDidLayout(n), o;
        }
        visibleRangeForPosition(e) {
          const t = this._visibleRangesForLineRange(e.lineNumber, e.column, e.column);
          return t ? new dle(t.outsideRenderedLine, t.ranges[0].left) : null;
        }
        _updateLineWidthsFast() {
          return this._updateLineWidths(true);
        }
        _updateLineWidthsSlow() {
          this._updateLineWidths(false);
        }
        _updateLineWidthsSlowIfDomDidLayout(e) {
          e.didDomLayout && (this._asyncUpdateLineWidths.isScheduled() || (this._asyncUpdateLineWidths.cancel(), this._updateLineWidthsSlow()));
        }
        _updateLineWidths(e) {
          const t = this._visibleLines.getStartLineNumber(), i = this._visibleLines.getEndLineNumber();
          let n = 1, o = true;
          for (let r = t; r <= i; r++) {
            const a = this._visibleLines.getVisibleLine(r);
            if (e && !a.getWidthIsFast()) {
              o = false;
              continue;
            }
            n = Math.max(n, a.getWidth(null));
          }
          return o && t === 1 && i === this._context.viewModel.getLineCount() && (this._maxLineWidth = 0), this._ensureMaxLineWidth(n), o;
        }
        _checkMonospaceFontAssumptions() {
          let e = -1, t = -1;
          const i = this._visibleLines.getStartLineNumber(), n = this._visibleLines.getEndLineNumber();
          for (let o = i; o <= n; o++) {
            const r = this._visibleLines.getVisibleLine(o);
            if (r.needsMonospaceFontCheck()) {
              const a = r.getWidth(null);
              a > t && (t = a, e = o);
            }
          }
          if (e !== -1 && !this._visibleLines.getVisibleLine(e).monospaceAssumptionsAreValid()) for (let o = i; o <= n; o++) this._visibleLines.getVisibleLine(o).onMonospaceAssumptionsInvalidated();
        }
        prepareRender() {
          throw new Error("Not supported");
        }
        render() {
          throw new Error("Not supported");
        }
        renderText(e) {
          if (this._visibleLines.renderLines(e), this._lastRenderedData.setCurrentVisibleRange(e.visibleRange), this.domNode.setWidth(this._context.viewLayout.getScrollWidth()), this.domNode.setHeight(Math.min(this._context.viewLayout.getScrollHeight(), 1e6)), this._horizontalRevealRequest) {
            const i = this._horizontalRevealRequest;
            if (e.startLineNumber <= i.minLineNumber && i.maxLineNumber <= e.endLineNumber) {
              this._horizontalRevealRequest = null, this.onDidRender();
              const n = this._computeScrollLeftToReveal(i);
              n && (this._isViewportWrapping || this._ensureMaxLineWidth(n.maxHorizontalOffset), this._context.viewModel.viewLayout.setScrollPosition({
                scrollLeft: n.scrollLeft
              }, i.scrollType));
            }
          }
          if (this._updateLineWidthsFast() ? this._asyncUpdateLineWidths.cancel() : this._asyncUpdateLineWidths.schedule(), Is && !this._asyncCheckMonospaceFontAssumptions.isScheduled()) {
            const i = this._visibleLines.getStartLineNumber(), n = this._visibleLines.getEndLineNumber();
            for (let o = i; o <= n; o++) if (this._visibleLines.getVisibleLine(o).needsMonospaceFontCheck()) {
              this._asyncCheckMonospaceFontAssumptions.schedule();
              break;
            }
          }
          this._linesContent.setLayerHinting(this._canUseLayerHinting), this._linesContent.setContain("strict");
          const t = this._context.viewLayout.getCurrentScrollTop() - e.bigNumbersDelta;
          this._linesContent.setTop(-t), this._linesContent.setLeft(-this._context.viewLayout.getCurrentScrollLeft());
        }
        _ensureMaxLineWidth(e) {
          const t = Math.ceil(e);
          this._maxLineWidth < t && (this._maxLineWidth = t, this._context.viewModel.viewLayout.setMaxLineWidth(this._maxLineWidth));
        }
        _computeScrollTopToRevealRange(e, t, i, n, o, r) {
          const a = e.top, l = e.height, u = a + l;
          let d, f, m;
          if (o && o.length > 0) {
            let x = o[0].startLineNumber, L = o[0].endLineNumber;
            for (let D = 1, k = o.length; D < k; D++) {
              const T = o[D];
              x = Math.min(x, T.startLineNumber), L = Math.max(L, T.endLineNumber);
            }
            d = false, f = this._context.viewLayout.getVerticalOffsetForLineNumber(x), m = this._context.viewLayout.getVerticalOffsetForLineNumber(L) + this._lineHeight;
          } else if (n) d = true, f = this._context.viewLayout.getVerticalOffsetForLineNumber(n.startLineNumber), m = this._context.viewLayout.getVerticalOffsetForLineNumber(n.endLineNumber) + this._lineHeight;
          else return -1;
          const _ = (t === "mouse" || i) && this._cursorSurroundingLinesStyle === "default";
          let b = 0, v = 0;
          if (_) i || (b = this._lineHeight);
          else {
            const x = l / this._lineHeight, L = Math.max(this._cursorSurroundingLines, this._stickyScrollEnabled ? this._maxNumberStickyLines : 0), D = Math.min(x / 2, L);
            b = D * this._lineHeight, v = Math.max(0, D - 1) * this._lineHeight;
          }
          i || (r === 0 || r === 4) && (v += this._lineHeight), f -= b, m += v;
          let y;
          if (m - f > l) {
            if (!d) return -1;
            y = f;
          } else if (r === 5 || r === 6) if (r === 6 && a <= f && m <= u) y = a;
          else {
            const x = Math.max(5 * this._lineHeight, l * 0.2), L = f - x, D = m - l;
            y = Math.max(D, L);
          }
          else if (r === 1 || r === 2) if (r === 2 && a <= f && m <= u) y = a;
          else {
            const x = (f + m) / 2;
            y = Math.max(0, x - l / 2);
          }
          else y = this._computeMinimumScrolling(a, u, f, m, r === 3, r === 4);
          return y;
        }
        _computeScrollLeftToReveal(e) {
          const t = this._context.viewLayout.getCurrentViewport(), i = this._context.configuration.options.get(146), n = t.left, o = n + t.width - i.verticalScrollbarWidth;
          let r = 1073741824, a = 0;
          if (e.type === "range") {
            const u = this._visibleRangesForLineRange(e.lineNumber, e.startColumn, e.endColumn);
            if (!u) return null;
            for (const d of u.ranges) r = Math.min(r, Math.round(d.left)), a = Math.max(a, Math.round(d.left + d.width));
          } else for (const u of e.selections) {
            if (u.startLineNumber !== u.endLineNumber) return null;
            const d = this._visibleRangesForLineRange(u.startLineNumber, u.startColumn, u.endColumn);
            if (!d) return null;
            for (const f of d.ranges) r = Math.min(r, Math.round(f.left)), a = Math.max(a, Math.round(f.left + f.width));
          }
          return e.minimalReveal || (r = Math.max(0, r - _sI.HORIZONTAL_EXTRA_PX), a += this._revealHorizontalRightPadding), e.type === "selections" && a - r > t.width ? null : {
            scrollLeft: this._computeMinimumScrolling(n, o, r, a),
            maxHorizontalOffset: a
          };
        }
        _computeMinimumScrolling(e, t, i, n, o, r) {
          e = e | 0, t = t | 0, i = i | 0, n = n | 0, o = !!o, r = !!r;
          const a = t - e;
          if (n - i < a) {
            if (o) return i;
            if (r) return Math.max(0, n - a);
            if (i < e) return i;
            if (n > t) return Math.max(0, n - a);
          } else return i;
          return e;
        }
      };
      _sI.HORIZONTAL_EXTRA_PX = 30;
      let sI = _sI;
      class Tce extends BF {
        constructor(e) {
          super(), this._context = e;
          const i = this._context.configuration.options.get(146);
          this._decorationsLeft = i.decorationsLeft, this._decorationsWidth = i.decorationsWidth, this._renderResult = null, this._context.addEventHandler(this);
        }
        dispose() {
          this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
        }
        onConfigurationChanged(e) {
          const i = this._context.configuration.options.get(146);
          return this._decorationsLeft = i.decorationsLeft, this._decorationsWidth = i.decorationsWidth, true;
        }
        onDecorationsChanged(e) {
          return true;
        }
        onFlushed(e) {
          return true;
        }
        onLinesChanged(e) {
          return true;
        }
        onLinesDeleted(e) {
          return true;
        }
        onLinesInserted(e) {
          return true;
        }
        onScrollChanged(e) {
          return e.scrollTopChanged;
        }
        onZonesChanged(e) {
          return true;
        }
        _getDecorations(e) {
          const t = e.getDecorationsInViewport(), i = [];
          let n = 0;
          for (let o = 0, r = t.length; o < r; o++) {
            const a = t[o], l = a.options.linesDecorationsClassName, u = a.options.zIndex;
            l && (i[n++] = new X2(a.range.startLineNumber, a.range.endLineNumber, l, a.options.linesDecorationsTooltip ?? null, u));
            const d = a.options.firstLineDecorationClassName;
            d && (i[n++] = new X2(a.range.startLineNumber, a.range.startLineNumber, d, a.options.linesDecorationsTooltip ?? null, u));
          }
          return i;
        }
        prepareRender(e) {
          const t = e.visibleRange.startLineNumber, i = e.visibleRange.endLineNumber, n = this._render(t, i, this._getDecorations(e)), o = this._decorationsLeft.toString(), r = this._decorationsWidth.toString(), a = '" style="left:' + o + "px;width:" + r + 'px;"></div>', l = [];
          for (let u = t; u <= i; u++) {
            const d = u - t, f = n[d].getDecorations();
            let m = "";
            for (const _ of f) {
              let b = '<div class="cldr ' + _.className;
              _.tooltip !== null && (b += '" title="' + _.tooltip), b += a, m += b;
            }
            l[d] = m;
          }
          this._renderResult = l;
        }
        render(e, t) {
          return this._renderResult ? this._renderResult[t - e] : "";
        }
      }
      class Nce extends BF {
        constructor(e) {
          super(), this._context = e, this._renderResult = null, this._context.addEventHandler(this);
        }
        dispose() {
          this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
        }
        onConfigurationChanged(e) {
          return true;
        }
        onDecorationsChanged(e) {
          return true;
        }
        onFlushed(e) {
          return true;
        }
        onLinesChanged(e) {
          return true;
        }
        onLinesDeleted(e) {
          return true;
        }
        onLinesInserted(e) {
          return true;
        }
        onScrollChanged(e) {
          return e.scrollTopChanged;
        }
        onZonesChanged(e) {
          return true;
        }
        _getDecorations(e) {
          const t = e.getDecorationsInViewport(), i = [];
          let n = 0;
          for (let o = 0, r = t.length; o < r; o++) {
            const a = t[o], l = a.options.marginClassName, u = a.options.zIndex;
            l && (i[n++] = new X2(a.range.startLineNumber, a.range.endLineNumber, l, null, u));
          }
          return i;
        }
        prepareRender(e) {
          const t = e.visibleRange.startLineNumber, i = e.visibleRange.endLineNumber, n = this._render(t, i, this._getDecorations(e)), o = [];
          for (let r = t; r <= i; r++) {
            const a = r - t, l = n[a].getDecorations();
            let u = "";
            for (const d of l) u += '<div class="cmdr ' + d.className + '" style=""></div>';
            o[a] = u;
          }
          this._renderResult = o;
        }
        render(e, t) {
          return this._renderResult ? this._renderResult[t - e] : "";
        }
      }
      const _Oo = class _Oo {
        constructor(e, t, i, n) {
          this._rgba8Brand = void 0, this.r = _Oo._clamp(e), this.g = _Oo._clamp(t), this.b = _Oo._clamp(i), this.a = _Oo._clamp(n);
        }
        equals(e) {
          return this.r === e.r && this.g === e.g && this.b === e.b && this.a === e.a;
        }
        static _clamp(e) {
          return e < 0 ? 0 : e > 255 ? 255 : e | 0;
        }
      };
      _Oo.Empty = new _Oo(0, 0, 0, 0);
      let Oo = _Oo;
      const _qw = class _qw extends he {
        static getInstance() {
          return this._INSTANCE || (this._INSTANCE = new _qw()), this._INSTANCE;
        }
        constructor() {
          super(), this._onDidChange = new G(), this.onDidChange = this._onDidChange.event, this._updateColorMap(), this._register(Bi.onDidChange((e) => {
            e.changedColorMap && this._updateColorMap();
          }));
        }
        _updateColorMap() {
          const e = Bi.getColorMap();
          if (!e) {
            this._colors = [
              Oo.Empty
            ], this._backgroundIsLight = true;
            return;
          }
          this._colors = [
            Oo.Empty
          ];
          for (let i = 1; i < e.length; i++) {
            const n = e[i].rgba;
            this._colors[i] = new Oo(n.r, n.g, n.b, Math.round(n.a * 255));
          }
          const t = e[2].getRelativeLuminance();
          this._backgroundIsLight = t >= 0.5, this._onDidChange.fire(void 0);
        }
        getColor(e) {
          return (e < 1 || e >= this._colors.length) && (e = 2), this._colors[e];
        }
        backgroundIsLight() {
          return this._backgroundIsLight;
        }
      };
      _qw._INSTANCE = null;
      let qw = _qw;
      const Ice = (() => {
        const s = [];
        for (let e = 32; e <= 126; e++) s.push(e);
        return s.push(65533), s;
      })(), Mce = (s, e) => (s -= 32, s < 0 || s > 96 ? e <= 2 ? (s + 96) % 96 : 95 : s);
      class D_ {
        constructor(e, t) {
          this.scale = t, this._minimapCharRendererBrand = void 0, this.charDataNormal = D_.soften(e, 12 / 15), this.charDataLight = D_.soften(e, 50 / 60);
        }
        static soften(e, t) {
          const i = new Uint8ClampedArray(e.length);
          for (let n = 0, o = e.length; n < o; n++) i[n] = uv(e[n] * t);
          return i;
        }
        renderChar(e, t, i, n, o, r, a, l, u, d, f) {
          const m = 1 * this.scale, _ = 2 * this.scale, b = f ? 1 : _;
          if (t + m > e.width || i + b > e.height) {
            console.warn("bad render request outside image data");
            return;
          }
          const v = d ? this.charDataLight : this.charDataNormal, y = Mce(n, u), x = e.width * 4, L = a.r, D = a.g, k = a.b, T = o.r - L, M = o.g - D, I = o.b - k, R = Math.max(r, l), A = e.data;
          let Y = y * m * _, U = i * x + t * 4;
          for (let j = 0; j < b; j++) {
            let ee = U;
            for (let K = 0; K < m; K++) {
              const te = v[Y++] / 255 * (r / 255);
              A[ee++] = L + T * te, A[ee++] = D + M * te, A[ee++] = k + I * te, A[ee++] = R;
            }
            U += x;
          }
        }
        blockRenderChar(e, t, i, n, o, r, a, l) {
          const u = 1 * this.scale, d = 2 * this.scale, f = l ? 1 : d;
          if (t + u > e.width || i + f > e.height) {
            console.warn("bad render request outside image data");
            return;
          }
          const m = e.width * 4, _ = 0.5 * (o / 255), b = r.r, v = r.g, y = r.b, x = n.r - b, L = n.g - v, D = n.b - y, k = b + x * _, T = v + L * _, M = y + D * _, I = Math.max(o, a), R = e.data;
          let A = i * m + t * 4;
          for (let Y = 0; Y < f; Y++) {
            let U = A;
            for (let j = 0; j < u; j++) R[U++] = k, R[U++] = T, R[U++] = M, R[U++] = I;
            A += m;
          }
        }
      }
      const z3 = {
        0: 0,
        1: 1,
        2: 2,
        3: 3,
        4: 4,
        5: 5,
        6: 6,
        7: 7,
        8: 8,
        9: 9,
        A: 10,
        B: 11,
        C: 12,
        D: 13,
        E: 14,
        F: 15
      }, U3 = (s) => {
        const e = new Uint8ClampedArray(s.length / 2);
        for (let t = 0; t < s.length; t += 2) e[t >> 1] = z3[s[t]] << 4 | z3[s[t + 1]] & 15;
        return e;
      }, $3 = {
        1: tg(() => U3("0000511D6300CF609C709645A78432005642574171487021003C451900274D35D762755E8B629C5BA856AF57BA649530C167D1512A272A3F6038604460398526BCA2A968DB6F8957C768BE5FBE2FB467CF5D8D5B795DC7625B5DFF50DE64C466DB2FC47CD860A65E9A2EB96CB54CE06DA763AB2EA26860524D3763536601005116008177A8705E53AB738E6A982F88BAA35B5F5B626D9C636B449B737E5B7B678598869A662F6B5B8542706C704C80736A607578685B70594A49715A4522E792")),
        2: tg(() => U3("000000000000000055394F383D2800008B8B1F210002000081B1CBCBCC820000847AAF6B9AAF2119BE08B8881AD60000A44FD07DCCF107015338130C00000000385972265F390B406E2437634B4B48031B12B8A0847000001E15B29A402F0000000000004B33460B00007A752C2A0000000000004D3900000084394B82013400ABA5CFC7AD9C0302A45A3E5A98AB000089A43382D97900008BA54AA087A70A0248A6A7AE6DBE0000BF6F94987EA40A01A06DCFA7A7A9030496C32F77891D0000A99FB1A0AFA80603B29AB9CA75930D010C0948354D3900000C0948354F37460D0028BE673D8400000000AF9D7B6E00002B007AA8933400007AA642675C2700007984CFB9C3985B768772A8A6B7B20000CAAECAAFC4B700009F94A6009F840009D09F9BA4CA9C0000CC8FC76DC87F0000C991C472A2000000A894A48CA7B501079BA2C9C69BA20000B19A5D3FA89000005CA6009DA2960901B0A7F0669FB200009D009E00B7890000DAD0F5D092820000D294D4C48BD10000B5A7A4A3B1A50402CAB6CBA6A2000000B5A7A4A3B1A8044FCDADD19D9CB00000B7778F7B8AAE0803C9AB5D3F5D3F00009EA09EA0BAB006039EA0989A8C7900009B9EF4D6B7C00000A9A7816CACA80000ABAC84705D3F000096DA635CDC8C00006F486F266F263D4784006124097B00374F6D2D6D2D6D4A3A95872322000000030000000000008D8939130000000000002E22A5C9CBC70600AB25C0B5C9B400061A2DB04CA67001082AA6BEBEBFC606002321DACBC19E03087AA08B6768380000282FBAC0B8CA7A88AD25BBA5A29900004C396C5894A6000040485A6E356E9442A32CD17EADA70000B4237923628600003E2DE9C1D7B500002F25BBA5A2990000231DB6AFB4A804023025C0B5CAB588062B2CBDBEC0C706882435A75CA20000002326BD6A82A908048B4B9A5A668000002423A09CB4BB060025259C9D8A7900001C1FCAB2C7C700002A2A9387ABA200002626A4A47D6E9D14333163A0C87500004B6F9C2D643A257049364936493647358A34438355497F1A0000A24C1D590000D38DFFBDD4CD3126"))
      };
      class Bp {
        static create(e, t) {
          if (this.lastCreated && e === this.lastCreated.scale && t === this.lastFontFamily) return this.lastCreated;
          let i;
          return $3[e] ? i = new D_($3[e](), e) : i = Bp.createFromSampleData(Bp.createSampleData(t).data, e), this.lastFontFamily = t, this.lastCreated = i, i;
        }
        static createSampleData(e) {
          const t = document.createElement("canvas"), i = t.getContext("2d");
          t.style.height = "16px", t.height = 16, t.width = 96 * 10, t.style.width = 96 * 10 + "px", i.fillStyle = "#ffffff", i.font = `bold 16px ${e}`, i.textBaseline = "middle";
          let n = 0;
          for (const o of Ice) i.fillText(String.fromCharCode(o), n, 16 / 2), n += 10;
          return i.getImageData(0, 0, 96 * 10, 16);
        }
        static createFromSampleData(e, t) {
          if (e.length !== 61440) throw new Error("Unexpected source in MinimapCharRenderer");
          const n = Bp._downsample(e, t);
          return new D_(n, t);
        }
        static _downsampleChar(e, t, i, n, o) {
          const r = 1 * o, a = 2 * o;
          let l = n, u = 0;
          for (let d = 0; d < a; d++) {
            const f = d / a * 16, m = (d + 1) / a * 16;
            for (let _ = 0; _ < r; _++) {
              const b = _ / r * 10, v = (_ + 1) / r * 10;
              let y = 0, x = 0;
              for (let D = f; D < m; D++) {
                const k = t + Math.floor(D) * 3840, T = 1 - (D - Math.floor(D));
                for (let M = b; M < v; M++) {
                  const I = 1 - (M - Math.floor(M)), R = k + Math.floor(M) * 4, A = I * T;
                  x += A, y += e[R] * e[R + 3] / 255 * A;
                }
              }
              const L = y / x;
              u = Math.max(u, L), i[l++] = uv(L);
            }
          }
          return u;
        }
        static _downsample(e, t) {
          const i = 2 * t * 1 * t, n = i * 96, o = new Uint8ClampedArray(n);
          let r = 0, a = 0, l = 0;
          for (let u = 0; u < 96; u++) l = Math.max(l, this._downsampleChar(e, a, o, r, t)), r += i, a += 10 * 4;
          if (l > 0) {
            const u = 255 / l;
            for (let d = 0; d < n; d++) o[d] *= u;
          }
          return o;
        }
      }
      const Ace = Ks ? '"Segoe WPC", "Segoe UI", sans-serif' : _t ? "-apple-system, BlinkMacSystemFont, sans-serif" : 'system-ui, "Ubuntu", "Droid Sans", sans-serif', Rce = 140, Oce = 2;
      class Xf {
        constructor(e, t, i) {
          const n = e.options, o = n.get(144), r = n.get(146), a = r.minimap, l = n.get(50), u = n.get(73);
          this.renderMinimap = a.renderMinimap, this.size = u.size, this.minimapHeightIsEditorHeight = a.minimapHeightIsEditorHeight, this.scrollBeyondLastLine = n.get(106), this.paddingTop = n.get(84).top, this.paddingBottom = n.get(84).bottom, this.showSlider = u.showSlider, this.autohide = u.autohide, this.pixelRatio = o, this.typicalHalfwidthCharacterWidth = l.typicalHalfwidthCharacterWidth, this.lineHeight = n.get(67), this.minimapLeft = a.minimapLeft, this.minimapWidth = a.minimapWidth, this.minimapHeight = r.height, this.canvasInnerWidth = a.minimapCanvasInnerWidth, this.canvasInnerHeight = a.minimapCanvasInnerHeight, this.canvasOuterWidth = a.minimapCanvasOuterWidth, this.canvasOuterHeight = a.minimapCanvasOuterHeight, this.isSampling = a.minimapIsSampling, this.editorHeight = r.height, this.fontScale = a.minimapScale, this.minimapLineHeight = a.minimapLineHeight, this.minimapCharWidth = 1 * this.fontScale, this.sectionHeaderFontFamily = Ace, this.sectionHeaderFontSize = u.sectionHeaderFontSize * o, this.sectionHeaderLetterSpacing = u.sectionHeaderLetterSpacing, this.sectionHeaderFontColor = Xf._getSectionHeaderColor(t, i.getColor(1)), this.charRenderer = tg(() => Bp.create(this.fontScale, l.fontFamily)), this.defaultBackgroundColor = i.getColor(2), this.backgroundColor = Xf._getMinimapBackground(t, this.defaultBackgroundColor), this.foregroundAlpha = Xf._getMinimapForegroundOpacity(t);
        }
        static _getMinimapBackground(e, t) {
          const i = e.getColor(tQ);
          return i ? new Oo(i.rgba.r, i.rgba.g, i.rgba.b, Math.round(255 * i.rgba.a)) : t;
        }
        static _getMinimapForegroundOpacity(e) {
          const t = e.getColor(iQ);
          return t ? Oo._clamp(Math.round(255 * t.rgba.a)) : 255;
        }
        static _getSectionHeaderColor(e, t) {
          const i = e.getColor(G_);
          return i ? new Oo(i.rgba.r, i.rgba.g, i.rgba.b, Math.round(255 * i.rgba.a)) : t;
        }
        equals(e) {
          return this.renderMinimap === e.renderMinimap && this.size === e.size && this.minimapHeightIsEditorHeight === e.minimapHeightIsEditorHeight && this.scrollBeyondLastLine === e.scrollBeyondLastLine && this.paddingTop === e.paddingTop && this.paddingBottom === e.paddingBottom && this.showSlider === e.showSlider && this.autohide === e.autohide && this.pixelRatio === e.pixelRatio && this.typicalHalfwidthCharacterWidth === e.typicalHalfwidthCharacterWidth && this.lineHeight === e.lineHeight && this.minimapLeft === e.minimapLeft && this.minimapWidth === e.minimapWidth && this.minimapHeight === e.minimapHeight && this.canvasInnerWidth === e.canvasInnerWidth && this.canvasInnerHeight === e.canvasInnerHeight && this.canvasOuterWidth === e.canvasOuterWidth && this.canvasOuterHeight === e.canvasOuterHeight && this.isSampling === e.isSampling && this.editorHeight === e.editorHeight && this.fontScale === e.fontScale && this.minimapLineHeight === e.minimapLineHeight && this.minimapCharWidth === e.minimapCharWidth && this.sectionHeaderFontSize === e.sectionHeaderFontSize && this.sectionHeaderLetterSpacing === e.sectionHeaderLetterSpacing && this.defaultBackgroundColor && this.defaultBackgroundColor.equals(e.defaultBackgroundColor) && this.backgroundColor && this.backgroundColor.equals(e.backgroundColor) && this.foregroundAlpha === e.foregroundAlpha;
        }
      }
      class Fp {
        constructor(e, t, i, n, o, r, a, l, u) {
          this.scrollTop = e, this.scrollHeight = t, this.sliderNeeded = i, this._computedSliderRatio = n, this.sliderTop = o, this.sliderHeight = r, this.topPaddingLineCount = a, this.startLineNumber = l, this.endLineNumber = u;
        }
        getDesiredScrollTopFromDelta(e) {
          return Math.round(this.scrollTop + e / this._computedSliderRatio);
        }
        getDesiredScrollTopFromTouchLocation(e) {
          return Math.round((e - this.sliderHeight / 2) / this._computedSliderRatio);
        }
        intersectWithViewport(e) {
          const t = Math.max(this.startLineNumber, e.startLineNumber), i = Math.min(this.endLineNumber, e.endLineNumber);
          return t > i ? null : [
            t,
            i
          ];
        }
        getYForLineNumber(e, t) {
          return +(e - this.startLineNumber + this.topPaddingLineCount) * t;
        }
        static create(e, t, i, n, o, r, a, l, u, d, f) {
          const m = e.pixelRatio, _ = e.minimapLineHeight, b = Math.floor(e.canvasInnerHeight / _), v = e.lineHeight;
          if (e.minimapHeightIsEditorHeight) {
            let M = l * e.lineHeight + e.paddingTop + e.paddingBottom;
            e.scrollBeyondLastLine && (M += Math.max(0, o - e.lineHeight - e.paddingBottom));
            const I = Math.max(1, Math.floor(o * o / M)), R = Math.max(0, e.minimapHeight - I), A = R / (d - o), Y = u * A, U = R > 0, j = Math.floor(e.canvasInnerHeight / e.minimapLineHeight), ee = Math.floor(e.paddingTop / e.lineHeight);
            return new Fp(u, d, U, A, Y, I, ee, 1, Math.min(a, j));
          }
          let y;
          if (r && i !== a) {
            const M = i - t + 1;
            y = Math.floor(M * _ / m);
          } else {
            const M = o / v;
            y = Math.floor(M * _ / m);
          }
          const x = Math.floor(e.paddingTop / v);
          let L = Math.floor(e.paddingBottom / v);
          if (e.scrollBeyondLastLine) {
            const M = o / v;
            L = Math.max(L, M - 1);
          }
          let D;
          if (L > 0) {
            const M = o / v;
            D = (x + a + L - M - 1) * _ / m;
          } else D = Math.max(0, (x + a) * _ / m - y);
          D = Math.min(e.minimapHeight - y, D);
          const k = D / (d - o), T = u * k;
          if (b >= x + a + L) {
            const M = D > 0;
            return new Fp(u, d, M, k, T, y, x, 1, a);
          } else {
            let M;
            t > 1 ? M = t + x : M = Math.max(1, u / v);
            let I, R = Math.max(1, Math.floor(M - T * m / _));
            R < x ? (I = x - R + 1, R = 1) : (I = 0, R = Math.max(1, R - x)), f && f.scrollHeight === d && (f.scrollTop > u && (R = Math.min(R, f.startLineNumber), I = Math.max(I, f.topPaddingLineCount)), f.scrollTop < u && (R = Math.max(R, f.startLineNumber), I = Math.min(I, f.topPaddingLineCount)));
            const A = Math.min(a, R - I + b - 1), Y = (u - n) / v;
            let U;
            return u >= e.paddingTop ? U = (t - R + I + Y) * _ / m : U = u / e.paddingTop * (I + Y) * _ / m, new Fp(u, d, true, k, U, y, I, R, A);
          }
        }
      }
      const _Kw = class _Kw {
        constructor(e) {
          this.dy = e;
        }
        onContentChanged() {
          this.dy = -1;
        }
        onTokensChanged() {
          this.dy = -1;
        }
      };
      _Kw.INVALID = new _Kw(-1);
      let Kw = _Kw;
      class q3 {
        constructor(e, t, i) {
          this.renderedLayout = e, this._imageData = t, this._renderedLines = new AF({
            createLine: () => Kw.INVALID
          }), this._renderedLines._set(e.startLineNumber, i);
        }
        linesEquals(e) {
          if (!this.scrollEquals(e)) return false;
          const i = this._renderedLines._get().lines;
          for (let n = 0, o = i.length; n < o; n++) if (i[n].dy === -1) return false;
          return true;
        }
        scrollEquals(e) {
          return this.renderedLayout.startLineNumber === e.startLineNumber && this.renderedLayout.endLineNumber === e.endLineNumber;
        }
        _get() {
          const e = this._renderedLines._get();
          return {
            imageData: this._imageData,
            rendLineNumberStart: e.rendLineNumberStart,
            lines: e.lines
          };
        }
        onLinesChanged(e, t) {
          return this._renderedLines.onLinesChanged(e, t);
        }
        onLinesDeleted(e, t) {
          this._renderedLines.onLinesDeleted(e, t);
        }
        onLinesInserted(e, t) {
          this._renderedLines.onLinesInserted(e, t);
        }
        onTokensChanged(e) {
          return this._renderedLines.onTokensChanged(e);
        }
      }
      class oI {
        constructor(e, t, i, n) {
          this._backgroundFillData = oI._createBackgroundFillData(t, i, n), this._buffers = [
            e.createImageData(t, i),
            e.createImageData(t, i)
          ], this._lastUsedBuffer = 0;
        }
        getBuffer() {
          this._lastUsedBuffer = 1 - this._lastUsedBuffer;
          const e = this._buffers[this._lastUsedBuffer];
          return e.data.set(this._backgroundFillData), e;
        }
        static _createBackgroundFillData(e, t, i) {
          const n = i.r, o = i.g, r = i.b, a = i.a, l = new Uint8ClampedArray(e * t * 4);
          let u = 0;
          for (let d = 0; d < t; d++) for (let f = 0; f < e; f++) l[u] = n, l[u + 1] = o, l[u + 2] = r, l[u + 3] = a, u += 4;
          return l;
        }
      }
      class E_ {
        static compute(e, t, i) {
          if (e.renderMinimap === 0 || !e.isSampling) return [
            null,
            []
          ];
          const { minimapLineCount: n } = Nf.computeContainedMinimapLineCount({
            viewLineCount: t,
            scrollBeyondLastLine: e.scrollBeyondLastLine,
            paddingTop: e.paddingTop,
            paddingBottom: e.paddingBottom,
            height: e.editorHeight,
            lineHeight: e.lineHeight,
            pixelRatio: e.pixelRatio
          }), o = t / n, r = o / 2;
          if (!i || i.minimapLines.length === 0) {
            const y = [];
            if (y[0] = 1, n > 1) {
              for (let x = 0, L = n - 1; x < L; x++) y[x] = Math.round(x * o + r);
              y[n - 1] = t;
            }
            return [
              new E_(o, y),
              []
            ];
          }
          const a = i.minimapLines, l = a.length, u = [];
          let d = 0, f = 0, m = 1;
          const _ = 10;
          let b = [], v = null;
          for (let y = 0; y < n; y++) {
            const x = Math.max(m, Math.round(y * o)), L = Math.max(x, Math.round((y + 1) * o));
            for (; d < l && a[d] < x; ) {
              if (b.length < _) {
                const k = d + 1 + f;
                v && v.type === "deleted" && v._oldIndex === d - 1 ? v.deleteToLineNumber++ : (v = {
                  type: "deleted",
                  _oldIndex: d,
                  deleteFromLineNumber: k,
                  deleteToLineNumber: k
                }, b.push(v)), f--;
              }
              d++;
            }
            let D;
            if (d < l && a[d] <= L) D = a[d], d++;
            else if (y === 0 ? D = 1 : y + 1 === n ? D = t : D = Math.round(y * o + r), b.length < _) {
              const k = d + 1 + f;
              v && v.type === "inserted" && v._i === y - 1 ? v.insertToLineNumber++ : (v = {
                type: "inserted",
                _i: y,
                insertFromLineNumber: k,
                insertToLineNumber: k
              }, b.push(v)), f++;
            }
            u[y] = D, m = D;
          }
          if (b.length < _) for (; d < l; ) {
            const y = d + 1 + f;
            v && v.type === "deleted" && v._oldIndex === d - 1 ? v.deleteToLineNumber++ : (v = {
              type: "deleted",
              _oldIndex: d,
              deleteFromLineNumber: y,
              deleteToLineNumber: y
            }, b.push(v)), f--, d++;
          }
          else b = [
            {
              type: "flush"
            }
          ];
          return [
            new E_(o, u),
            b
          ];
        }
        constructor(e, t) {
          this.samplingRatio = e, this.minimapLines = t;
        }
        modelLineToMinimapLine(e) {
          return Math.min(this.minimapLines.length, Math.max(1, Math.round(e / this.samplingRatio)));
        }
        modelLineRangeToMinimapLineRange(e, t) {
          let i = this.modelLineToMinimapLine(e) - 1;
          for (; i > 0 && this.minimapLines[i - 1] >= e; ) i--;
          let n = this.modelLineToMinimapLine(t) - 1;
          for (; n + 1 < this.minimapLines.length && this.minimapLines[n + 1] <= t; ) n++;
          if (i === n) {
            const o = this.minimapLines[i];
            if (o < e || o > t) return null;
          }
          return [
            i + 1,
            n + 1
          ];
        }
        decorationLineRangeToMinimapLineRange(e, t) {
          let i = this.modelLineToMinimapLine(e), n = this.modelLineToMinimapLine(t);
          return e !== t && n === i && (n === this.minimapLines.length ? i > 1 && i-- : n++), [
            i,
            n
          ];
        }
        onLinesDeleted(e) {
          const t = e.toLineNumber - e.fromLineNumber + 1;
          let i = this.minimapLines.length, n = 0;
          for (let o = this.minimapLines.length - 1; o >= 0 && !(this.minimapLines[o] < e.fromLineNumber); o--) this.minimapLines[o] <= e.toLineNumber ? (this.minimapLines[o] = Math.max(1, e.fromLineNumber - 1), i = Math.min(i, o), n = Math.max(n, o)) : this.minimapLines[o] -= t;
          return [
            i,
            n
          ];
        }
        onLinesInserted(e) {
          const t = e.toLineNumber - e.fromLineNumber + 1;
          for (let i = this.minimapLines.length - 1; i >= 0 && !(this.minimapLines[i] < e.fromLineNumber); i--) this.minimapLines[i] += t;
        }
      }
      class Pce extends Zs {
        constructor(e) {
          super(e), this._sectionHeaderCache = new K_(10, 1.5), this.tokensColorTracker = qw.getInstance(), this._selections = [], this._minimapSelections = null, this.options = new Xf(this._context.configuration, this._context.theme, this.tokensColorTracker);
          const [t] = E_.compute(this.options, this._context.viewModel.getLineCount(), null);
          this._samplingState = t, this._shouldCheckSampling = false, this._actual = new Df(e.theme, this);
        }
        dispose() {
          this._actual.dispose(), super.dispose();
        }
        getDomNode() {
          return this._actual.getDomNode();
        }
        _onOptionsMaybeChanged() {
          const e = new Xf(this._context.configuration, this._context.theme, this.tokensColorTracker);
          return this.options.equals(e) ? false : (this.options = e, this._recreateLineSampling(), this._actual.onDidChangeOptions(), true);
        }
        onConfigurationChanged(e) {
          return this._onOptionsMaybeChanged();
        }
        onCursorStateChanged(e) {
          return this._selections = e.selections, this._minimapSelections = null, this._actual.onSelectionChanged();
        }
        onDecorationsChanged(e) {
          return e.affectsMinimap ? this._actual.onDecorationsChanged() : false;
        }
        onFlushed(e) {
          return this._samplingState && (this._shouldCheckSampling = true), this._actual.onFlushed();
        }
        onLinesChanged(e) {
          if (this._samplingState) {
            const t = this._samplingState.modelLineRangeToMinimapLineRange(e.fromLineNumber, e.fromLineNumber + e.count - 1);
            return t ? this._actual.onLinesChanged(t[0], t[1] - t[0] + 1) : false;
          } else return this._actual.onLinesChanged(e.fromLineNumber, e.count);
        }
        onLinesDeleted(e) {
          if (this._samplingState) {
            const [t, i] = this._samplingState.onLinesDeleted(e);
            return t <= i && this._actual.onLinesChanged(t + 1, i - t + 1), this._shouldCheckSampling = true, true;
          } else return this._actual.onLinesDeleted(e.fromLineNumber, e.toLineNumber);
        }
        onLinesInserted(e) {
          return this._samplingState ? (this._samplingState.onLinesInserted(e), this._shouldCheckSampling = true, true) : this._actual.onLinesInserted(e.fromLineNumber, e.toLineNumber);
        }
        onScrollChanged(e) {
          return this._actual.onScrollChanged();
        }
        onThemeChanged(e) {
          return this._actual.onThemeChanged(), this._onOptionsMaybeChanged(), true;
        }
        onTokensChanged(e) {
          if (this._samplingState) {
            const t = [];
            for (const i of e.ranges) {
              const n = this._samplingState.modelLineRangeToMinimapLineRange(i.fromLineNumber, i.toLineNumber);
              n && t.push({
                fromLineNumber: n[0],
                toLineNumber: n[1]
              });
            }
            return t.length ? this._actual.onTokensChanged(t) : false;
          } else return this._actual.onTokensChanged(e.ranges);
        }
        onTokensColorsChanged(e) {
          return this._onOptionsMaybeChanged(), this._actual.onTokensColorsChanged();
        }
        onZonesChanged(e) {
          return this._actual.onZonesChanged();
        }
        prepareRender(e) {
          this._shouldCheckSampling && (this._shouldCheckSampling = false, this._recreateLineSampling());
        }
        render(e) {
          let t = e.visibleRange.startLineNumber, i = e.visibleRange.endLineNumber;
          this._samplingState && (t = this._samplingState.modelLineToMinimapLine(t), i = this._samplingState.modelLineToMinimapLine(i));
          const n = {
            viewportContainsWhitespaceGaps: e.viewportData.whitespaceViewportData.length > 0,
            scrollWidth: e.scrollWidth,
            scrollHeight: e.scrollHeight,
            viewportStartLineNumber: t,
            viewportEndLineNumber: i,
            viewportStartLineNumberVerticalOffset: e.getVerticalOffsetForLineNumber(t),
            scrollTop: e.scrollTop,
            scrollLeft: e.scrollLeft,
            viewportWidth: e.viewportWidth,
            viewportHeight: e.viewportHeight
          };
          this._actual.render(n);
        }
        _recreateLineSampling() {
          this._minimapSelections = null;
          const e = !!this._samplingState, [t, i] = E_.compute(this.options, this._context.viewModel.getLineCount(), this._samplingState);
          if (this._samplingState = t, e && this._samplingState) for (const n of i) switch (n.type) {
            case "deleted":
              this._actual.onLinesDeleted(n.deleteFromLineNumber, n.deleteToLineNumber);
              break;
            case "inserted":
              this._actual.onLinesInserted(n.insertFromLineNumber, n.insertToLineNumber);
              break;
            case "flush":
              this._actual.onFlushed();
              break;
          }
        }
        getLineCount() {
          return this._samplingState ? this._samplingState.minimapLines.length : this._context.viewModel.getLineCount();
        }
        getRealLineCount() {
          return this._context.viewModel.getLineCount();
        }
        getLineContent(e) {
          return this._samplingState ? this._context.viewModel.getLineContent(this._samplingState.minimapLines[e - 1]) : this._context.viewModel.getLineContent(e);
        }
        getLineMaxColumn(e) {
          return this._samplingState ? this._context.viewModel.getLineMaxColumn(this._samplingState.minimapLines[e - 1]) : this._context.viewModel.getLineMaxColumn(e);
        }
        getMinimapLinesRenderingData(e, t, i) {
          if (this._samplingState) {
            const n = [];
            for (let o = 0, r = t - e + 1; o < r; o++) i[o] ? n[o] = this._context.viewModel.getViewLineData(this._samplingState.minimapLines[e + o - 1]) : n[o] = null;
            return n;
          }
          return this._context.viewModel.getMinimapLinesRenderingData(e, t, i).data;
        }
        getSelections() {
          if (this._minimapSelections === null) if (this._samplingState) {
            this._minimapSelections = [];
            for (const e of this._selections) {
              const [t, i] = this._samplingState.decorationLineRangeToMinimapLineRange(e.startLineNumber, e.endLineNumber);
              this._minimapSelections.push(new mt(t, e.startColumn, i, e.endColumn));
            }
          } else this._minimapSelections = this._selections;
          return this._minimapSelections;
        }
        getMinimapDecorationsInViewport(e, t) {
          const i = this._getMinimapDecorationsInViewport(e, t).filter((n) => {
            var _a3;
            return !((_a3 = n.options.minimap) == null ? void 0 : _a3.sectionHeaderStyle);
          });
          if (this._samplingState) {
            const n = [];
            for (const o of i) {
              if (!o.options.minimap) continue;
              const r = o.range, a = this._samplingState.modelLineToMinimapLine(r.startLineNumber), l = this._samplingState.modelLineToMinimapLine(r.endLineNumber);
              n.push(new vF(new z(a, r.startColumn, l, r.endColumn), o.options));
            }
            return n;
          }
          return i;
        }
        getSectionHeaderDecorationsInViewport(e, t) {
          const i = this.options.minimapLineHeight, o = this.options.sectionHeaderFontSize / i;
          return e = Math.floor(Math.max(1, e - o)), this._getMinimapDecorationsInViewport(e, t).filter((r) => {
            var _a3;
            return !!((_a3 = r.options.minimap) == null ? void 0 : _a3.sectionHeaderStyle);
          });
        }
        _getMinimapDecorationsInViewport(e, t) {
          let i;
          if (this._samplingState) {
            const n = this._samplingState.minimapLines[e - 1], o = this._samplingState.minimapLines[t - 1];
            i = new z(n, 1, o, this._context.viewModel.getLineMaxColumn(o));
          } else i = new z(e, 1, t, this._context.viewModel.getLineMaxColumn(t));
          return this._context.viewModel.getMinimapDecorationsInRange(i);
        }
        getSectionHeaderText(e, t) {
          var _a3;
          const i = (_a3 = e.options.minimap) == null ? void 0 : _a3.sectionHeaderText;
          if (!i) return null;
          const n = this._sectionHeaderCache.get(i);
          if (n) return n;
          const o = t(i);
          return this._sectionHeaderCache.set(i, o), o;
        }
        getOptions() {
          return this._context.viewModel.model.getOptions();
        }
        revealLineNumber(e) {
          this._samplingState && (e = this._samplingState.minimapLines[e - 1]), this._context.viewModel.revealRange("mouse", false, new z(e, 1, e, 1), 1, 0);
        }
        setScrollTop(e) {
          this._context.viewModel.viewLayout.setScrollPosition({
            scrollTop: e
          }, 1);
        }
      }
      class Df extends he {
        constructor(e, t) {
          super(), this._renderDecorations = false, this._gestureInProgress = false, this._theme = e, this._model = t, this._lastRenderData = null, this._buffers = null, this._selectionColor = this._theme.getColor(D5), this._domNode = St(document.createElement("div")), Yr.write(this._domNode, 9), this._domNode.setClassName(this._getMinimapDomNodeClassName()), this._domNode.setPosition("absolute"), this._domNode.setAttribute("role", "presentation"), this._domNode.setAttribute("aria-hidden", "true"), this._shadow = St(document.createElement("div")), this._shadow.setClassName("minimap-shadow-hidden"), this._domNode.appendChild(this._shadow), this._canvas = St(document.createElement("canvas")), this._canvas.setPosition("absolute"), this._canvas.setLeft(0), this._domNode.appendChild(this._canvas), this._decorationsCanvas = St(document.createElement("canvas")), this._decorationsCanvas.setPosition("absolute"), this._decorationsCanvas.setClassName("minimap-decorations-layer"), this._decorationsCanvas.setLeft(0), this._domNode.appendChild(this._decorationsCanvas), this._slider = St(document.createElement("div")), this._slider.setPosition("absolute"), this._slider.setClassName("minimap-slider"), this._slider.setLayerHinting(true), this._slider.setContain("strict"), this._domNode.appendChild(this._slider), this._sliderHorizontal = St(document.createElement("div")), this._sliderHorizontal.setPosition("absolute"), this._sliderHorizontal.setClassName("minimap-slider-horizontal"), this._slider.appendChild(this._sliderHorizontal), this._applyLayout(), this._pointerDownListener = ln(this._domNode.domNode, Ce.POINTER_DOWN, (i) => {
            if (i.preventDefault(), this._model.options.renderMinimap === 0 || !this._lastRenderData) return;
            if (this._model.options.size !== "proportional") {
              if (i.button === 0 && this._lastRenderData) {
                const u = Bo(this._slider.domNode), d = u.top + u.height / 2;
                this._startSliderDragging(i, d, this._lastRenderData.renderedLayout);
              }
              return;
            }
            const o = this._model.options.minimapLineHeight, r = this._model.options.canvasInnerHeight / this._model.options.canvasOuterHeight * i.offsetY;
            let l = Math.floor(r / o) + this._lastRenderData.renderedLayout.startLineNumber - this._lastRenderData.renderedLayout.topPaddingLineCount;
            l = Math.min(l, this._model.getLineCount()), this._model.revealLineNumber(l);
          }), this._sliderPointerMoveMonitor = new uw(), this._sliderPointerDownListener = ln(this._slider.domNode, Ce.POINTER_DOWN, (i) => {
            i.preventDefault(), i.stopPropagation(), i.button === 0 && this._lastRenderData && this._startSliderDragging(i, i.pageY, this._lastRenderData.renderedLayout);
          }), this._gestureDisposable = ui.addTarget(this._domNode.domNode), this._sliderTouchStartListener = re(this._domNode.domNode, Qt.Start, (i) => {
            i.preventDefault(), i.stopPropagation(), this._lastRenderData && (this._slider.toggleClassName("active", true), this._gestureInProgress = true, this.scrollDueToTouchEvent(i));
          }, {
            passive: false
          }), this._sliderTouchMoveListener = re(this._domNode.domNode, Qt.Change, (i) => {
            i.preventDefault(), i.stopPropagation(), this._lastRenderData && this._gestureInProgress && this.scrollDueToTouchEvent(i);
          }, {
            passive: false
          }), this._sliderTouchEndListener = ln(this._domNode.domNode, Qt.End, (i) => {
            i.preventDefault(), i.stopPropagation(), this._gestureInProgress = false, this._slider.toggleClassName("active", false);
          });
        }
        _startSliderDragging(e, t, i) {
          if (!e.target || !(e.target instanceof Element)) return;
          const n = e.pageX;
          this._slider.toggleClassName("active", true);
          const o = (r, a) => {
            const l = Bo(this._domNode.domNode), u = Math.min(Math.abs(a - n), Math.abs(a - l.left), Math.abs(a - l.left - l.width));
            if (Ks && u > Rce) {
              this._model.setScrollTop(i.scrollTop);
              return;
            }
            const d = r - t;
            this._model.setScrollTop(i.getDesiredScrollTopFromDelta(d));
          };
          e.pageY !== t && o(e.pageY, n), this._sliderPointerMoveMonitor.startMonitoring(e.target, e.pointerId, e.buttons, (r) => o(r.pageY, r.pageX), () => {
            this._slider.toggleClassName("active", false);
          });
        }
        scrollDueToTouchEvent(e) {
          const t = this._domNode.domNode.getBoundingClientRect().top, i = this._lastRenderData.renderedLayout.getDesiredScrollTopFromTouchLocation(e.pageY - t);
          this._model.setScrollTop(i);
        }
        dispose() {
          this._pointerDownListener.dispose(), this._sliderPointerMoveMonitor.dispose(), this._sliderPointerDownListener.dispose(), this._gestureDisposable.dispose(), this._sliderTouchStartListener.dispose(), this._sliderTouchMoveListener.dispose(), this._sliderTouchEndListener.dispose(), super.dispose();
        }
        _getMinimapDomNodeClassName() {
          const e = [
            "minimap"
          ];
          return this._model.options.showSlider === "always" ? e.push("slider-always") : e.push("slider-mouseover"), this._model.options.autohide && e.push("autohide"), e.join(" ");
        }
        getDomNode() {
          return this._domNode;
        }
        _applyLayout() {
          this._domNode.setLeft(this._model.options.minimapLeft), this._domNode.setWidth(this._model.options.minimapWidth), this._domNode.setHeight(this._model.options.minimapHeight), this._shadow.setHeight(this._model.options.minimapHeight), this._canvas.setWidth(this._model.options.canvasOuterWidth), this._canvas.setHeight(this._model.options.canvasOuterHeight), this._canvas.domNode.width = this._model.options.canvasInnerWidth, this._canvas.domNode.height = this._model.options.canvasInnerHeight, this._decorationsCanvas.setWidth(this._model.options.canvasOuterWidth), this._decorationsCanvas.setHeight(this._model.options.canvasOuterHeight), this._decorationsCanvas.domNode.width = this._model.options.canvasInnerWidth, this._decorationsCanvas.domNode.height = this._model.options.canvasInnerHeight, this._slider.setWidth(this._model.options.minimapWidth);
        }
        _getBuffer() {
          return this._buffers || this._model.options.canvasInnerWidth > 0 && this._model.options.canvasInnerHeight > 0 && (this._buffers = new oI(this._canvas.domNode.getContext("2d"), this._model.options.canvasInnerWidth, this._model.options.canvasInnerHeight, this._model.options.backgroundColor)), this._buffers ? this._buffers.getBuffer() : null;
        }
        onDidChangeOptions() {
          this._lastRenderData = null, this._buffers = null, this._applyLayout(), this._domNode.setClassName(this._getMinimapDomNodeClassName());
        }
        onSelectionChanged() {
          return this._renderDecorations = true, true;
        }
        onDecorationsChanged() {
          return this._renderDecorations = true, true;
        }
        onFlushed() {
          return this._lastRenderData = null, true;
        }
        onLinesChanged(e, t) {
          return this._lastRenderData ? this._lastRenderData.onLinesChanged(e, t) : false;
        }
        onLinesDeleted(e, t) {
          var _a3;
          return (_a3 = this._lastRenderData) == null ? void 0 : _a3.onLinesDeleted(e, t), true;
        }
        onLinesInserted(e, t) {
          var _a3;
          return (_a3 = this._lastRenderData) == null ? void 0 : _a3.onLinesInserted(e, t), true;
        }
        onScrollChanged() {
          return this._renderDecorations = true, true;
        }
        onThemeChanged() {
          return this._selectionColor = this._theme.getColor(D5), this._renderDecorations = true, true;
        }
        onTokensChanged(e) {
          return this._lastRenderData ? this._lastRenderData.onTokensChanged(e) : false;
        }
        onTokensColorsChanged() {
          return this._lastRenderData = null, this._buffers = null, true;
        }
        onZonesChanged() {
          return this._lastRenderData = null, true;
        }
        render(e) {
          if (this._model.options.renderMinimap === 0) {
            this._shadow.setClassName("minimap-shadow-hidden"), this._sliderHorizontal.setWidth(0), this._sliderHorizontal.setHeight(0);
            return;
          }
          e.scrollLeft + e.viewportWidth >= e.scrollWidth ? this._shadow.setClassName("minimap-shadow-hidden") : this._shadow.setClassName("minimap-shadow-visible");
          const i = Fp.create(this._model.options, e.viewportStartLineNumber, e.viewportEndLineNumber, e.viewportStartLineNumberVerticalOffset, e.viewportHeight, e.viewportContainsWhitespaceGaps, this._model.getLineCount(), this._model.getRealLineCount(), e.scrollTop, e.scrollHeight, this._lastRenderData ? this._lastRenderData.renderedLayout : null);
          this._slider.setDisplay(i.sliderNeeded ? "block" : "none"), this._slider.setTop(i.sliderTop), this._slider.setHeight(i.sliderHeight), this._sliderHorizontal.setLeft(0), this._sliderHorizontal.setWidth(this._model.options.minimapWidth), this._sliderHorizontal.setTop(0), this._sliderHorizontal.setHeight(i.sliderHeight), this.renderDecorations(i), this._lastRenderData = this.renderLines(i);
        }
        renderDecorations(e) {
          if (this._renderDecorations) {
            this._renderDecorations = false;
            const t = this._model.getSelections();
            t.sort(z.compareRangesUsingStarts);
            const i = this._model.getMinimapDecorationsInViewport(e.startLineNumber, e.endLineNumber);
            i.sort((m, _) => (m.options.zIndex || 0) - (_.options.zIndex || 0));
            const { canvasInnerWidth: n, canvasInnerHeight: o } = this._model.options, r = this._model.options.minimapLineHeight, a = this._model.options.minimapCharWidth, l = this._model.getOptions().tabSize, u = this._decorationsCanvas.domNode.getContext("2d");
            u.clearRect(0, 0, n, o);
            const d = new K3(e.startLineNumber, e.endLineNumber, false);
            this._renderSelectionLineHighlights(u, t, d, e, r), this._renderDecorationsLineHighlights(u, i, d, e, r);
            const f = new K3(e.startLineNumber, e.endLineNumber, null);
            this._renderSelectionsHighlights(u, t, f, e, r, l, a, n), this._renderDecorationsHighlights(u, i, f, e, r, l, a, n), this._renderSectionHeaders(e);
          }
        }
        _renderSelectionLineHighlights(e, t, i, n, o) {
          if (!this._selectionColor || this._selectionColor.isTransparent()) return;
          e.fillStyle = this._selectionColor.transparent(0.5).toString();
          let r = 0, a = 0;
          for (const l of t) {
            const u = n.intersectWithViewport(l);
            if (!u) continue;
            const [d, f] = u;
            for (let b = d; b <= f; b++) i.set(b, true);
            const m = n.getYForLineNumber(d, o), _ = n.getYForLineNumber(f, o);
            a >= m || (a > r && e.fillRect(ma, r, e.canvas.width, a - r), r = m), a = _;
          }
          a > r && e.fillRect(ma, r, e.canvas.width, a - r);
        }
        _renderDecorationsLineHighlights(e, t, i, n, o) {
          const r = /* @__PURE__ */ new Map();
          for (let a = t.length - 1; a >= 0; a--) {
            const l = t[a], u = l.options.minimap;
            if (!u || u.position !== 1) continue;
            const d = n.intersectWithViewport(l.range);
            if (!d) continue;
            const [f, m] = d, _ = u.getColor(this._theme.value);
            if (!_ || _.isTransparent()) continue;
            let b = r.get(_.toString());
            b || (b = _.transparent(0.5).toString(), r.set(_.toString(), b)), e.fillStyle = b;
            for (let v = f; v <= m; v++) {
              if (i.has(v)) continue;
              i.set(v, true);
              const y = n.getYForLineNumber(f, o);
              e.fillRect(ma, y, e.canvas.width, o);
            }
          }
        }
        _renderSelectionsHighlights(e, t, i, n, o, r, a, l) {
          if (!(!this._selectionColor || this._selectionColor.isTransparent())) for (const u of t) {
            const d = n.intersectWithViewport(u);
            if (!d) continue;
            const [f, m] = d;
            for (let _ = f; _ <= m; _++) this.renderDecorationOnLine(e, i, u, this._selectionColor, n, _, o, o, r, a, l);
          }
        }
        _renderDecorationsHighlights(e, t, i, n, o, r, a, l) {
          for (const u of t) {
            const d = u.options.minimap;
            if (!d) continue;
            const f = n.intersectWithViewport(u.range);
            if (!f) continue;
            const [m, _] = f, b = d.getColor(this._theme.value);
            if (!(!b || b.isTransparent())) for (let v = m; v <= _; v++) switch (d.position) {
              case 1:
                this.renderDecorationOnLine(e, i, u.range, b, n, v, o, o, r, a, l);
                continue;
              case 2: {
                const y = n.getYForLineNumber(v, o);
                this.renderDecoration(e, b, 2, y, Oce, o);
                continue;
              }
            }
          }
        }
        renderDecorationOnLine(e, t, i, n, o, r, a, l, u, d, f) {
          const m = o.getYForLineNumber(r, l);
          if (m + a < 0 || m > this._model.options.canvasInnerHeight) return;
          const { startLineNumber: _, endLineNumber: b } = i, v = _ === r ? i.startColumn : 1, y = b === r ? i.endColumn : this._model.getLineMaxColumn(r), x = this.getXOffsetForPosition(t, r, v, u, d, f), L = this.getXOffsetForPosition(t, r, y, u, d, f);
          this.renderDecoration(e, n, x, m, L - x, a);
        }
        getXOffsetForPosition(e, t, i, n, o, r) {
          if (i === 1) return ma;
          if ((i - 1) * o >= r) return r;
          let l = e.get(t);
          if (!l) {
            const u = this._model.getLineContent(t);
            l = [
              ma
            ];
            let d = ma;
            for (let f = 1; f < u.length + 1; f++) {
              const m = u.charCodeAt(f - 1), _ = m === 9 ? n * o : nu(m) ? 2 * o : o, b = d + _;
              if (b >= r) {
                l[f] = r;
                break;
              }
              l[f] = b, d = b;
            }
            e.set(t, l);
          }
          return i - 1 < l.length ? l[i - 1] : r;
        }
        renderDecoration(e, t, i, n, o, r) {
          e.fillStyle = t && t.toString() || "", e.fillRect(i, n, o, r);
        }
        _renderSectionHeaders(e) {
          var _a3;
          const t = this._model.options.minimapLineHeight, i = this._model.options.sectionHeaderFontSize, n = this._model.options.sectionHeaderLetterSpacing, o = i * 1.5, { canvasInnerWidth: r } = this._model.options, a = this._model.options.backgroundColor, l = `rgb(${a.r} ${a.g} ${a.b} / .7)`, u = this._model.options.sectionHeaderFontColor, d = `rgb(${u.r} ${u.g} ${u.b})`, f = d, m = this._decorationsCanvas.domNode.getContext("2d");
          m.letterSpacing = n + "px", m.font = "500 " + i + "px " + this._model.options.sectionHeaderFontFamily, m.strokeStyle = f, m.lineWidth = 0.2;
          const _ = this._model.getSectionHeaderDecorationsInViewport(e.startLineNumber, e.endLineNumber);
          _.sort((v, y) => v.range.startLineNumber - y.range.startLineNumber);
          const b = Df._fitSectionHeader.bind(null, m, r - ma);
          for (const v of _) {
            const y = e.getYForLineNumber(v.range.startLineNumber, t) + i, x = y - i, L = x + 2, D = this._model.getSectionHeaderText(v, b);
            Df._renderSectionLabel(m, D, ((_a3 = v.options.minimap) == null ? void 0 : _a3.sectionHeaderStyle) === 2, l, d, r, x, o, y, L);
          }
        }
        static _fitSectionHeader(e, t, i) {
          if (!i) return i;
          const n = "\u2026", o = e.measureText(i).width, r = e.measureText(n).width;
          if (o <= t || o <= r) return i;
          const a = i.length, l = o / i.length, u = Math.floor((t - r) / l) - 1;
          let d = Math.ceil(u / 2);
          for (; d > 0 && /\s/.test(i[d - 1]); ) --d;
          return i.substring(0, d) + n + i.substring(a - (u - d));
        }
        static _renderSectionLabel(e, t, i, n, o, r, a, l, u, d) {
          t && (e.fillStyle = n, e.fillRect(0, a, r, l), e.fillStyle = o, e.fillText(t, ma, u)), i && (e.beginPath(), e.moveTo(0, d), e.lineTo(r, d), e.closePath(), e.stroke());
        }
        renderLines(e) {
          const t = e.startLineNumber, i = e.endLineNumber, n = this._model.options.minimapLineHeight;
          if (this._lastRenderData && this._lastRenderData.linesEquals(e)) {
            const te = this._lastRenderData._get();
            return new q3(e, te.imageData, te.lines);
          }
          const o = this._getBuffer();
          if (!o) return null;
          const [r, a, l] = Df._renderUntouchedLines(o, e.topPaddingLineCount, t, i, n, this._lastRenderData), u = this._model.getMinimapLinesRenderingData(t, i, l), d = this._model.getOptions().tabSize, f = this._model.options.defaultBackgroundColor, m = this._model.options.backgroundColor, _ = this._model.options.foregroundAlpha, b = this._model.tokensColorTracker, v = b.backgroundIsLight(), y = this._model.options.renderMinimap, x = this._model.options.charRenderer(), L = this._model.options.fontScale, D = this._model.options.minimapCharWidth, T = (y === 1 ? 2 : 3) * L, M = n > T ? Math.floor((n - T) / 2) : 0, I = m.a / 255, R = new Oo(Math.round((m.r - f.r) * I + f.r), Math.round((m.g - f.g) * I + f.g), Math.round((m.b - f.b) * I + f.b), 255);
          let A = e.topPaddingLineCount * n;
          const Y = [];
          for (let te = 0, H = i - t + 1; te < H; te++) l[te] && Df._renderLine(o, R, m.a, v, y, D, b, _, x, A, M, d, u[te], L, n), Y[te] = new Kw(A), A += n;
          const U = r === -1 ? 0 : r, ee = (a === -1 ? o.height : a) - U;
          return this._canvas.domNode.getContext("2d").putImageData(o, 0, 0, 0, U, o.width, ee), new q3(e, o, Y);
        }
        static _renderUntouchedLines(e, t, i, n, o, r) {
          const a = [];
          if (!r) {
            for (let A = 0, Y = n - i + 1; A < Y; A++) a[A] = true;
            return [
              -1,
              -1,
              a
            ];
          }
          const l = r._get(), u = l.imageData.data, d = l.rendLineNumberStart, f = l.lines, m = f.length, _ = e.width, b = e.data, v = (n - i + 1) * o * _ * 4;
          let y = -1, x = -1, L = -1, D = -1, k = -1, T = -1, M = t * o;
          for (let A = i; A <= n; A++) {
            const Y = A - i, U = A - d, j = U >= 0 && U < m ? f[U].dy : -1;
            if (j === -1) {
              a[Y] = true, M += o;
              continue;
            }
            const ee = j * _ * 4, K = (j + o) * _ * 4, te = M * _ * 4, H = (M + o) * _ * 4;
            D === ee && T === te ? (D = K, T = H) : (L !== -1 && (b.set(u.subarray(L, D), k), y === -1 && L === 0 && L === k && (y = D), x === -1 && D === v && L === k && (x = L)), L = ee, D = K, k = te, T = H), a[Y] = false, M += o;
          }
          L !== -1 && (b.set(u.subarray(L, D), k), y === -1 && L === 0 && L === k && (y = D), x === -1 && D === v && L === k && (x = L));
          const I = y === -1 ? -1 : y / (_ * 4), R = x === -1 ? -1 : x / (_ * 4);
          return [
            I,
            R,
            a
          ];
        }
        static _renderLine(e, t, i, n, o, r, a, l, u, d, f, m, _, b, v) {
          const y = _.content, x = _.tokens, L = e.width - r, D = v === 1;
          let k = ma, T = 0, M = 0;
          for (let I = 0, R = x.getCount(); I < R; I++) {
            const A = x.getEndOffset(I), Y = x.getForeground(I), U = a.getColor(Y);
            for (; T < A; T++) {
              if (k > L) return;
              const j = y.charCodeAt(T);
              if (j === 9) {
                const ee = m - (T + M) % m;
                M += ee - 1, k += ee * r;
              } else if (j === 32) k += r;
              else {
                const ee = nu(j) ? 2 : 1;
                for (let K = 0; K < ee; K++) if (o === 2 ? u.blockRenderChar(e, k, d + f, U, l, t, i, D) : u.renderChar(e, k, d + f, j, U, l, t, i, b, n, D), k += r, k > L) return;
              }
            }
          }
        }
      }
      class K3 {
        constructor(e, t, i) {
          this._startLineNumber = e, this._endLineNumber = t, this._defaultValue = i, this._values = [];
          for (let n = 0, o = this._endLineNumber - this._startLineNumber + 1; n < o; n++) this._values[n] = i;
        }
        has(e) {
          return this.get(e) !== this._defaultValue;
        }
        set(e, t) {
          e < this._startLineNumber || e > this._endLineNumber || (this._values[e - this._startLineNumber] = t);
        }
        get(e) {
          return e < this._startLineNumber || e > this._endLineNumber ? this._defaultValue : this._values[e - this._startLineNumber];
        }
      }
      class Bce extends Zs {
        constructor(e, t) {
          super(e), this._viewDomNode = t;
          const n = this._context.configuration.options.get(146);
          this._widgets = {}, this._verticalScrollbarWidth = n.verticalScrollbarWidth, this._minimapWidth = n.minimap.minimapWidth, this._horizontalScrollbarHeight = n.horizontalScrollbarHeight, this._editorHeight = n.height, this._editorWidth = n.width, this._viewDomNodeRect = {
            top: 0,
            left: 0,
            width: 0,
            height: 0
          }, this._domNode = St(document.createElement("div")), Yr.write(this._domNode, 4), this._domNode.setClassName("overlayWidgets"), this.overflowingOverlayWidgetsDomNode = St(document.createElement("div")), Yr.write(this.overflowingOverlayWidgetsDomNode, 5), this.overflowingOverlayWidgetsDomNode.setClassName("overflowingOverlayWidgets");
        }
        dispose() {
          super.dispose(), this._widgets = {};
        }
        getDomNode() {
          return this._domNode;
        }
        onConfigurationChanged(e) {
          const i = this._context.configuration.options.get(146);
          return this._verticalScrollbarWidth = i.verticalScrollbarWidth, this._minimapWidth = i.minimap.minimapWidth, this._horizontalScrollbarHeight = i.horizontalScrollbarHeight, this._editorHeight = i.height, this._editorWidth = i.width, true;
        }
        addWidget(e) {
          const t = St(e.getDomNode());
          this._widgets[e.getId()] = {
            widget: e,
            preference: null,
            domNode: t
          }, t.setPosition("absolute"), t.setAttribute("widgetId", e.getId()), e.allowEditorOverflow ? this.overflowingOverlayWidgetsDomNode.appendChild(t) : this._domNode.appendChild(t), this.setShouldRender(), this._updateMaxMinWidth();
        }
        setWidgetPosition(e, t) {
          const i = this._widgets[e.getId()], n = t ? t.preference : null, o = t == null ? void 0 : t.stackOridinal;
          return i.preference === n && i.stack === o ? (this._updateMaxMinWidth(), false) : (i.preference = n, i.stack = o, this.setShouldRender(), this._updateMaxMinWidth(), true);
        }
        removeWidget(e) {
          const t = e.getId();
          if (this._widgets.hasOwnProperty(t)) {
            const n = this._widgets[t].domNode.domNode;
            delete this._widgets[t], n.remove(), this.setShouldRender(), this._updateMaxMinWidth();
          }
        }
        _updateMaxMinWidth() {
          var _a3, _b3;
          let e = 0;
          const t = Object.keys(this._widgets);
          for (let i = 0, n = t.length; i < n; i++) {
            const o = t[i], a = (_b3 = (_a3 = this._widgets[o].widget).getMinContentWidthInPx) == null ? void 0 : _b3.call(_a3);
            typeof a < "u" && (e = Math.max(e, a));
          }
          this._context.viewLayout.setOverlayWidgetsMinWidth(e);
        }
        _renderWidget(e, t) {
          const i = e.domNode;
          if (e.preference === null) {
            i.setTop("");
            return;
          }
          const n = 2 * this._verticalScrollbarWidth + this._minimapWidth;
          if (e.preference === 0 || e.preference === 1) {
            if (e.preference === 1) {
              const o = i.domNode.clientHeight;
              i.setTop(this._editorHeight - o - 2 * this._horizontalScrollbarHeight);
            } else i.setTop(0);
            e.stack !== void 0 ? (i.setTop(t[e.preference]), t[e.preference] += i.domNode.clientWidth) : i.setRight(n);
          } else if (e.preference === 2) i.domNode.style.right = "50%", e.stack !== void 0 ? (i.setTop(t[2]), t[2] += i.domNode.clientHeight) : i.setTop(0);
          else {
            const { top: o, left: r } = e.preference;
            if (this._context.configuration.options.get(42) && e.widget.allowEditorOverflow) {
              const l = this._viewDomNodeRect;
              i.setTop(o + l.top), i.setLeft(r + l.left), i.setPosition("fixed");
            } else i.setTop(o), i.setLeft(r), i.setPosition("absolute");
          }
        }
        prepareRender(e) {
          this._viewDomNodeRect = Bo(this._viewDomNode.domNode);
        }
        render(e) {
          this._domNode.setWidth(this._editorWidth);
          const t = Object.keys(this._widgets), i = Array.from({
            length: 3
          }, () => 0);
          t.sort((n, o) => (this._widgets[n].stack || 0) - (this._widgets[o].stack || 0));
          for (let n = 0, o = t.length; n < o; n++) {
            const r = t[n];
            this._renderWidget(this._widgets[r], i);
          }
        }
      }
      class Fce {
        constructor(e, t) {
          const i = e.options;
          this.lineHeight = i.get(67), this.pixelRatio = i.get(144), this.overviewRulerLanes = i.get(83), this.renderBorder = i.get(82);
          const n = t.getColor(Cie);
          this.borderColor = n ? n.toString() : null, this.hideCursor = i.get(59);
          const o = t.getColor(xw);
          this.cursorColorSingle = o ? o.transparent(0.7).toString() : null;
          const r = t.getColor(aB);
          this.cursorColorPrimary = r ? r.transparent(0.7).toString() : null;
          const a = t.getColor(lB);
          this.cursorColorSecondary = a ? a.transparent(0.7).toString() : null, this.themeType = t.type;
          const l = i.get(73), u = l.enabled, d = l.side, f = t.getColor(wie), m = Bi.getDefaultBackground();
          f ? this.backgroundColor = f : u && d === "right" ? this.backgroundColor = m : this.backgroundColor = null;
          const b = i.get(146).overviewRuler;
          this.top = b.top, this.right = b.right, this.domWidth = b.width, this.domHeight = b.height, this.overviewRulerLanes === 0 ? (this.canvasWidth = 0, this.canvasHeight = 0) : (this.canvasWidth = this.domWidth * this.pixelRatio | 0, this.canvasHeight = this.domHeight * this.pixelRatio | 0);
          const [v, y] = this._initLanes(1, this.canvasWidth, this.overviewRulerLanes);
          this.x = v, this.w = y;
        }
        _initLanes(e, t, i) {
          const n = t - e;
          if (i >= 3) {
            const o = Math.floor(n / 3), r = Math.floor(n / 3), a = n - o - r, l = e, u = l + o, d = l + o + a;
            return [
              [
                0,
                l,
                u,
                l,
                d,
                l,
                u,
                l
              ],
              [
                0,
                o,
                a,
                o + a,
                r,
                o + a + r,
                a + r,
                o + a + r
              ]
            ];
          } else if (i === 2) {
            const o = Math.floor(n / 2), r = n - o, a = e, l = a + o;
            return [
              [
                0,
                a,
                a,
                a,
                l,
                a,
                a,
                a
              ],
              [
                0,
                o,
                o,
                o,
                r,
                o + r,
                o + r,
                o + r
              ]
            ];
          } else {
            const o = e, r = n;
            return [
              [
                0,
                o,
                o,
                o,
                o,
                o,
                o,
                o
              ],
              [
                0,
                r,
                r,
                r,
                r,
                r,
                r,
                r
              ]
            ];
          }
        }
        equals(e) {
          return this.lineHeight === e.lineHeight && this.pixelRatio === e.pixelRatio && this.overviewRulerLanes === e.overviewRulerLanes && this.renderBorder === e.renderBorder && this.borderColor === e.borderColor && this.hideCursor === e.hideCursor && this.cursorColorSingle === e.cursorColorSingle && this.cursorColorPrimary === e.cursorColorPrimary && this.cursorColorSecondary === e.cursorColorSecondary && this.themeType === e.themeType && le.equals(this.backgroundColor, e.backgroundColor) && this.top === e.top && this.right === e.right && this.domWidth === e.domWidth && this.domHeight === e.domHeight && this.canvasWidth === e.canvasWidth && this.canvasHeight === e.canvasHeight;
        }
      }
      class Vce extends Zs {
        constructor(e) {
          super(e), this._actualShouldRender = 0, this._renderedDecorations = [], this._renderedCursorPositions = [], this._domNode = St(document.createElement("canvas")), this._domNode.setClassName("decorationsOverviewRuler"), this._domNode.setPosition("absolute"), this._domNode.setLayerHinting(true), this._domNode.setContain("strict"), this._domNode.setAttribute("aria-hidden", "true"), this._updateSettings(false), this._tokensColorTrackerListener = Bi.onDidChange((t) => {
            t.changedColorMap && this._updateSettings(true);
          }), this._cursorPositions = [
            {
              position: new X(1, 1),
              color: this._settings.cursorColorSingle
            }
          ];
        }
        dispose() {
          super.dispose(), this._tokensColorTrackerListener.dispose();
        }
        _updateSettings(e) {
          const t = new Fce(this._context.configuration, this._context.theme);
          return this._settings && this._settings.equals(t) ? false : (this._settings = t, this._domNode.setTop(this._settings.top), this._domNode.setRight(this._settings.right), this._domNode.setWidth(this._settings.domWidth), this._domNode.setHeight(this._settings.domHeight), this._domNode.domNode.width = this._settings.canvasWidth, this._domNode.domNode.height = this._settings.canvasHeight, e && this._render(), true);
        }
        _markRenderingIsNeeded() {
          return this._actualShouldRender = 2, true;
        }
        _markRenderingIsMaybeNeeded() {
          return this._actualShouldRender = 1, true;
        }
        onConfigurationChanged(e) {
          return this._updateSettings(false) ? this._markRenderingIsNeeded() : false;
        }
        onCursorStateChanged(e) {
          this._cursorPositions = [];
          for (let t = 0, i = e.selections.length; t < i; t++) {
            let n = this._settings.cursorColorSingle;
            i > 1 && (n = t === 0 ? this._settings.cursorColorPrimary : this._settings.cursorColorSecondary), this._cursorPositions.push({
              position: e.selections[t].getPosition(),
              color: n
            });
          }
          return this._cursorPositions.sort((t, i) => X.compare(t.position, i.position)), this._markRenderingIsMaybeNeeded();
        }
        onDecorationsChanged(e) {
          return e.affectsOverviewRuler ? this._markRenderingIsMaybeNeeded() : false;
        }
        onFlushed(e) {
          return this._markRenderingIsNeeded();
        }
        onScrollChanged(e) {
          return e.scrollHeightChanged ? this._markRenderingIsNeeded() : false;
        }
        onZonesChanged(e) {
          return this._markRenderingIsNeeded();
        }
        onThemeChanged(e) {
          return this._updateSettings(false) ? this._markRenderingIsNeeded() : false;
        }
        getDomNode() {
          return this._domNode.domNode;
        }
        prepareRender(e) {
        }
        render(e) {
          this._render(), this._actualShouldRender = 0;
        }
        _render() {
          const e = this._settings.backgroundColor;
          if (this._settings.overviewRulerLanes === 0) {
            this._domNode.setBackgroundColor(e ? le.Format.CSS.formatHexA(e) : ""), this._domNode.setDisplay("none");
            return;
          }
          const t = this._context.viewModel.getAllOverviewRulerDecorations(this._context.theme);
          if (t.sort(y_.compareByRenderingProps), this._actualShouldRender === 1 && !y_.equalsArr(this._renderedDecorations, t) && (this._actualShouldRender = 2), this._actualShouldRender === 1 && !Qi(this._renderedCursorPositions, this._cursorPositions, (b, v) => b.position.lineNumber === v.position.lineNumber && b.color === v.color) && (this._actualShouldRender = 2), this._actualShouldRender === 1) return;
          this._renderedDecorations = t, this._renderedCursorPositions = this._cursorPositions, this._domNode.setDisplay("block");
          const i = this._settings.canvasWidth, n = this._settings.canvasHeight, o = this._settings.lineHeight, r = this._context.viewLayout, a = this._context.viewLayout.getScrollHeight(), l = n / a, u = 6 * this._settings.pixelRatio | 0, d = u / 2 | 0, f = this._domNode.domNode.getContext("2d");
          e ? e.isOpaque() ? (f.fillStyle = le.Format.CSS.formatHexA(e), f.fillRect(0, 0, i, n)) : (f.clearRect(0, 0, i, n), f.fillStyle = le.Format.CSS.formatHexA(e), f.fillRect(0, 0, i, n)) : f.clearRect(0, 0, i, n);
          const m = this._settings.x, _ = this._settings.w;
          for (const b of t) {
            const v = b.color, y = b.data;
            f.fillStyle = v;
            let x = 0, L = 0, D = 0;
            for (let k = 0, T = y.length / 3; k < T; k++) {
              const M = y[3 * k], I = y[3 * k + 1], R = y[3 * k + 2];
              let A = r.getVerticalOffsetForLineNumber(I) * l | 0, Y = (r.getVerticalOffsetForLineNumber(R) + o) * l | 0;
              if (Y - A < u) {
                let j = (A + Y) / 2 | 0;
                j < d ? j = d : j + d > n && (j = n - d), A = j - d, Y = j + d;
              }
              A > D + 1 || M !== x ? (k !== 0 && f.fillRect(m[x], L, _[x], D - L), x = M, L = A, D = Y) : Y > D && (D = Y);
            }
            f.fillRect(m[x], L, _[x], D - L);
          }
          if (!this._settings.hideCursor) {
            const b = 2 * this._settings.pixelRatio | 0, v = b / 2 | 0, y = this._settings.x[7], x = this._settings.w[7];
            let L = -100, D = -100, k = null;
            for (let T = 0, M = this._cursorPositions.length; T < M; T++) {
              const I = this._cursorPositions[T].color;
              if (!I) continue;
              const R = this._cursorPositions[T].position;
              let A = r.getVerticalOffsetForLineNumber(R.lineNumber) * l | 0;
              A < v ? A = v : A + v > n && (A = n - v);
              const Y = A - v, U = Y + b;
              Y > D + 1 || I !== k ? (T !== 0 && k && f.fillRect(y, L, x, D - L), L = Y, D = U) : U > D && (D = U), k = I, f.fillStyle = I;
            }
            k && f.fillRect(y, L, x, D - L);
          }
          this._settings.renderBorder && this._settings.borderColor && this._settings.overviewRulerLanes > 0 && (f.beginPath(), f.lineWidth = 1, f.strokeStyle = this._settings.borderColor, f.moveTo(0, 0), f.lineTo(0, n), f.moveTo(1, 0), f.lineTo(i, 0), f.stroke());
        }
      }
      class j3 {
        constructor(e, t, i) {
          this._colorZoneBrand = void 0, this.from = e | 0, this.to = t | 0, this.colorId = i | 0;
        }
        static compare(e, t) {
          return e.colorId === t.colorId ? e.from === t.from ? e.to - t.to : e.from - t.from : e.colorId - t.colorId;
        }
      }
      class FF {
        constructor(e, t, i, n) {
          this._overviewRulerZoneBrand = void 0, this.startLineNumber = e, this.endLineNumber = t, this.heightInLines = i, this.color = n, this._colorZone = null;
        }
        static compare(e, t) {
          return e.color === t.color ? e.startLineNumber === t.startLineNumber ? e.heightInLines === t.heightInLines ? e.endLineNumber - t.endLineNumber : e.heightInLines - t.heightInLines : e.startLineNumber - t.startLineNumber : e.color < t.color ? -1 : 1;
        }
        setColorZone(e) {
          this._colorZone = e;
        }
        getColorZones() {
          return this._colorZone;
        }
      }
      class Wce {
        constructor(e) {
          this._getVerticalOffsetForLine = e, this._zones = [], this._colorZonesInvalid = false, this._lineHeight = 0, this._domWidth = 0, this._domHeight = 0, this._outerHeight = 0, this._pixelRatio = 1, this._lastAssignedId = 0, this._color2Id = /* @__PURE__ */ Object.create(null), this._id2Color = [];
        }
        getId2Color() {
          return this._id2Color;
        }
        setZones(e) {
          this._zones = e, this._zones.sort(FF.compare);
        }
        setLineHeight(e) {
          return this._lineHeight === e ? false : (this._lineHeight = e, this._colorZonesInvalid = true, true);
        }
        setPixelRatio(e) {
          this._pixelRatio = e, this._colorZonesInvalid = true;
        }
        getDOMWidth() {
          return this._domWidth;
        }
        getCanvasWidth() {
          return this._domWidth * this._pixelRatio;
        }
        setDOMWidth(e) {
          return this._domWidth === e ? false : (this._domWidth = e, this._colorZonesInvalid = true, true);
        }
        getDOMHeight() {
          return this._domHeight;
        }
        getCanvasHeight() {
          return this._domHeight * this._pixelRatio;
        }
        setDOMHeight(e) {
          return this._domHeight === e ? false : (this._domHeight = e, this._colorZonesInvalid = true, true);
        }
        getOuterHeight() {
          return this._outerHeight;
        }
        setOuterHeight(e) {
          return this._outerHeight === e ? false : (this._outerHeight = e, this._colorZonesInvalid = true, true);
        }
        resolveColorZones() {
          const e = this._colorZonesInvalid, t = Math.floor(this._lineHeight), i = Math.floor(this.getCanvasHeight()), n = Math.floor(this._outerHeight), o = i / n, r = Math.floor(4 * this._pixelRatio / 2), a = [];
          for (let l = 0, u = this._zones.length; l < u; l++) {
            const d = this._zones[l];
            if (!e) {
              const k = d.getColorZones();
              if (k) {
                a.push(k);
                continue;
              }
            }
            const f = this._getVerticalOffsetForLine(d.startLineNumber), m = d.heightInLines === 0 ? this._getVerticalOffsetForLine(d.endLineNumber) + t : f + d.heightInLines * t, _ = Math.floor(o * f), b = Math.floor(o * m);
            let v = Math.floor((_ + b) / 2), y = b - v;
            y < r && (y = r), v - y < 0 && (v = y), v + y > i && (v = i - y);
            const x = d.color;
            let L = this._color2Id[x];
            L || (L = ++this._lastAssignedId, this._color2Id[x] = L, this._id2Color[L] = x);
            const D = new j3(v - y, v + y, L);
            d.setColorZone(D), a.push(D);
          }
          return this._colorZonesInvalid = false, a.sort(j3.compare), a;
        }
      }
      class Hce extends a1 {
        constructor(e, t) {
          super(), this._context = e;
          const i = this._context.configuration.options;
          this._domNode = St(document.createElement("canvas")), this._domNode.setClassName(t), this._domNode.setPosition("absolute"), this._domNode.setLayerHinting(true), this._domNode.setContain("strict"), this._zoneManager = new Wce((n) => this._context.viewLayout.getVerticalOffsetForLineNumber(n)), this._zoneManager.setDOMWidth(0), this._zoneManager.setDOMHeight(0), this._zoneManager.setOuterHeight(this._context.viewLayout.getScrollHeight()), this._zoneManager.setLineHeight(i.get(67)), this._zoneManager.setPixelRatio(i.get(144)), this._context.addEventHandler(this);
        }
        dispose() {
          this._context.removeEventHandler(this), super.dispose();
        }
        onConfigurationChanged(e) {
          const t = this._context.configuration.options;
          return e.hasChanged(67) && (this._zoneManager.setLineHeight(t.get(67)), this._render()), e.hasChanged(144) && (this._zoneManager.setPixelRatio(t.get(144)), this._domNode.setWidth(this._zoneManager.getDOMWidth()), this._domNode.setHeight(this._zoneManager.getDOMHeight()), this._domNode.domNode.width = this._zoneManager.getCanvasWidth(), this._domNode.domNode.height = this._zoneManager.getCanvasHeight(), this._render()), true;
        }
        onFlushed(e) {
          return this._render(), true;
        }
        onScrollChanged(e) {
          return e.scrollHeightChanged && (this._zoneManager.setOuterHeight(e.scrollHeight), this._render()), true;
        }
        onZonesChanged(e) {
          return this._render(), true;
        }
        getDomNode() {
          return this._domNode.domNode;
        }
        setLayout(e) {
          this._domNode.setTop(e.top), this._domNode.setRight(e.right);
          let t = false;
          t = this._zoneManager.setDOMWidth(e.width) || t, t = this._zoneManager.setDOMHeight(e.height) || t, t && (this._domNode.setWidth(this._zoneManager.getDOMWidth()), this._domNode.setHeight(this._zoneManager.getDOMHeight()), this._domNode.domNode.width = this._zoneManager.getCanvasWidth(), this._domNode.domNode.height = this._zoneManager.getCanvasHeight(), this._render());
        }
        setZones(e) {
          this._zoneManager.setZones(e), this._render();
        }
        _render() {
          if (this._zoneManager.getOuterHeight() === 0) return false;
          const e = this._zoneManager.getCanvasWidth(), t = this._zoneManager.getCanvasHeight(), i = this._zoneManager.resolveColorZones(), n = this._zoneManager.getId2Color(), o = this._domNode.domNode.getContext("2d");
          return o.clearRect(0, 0, e, t), i.length > 0 && this._renderOneLane(o, i, n, e), true;
        }
        _renderOneLane(e, t, i, n) {
          let o = 0, r = 0, a = 0;
          for (const l of t) {
            const u = l.colorId, d = l.from, f = l.to;
            u !== o ? (e.fillRect(0, r, n, a - r), o = u, e.fillStyle = i[o], r = d, a = f) : a >= d ? a = Math.max(a, f) : (e.fillRect(0, r, n, a - r), r = d, a = f);
          }
          e.fillRect(0, r, n, a - r);
        }
      }
      class zce extends Zs {
        constructor(e) {
          super(e), this.domNode = St(document.createElement("div")), this.domNode.setAttribute("role", "presentation"), this.domNode.setAttribute("aria-hidden", "true"), this.domNode.setClassName("view-rulers"), this._renderedRulers = [];
          const t = this._context.configuration.options;
          this._rulers = t.get(103), this._typicalHalfwidthCharacterWidth = t.get(50).typicalHalfwidthCharacterWidth;
        }
        dispose() {
          super.dispose();
        }
        onConfigurationChanged(e) {
          const t = this._context.configuration.options;
          return this._rulers = t.get(103), this._typicalHalfwidthCharacterWidth = t.get(50).typicalHalfwidthCharacterWidth, true;
        }
        onScrollChanged(e) {
          return e.scrollHeightChanged;
        }
        prepareRender(e) {
        }
        _ensureRulersCount() {
          const e = this._renderedRulers.length, t = this._rulers.length;
          if (e === t) return;
          if (e < t) {
            const { tabSize: n } = this._context.viewModel.model.getOptions(), o = n;
            let r = t - e;
            for (; r > 0; ) {
              const a = St(document.createElement("div"));
              a.setClassName("view-ruler"), a.setWidth(o), this.domNode.appendChild(a), this._renderedRulers.push(a), r--;
            }
            return;
          }
          let i = e - t;
          for (; i > 0; ) {
            const n = this._renderedRulers.pop();
            this.domNode.removeChild(n), i--;
          }
        }
        render(e) {
          this._ensureRulersCount();
          for (let t = 0, i = this._rulers.length; t < i; t++) {
            const n = this._renderedRulers[t], o = this._rulers[t];
            n.setBoxShadow(o.color ? `1px 0 0 0 ${o.color} inset` : ""), n.setHeight(Math.min(e.scrollHeight, 1e6)), n.setLeft(o.column * this._typicalHalfwidthCharacterWidth);
          }
        }
      }
      class Uce extends Zs {
        constructor(e) {
          super(e), this._scrollTop = 0, this._width = 0, this._updateWidth(), this._shouldShow = false;
          const i = this._context.configuration.options.get(104);
          this._useShadows = i.useShadows, this._domNode = St(document.createElement("div")), this._domNode.setAttribute("role", "presentation"), this._domNode.setAttribute("aria-hidden", "true");
        }
        dispose() {
          super.dispose();
        }
        _updateShouldShow() {
          const e = this._useShadows && this._scrollTop > 0;
          return this._shouldShow !== e ? (this._shouldShow = e, true) : false;
        }
        getDomNode() {
          return this._domNode;
        }
        _updateWidth() {
          const t = this._context.configuration.options.get(146);
          t.minimap.renderMinimap === 0 || t.minimap.minimapWidth > 0 && t.minimap.minimapLeft === 0 ? this._width = t.width : this._width = t.width - t.verticalScrollbarWidth;
        }
        onConfigurationChanged(e) {
          const i = this._context.configuration.options.get(104);
          return this._useShadows = i.useShadows, this._updateWidth(), this._updateShouldShow(), true;
        }
        onScrollChanged(e) {
          return this._scrollTop = e.scrollTop, this._updateShouldShow();
        }
        prepareRender(e) {
        }
        render(e) {
          this._domNode.setWidth(this._width), this._domNode.setClassName(this._shouldShow ? "scroll-decoration" : "");
        }
      }
      class $ce {
        constructor(e) {
          this.left = e.left, this.width = e.width, this.startStyle = null, this.endStyle = null;
        }
      }
      class qce {
        constructor(e, t) {
          this.lineNumber = e, this.ranges = t;
        }
      }
      function Kce(s) {
        return new $ce(s);
      }
      function jce(s) {
        return new qce(s.lineNumber, s.ranges.map(Kce));
      }
      const __n = class __n extends sd {
        constructor(e) {
          super(), this._previousFrameVisibleRangesWithStyle = [], this._context = e;
          const t = this._context.configuration.options;
          this._roundedSelection = t.get(102), this._typicalHalfwidthCharacterWidth = t.get(50).typicalHalfwidthCharacterWidth, this._selections = [], this._renderResult = null, this._context.addEventHandler(this);
        }
        dispose() {
          this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
        }
        onConfigurationChanged(e) {
          const t = this._context.configuration.options;
          return this._roundedSelection = t.get(102), this._typicalHalfwidthCharacterWidth = t.get(50).typicalHalfwidthCharacterWidth, true;
        }
        onCursorStateChanged(e) {
          return this._selections = e.selections.slice(0), true;
        }
        onDecorationsChanged(e) {
          return true;
        }
        onFlushed(e) {
          return true;
        }
        onLinesChanged(e) {
          return true;
        }
        onLinesDeleted(e) {
          return true;
        }
        onLinesInserted(e) {
          return true;
        }
        onScrollChanged(e) {
          return e.scrollTopChanged;
        }
        onZonesChanged(e) {
          return true;
        }
        _visibleRangesHaveGaps(e) {
          for (let t = 0, i = e.length; t < i; t++) if (e[t].ranges.length > 1) return true;
          return false;
        }
        _enrichVisibleRangesWithStyle(e, t, i) {
          const n = this._typicalHalfwidthCharacterWidth / 4;
          let o = null, r = null;
          if (i && i.length > 0 && t.length > 0) {
            const a = t[0].lineNumber;
            if (a === e.startLineNumber) for (let u = 0; !o && u < i.length; u++) i[u].lineNumber === a && (o = i[u].ranges[0]);
            const l = t[t.length - 1].lineNumber;
            if (l === e.endLineNumber) for (let u = i.length - 1; !r && u >= 0; u--) i[u].lineNumber === l && (r = i[u].ranges[0]);
            o && !o.startStyle && (o = null), r && !r.startStyle && (r = null);
          }
          for (let a = 0, l = t.length; a < l; a++) {
            const u = t[a].ranges[0], d = u.left, f = u.left + u.width, m = {
              top: 0,
              bottom: 0
            }, _ = {
              top: 0,
              bottom: 0
            };
            if (a > 0) {
              const b = t[a - 1].ranges[0].left, v = t[a - 1].ranges[0].left + t[a - 1].ranges[0].width;
              s0(d - b) < n ? m.top = 2 : d > b && (m.top = 1), s0(f - v) < n ? _.top = 2 : b < f && f < v && (_.top = 1);
            } else o && (m.top = o.startStyle.top, _.top = o.endStyle.top);
            if (a + 1 < l) {
              const b = t[a + 1].ranges[0].left, v = t[a + 1].ranges[0].left + t[a + 1].ranges[0].width;
              s0(d - b) < n ? m.bottom = 2 : b < d && d < v && (m.bottom = 1), s0(f - v) < n ? _.bottom = 2 : f < v && (_.bottom = 1);
            } else r && (m.bottom = r.startStyle.bottom, _.bottom = r.endStyle.bottom);
            u.startStyle = m, u.endStyle = _;
          }
        }
        _getVisibleRangesWithStyle(e, t, i) {
          const o = (t.linesVisibleRangesForRange(e, true) || []).map(jce);
          return !this._visibleRangesHaveGaps(o) && this._roundedSelection && this._enrichVisibleRangesWithStyle(t.visibleRange, o, i), o;
        }
        _createSelectionPiece(e, t, i, n, o) {
          return '<div class="cslr ' + i + '" style="top:' + e.toString() + "px;bottom:" + t.toString() + "px;left:" + n.toString() + "px;width:" + o.toString() + 'px;"></div>';
        }
        _actualRenderOneSelection(e, t, i, n) {
          if (n.length === 0) return;
          const o = !!n[0].ranges[0].startStyle, r = n[0].lineNumber, a = n[n.length - 1].lineNumber;
          for (let l = 0, u = n.length; l < u; l++) {
            const d = n[l], f = d.lineNumber, m = f - t, _ = i && f === r ? 1 : 0, b = i && f !== r && f === a ? 1 : 0;
            let v = "", y = "";
            for (let x = 0, L = d.ranges.length; x < L; x++) {
              const D = d.ranges[x];
              if (o) {
                const T = D.startStyle, M = D.endStyle;
                if (T.top === 1 || T.bottom === 1) {
                  v += this._createSelectionPiece(_, b, __n.SELECTION_CLASS_NAME, D.left - __n.ROUNDED_PIECE_WIDTH, __n.ROUNDED_PIECE_WIDTH);
                  let I = __n.EDITOR_BACKGROUND_CLASS_NAME;
                  T.top === 1 && (I += " " + __n.SELECTION_TOP_RIGHT), T.bottom === 1 && (I += " " + __n.SELECTION_BOTTOM_RIGHT), v += this._createSelectionPiece(_, b, I, D.left - __n.ROUNDED_PIECE_WIDTH, __n.ROUNDED_PIECE_WIDTH);
                }
                if (M.top === 1 || M.bottom === 1) {
                  v += this._createSelectionPiece(_, b, __n.SELECTION_CLASS_NAME, D.left + D.width, __n.ROUNDED_PIECE_WIDTH);
                  let I = __n.EDITOR_BACKGROUND_CLASS_NAME;
                  M.top === 1 && (I += " " + __n.SELECTION_TOP_LEFT), M.bottom === 1 && (I += " " + __n.SELECTION_BOTTOM_LEFT), v += this._createSelectionPiece(_, b, I, D.left + D.width, __n.ROUNDED_PIECE_WIDTH);
                }
              }
              let k = __n.SELECTION_CLASS_NAME;
              if (o) {
                const T = D.startStyle, M = D.endStyle;
                T.top === 0 && (k += " " + __n.SELECTION_TOP_LEFT), T.bottom === 0 && (k += " " + __n.SELECTION_BOTTOM_LEFT), M.top === 0 && (k += " " + __n.SELECTION_TOP_RIGHT), M.bottom === 0 && (k += " " + __n.SELECTION_BOTTOM_RIGHT);
              }
              y += this._createSelectionPiece(_, b, k, D.left, D.width);
            }
            e[m][0] += v, e[m][1] += y;
          }
        }
        prepareRender(e) {
          const t = [], i = e.visibleRange.startLineNumber, n = e.visibleRange.endLineNumber;
          for (let r = i; r <= n; r++) {
            const a = r - i;
            t[a] = [
              "",
              ""
            ];
          }
          const o = [];
          for (let r = 0, a = this._selections.length; r < a; r++) {
            const l = this._selections[r];
            if (l.isEmpty()) {
              o[r] = null;
              continue;
            }
            const u = this._getVisibleRangesWithStyle(l, e, this._previousFrameVisibleRangesWithStyle[r]);
            o[r] = u, this._actualRenderOneSelection(t, i, this._selections.length > 1, u);
          }
          this._previousFrameVisibleRangesWithStyle = o, this._renderResult = t.map(([r, a]) => r + a);
        }
        render(e, t) {
          if (!this._renderResult) return "";
          const i = t - e;
          return i < 0 || i >= this._renderResult.length ? "" : this._renderResult[i];
        }
      };
      __n.SELECTION_CLASS_NAME = "selected-text";
      __n.SELECTION_TOP_LEFT = "top-left-radius";
      __n.SELECTION_BOTTOM_LEFT = "bottom-left-radius";
      __n.SELECTION_TOP_RIGHT = "top-right-radius";
      __n.SELECTION_BOTTOM_RIGHT = "bottom-right-radius";
      __n.EDITOR_BACKGROUND_CLASS_NAME = "monaco-editor-background";
      __n.ROUNDED_PIECE_WIDTH = 10;
      let _n = __n;
      jl((s, e) => {
        const t = s.getColor(BZ);
        t && !t.isTransparent() && e.addRule(`.monaco-editor .view-line span.inline-selected-text { color: ${t}; }`);
      });
      function s0(s) {
        return s < 0 ? -s : s;
      }
      class G3 {
        constructor(e, t, i, n, o, r, a) {
          this.top = e, this.left = t, this.paddingLeft = i, this.width = n, this.height = o, this.textContent = r, this.textContentClassName = a;
        }
      }
      var Al;
      (function(s) {
        s[s.Single = 0] = "Single", s[s.MultiPrimary = 1] = "MultiPrimary", s[s.MultiSecondary = 2] = "MultiSecondary";
      })(Al || (Al = {}));
      class Y3 {
        constructor(e, t) {
          this._context = e;
          const i = this._context.configuration.options, n = i.get(50);
          this._cursorStyle = i.get(28), this._lineHeight = i.get(67), this._typicalHalfwidthCharacterWidth = n.typicalHalfwidthCharacterWidth, this._lineCursorWidth = Math.min(i.get(31), this._typicalHalfwidthCharacterWidth), this._isVisible = true, this._domNode = St(document.createElement("div")), this._domNode.setClassName(`cursor ${Qf}`), this._domNode.setHeight(this._lineHeight), this._domNode.setTop(0), this._domNode.setLeft(0), Un(this._domNode, n), this._domNode.setDisplay("none"), this._position = new X(1, 1), this._pluralityClass = "", this.setPlurality(t), this._lastRenderedContent = "", this._renderData = null;
        }
        getDomNode() {
          return this._domNode;
        }
        getPosition() {
          return this._position;
        }
        setPlurality(e) {
          switch (e) {
            default:
            case Al.Single:
              this._pluralityClass = "";
              break;
            case Al.MultiPrimary:
              this._pluralityClass = "cursor-primary";
              break;
            case Al.MultiSecondary:
              this._pluralityClass = "cursor-secondary";
              break;
          }
        }
        show() {
          this._isVisible || (this._domNode.setVisibility("inherit"), this._isVisible = true);
        }
        hide() {
          this._isVisible && (this._domNode.setVisibility("hidden"), this._isVisible = false);
        }
        onConfigurationChanged(e) {
          const t = this._context.configuration.options, i = t.get(50);
          return this._cursorStyle = t.get(28), this._lineHeight = t.get(67), this._typicalHalfwidthCharacterWidth = i.typicalHalfwidthCharacterWidth, this._lineCursorWidth = Math.min(t.get(31), this._typicalHalfwidthCharacterWidth), Un(this._domNode, i), true;
        }
        onCursorPositionChanged(e, t) {
          return t ? this._domNode.domNode.style.transitionProperty = "none" : this._domNode.domNode.style.transitionProperty = "", this._position = e, true;
        }
        _getGraphemeAwarePosition() {
          const { lineNumber: e, column: t } = this._position, i = this._context.viewModel.getLineContent(e), [n, o] = Mq(i, t - 1);
          return [
            new X(e, n + 1),
            i.substring(n, o)
          ];
        }
        _prepareRender(e) {
          let t = "", i = "";
          const [n, o] = this._getGraphemeAwarePosition();
          if (this._cursorStyle === vn.Line || this._cursorStyle === vn.LineThin) {
            const m = e.visibleRangeForPosition(n);
            if (!m || m.outsideRenderedLine) return null;
            const _ = Oe(this._domNode.domNode);
            let b;
            this._cursorStyle === vn.Line ? (b = cO(_, this._lineCursorWidth > 0 ? this._lineCursorWidth : 2), b > 2 && (t = o, i = this._getTokenClassName(n))) : b = cO(_, 1);
            let v = m.left, y = 0;
            b >= 2 && v >= 1 && (y = 1, v -= y);
            const x = e.getVerticalOffsetForLineNumber(n.lineNumber) - e.bigNumbersDelta;
            return new G3(x, v, y, b, this._lineHeight, t, i);
          }
          const r = e.linesVisibleRangesForRange(new z(n.lineNumber, n.column, n.lineNumber, n.column + o.length), false);
          if (!r || r.length === 0) return null;
          const a = r[0];
          if (a.outsideRenderedLine || a.ranges.length === 0) return null;
          const l = a.ranges[0], u = o === "	" ? this._typicalHalfwidthCharacterWidth : l.width < 1 ? this._typicalHalfwidthCharacterWidth : l.width;
          this._cursorStyle === vn.Block && (t = o, i = this._getTokenClassName(n));
          let d = e.getVerticalOffsetForLineNumber(n.lineNumber) - e.bigNumbersDelta, f = this._lineHeight;
          return (this._cursorStyle === vn.Underline || this._cursorStyle === vn.UnderlineThin) && (d += this._lineHeight - 2, f = 2), new G3(d, l.left, 0, u, f, t, i);
        }
        _getTokenClassName(e) {
          const t = this._context.viewModel.getViewLineData(e.lineNumber), i = t.tokens.findTokenIndexAtOffset(e.column - 1);
          return t.tokens.getClassName(i);
        }
        prepareRender(e) {
          this._renderData = this._prepareRender(e);
        }
        render(e) {
          return this._renderData ? (this._lastRenderedContent !== this._renderData.textContent && (this._lastRenderedContent = this._renderData.textContent, this._domNode.domNode.textContent = this._lastRenderedContent), this._domNode.setClassName(`cursor ${this._pluralityClass} ${Qf} ${this._renderData.textContentClassName}`), this._domNode.setDisplay("block"), this._domNode.setTop(this._renderData.top), this._domNode.setLeft(this._renderData.left), this._domNode.setPaddingLeft(this._renderData.paddingLeft), this._domNode.setWidth(this._renderData.width), this._domNode.setLineHeight(this._renderData.height), this._domNode.setHeight(this._renderData.height), {
            domNode: this._domNode.domNode,
            position: this._position,
            contentLeft: this._renderData.left,
            height: this._renderData.height,
            width: 2
          }) : (this._domNode.setDisplay("none"), null);
        }
      }
      const _CC = class _CC extends Zs {
        constructor(e) {
          super(e);
          const t = this._context.configuration.options;
          this._readOnly = t.get(92), this._cursorBlinking = t.get(26), this._cursorStyle = t.get(28), this._cursorSmoothCaretAnimation = t.get(27), this._selectionIsEmpty = true, this._isComposingInput = false, this._isVisible = false, this._primaryCursor = new Y3(this._context, Al.Single), this._secondaryCursors = [], this._renderData = [], this._domNode = St(document.createElement("div")), this._domNode.setAttribute("role", "presentation"), this._domNode.setAttribute("aria-hidden", "true"), this._updateDomClassName(), this._domNode.appendChild(this._primaryCursor.getDomNode()), this._startCursorBlinkAnimation = new Kh(), this._cursorFlatBlinkInterval = new sT(), this._blinkingEnabled = false, this._editorHasFocus = false, this._updateBlinking();
        }
        dispose() {
          super.dispose(), this._startCursorBlinkAnimation.dispose(), this._cursorFlatBlinkInterval.dispose();
        }
        getDomNode() {
          return this._domNode;
        }
        onCompositionStart(e) {
          return this._isComposingInput = true, this._updateBlinking(), true;
        }
        onCompositionEnd(e) {
          return this._isComposingInput = false, this._updateBlinking(), true;
        }
        onConfigurationChanged(e) {
          const t = this._context.configuration.options;
          this._readOnly = t.get(92), this._cursorBlinking = t.get(26), this._cursorStyle = t.get(28), this._cursorSmoothCaretAnimation = t.get(27), this._updateBlinking(), this._updateDomClassName(), this._primaryCursor.onConfigurationChanged(e);
          for (let i = 0, n = this._secondaryCursors.length; i < n; i++) this._secondaryCursors[i].onConfigurationChanged(e);
          return true;
        }
        _onCursorPositionChanged(e, t, i) {
          const n = this._secondaryCursors.length !== t.length || this._cursorSmoothCaretAnimation === "explicit" && i !== 3;
          if (this._primaryCursor.setPlurality(t.length ? Al.MultiPrimary : Al.Single), this._primaryCursor.onCursorPositionChanged(e, n), this._updateBlinking(), this._secondaryCursors.length < t.length) {
            const o = t.length - this._secondaryCursors.length;
            for (let r = 0; r < o; r++) {
              const a = new Y3(this._context, Al.MultiSecondary);
              this._domNode.domNode.insertBefore(a.getDomNode().domNode, this._primaryCursor.getDomNode().domNode.nextSibling), this._secondaryCursors.push(a);
            }
          } else if (this._secondaryCursors.length > t.length) {
            const o = this._secondaryCursors.length - t.length;
            for (let r = 0; r < o; r++) this._domNode.removeChild(this._secondaryCursors[0].getDomNode()), this._secondaryCursors.splice(0, 1);
          }
          for (let o = 0; o < t.length; o++) this._secondaryCursors[o].onCursorPositionChanged(t[o], n);
        }
        onCursorStateChanged(e) {
          const t = [];
          for (let n = 0, o = e.selections.length; n < o; n++) t[n] = e.selections[n].getPosition();
          this._onCursorPositionChanged(t[0], t.slice(1), e.reason);
          const i = e.selections[0].isEmpty();
          return this._selectionIsEmpty !== i && (this._selectionIsEmpty = i, this._updateDomClassName()), true;
        }
        onDecorationsChanged(e) {
          return true;
        }
        onFlushed(e) {
          return true;
        }
        onFocusChanged(e) {
          return this._editorHasFocus = e.isFocused, this._updateBlinking(), false;
        }
        onLinesChanged(e) {
          return true;
        }
        onLinesDeleted(e) {
          return true;
        }
        onLinesInserted(e) {
          return true;
        }
        onScrollChanged(e) {
          return true;
        }
        onTokensChanged(e) {
          const t = (i) => {
            for (let n = 0, o = e.ranges.length; n < o; n++) if (e.ranges[n].fromLineNumber <= i.lineNumber && i.lineNumber <= e.ranges[n].toLineNumber) return true;
            return false;
          };
          if (t(this._primaryCursor.getPosition())) return true;
          for (const i of this._secondaryCursors) if (t(i.getPosition())) return true;
          return false;
        }
        onZonesChanged(e) {
          return true;
        }
        _getCursorBlinking() {
          return this._isComposingInput || !this._editorHasFocus ? 0 : this._readOnly ? 5 : this._cursorBlinking;
        }
        _updateBlinking() {
          this._startCursorBlinkAnimation.cancel(), this._cursorFlatBlinkInterval.cancel();
          const e = this._getCursorBlinking(), t = e === 0, i = e === 5;
          t ? this._hide() : this._show(), this._blinkingEnabled = false, this._updateDomClassName(), !t && !i && (e === 1 ? this._cursorFlatBlinkInterval.cancelAndSet(() => {
            this._isVisible ? this._hide() : this._show();
          }, _CC.BLINK_INTERVAL, Oe(this._domNode.domNode)) : this._startCursorBlinkAnimation.setIfNotSet(() => {
            this._blinkingEnabled = true, this._updateDomClassName();
          }, _CC.BLINK_INTERVAL));
        }
        _updateDomClassName() {
          this._domNode.setClassName(this._getClassName());
        }
        _getClassName() {
          let e = "cursors-layer";
          switch (this._selectionIsEmpty || (e += " has-selection"), this._cursorStyle) {
            case vn.Line:
              e += " cursor-line-style";
              break;
            case vn.Block:
              e += " cursor-block-style";
              break;
            case vn.Underline:
              e += " cursor-underline-style";
              break;
            case vn.LineThin:
              e += " cursor-line-thin-style";
              break;
            case vn.BlockOutline:
              e += " cursor-block-outline-style";
              break;
            case vn.UnderlineThin:
              e += " cursor-underline-thin-style";
              break;
            default:
              e += " cursor-line-style";
          }
          if (this._blinkingEnabled) switch (this._getCursorBlinking()) {
            case 1:
              e += " cursor-blink";
              break;
            case 2:
              e += " cursor-smooth";
              break;
            case 3:
              e += " cursor-phase";
              break;
            case 4:
              e += " cursor-expand";
              break;
            case 5:
              e += " cursor-solid";
              break;
            default:
              e += " cursor-solid";
          }
          else e += " cursor-solid";
          return (this._cursorSmoothCaretAnimation === "on" || this._cursorSmoothCaretAnimation === "explicit") && (e += " cursor-smooth-caret-animation"), e;
        }
        _show() {
          this._primaryCursor.show();
          for (let e = 0, t = this._secondaryCursors.length; e < t; e++) this._secondaryCursors[e].show();
          this._isVisible = true;
        }
        _hide() {
          this._primaryCursor.hide();
          for (let e = 0, t = this._secondaryCursors.length; e < t; e++) this._secondaryCursors[e].hide();
          this._isVisible = false;
        }
        prepareRender(e) {
          this._primaryCursor.prepareRender(e);
          for (let t = 0, i = this._secondaryCursors.length; t < i; t++) this._secondaryCursors[t].prepareRender(e);
        }
        render(e) {
          const t = [];
          let i = 0;
          const n = this._primaryCursor.render(e);
          n && (t[i++] = n);
          for (let o = 0, r = this._secondaryCursors.length; o < r; o++) {
            const a = this._secondaryCursors[o].render(e);
            a && (t[i++] = a);
          }
          this._renderData = t;
        }
        getLastRenderData() {
          return this._renderData;
        }
      };
      _CC.BLINK_INTERVAL = 500;
      let CC = _CC;
      jl((s, e) => {
        const t = [
          {
            class: ".cursor",
            foreground: xw,
            background: rN
          },
          {
            class: ".cursor-primary",
            foreground: aB,
            background: nie
          },
          {
            class: ".cursor-secondary",
            foreground: lB,
            background: sie
          }
        ];
        for (const i of t) {
          const n = s.getColor(i.foreground);
          if (n) {
            let o = s.getColor(i.background);
            o || (o = n.opposite()), e.addRule(`.monaco-editor .cursors-layer ${i.class} { background-color: ${n}; border-color: ${n}; color: ${o}; }`), Bf(s.type) && e.addRule(`.monaco-editor .cursors-layer.has-selection ${i.class} { border-left: 1px solid ${o}; border-right: 1px solid ${o}; }`);
          }
        }
      });
      const Sx = () => {
        throw new Error("Invalid change accessor");
      };
      class Gce extends Zs {
        constructor(e) {
          super(e);
          const t = this._context.configuration.options, i = t.get(146);
          this._lineHeight = t.get(67), this._contentWidth = i.contentWidth, this._contentLeft = i.contentLeft, this.domNode = St(document.createElement("div")), this.domNode.setClassName("view-zones"), this.domNode.setPosition("absolute"), this.domNode.setAttribute("role", "presentation"), this.domNode.setAttribute("aria-hidden", "true"), this.marginDomNode = St(document.createElement("div")), this.marginDomNode.setClassName("margin-view-zones"), this.marginDomNode.setPosition("absolute"), this.marginDomNode.setAttribute("role", "presentation"), this.marginDomNode.setAttribute("aria-hidden", "true"), this._zones = {};
        }
        dispose() {
          super.dispose(), this._zones = {};
        }
        _recomputeWhitespacesProps() {
          const e = this._context.viewLayout.getWhitespaces(), t = /* @__PURE__ */ new Map();
          for (const n of e) t.set(n.id, n);
          let i = false;
          return this._context.viewModel.changeWhitespace((n) => {
            const o = Object.keys(this._zones);
            for (let r = 0, a = o.length; r < a; r++) {
              const l = o[r], u = this._zones[l], d = this._computeWhitespaceProps(u.delegate);
              u.isInHiddenArea = d.isInHiddenArea;
              const f = t.get(l);
              f && (f.afterLineNumber !== d.afterViewLineNumber || f.height !== d.heightInPx) && (n.changeOneWhitespace(l, d.afterViewLineNumber, d.heightInPx), this._safeCallOnComputedHeight(u.delegate, d.heightInPx), i = true);
            }
          }), i;
        }
        onConfigurationChanged(e) {
          const t = this._context.configuration.options, i = t.get(146);
          return this._lineHeight = t.get(67), this._contentWidth = i.contentWidth, this._contentLeft = i.contentLeft, e.hasChanged(67) && this._recomputeWhitespacesProps(), true;
        }
        onLineMappingChanged(e) {
          return this._recomputeWhitespacesProps();
        }
        onLinesDeleted(e) {
          return true;
        }
        onScrollChanged(e) {
          return e.scrollTopChanged || e.scrollWidthChanged;
        }
        onZonesChanged(e) {
          return true;
        }
        onLinesInserted(e) {
          return true;
        }
        _getZoneOrdinal(e) {
          return e.ordinal ?? e.afterColumn ?? 1e4;
        }
        _computeWhitespaceProps(e) {
          if (e.afterLineNumber === 0) return {
            isInHiddenArea: false,
            afterViewLineNumber: 0,
            heightInPx: this._heightInPixels(e),
            minWidthInPx: this._minWidthInPixels(e)
          };
          let t;
          if (typeof e.afterColumn < "u") t = this._context.viewModel.model.validatePosition({
            lineNumber: e.afterLineNumber,
            column: e.afterColumn
          });
          else {
            const r = this._context.viewModel.model.validatePosition({
              lineNumber: e.afterLineNumber,
              column: 1
            }).lineNumber;
            t = new X(r, this._context.viewModel.model.getLineMaxColumn(r));
          }
          let i;
          t.column === this._context.viewModel.model.getLineMaxColumn(t.lineNumber) ? i = this._context.viewModel.model.validatePosition({
            lineNumber: t.lineNumber + 1,
            column: 1
          }) : i = this._context.viewModel.model.validatePosition({
            lineNumber: t.lineNumber,
            column: t.column + 1
          });
          const n = this._context.viewModel.coordinatesConverter.convertModelPositionToViewPosition(t, e.afterColumnAffinity, true), o = e.showInHiddenAreas || this._context.viewModel.coordinatesConverter.modelPositionIsVisible(i);
          return {
            isInHiddenArea: !o,
            afterViewLineNumber: n.lineNumber,
            heightInPx: o ? this._heightInPixels(e) : 0,
            minWidthInPx: this._minWidthInPixels(e)
          };
        }
        changeViewZones(e) {
          let t = false;
          return this._context.viewModel.changeWhitespace((i) => {
            const n = {
              addZone: (o) => (t = true, this._addZone(i, o)),
              removeZone: (o) => {
                o && (t = this._removeZone(i, o) || t);
              },
              layoutZone: (o) => {
                o && (t = this._layoutZone(i, o) || t);
              }
            };
            Yce(e, n), n.addZone = Sx, n.removeZone = Sx, n.layoutZone = Sx;
          }), t;
        }
        _addZone(e, t) {
          const i = this._computeWhitespaceProps(t), o = {
            whitespaceId: e.insertWhitespace(i.afterViewLineNumber, this._getZoneOrdinal(t), i.heightInPx, i.minWidthInPx),
            delegate: t,
            isInHiddenArea: i.isInHiddenArea,
            isVisible: false,
            domNode: St(t.domNode),
            marginDomNode: t.marginDomNode ? St(t.marginDomNode) : null
          };
          return this._safeCallOnComputedHeight(o.delegate, i.heightInPx), o.domNode.setPosition("absolute"), o.domNode.domNode.style.width = "100%", o.domNode.setDisplay("none"), o.domNode.setAttribute("monaco-view-zone", o.whitespaceId), this.domNode.appendChild(o.domNode), o.marginDomNode && (o.marginDomNode.setPosition("absolute"), o.marginDomNode.domNode.style.width = "100%", o.marginDomNode.setDisplay("none"), o.marginDomNode.setAttribute("monaco-view-zone", o.whitespaceId), this.marginDomNode.appendChild(o.marginDomNode)), this._zones[o.whitespaceId] = o, this.setShouldRender(), o.whitespaceId;
        }
        _removeZone(e, t) {
          if (this._zones.hasOwnProperty(t)) {
            const i = this._zones[t];
            return delete this._zones[t], e.removeWhitespace(i.whitespaceId), i.domNode.removeAttribute("monaco-visible-view-zone"), i.domNode.removeAttribute("monaco-view-zone"), i.domNode.domNode.remove(), i.marginDomNode && (i.marginDomNode.removeAttribute("monaco-visible-view-zone"), i.marginDomNode.removeAttribute("monaco-view-zone"), i.marginDomNode.domNode.remove()), this.setShouldRender(), true;
          }
          return false;
        }
        _layoutZone(e, t) {
          if (this._zones.hasOwnProperty(t)) {
            const i = this._zones[t], n = this._computeWhitespaceProps(i.delegate);
            return i.isInHiddenArea = n.isInHiddenArea, e.changeOneWhitespace(i.whitespaceId, n.afterViewLineNumber, n.heightInPx), this._safeCallOnComputedHeight(i.delegate, n.heightInPx), this.setShouldRender(), true;
          }
          return false;
        }
        shouldSuppressMouseDownOnViewZone(e) {
          return this._zones.hasOwnProperty(e) ? !!this._zones[e].delegate.suppressMouseDown : false;
        }
        _heightInPixels(e) {
          return typeof e.heightInPx == "number" ? e.heightInPx : typeof e.heightInLines == "number" ? this._lineHeight * e.heightInLines : this._lineHeight;
        }
        _minWidthInPixels(e) {
          return typeof e.minWidthInPx == "number" ? e.minWidthInPx : 0;
        }
        _safeCallOnComputedHeight(e, t) {
          if (typeof e.onComputedHeight == "function") try {
            e.onComputedHeight(t);
          } catch (i) {
            qt(i);
          }
        }
        _safeCallOnDomNodeTop(e, t) {
          if (typeof e.onDomNodeTop == "function") try {
            e.onDomNodeTop(t);
          } catch (i) {
            qt(i);
          }
        }
        prepareRender(e) {
        }
        render(e) {
          const t = e.viewportData.whitespaceViewportData, i = {};
          let n = false;
          for (const r of t) this._zones[r.id].isInHiddenArea || (i[r.id] = r, n = true);
          const o = Object.keys(this._zones);
          for (let r = 0, a = o.length; r < a; r++) {
            const l = o[r], u = this._zones[l];
            let d = 0, f = 0, m = "none";
            i.hasOwnProperty(l) ? (d = i[l].verticalOffset - e.bigNumbersDelta, f = i[l].height, m = "block", u.isVisible || (u.domNode.setAttribute("monaco-visible-view-zone", "true"), u.isVisible = true), this._safeCallOnDomNodeTop(u.delegate, e.getScrolledTopFromAbsoluteTop(i[l].verticalOffset))) : (u.isVisible && (u.domNode.removeAttribute("monaco-visible-view-zone"), u.isVisible = false), this._safeCallOnDomNodeTop(u.delegate, e.getScrolledTopFromAbsoluteTop(-1e6))), u.domNode.setTop(d), u.domNode.setHeight(f), u.domNode.setDisplay(m), u.marginDomNode && (u.marginDomNode.setTop(d), u.marginDomNode.setHeight(f), u.marginDomNode.setDisplay(m));
          }
          n && (this.domNode.setWidth(Math.max(e.scrollWidth, this._contentWidth)), this.marginDomNode.setWidth(this._contentLeft));
        }
      }
      function Yce(s, e) {
        try {
          return s(e);
        } catch (t) {
          qt(t);
        }
      }
      class Zce extends sd {
        constructor(e) {
          super(), this._context = e, this._options = new Z3(this._context.configuration), this._selection = [], this._renderResult = null, this._context.addEventHandler(this);
        }
        dispose() {
          this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
        }
        onConfigurationChanged(e) {
          const t = new Z3(this._context.configuration);
          return this._options.equals(t) ? e.hasChanged(146) : (this._options = t, true);
        }
        onCursorStateChanged(e) {
          return this._selection = e.selections, this._options.renderWhitespace === "selection";
        }
        onDecorationsChanged(e) {
          return true;
        }
        onFlushed(e) {
          return true;
        }
        onLinesChanged(e) {
          return true;
        }
        onLinesDeleted(e) {
          return true;
        }
        onLinesInserted(e) {
          return true;
        }
        onScrollChanged(e) {
          return e.scrollTopChanged;
        }
        onZonesChanged(e) {
          return true;
        }
        prepareRender(e) {
          if (this._options.renderWhitespace === "none") {
            this._renderResult = null;
            return;
          }
          const t = e.visibleRange.startLineNumber, n = e.visibleRange.endLineNumber - t + 1, o = new Array(n);
          for (let a = 0; a < n; a++) o[a] = true;
          const r = this._context.viewModel.getMinimapLinesRenderingData(e.viewportData.startLineNumber, e.viewportData.endLineNumber, o);
          this._renderResult = [];
          for (let a = e.viewportData.startLineNumber; a <= e.viewportData.endLineNumber; a++) {
            const l = a - e.viewportData.startLineNumber, u = r.data[l];
            let d = null;
            if (this._options.renderWhitespace === "selection") {
              const f = this._selection;
              for (const m of f) {
                if (m.endLineNumber < a || m.startLineNumber > a) continue;
                const _ = m.startLineNumber === a ? m.startColumn : u.minColumn, b = m.endLineNumber === a ? m.endColumn : u.maxColumn;
                _ < b && (d || (d = []), d.push(new pF(_ - 1, b - 1)));
              }
            }
            this._renderResult[l] = this._applyRenderWhitespace(e, a, d, u);
          }
        }
        _applyRenderWhitespace(e, t, i, n) {
          if (this._options.renderWhitespace === "selection" && !i || this._options.renderWhitespace === "trailing" && n.continuesWithWrappedLine) return "";
          const o = this._context.theme.getColor(aN), r = this._options.renderWithSVG, a = n.content, l = this._options.stopRenderingLineAfter === -1 ? a.length : Math.min(this._options.stopRenderingLineAfter, a.length), u = n.continuesWithWrappedLine, d = n.minColumn - 1, f = this._options.renderWhitespace === "boundary", m = this._options.renderWhitespace === "trailing", _ = this._options.lineHeight, b = this._options.middotWidth, v = this._options.wsmiddotWidth, y = this._options.spaceWidth, x = Math.abs(v - y), L = Math.abs(b - y), D = x < L ? 11825 : 183, k = this._options.canUseHalfwidthRightwardsArrow;
          let T = "", M = false, I = qs(a), R;
          I === -1 ? (M = true, I = l, R = l) : R = qh(a);
          let A = 0, Y = i && i[A], U = 0;
          for (let j = d; j < l; j++) {
            const ee = a.charCodeAt(j);
            if (Y && j >= Y.endOffset && (A++, Y = i && i[A]), ee !== 9 && ee !== 32 || m && !M && j <= R) continue;
            if (f && j >= I && j <= R && ee === 32) {
              const te = j - 1 >= 0 ? a.charCodeAt(j - 1) : 0, H = j + 1 < l ? a.charCodeAt(j + 1) : 0;
              if (te !== 32 && H !== 32) continue;
            }
            if (f && u && j === l - 1) {
              const te = j - 1 >= 0 ? a.charCodeAt(j - 1) : 0;
              if (ee === 32 && te !== 32 && te !== 9) continue;
            }
            if (i && (!Y || Y.startOffset > j || Y.endOffset <= j)) continue;
            const K = e.visibleRangeForPosition(new X(t, j + 1));
            K && (r ? (U = Math.max(U, K.left), ee === 9 ? T += this._renderArrow(_, y, K.left) : T += `<circle cx="${(K.left + y / 2).toFixed(2)}" cy="${(_ / 2).toFixed(2)}" r="${(y / 7).toFixed(2)}" />`) : ee === 9 ? T += `<div class="mwh" style="left:${K.left}px;height:${_}px;">${k ? "\uFFEB" : "\u2192"}</div>` : T += `<div class="mwh" style="left:${K.left}px;height:${_}px;">${String.fromCharCode(D)}</div>`);
          }
          return r ? (U = Math.round(U + y), `<svg style="bottom:0;position:absolute;width:${U}px;height:${_}px" viewBox="0 0 ${U} ${_}" xmlns="http://www.w3.org/2000/svg" fill="${o}">` + T + "</svg>") : T;
        }
        _renderArrow(e, t, i) {
          const n = t / 7, o = t, r = e / 2, a = i, l = {
            x: 0,
            y: n / 2
          }, u = {
            x: 100 / 125 * o,
            y: l.y
          }, d = {
            x: u.x - 0.2 * u.x,
            y: u.y + 0.2 * u.x
          }, f = {
            x: d.x + 0.1 * u.x,
            y: d.y + 0.1 * u.x
          }, m = {
            x: f.x + 0.35 * u.x,
            y: f.y - 0.35 * u.x
          }, _ = {
            x: m.x,
            y: -m.y
          }, b = {
            x: f.x,
            y: -f.y
          }, v = {
            x: d.x,
            y: -d.y
          }, y = {
            x: u.x,
            y: -u.y
          }, x = {
            x: l.x,
            y: -l.y
          };
          return `<path d="M ${[
            l,
            u,
            d,
            f,
            m,
            _,
            b,
            v,
            y,
            x
          ].map((k) => `${(a + k.x).toFixed(2)} ${(r + k.y).toFixed(2)}`).join(" L ")}" />`;
        }
        render(e, t) {
          if (!this._renderResult) return "";
          const i = t - e;
          return i < 0 || i >= this._renderResult.length ? "" : this._renderResult[i];
        }
      }
      class Z3 {
        constructor(e) {
          const t = e.options, i = t.get(50), n = t.get(38);
          n === "off" ? (this.renderWhitespace = "none", this.renderWithSVG = false) : n === "svg" ? (this.renderWhitespace = t.get(100), this.renderWithSVG = true) : (this.renderWhitespace = t.get(100), this.renderWithSVG = false), this.spaceWidth = i.spaceWidth, this.middotWidth = i.middotWidth, this.wsmiddotWidth = i.wsmiddotWidth, this.canUseHalfwidthRightwardsArrow = i.canUseHalfwidthRightwardsArrow, this.lineHeight = t.get(67), this.stopRenderingLineAfter = t.get(118);
        }
        equals(e) {
          return this.renderWhitespace === e.renderWhitespace && this.renderWithSVG === e.renderWithSVG && this.spaceWidth === e.spaceWidth && this.middotWidth === e.middotWidth && this.wsmiddotWidth === e.wsmiddotWidth && this.canUseHalfwidthRightwardsArrow === e.canUseHalfwidthRightwardsArrow && this.lineHeight === e.lineHeight && this.stopRenderingLineAfter === e.stopRenderingLineAfter;
        }
      }
      class Qce {
        constructor(e, t, i, n) {
          this.selections = e, this.startLineNumber = t.startLineNumber | 0, this.endLineNumber = t.endLineNumber | 0, this.relativeVerticalOffset = t.relativeVerticalOffset, this.bigNumbersDelta = t.bigNumbersDelta | 0, this.lineHeight = t.lineHeight | 0, this.whitespaceViewportData = i, this._model = n, this.visibleRange = new z(t.startLineNumber, this._model.getLineMinColumn(t.startLineNumber), t.endLineNumber, this._model.getLineMaxColumn(t.endLineNumber));
        }
        getViewLineRenderingData(e) {
          return this._model.getViewportViewLineRenderingData(this.visibleRange, e);
        }
        getDecorationsInViewport() {
          return this._model.getDecorationsInViewport(this.visibleRange);
        }
      }
      class Xce {
        get type() {
          return this._theme.type;
        }
        get value() {
          return this._theme;
        }
        constructor(e) {
          this._theme = e;
        }
        update(e) {
          this._theme = e;
        }
        getColor(e) {
          return this._theme.getColor(e);
        }
      }
      class Jce {
        constructor(e, t, i) {
          this.configuration = e, this.theme = new Xce(t), this.viewModel = i, this.viewLayout = i.viewLayout;
        }
        addEventHandler(e) {
          this.viewModel.addViewEventHandler(e);
        }
        removeEventHandler(e) {
          this.viewModel.removeViewEventHandler(e);
        }
      }
      var eue = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      }, tue = function(s, e) {
        return function(t, i) {
          e(t, i, s);
        };
      };
      let J2 = class extends a1 {
        constructor(e, t, i, n, o, r, a) {
          super(), this._instantiationService = a, this._shouldRecomputeGlyphMarginLanes = false, this._selections = [
            new mt(1, 1, 1, 1)
          ], this._renderAnimationFrame = null;
          const l = new lce(t, n, o, e);
          this._context = new Jce(t, i, n), this._context.addEventHandler(this), this._viewParts = [], this._textAreaHandler = this._instantiationService.createInstance(Y2, this._context, l, this._createTextAreaHandlerHelper()), this._viewParts.push(this._textAreaHandler), this._linesContent = St(document.createElement("div")), this._linesContent.setClassName("lines-content monaco-editor-background"), this._linesContent.setPosition("absolute"), this.domNode = St(document.createElement("div")), this.domNode.setClassName(this._getEditorClassName()), this.domNode.setAttribute("role", "code"), this._overflowGuardContainer = St(document.createElement("div")), Yr.write(this._overflowGuardContainer, 3), this._overflowGuardContainer.setClassName("overflow-guard"), this._scrollbar = new bce(this._context, this._linesContent, this.domNode, this._overflowGuardContainer), this._viewParts.push(this._scrollbar), this._viewLines = new sI(this._context, this._linesContent), this._viewZones = new Gce(this._context), this._viewParts.push(this._viewZones);
          const u = new Vce(this._context);
          this._viewParts.push(u);
          const d = new Uce(this._context);
          this._viewParts.push(d);
          const f = new uce(this._context);
          this._viewParts.push(f), f.addDynamicOverlay(new mce(this._context)), f.addDynamicOverlay(new _n(this._context)), f.addDynamicOverlay(new xce(this._context)), f.addDynamicOverlay(new _ce(this._context)), f.addDynamicOverlay(new Zce(this._context));
          const m = new hce(this._context);
          this._viewParts.push(m), m.addDynamicOverlay(new pce(this._context)), m.addDynamicOverlay(new Nce(this._context)), m.addDynamicOverlay(new Tce(this._context)), m.addDynamicOverlay(new zw(this._context)), this._glyphMarginWidgets = new wce(this._context), this._viewParts.push(this._glyphMarginWidgets);
          const _ = new k_(this._context);
          _.getDomNode().appendChild(this._viewZones.marginDomNode), _.getDomNode().appendChild(m.getDomNode()), _.getDomNode().appendChild(this._glyphMarginWidgets.domNode), this._viewParts.push(_), this._contentWidgets = new fce(this._context, this.domNode), this._viewParts.push(this._contentWidgets), this._viewCursors = new CC(this._context), this._viewParts.push(this._viewCursors), this._overlayWidgets = new Bce(this._context, this.domNode), this._viewParts.push(this._overlayWidgets);
          const b = new zce(this._context);
          this._viewParts.push(b);
          const v = new dce(this._context);
          this._viewParts.push(v);
          const y = new Pce(this._context);
          if (this._viewParts.push(y), u) {
            const x = this._scrollbar.getOverviewRulerLayoutInfo();
            x.parent.insertBefore(u.getDomNode(), x.insertBefore);
          }
          this._linesContent.appendChild(f.getDomNode()), this._linesContent.appendChild(b.domNode), this._linesContent.appendChild(this._viewZones.domNode), this._linesContent.appendChild(this._viewLines.getDomNode()), this._linesContent.appendChild(this._contentWidgets.domNode), this._linesContent.appendChild(this._viewCursors.getDomNode()), this._overflowGuardContainer.appendChild(_.getDomNode()), this._overflowGuardContainer.appendChild(this._scrollbar.getDomNode()), this._overflowGuardContainer.appendChild(d.getDomNode()), this._overflowGuardContainer.appendChild(this._textAreaHandler.textArea), this._overflowGuardContainer.appendChild(this._textAreaHandler.textAreaCover), this._overflowGuardContainer.appendChild(this._overlayWidgets.getDomNode()), this._overflowGuardContainer.appendChild(y.getDomNode()), this._overflowGuardContainer.appendChild(v.domNode), this.domNode.appendChild(this._overflowGuardContainer), r ? (r.appendChild(this._contentWidgets.overflowingContentWidgetsDomNode.domNode), r.appendChild(this._overlayWidgets.overflowingOverlayWidgetsDomNode.domNode)) : (this.domNode.appendChild(this._contentWidgets.overflowingContentWidgetsDomNode), this.domNode.appendChild(this._overlayWidgets.overflowingOverlayWidgetsDomNode)), this._applyLayout(), this._pointerHandler = this._register(new Tle(this._context, l, this._createPointerHandlerHelper()));
        }
        _computeGlyphMarginLanes() {
          const e = this._context.viewModel.model, t = this._context.viewModel.glyphLanes;
          let i = [], n = 0;
          i = i.concat(e.getAllMarginDecorations().map((o) => {
            var _a3, _b3;
            const r = ((_a3 = o.options.glyphMargin) == null ? void 0 : _a3.position) ?? ru.Center;
            return n = Math.max(n, o.range.endLineNumber), {
              range: o.range,
              lane: r,
              persist: (_b3 = o.options.glyphMargin) == null ? void 0 : _b3.persistLane
            };
          })), i = i.concat(this._glyphMarginWidgets.getWidgets().map((o) => {
            const r = e.validateRange(o.preference.range);
            return n = Math.max(n, r.endLineNumber), {
              range: r,
              lane: o.preference.lane
            };
          })), i.sort((o, r) => z.compareRangesUsingStarts(o.range, r.range)), t.reset(n);
          for (const o of i) t.push(o.lane, o.range, o.persist);
          return t;
        }
        _createPointerHandlerHelper() {
          return {
            viewDomNode: this.domNode.domNode,
            linesContentDomNode: this._linesContent.domNode,
            viewLinesDomNode: this._viewLines.getDomNode().domNode,
            focusTextArea: () => {
              this.focus();
            },
            dispatchTextAreaEvent: (e) => {
              this._textAreaHandler.textArea.domNode.dispatchEvent(e);
            },
            getLastRenderData: () => {
              const e = this._viewCursors.getLastRenderData() || [], t = this._textAreaHandler.getLastRenderData();
              return new _le(e, t);
            },
            renderNow: () => {
              this.render(true, false);
            },
            shouldSuppressMouseDownOnViewZone: (e) => this._viewZones.shouldSuppressMouseDownOnViewZone(e),
            shouldSuppressMouseDownOnWidget: (e) => this._contentWidgets.shouldSuppressMouseDownOnWidget(e),
            getPositionFromDOMInfo: (e, t) => (this._flushAccumulatedAndRenderNow(), this._viewLines.getPositionFromDOMInfo(e, t)),
            visibleRangeForPosition: (e, t) => (this._flushAccumulatedAndRenderNow(), this._viewLines.visibleRangeForPosition(new X(e, t))),
            getLineWidth: (e) => (this._flushAccumulatedAndRenderNow(), this._viewLines.getLineWidth(e))
          };
        }
        _createTextAreaHandlerHelper() {
          return {
            visibleRangeForPosition: (e) => (this._flushAccumulatedAndRenderNow(), this._viewLines.visibleRangeForPosition(e))
          };
        }
        _applyLayout() {
          const t = this._context.configuration.options.get(146);
          this.domNode.setWidth(t.width), this.domNode.setHeight(t.height), this._overflowGuardContainer.setWidth(t.width), this._overflowGuardContainer.setHeight(t.height), this._linesContent.setWidth(16777216), this._linesContent.setHeight(16777216);
        }
        _getEditorClassName() {
          const e = this._textAreaHandler.isFocused() ? " focused" : "";
          return this._context.configuration.options.get(143) + " " + lD(this._context.theme.type) + e;
        }
        handleEvents(e) {
          super.handleEvents(e), this._scheduleRender();
        }
        onConfigurationChanged(e) {
          return this.domNode.setClassName(this._getEditorClassName()), this._applyLayout(), false;
        }
        onCursorStateChanged(e) {
          return this._selections = e.selections, false;
        }
        onDecorationsChanged(e) {
          return e.affectsGlyphMargin && (this._shouldRecomputeGlyphMarginLanes = true), false;
        }
        onFocusChanged(e) {
          return this.domNode.setClassName(this._getEditorClassName()), false;
        }
        onThemeChanged(e) {
          return this._context.theme.update(e.theme), this.domNode.setClassName(this._getEditorClassName()), false;
        }
        dispose() {
          this._renderAnimationFrame !== null && (this._renderAnimationFrame.dispose(), this._renderAnimationFrame = null), this._contentWidgets.overflowingContentWidgetsDomNode.domNode.remove(), this._context.removeEventHandler(this), this._viewLines.dispose();
          for (const e of this._viewParts) e.dispose();
          super.dispose();
        }
        _scheduleRender() {
          var _a3;
          if (this._store.isDisposed) throw new It();
          if (this._renderAnimationFrame === null) {
            const e = this._createCoordinatedRendering();
            this._renderAnimationFrame = rI.INSTANCE.scheduleCoordinatedRendering({
              window: Oe((_a3 = this.domNode) == null ? void 0 : _a3.domNode),
              prepareRenderText: () => {
                if (this._store.isDisposed) throw new It();
                try {
                  return e.prepareRenderText();
                } finally {
                  this._renderAnimationFrame = null;
                }
              },
              renderText: () => {
                if (this._store.isDisposed) throw new It();
                return e.renderText();
              },
              prepareRender: (t, i) => {
                if (this._store.isDisposed) throw new It();
                return e.prepareRender(t, i);
              },
              render: (t, i) => {
                if (this._store.isDisposed) throw new It();
                return e.render(t, i);
              }
            });
          }
        }
        _flushAccumulatedAndRenderNow() {
          const e = this._createCoordinatedRendering();
          jc(() => e.prepareRenderText());
          const t = jc(() => e.renderText());
          if (t) {
            const [i, n] = t;
            jc(() => e.prepareRender(i, n)), jc(() => e.render(i, n));
          }
        }
        _getViewPartsToRender() {
          const e = [];
          let t = 0;
          for (const i of this._viewParts) i.shouldRender() && (e[t++] = i);
          return e;
        }
        _createCoordinatedRendering() {
          return {
            prepareRenderText: () => {
              if (this._shouldRecomputeGlyphMarginLanes) {
                this._shouldRecomputeGlyphMarginLanes = false;
                const e = this._computeGlyphMarginLanes();
                this._context.configuration.setGlyphMarginDecorationLaneCount(e.requiredLanes);
              }
              Kc.onRenderStart();
            },
            renderText: () => {
              if (!this.domNode.domNode.isConnected) return null;
              let e = this._getViewPartsToRender();
              if (!this._viewLines.shouldRender() && e.length === 0) return null;
              const t = this._context.viewLayout.getLinesViewportData();
              this._context.viewModel.setViewport(t.startLineNumber, t.endLineNumber, t.centeredLineNumber);
              const i = new Qce(this._selections, t, this._context.viewLayout.getWhitespaceViewportData(), this._context.viewModel);
              return this._contentWidgets.shouldRender() && this._contentWidgets.onBeforeRender(i), this._viewLines.shouldRender() && (this._viewLines.renderText(i), this._viewLines.onDidRender(), e = this._getViewPartsToRender()), [
                e,
                new ule(this._context.viewLayout, i, this._viewLines)
              ];
            },
            prepareRender: (e, t) => {
              for (const i of e) i.prepareRender(t);
            },
            render: (e, t) => {
              for (const i of e) i.render(t), i.onDidRender();
            }
          };
        }
        delegateVerticalScrollbarPointerDown(e) {
          this._scrollbar.delegateVerticalScrollbarPointerDown(e);
        }
        delegateScrollFromMouseWheelEvent(e) {
          this._scrollbar.delegateScrollFromMouseWheelEvent(e);
        }
        restoreState(e) {
          this._context.viewModel.viewLayout.setScrollPosition({
            scrollTop: e.scrollTop,
            scrollLeft: e.scrollLeft
          }, 1), this._context.viewModel.visibleLinesStabilized();
        }
        getOffsetForColumn(e, t) {
          const i = this._context.viewModel.model.validatePosition({
            lineNumber: e,
            column: t
          }), n = this._context.viewModel.coordinatesConverter.convertModelPositionToViewPosition(i);
          this._flushAccumulatedAndRenderNow();
          const o = this._viewLines.visibleRangeForPosition(new X(n.lineNumber, n.column));
          return o ? o.left : -1;
        }
        getTargetAtClientPoint(e, t) {
          const i = this._pointerHandler.getTargetAtClientPoint(e, t);
          return i ? $w.convertViewToModelMouseTarget(i, this._context.viewModel.coordinatesConverter) : null;
        }
        createOverviewRuler(e) {
          return new Hce(this._context, e);
        }
        change(e) {
          this._viewZones.changeViewZones(e), this._scheduleRender();
        }
        render(e, t) {
          if (t) {
            this._viewLines.forceShouldRender();
            for (const i of this._viewParts) i.forceShouldRender();
          }
          e ? this._flushAccumulatedAndRenderNow() : this._scheduleRender();
        }
        writeScreenReaderContent(e) {
          this._textAreaHandler.writeScreenReaderContent(e);
        }
        focus() {
          this._textAreaHandler.focusTextArea();
        }
        isFocused() {
          return this._textAreaHandler.isFocused();
        }
        setAriaOptions(e) {
          this._textAreaHandler.setAriaOptions(e);
        }
        addContentWidget(e) {
          this._contentWidgets.addWidget(e.widget), this.layoutContentWidget(e), this._scheduleRender();
        }
        layoutContentWidget(e) {
          var _a3, _b3, _c2, _d2;
          this._contentWidgets.setWidgetPosition(e.widget, ((_a3 = e.position) == null ? void 0 : _a3.position) ?? null, ((_b3 = e.position) == null ? void 0 : _b3.secondaryPosition) ?? null, ((_c2 = e.position) == null ? void 0 : _c2.preference) ?? null, ((_d2 = e.position) == null ? void 0 : _d2.positionAffinity) ?? null), this._scheduleRender();
        }
        removeContentWidget(e) {
          this._contentWidgets.removeWidget(e.widget), this._scheduleRender();
        }
        addOverlayWidget(e) {
          this._overlayWidgets.addWidget(e.widget), this.layoutOverlayWidget(e), this._scheduleRender();
        }
        layoutOverlayWidget(e) {
          this._overlayWidgets.setWidgetPosition(e.widget, e.position) && this._scheduleRender();
        }
        removeOverlayWidget(e) {
          this._overlayWidgets.removeWidget(e.widget), this._scheduleRender();
        }
        addGlyphMarginWidget(e) {
          this._glyphMarginWidgets.addWidget(e.widget), this._shouldRecomputeGlyphMarginLanes = true, this._scheduleRender();
        }
        layoutGlyphMarginWidget(e) {
          const t = e.position;
          this._glyphMarginWidgets.setWidgetPosition(e.widget, t) && (this._shouldRecomputeGlyphMarginLanes = true, this._scheduleRender());
        }
        removeGlyphMarginWidget(e) {
          this._glyphMarginWidgets.removeWidget(e.widget), this._shouldRecomputeGlyphMarginLanes = true, this._scheduleRender();
        }
      };
      J2 = eue([
        tue(6, Ft)
      ], J2);
      function jc(s) {
        try {
          return s();
        } catch (e) {
          return qt(e), null;
        }
      }
      const _rI = class _rI {
        constructor() {
          this._coordinatedRenderings = [], this._animationFrameRunners = /* @__PURE__ */ new Map();
        }
        scheduleCoordinatedRendering(e) {
          return this._coordinatedRenderings.push(e), this._scheduleRender(e.window), {
            dispose: () => {
              const t = this._coordinatedRenderings.indexOf(e);
              if (t !== -1 && (this._coordinatedRenderings.splice(t, 1), this._coordinatedRenderings.length === 0)) {
                for (const [i, n] of this._animationFrameRunners) n.dispose();
                this._animationFrameRunners.clear();
              }
            }
          };
        }
        _scheduleRender(e) {
          if (!this._animationFrameRunners.has(e)) {
            const t = () => {
              this._animationFrameRunners.delete(e), this._onRenderScheduled();
            };
            this._animationFrameRunners.set(e, G9(e, t, 100));
          }
        }
        _onRenderScheduled() {
          const e = this._coordinatedRenderings.slice(0);
          this._coordinatedRenderings = [];
          for (const i of e) jc(() => i.prepareRenderText());
          const t = [];
          for (let i = 0, n = e.length; i < n; i++) {
            const o = e[i];
            t[i] = jc(() => o.renderText());
          }
          for (let i = 0, n = e.length; i < n; i++) {
            const o = e[i], r = t[i];
            if (!r) continue;
            const [a, l] = r;
            jc(() => o.prepareRender(a, l));
          }
          for (let i = 0, n = e.length; i < n; i++) {
            const o = e[i], r = t[i];
            if (!r) continue;
            const [a, l] = r;
            jc(() => o.render(a, l));
          }
        }
      };
      _rI.INSTANCE = new _rI();
      let rI = _rI;
      class Vp {
        constructor(e, t, i, n, o) {
          this.injectionOffsets = e, this.injectionOptions = t, this.breakOffsets = i, this.breakOffsetsVisibleColumn = n, this.wrappedTextIndentLength = o;
        }
        getOutputLineCount() {
          return this.breakOffsets.length;
        }
        getMinOutputOffset(e) {
          return e > 0 ? this.wrappedTextIndentLength : 0;
        }
        getLineLength(e) {
          const t = e > 0 ? this.breakOffsets[e - 1] : 0;
          let n = this.breakOffsets[e] - t;
          return e > 0 && (n += this.wrappedTextIndentLength), n;
        }
        getMaxOutputOffset(e) {
          return this.getLineLength(e);
        }
        translateToInputOffset(e, t) {
          e > 0 && (t = Math.max(0, t - this.wrappedTextIndentLength));
          let n = e === 0 ? t : this.breakOffsets[e - 1] + t;
          if (this.injectionOffsets !== null) for (let o = 0; o < this.injectionOffsets.length && n > this.injectionOffsets[o]; o++) n < this.injectionOffsets[o] + this.injectionOptions[o].content.length ? n = this.injectionOffsets[o] : n -= this.injectionOptions[o].content.length;
          return n;
        }
        translateToOutputPosition(e, t = 2) {
          let i = e;
          if (this.injectionOffsets !== null) for (let n = 0; n < this.injectionOffsets.length && !(e < this.injectionOffsets[n] || t !== 1 && e === this.injectionOffsets[n]); n++) i += this.injectionOptions[n].content.length;
          return this.offsetInInputWithInjectionsToOutputPosition(i, t);
        }
        offsetInInputWithInjectionsToOutputPosition(e, t = 2) {
          let i = 0, n = this.breakOffsets.length - 1, o = 0, r = 0;
          for (; i <= n; ) {
            o = i + (n - i) / 2 | 0;
            const l = this.breakOffsets[o];
            if (r = o > 0 ? this.breakOffsets[o - 1] : 0, t === 0) if (e <= r) n = o - 1;
            else if (e > l) i = o + 1;
            else break;
            else if (e < r) n = o - 1;
            else if (e >= l) i = o + 1;
            else break;
          }
          let a = e - r;
          return o > 0 && (a += this.wrappedTextIndentLength), new o0(o, a);
        }
        normalizeOutputPosition(e, t, i) {
          if (this.injectionOffsets !== null) {
            const n = this.outputPositionToOffsetInInputWithInjections(e, t), o = this.normalizeOffsetInInputWithInjectionsAroundInjections(n, i);
            if (o !== n) return this.offsetInInputWithInjectionsToOutputPosition(o, i);
          }
          if (i === 0) {
            if (e > 0 && t === this.getMinOutputOffset(e)) return new o0(e - 1, this.getMaxOutputOffset(e - 1));
          } else if (i === 1) {
            const n = this.getOutputLineCount() - 1;
            if (e < n && t === this.getMaxOutputOffset(e)) return new o0(e + 1, this.getMinOutputOffset(e + 1));
          }
          return new o0(e, t);
        }
        outputPositionToOffsetInInputWithInjections(e, t) {
          return e > 0 && (t = Math.max(0, t - this.wrappedTextIndentLength)), (e > 0 ? this.breakOffsets[e - 1] : 0) + t;
        }
        normalizeOffsetInInputWithInjectionsAroundInjections(e, t) {
          const i = this.getInjectedTextAtOffset(e);
          if (!i) return e;
          if (t === 2) {
            if (e === i.offsetInInputWithInjections + i.length && Q3(this.injectionOptions[i.injectedTextIndex].cursorStops)) return i.offsetInInputWithInjections + i.length;
            {
              let n = i.offsetInInputWithInjections;
              if (X3(this.injectionOptions[i.injectedTextIndex].cursorStops)) return n;
              let o = i.injectedTextIndex - 1;
              for (; o >= 0 && this.injectionOffsets[o] === this.injectionOffsets[i.injectedTextIndex] && !(Q3(this.injectionOptions[o].cursorStops) || (n -= this.injectionOptions[o].content.length, X3(this.injectionOptions[o].cursorStops))); ) o--;
              return n;
            }
          } else if (t === 1 || t === 4) {
            let n = i.offsetInInputWithInjections + i.length, o = i.injectedTextIndex;
            for (; o + 1 < this.injectionOffsets.length && this.injectionOffsets[o + 1] === this.injectionOffsets[o]; ) n += this.injectionOptions[o + 1].content.length, o++;
            return n;
          } else if (t === 0 || t === 3) {
            let n = i.offsetInInputWithInjections, o = i.injectedTextIndex;
            for (; o - 1 >= 0 && this.injectionOffsets[o - 1] === this.injectionOffsets[o]; ) n -= this.injectionOptions[o - 1].content.length, o--;
            return n;
          }
          gT();
        }
        getInjectedText(e, t) {
          const i = this.outputPositionToOffsetInInputWithInjections(e, t), n = this.getInjectedTextAtOffset(i);
          return n ? {
            options: this.injectionOptions[n.injectedTextIndex]
          } : null;
        }
        getInjectedTextAtOffset(e) {
          const t = this.injectionOffsets, i = this.injectionOptions;
          if (t !== null) {
            let n = 0;
            for (let o = 0; o < t.length; o++) {
              const r = i[o].content.length, a = t[o] + n, l = t[o] + n + r;
              if (a > e) break;
              if (e <= l) return {
                injectedTextIndex: o,
                offsetInInputWithInjections: a,
                length: r
              };
              n += r;
            }
          }
        }
      }
      function Q3(s) {
        return s == null ? true : s === ag.Right || s === ag.Both;
      }
      function X3(s) {
        return s == null ? true : s === ag.Left || s === ag.Both;
      }
      class o0 {
        constructor(e, t) {
          this.outputLineIndex = e, this.outputOffset = t;
        }
        toString() {
          return `${this.outputLineIndex}:${this.outputOffset}`;
        }
        toPosition(e) {
          return new X(e + this.outputLineIndex, this.outputOffset + 1);
        }
      }
      const iue = Xh("domLineBreaksComputer", {
        createHTML: (s) => s
      });
      class aI {
        static create(e) {
          return new aI(new WeakRef(e));
        }
        constructor(e) {
          this.targetWindow = e;
        }
        createLineBreaksComputer(e, t, i, n, o) {
          const r = [], a = [];
          return {
            addRequest: (l, u, d) => {
              r.push(l), a.push(u);
            },
            finalize: () => nue(G7(this.targetWindow.deref()), r, e, t, i, n, o, a)
          };
        }
      }
      function nue(s, e, t, i, n, o, r, a) {
        function l(A) {
          const Y = a[A];
          if (Y) {
            const U = Kr.applyInjectedText(e[A], Y), j = Y.map((K) => K.options), ee = Y.map((K) => K.column - 1);
            return new Vp(ee, j, [
              U.length
            ], [], 0);
          } else return null;
        }
        if (n === -1) {
          const A = [];
          for (let Y = 0, U = e.length; Y < U; Y++) A[Y] = l(Y);
          return A;
        }
        const u = Math.round(n * t.typicalHalfwidthCharacterWidth), f = Math.round(i * (o === 3 ? 2 : o === 2 ? 1 : 0)), m = Math.ceil(t.spaceWidth * f), _ = document.createElement("div");
        Un(_, t);
        const b = new iw(1e4), v = [], y = [], x = [], L = [], D = [];
        for (let A = 0; A < e.length; A++) {
          const Y = Kr.applyInjectedText(e[A], a[A]);
          let U = 0, j = 0, ee = u;
          if (o !== 0) if (U = qs(Y), U === -1) U = 0;
          else {
            for (let se = 0; se < U; se++) {
              const de = Y.charCodeAt(se) === 9 ? i - j % i : 1;
              j += de;
            }
            const H = Math.ceil(t.spaceWidth * j);
            H + t.typicalFullwidthCharacterWidth > u ? (U = 0, j = 0) : ee = u - H;
          }
          const K = Y.substr(U), te = sue(K, j, i, ee, b, m);
          v[A] = U, y[A] = j, x[A] = K, L[A] = te[0], D[A] = te[1];
        }
        const k = b.build(), T = (iue == null ? void 0 : iue.createHTML(k)) ?? k;
        _.innerHTML = T, _.style.position = "absolute", _.style.top = "10000", r === "keepAll" ? (_.style.wordBreak = "keep-all", _.style.overflowWrap = "anywhere") : (_.style.wordBreak = "inherit", _.style.overflowWrap = "break-word"), s.document.body.appendChild(_);
        const M = document.createRange(), I = Array.prototype.slice.call(_.children, 0), R = [];
        for (let A = 0; A < e.length; A++) {
          const Y = I[A], U = oue(M, Y, x[A], L[A]);
          if (U === null) {
            R[A] = l(A);
            continue;
          }
          const j = v[A], ee = y[A] + f, K = D[A], te = [];
          for (let fe = 0, W = U.length; fe < W; fe++) te[fe] = K[U[fe]];
          if (j !== 0) for (let fe = 0, W = U.length; fe < W; fe++) U[fe] += j;
          let H, se;
          const de = a[A];
          de ? (H = de.map((fe) => fe.options), se = de.map((fe) => fe.column - 1)) : (H = null, se = null), R[A] = new Vp(se, H, U, te, ee);
        }
        return _.remove(), R;
      }
      function sue(s, e, t, i, n, o) {
        if (o !== 0) {
          const m = String(o);
          n.appendString('<div style="text-indent: -'), n.appendString(m), n.appendString("px; padding-left: "), n.appendString(m), n.appendString("px; box-sizing: border-box; width:");
        } else n.appendString('<div style="width:');
        n.appendString(String(i)), n.appendString('px;">');
        const r = s.length;
        let a = e, l = 0;
        const u = [], d = [];
        let f = 0 < r ? s.charCodeAt(0) : 0;
        n.appendString("<span>");
        for (let m = 0; m < r; m++) {
          m !== 0 && m % 16384 === 0 && n.appendString("</span><span>"), u[m] = l, d[m] = a;
          const _ = f;
          f = m + 1 < r ? s.charCodeAt(m + 1) : 0;
          let b = 1, v = 1;
          switch (_) {
            case 9:
              b = t - a % t, v = b;
              for (let y = 1; y <= b; y++) y < b ? n.appendCharCode(160) : n.appendASCIICharCode(32);
              break;
            case 32:
              f === 32 ? n.appendCharCode(160) : n.appendASCIICharCode(32);
              break;
            case 60:
              n.appendString("&lt;");
              break;
            case 62:
              n.appendString("&gt;");
              break;
            case 38:
              n.appendString("&amp;");
              break;
            case 0:
              n.appendString("&#00;");
              break;
            case 65279:
            case 8232:
            case 8233:
            case 133:
              n.appendCharCode(65533);
              break;
            default:
              nu(_) && v++, _ < 32 ? n.appendCharCode(9216 + _) : n.appendCharCode(_);
          }
          l += b, a += v;
        }
        return n.appendString("</span>"), u[s.length] = l, d[s.length] = a, n.appendString("</div>"), [
          u,
          d
        ];
      }
      function oue(s, e, t, i) {
        if (t.length <= 1) return null;
        const n = Array.prototype.slice.call(e.children, 0), o = [];
        try {
          eE(s, n, i, 0, null, t.length - 1, null, o);
        } catch (r) {
          return console.log(r), null;
        }
        return o.length === 0 ? null : (o.push(t.length), o);
      }
      function eE(s, e, t, i, n, o, r, a) {
        if (i === o || (n = n || Lx(s, e, t[i], t[i + 1]), r = r || Lx(s, e, t[o], t[o + 1]), Math.abs(n[0].top - r[0].top) <= 0.1)) return;
        if (i + 1 === o) {
          a.push(o);
          return;
        }
        const l = i + (o - i) / 2 | 0, u = Lx(s, e, t[l], t[l + 1]);
        eE(s, e, t, i, n, l, u, a), eE(s, e, t, l, u, o, r, a);
      }
      function Lx(s, e, t, i) {
        return s.setStart(e[t / 16384 | 0].firstChild, t % 16384), s.setEnd(e[i / 16384 | 0].firstChild, i % 16384), s.getClientRects();
      }
      class rue extends he {
        constructor() {
          super(), this._editor = null, this._instantiationService = null, this._instances = this._register(new VE()), this._pending = /* @__PURE__ */ new Map(), this._finishedInstantiation = [], this._finishedInstantiation[0] = false, this._finishedInstantiation[1] = false, this._finishedInstantiation[2] = false, this._finishedInstantiation[3] = false;
        }
        initialize(e, t, i) {
          this._editor = e, this._instantiationService = i;
          for (const n of t) {
            if (this._pending.has(n.id)) {
              qt(new Error(`Cannot have two contributions with the same id ${n.id}`));
              continue;
            }
            this._pending.set(n.id, n);
          }
          this._instantiateSome(0), this._register(Db(Oe(this._editor.getDomNode()), () => {
            this._instantiateSome(1);
          })), this._register(Db(Oe(this._editor.getDomNode()), () => {
            this._instantiateSome(2);
          })), this._register(Db(Oe(this._editor.getDomNode()), () => {
            this._instantiateSome(3);
          }, 5e3));
        }
        saveViewState() {
          const e = {};
          for (const [t, i] of this._instances) typeof i.saveViewState == "function" && (e[t] = i.saveViewState());
          return e;
        }
        restoreViewState(e) {
          for (const [t, i] of this._instances) typeof i.restoreViewState == "function" && i.restoreViewState(e[t]);
        }
        get(e) {
          return this._instantiateById(e), this._instances.get(e) || null;
        }
        onBeforeInteractionEvent() {
          this._instantiateSome(2);
        }
        onAfterModelAttached() {
          var _a3;
          return Db(Oe((_a3 = this._editor) == null ? void 0 : _a3.getDomNode()), () => {
            this._instantiateSome(1);
          }, 50);
        }
        _instantiateSome(e) {
          if (this._finishedInstantiation[e]) return;
          this._finishedInstantiation[e] = true;
          const t = this._findPendingContributionsByInstantiation(e);
          for (const i of t) this._instantiateById(i.id);
        }
        _findPendingContributionsByInstantiation(e) {
          const t = [];
          for (const [, i] of this._pending) i.instantiation === e && t.push(i);
          return t;
        }
        _instantiateById(e) {
          const t = this._pending.get(e);
          if (t) {
            if (this._pending.delete(e), !this._instantiationService || !this._editor) throw new Error("Cannot instantiate contributions before being initialized!");
            try {
              const i = this._instantiationService.createInstance(t.ctor, this._editor);
              this._instances.set(t.id, i), typeof i.restoreViewState == "function" && t.instantiation !== 0 && console.warn(`Editor contribution '${t.id}' should be eager instantiated because it uses saveViewState / restoreViewState.`);
            } catch (i) {
              qt(i);
            }
          }
        }
      }
      class VF {
        constructor(e, t, i, n, o, r, a) {
          this.id = e, this.label = t, this.alias = i, this.metadata = n, this._precondition = o, this._run = r, this._contextKeyService = a;
        }
        isSupported() {
          return this._contextKeyService.contextMatchesRules(this._precondition);
        }
        run(e) {
          return this.isSupported() ? this._run(e) : Promise.resolve(void 0);
        }
      }
      class lI {
        static create(e) {
          return new lI(e.get(135), e.get(134));
        }
        constructor(e, t) {
          this.classifier = new aue(e, t);
        }
        createLineBreaksComputer(e, t, i, n, o) {
          const r = [], a = [], l = [];
          return {
            addRequest: (u, d, f) => {
              r.push(u), a.push(d), l.push(f);
            },
            finalize: () => {
              const u = e.typicalFullwidthCharacterWidth / e.typicalHalfwidthCharacterWidth, d = [];
              for (let f = 0, m = r.length; f < m; f++) {
                const _ = a[f], b = l[f];
                b && !b.injectionOptions && !_ ? d[f] = lue(this.classifier, b, r[f], t, i, u, n, o) : d[f] = cue(this.classifier, r[f], _, t, i, u, n, o);
              }
              return tE.length = 0, iE.length = 0, d;
            }
          };
        }
      }
      class aue extends q_ {
        constructor(e, t) {
          super(0);
          for (let i = 0; i < e.length; i++) this.set(e.charCodeAt(i), 1);
          for (let i = 0; i < t.length; i++) this.set(t.charCodeAt(i), 2);
        }
        get(e) {
          return e >= 0 && e < 256 ? this._asciiMap[e] : e >= 12352 && e <= 12543 || e >= 13312 && e <= 19903 || e >= 19968 && e <= 40959 ? 3 : this._map.get(e) || this._defaultValue;
        }
      }
      let tE = [], iE = [];
      function lue(s, e, t, i, n, o, r, a) {
        if (n === -1) return null;
        const l = t.length;
        if (l <= 1) return null;
        const u = a === "keepAll", d = e.breakOffsets, f = e.breakOffsetsVisibleColumn, m = WF(t, i, n, o, r), _ = n - m, b = tE, v = iE;
        let y = 0, x = 0, L = 0, D = n;
        const k = d.length;
        let T = 0;
        if (T >= 0) {
          let M = Math.abs(f[T] - D);
          for (; T + 1 < k; ) {
            const I = Math.abs(f[T + 1] - D);
            if (I >= M) break;
            M = I, T++;
          }
        }
        for (; T < k; ) {
          let M = T < 0 ? 0 : d[T], I = T < 0 ? 0 : f[T];
          x > M && (M = x, I = L);
          let R = 0, A = 0, Y = 0, U = 0;
          if (I <= D) {
            let ee = I, K = M === 0 ? 0 : t.charCodeAt(M - 1), te = M === 0 ? 0 : s.get(K), H = true;
            for (let se = M; se < l; se++) {
              const de = se, fe = t.charCodeAt(se);
              let W, ne;
              if (on(fe) ? (se++, W = 0, ne = 2) : (W = s.get(fe), ne = Wp(fe, ee, i, o)), de > x && nE(K, te, fe, W, u) && (R = de, A = ee), ee += ne, ee > D) {
                de > x ? (Y = de, U = ee - ne) : (Y = se + 1, U = ee), ee - A > _ && (R = 0), H = false;
                break;
              }
              K = fe, te = W;
            }
            if (H) {
              y > 0 && (b[y] = d[d.length - 1], v[y] = f[d.length - 1], y++);
              break;
            }
          }
          if (R === 0) {
            let ee = I, K = t.charCodeAt(M), te = s.get(K), H = false;
            for (let se = M - 1; se >= x; se--) {
              const de = se + 1, fe = t.charCodeAt(se);
              if (fe === 9) {
                H = true;
                break;
              }
              let W, ne;
              if (ig(fe) ? (se--, W = 0, ne = 2) : (W = s.get(fe), ne = nu(fe) ? o : 1), ee <= D) {
                if (Y === 0 && (Y = de, U = ee), ee <= D - _) break;
                if (nE(fe, W, K, te, u)) {
                  R = de, A = ee;
                  break;
                }
              }
              ee -= ne, K = fe, te = W;
            }
            if (R !== 0) {
              const se = _ - (U - A);
              if (se <= i) {
                const de = t.charCodeAt(Y);
                let fe;
                on(de) ? fe = 2 : fe = Wp(de, U, i, o), se - fe < 0 && (R = 0);
              }
            }
            if (H) {
              T--;
              continue;
            }
          }
          if (R === 0 && (R = Y, A = U), R <= x) {
            const ee = t.charCodeAt(x);
            on(ee) ? (R = x + 2, A = L + 2) : (R = x + 1, A = L + Wp(ee, L, i, o));
          }
          for (x = R, b[y] = R, L = A, v[y] = A, y++, D = A + _; T < 0 || T < k && f[T] < A; ) T++;
          let j = Math.abs(f[T] - D);
          for (; T + 1 < k; ) {
            const ee = Math.abs(f[T + 1] - D);
            if (ee >= j) break;
            j = ee, T++;
          }
        }
        return y === 0 ? null : (b.length = y, v.length = y, tE = e.breakOffsets, iE = e.breakOffsetsVisibleColumn, e.breakOffsets = b, e.breakOffsetsVisibleColumn = v, e.wrappedTextIndentLength = m, e);
      }
      function cue(s, e, t, i, n, o, r, a) {
        const l = Kr.applyInjectedText(e, t);
        let u, d;
        if (t && t.length > 0 ? (u = t.map((A) => A.options), d = t.map((A) => A.column - 1)) : (u = null, d = null), n === -1) return u ? new Vp(d, u, [
          l.length
        ], [], 0) : null;
        const f = l.length;
        if (f <= 1) return u ? new Vp(d, u, [
          l.length
        ], [], 0) : null;
        const m = a === "keepAll", _ = WF(l, i, n, o, r), b = n - _, v = [], y = [];
        let x = 0, L = 0, D = 0, k = n, T = l.charCodeAt(0), M = s.get(T), I = Wp(T, 0, i, o), R = 1;
        on(T) && (I += 1, T = l.charCodeAt(1), M = s.get(T), R++);
        for (let A = R; A < f; A++) {
          const Y = A, U = l.charCodeAt(A);
          let j, ee;
          on(U) ? (A++, j = 0, ee = 2) : (j = s.get(U), ee = Wp(U, I, i, o)), nE(T, M, U, j, m) && (L = Y, D = I), I += ee, I > k && ((L === 0 || I - D > b) && (L = Y, D = I - ee), v[x] = L, y[x] = D, x++, k = D + b, L = 0), T = U, M = j;
        }
        return x === 0 && (!t || t.length === 0) ? null : (v[x] = f, y[x] = I, new Vp(d, u, v, y, _));
      }
      function Wp(s, e, t, i) {
        return s === 9 ? t - e % t : nu(s) || s < 32 ? i : 1;
      }
      function J3(s, e) {
        return e - s % e;
      }
      function nE(s, e, t, i, n) {
        return t !== 32 && (e === 2 && i !== 2 || e !== 1 && i === 1 || !n && e === 3 && i !== 2 || !n && i === 3 && e !== 1);
      }
      function WF(s, e, t, i, n) {
        let o = 0;
        if (n !== 0) {
          const r = qs(s);
          if (r !== -1) {
            for (let l = 0; l < r; l++) {
              const u = s.charCodeAt(l) === 9 ? J3(o, e) : 1;
              o += u;
            }
            const a = n === 3 ? 2 : n === 2 ? 1 : 0;
            for (let l = 0; l < a; l++) {
              const u = J3(o, e);
              o += u;
            }
            o + i > t && (o = 0);
          }
        }
        return o;
      }
      class wC {
        constructor(e) {
          this._selTrackedRange = null, this._trackSelection = true, this._setState(e, new bn(new z(1, 1, 1, 1), 0, 0, new X(1, 1), 0), new bn(new z(1, 1, 1, 1), 0, 0, new X(1, 1), 0));
        }
        dispose(e) {
          this._removeTrackedRange(e);
        }
        startTrackingSelection(e) {
          this._trackSelection = true, this._updateTrackedRange(e);
        }
        stopTrackingSelection(e) {
          this._trackSelection = false, this._removeTrackedRange(e);
        }
        _updateTrackedRange(e) {
          this._trackSelection && (this._selTrackedRange = e.model._setTrackedRange(this._selTrackedRange, this.modelState.selection, 0));
        }
        _removeTrackedRange(e) {
          this._selTrackedRange = e.model._setTrackedRange(this._selTrackedRange, null, 0);
        }
        asCursorState() {
          return new lt(this.modelState, this.viewState);
        }
        readSelectionFromMarkers(e) {
          const t = e.model._getTrackedRange(this._selTrackedRange);
          return this.modelState.selection.isEmpty() && !t.isEmpty() ? mt.fromRange(t.collapseToEnd(), this.modelState.selection.getDirection()) : mt.fromRange(t, this.modelState.selection.getDirection());
        }
        ensureValidState(e) {
          this._setState(e, this.modelState, this.viewState);
        }
        setState(e, t, i) {
          this._setState(e, t, i);
        }
        static _validatePositionWithCache(e, t, i, n) {
          return t.equals(i) ? n : e.normalizePosition(t, 2);
        }
        static _validateViewState(e, t) {
          const i = t.position, n = t.selectionStart.getStartPosition(), o = t.selectionStart.getEndPosition(), r = e.normalizePosition(i, 2), a = this._validatePositionWithCache(e, n, i, r), l = this._validatePositionWithCache(e, o, n, a);
          return i.equals(r) && n.equals(a) && o.equals(l) ? t : new bn(z.fromPositions(a, l), t.selectionStartKind, t.selectionStartLeftoverVisibleColumns + n.column - a.column, r, t.leftoverVisibleColumns + i.column - r.column);
        }
        _setState(e, t, i) {
          if (i && (i = wC._validateViewState(e.viewModel, i)), t) {
            const n = e.model.validateRange(t.selectionStart), o = t.selectionStart.equalsRange(n) ? t.selectionStartLeftoverVisibleColumns : 0, r = e.model.validatePosition(t.position), a = t.position.equals(r) ? t.leftoverVisibleColumns : 0;
            t = new bn(n, t.selectionStartKind, o, r, a);
          } else {
            if (!i) return;
            const n = e.model.validateRange(e.coordinatesConverter.convertViewRangeToModelRange(i.selectionStart)), o = e.model.validatePosition(e.coordinatesConverter.convertViewPositionToModelPosition(i.position));
            t = new bn(n, i.selectionStartKind, i.selectionStartLeftoverVisibleColumns, o, i.leftoverVisibleColumns);
          }
          if (i) {
            const n = e.coordinatesConverter.validateViewRange(i.selectionStart, t.selectionStart), o = e.coordinatesConverter.validateViewPosition(i.position, t.position);
            i = new bn(n, t.selectionStartKind, t.selectionStartLeftoverVisibleColumns, o, t.leftoverVisibleColumns);
          } else {
            const n = e.coordinatesConverter.convertModelPositionToViewPosition(new X(t.selectionStart.startLineNumber, t.selectionStart.startColumn)), o = e.coordinatesConverter.convertModelPositionToViewPosition(new X(t.selectionStart.endLineNumber, t.selectionStart.endColumn)), r = new z(n.lineNumber, n.column, o.lineNumber, o.column), a = e.coordinatesConverter.convertModelPositionToViewPosition(t.position);
            i = new bn(r, t.selectionStartKind, t.selectionStartLeftoverVisibleColumns, a, t.leftoverVisibleColumns);
          }
          this.modelState = t, this.viewState = i, this._updateTrackedRange(e);
        }
      }
      class e7 {
        constructor(e) {
          this.context = e, this.cursors = [
            new wC(e)
          ], this.lastAddedCursorIndex = 0;
        }
        dispose() {
          for (const e of this.cursors) e.dispose(this.context);
        }
        startTrackingSelections() {
          for (const e of this.cursors) e.startTrackingSelection(this.context);
        }
        stopTrackingSelections() {
          for (const e of this.cursors) e.stopTrackingSelection(this.context);
        }
        updateContext(e) {
          this.context = e;
        }
        ensureValidState() {
          for (const e of this.cursors) e.ensureValidState(this.context);
        }
        readSelectionFromMarkers() {
          return this.cursors.map((e) => e.readSelectionFromMarkers(this.context));
        }
        getAll() {
          return this.cursors.map((e) => e.asCursorState());
        }
        getViewPositions() {
          return this.cursors.map((e) => e.viewState.position);
        }
        getTopMostViewPosition() {
          return QG(this.cursors, fr((e) => e.viewState.position, X.compare)).viewState.position;
        }
        getBottomMostViewPosition() {
          return ZG(this.cursors, fr((e) => e.viewState.position, X.compare)).viewState.position;
        }
        getSelections() {
          return this.cursors.map((e) => e.modelState.selection);
        }
        getViewSelections() {
          return this.cursors.map((e) => e.viewState.selection);
        }
        setSelections(e) {
          this.setStates(lt.fromModelSelections(e));
        }
        getPrimaryCursor() {
          return this.cursors[0].asCursorState();
        }
        setStates(e) {
          e !== null && (this.cursors[0].setState(this.context, e[0].modelState, e[0].viewState), this._setSecondaryStates(e.slice(1)));
        }
        _setSecondaryStates(e) {
          const t = this.cursors.length - 1, i = e.length;
          if (t < i) {
            const n = i - t;
            for (let o = 0; o < n; o++) this._addSecondaryCursor();
          } else if (t > i) {
            const n = t - i;
            for (let o = 0; o < n; o++) this._removeSecondaryCursor(this.cursors.length - 2);
          }
          for (let n = 0; n < i; n++) this.cursors[n + 1].setState(this.context, e[n].modelState, e[n].viewState);
        }
        killSecondaryCursors() {
          this._setSecondaryStates([]);
        }
        _addSecondaryCursor() {
          this.cursors.push(new wC(this.context)), this.lastAddedCursorIndex = this.cursors.length - 1;
        }
        getLastAddedCursorIndex() {
          return this.cursors.length === 1 || this.lastAddedCursorIndex === 0 ? 0 : this.lastAddedCursorIndex;
        }
        _removeSecondaryCursor(e) {
          this.lastAddedCursorIndex >= e + 1 && this.lastAddedCursorIndex--, this.cursors[e + 1].dispose(this.context), this.cursors.splice(e + 1, 1);
        }
        normalize() {
          if (this.cursors.length === 1) return;
          const e = this.cursors.slice(0), t = [];
          for (let i = 0, n = e.length; i < n; i++) t.push({
            index: i,
            selection: e[i].modelState.selection
          });
          t.sort(fr((i) => i.selection, z.compareRangesUsingStarts));
          for (let i = 0; i < t.length - 1; i++) {
            const n = t[i], o = t[i + 1], r = n.selection, a = o.selection;
            if (!this.context.cursorConfig.multiCursorMergeOverlapping) continue;
            let l;
            if (a.isEmpty() || r.isEmpty() ? l = a.getStartPosition().isBeforeOrEqual(r.getEndPosition()) : l = a.getStartPosition().isBefore(r.getEndPosition()), l) {
              const u = n.index < o.index ? i : i + 1, d = n.index < o.index ? i + 1 : i, f = t[d].index, m = t[u].index, _ = t[d].selection, b = t[u].selection;
              if (!_.equalsSelection(b)) {
                const v = _.plusRange(b), y = _.selectionStartLineNumber === _.startLineNumber && _.selectionStartColumn === _.startColumn, x = b.selectionStartLineNumber === b.startLineNumber && b.selectionStartColumn === b.startColumn;
                let L;
                f === this.lastAddedCursorIndex ? (L = y, this.lastAddedCursorIndex = m) : L = x;
                let D;
                L ? D = new mt(v.startLineNumber, v.startColumn, v.endLineNumber, v.endColumn) : D = new mt(v.endLineNumber, v.endColumn, v.startLineNumber, v.startColumn), t[u].selection = D;
                const k = lt.fromModelSelection(D);
                e[m].setState(this.context, k.modelState, k.viewState);
              }
              for (const v of t) v.index > f && v.index--;
              e.splice(f, 1), t.splice(d, 1), this._removeSecondaryCursor(f - 1), i--;
            }
          }
        }
      }
      class t7 {
        constructor(e, t, i, n) {
          this._cursorContextBrand = void 0, this.model = e, this.viewModel = t, this.coordinatesConverter = i, this.cursorConfig = n;
        }
      }
      class uue {
        constructor() {
          this.type = 0;
        }
      }
      class hue {
        constructor() {
          this.type = 1;
        }
      }
      class due {
        constructor(e) {
          this.type = 2, this._source = e;
        }
        hasChanged(e) {
          return this._source.hasChanged(e);
        }
      }
      class fue {
        constructor(e, t, i) {
          this.selections = e, this.modelSelections = t, this.reason = i, this.type = 3;
        }
      }
      class zu {
        constructor(e) {
          this.type = 4, e ? (this.affectsMinimap = e.affectsMinimap, this.affectsOverviewRuler = e.affectsOverviewRuler, this.affectsGlyphMargin = e.affectsGlyphMargin, this.affectsLineNumber = e.affectsLineNumber) : (this.affectsMinimap = true, this.affectsOverviewRuler = true, this.affectsGlyphMargin = true, this.affectsLineNumber = true);
        }
      }
      class r0 {
        constructor() {
          this.type = 5;
        }
      }
      class gue {
        constructor(e) {
          this.type = 6, this.isFocused = e;
        }
      }
      class mue {
        constructor() {
          this.type = 7;
        }
      }
      class a0 {
        constructor() {
          this.type = 8;
        }
      }
      class HF {
        constructor(e, t) {
          this.fromLineNumber = e, this.count = t, this.type = 9;
        }
      }
      class sE {
        constructor(e, t) {
          this.type = 10, this.fromLineNumber = e, this.toLineNumber = t;
        }
      }
      class oE {
        constructor(e, t) {
          this.type = 11, this.fromLineNumber = e, this.toLineNumber = t;
        }
      }
      class Hp {
        constructor(e, t, i, n, o, r, a) {
          this.source = e, this.minimalReveal = t, this.range = i, this.selections = n, this.verticalType = o, this.revealHorizontal = r, this.scrollType = a, this.type = 12;
        }
      }
      class pue {
        constructor(e) {
          this.type = 13, this.scrollWidth = e.scrollWidth, this.scrollLeft = e.scrollLeft, this.scrollHeight = e.scrollHeight, this.scrollTop = e.scrollTop, this.scrollWidthChanged = e.scrollWidthChanged, this.scrollLeftChanged = e.scrollLeftChanged, this.scrollHeightChanged = e.scrollHeightChanged, this.scrollTopChanged = e.scrollTopChanged;
        }
      }
      class _ue {
        constructor(e) {
          this.theme = e, this.type = 14;
        }
      }
      class bue {
        constructor(e) {
          this.type = 15, this.ranges = e;
        }
      }
      class vue {
        constructor() {
          this.type = 16;
        }
      }
      let Cue = class {
        constructor() {
          this.type = 17;
        }
      };
      class wue extends he {
        constructor() {
          super(), this._onEvent = this._register(new G()), this.onEvent = this._onEvent.event, this._eventHandlers = [], this._viewEventQueue = null, this._isConsumingViewEventQueue = false, this._collector = null, this._collectorCnt = 0, this._outgoingEvents = [];
        }
        emitOutgoingEvent(e) {
          this._addOutgoingEvent(e), this._emitOutgoingEvents();
        }
        _addOutgoingEvent(e) {
          for (let t = 0, i = this._outgoingEvents.length; t < i; t++) {
            const n = this._outgoingEvents[t].kind === e.kind ? this._outgoingEvents[t].attemptToMerge(e) : null;
            if (n) {
              this._outgoingEvents[t] = n;
              return;
            }
          }
          this._outgoingEvents.push(e);
        }
        _emitOutgoingEvents() {
          for (; this._outgoingEvents.length > 0; ) {
            if (this._collector || this._isConsumingViewEventQueue) return;
            const e = this._outgoingEvents.shift();
            e.isNoOp() || this._onEvent.fire(e);
          }
        }
        addViewEventHandler(e) {
          for (let t = 0, i = this._eventHandlers.length; t < i; t++) this._eventHandlers[t] === e && console.warn("Detected duplicate listener in ViewEventDispatcher", e);
          this._eventHandlers.push(e);
        }
        removeViewEventHandler(e) {
          for (let t = 0; t < this._eventHandlers.length; t++) if (this._eventHandlers[t] === e) {
            this._eventHandlers.splice(t, 1);
            break;
          }
        }
        beginEmitViewEvents() {
          return this._collectorCnt++, this._collectorCnt === 1 && (this._collector = new yue()), this._collector;
        }
        endEmitViewEvents() {
          if (this._collectorCnt--, this._collectorCnt === 0) {
            const e = this._collector.outgoingEvents, t = this._collector.viewEvents;
            this._collector = null;
            for (const i of e) this._addOutgoingEvent(i);
            t.length > 0 && this._emitMany(t);
          }
          this._emitOutgoingEvents();
        }
        emitSingleViewEvent(e) {
          try {
            this.beginEmitViewEvents().emitViewEvent(e);
          } finally {
            this.endEmitViewEvents();
          }
        }
        _emitMany(e) {
          this._viewEventQueue ? this._viewEventQueue = this._viewEventQueue.concat(e) : this._viewEventQueue = e, this._isConsumingViewEventQueue || this._consumeViewEventQueue();
        }
        _consumeViewEventQueue() {
          try {
            this._isConsumingViewEventQueue = true, this._doConsumeQueue();
          } finally {
            this._isConsumingViewEventQueue = false;
          }
        }
        _doConsumeQueue() {
          for (; this._viewEventQueue; ) {
            const e = this._viewEventQueue;
            this._viewEventQueue = null;
            const t = this._eventHandlers.slice(0);
            for (const i of t) i.handleEvents(e);
          }
        }
      }
      class yue {
        constructor() {
          this.viewEvents = [], this.outgoingEvents = [];
        }
        emitViewEvent(e) {
          this.viewEvents.push(e);
        }
        emitOutgoingEvent(e) {
          this.outgoingEvents.push(e);
        }
      }
      class cI {
        constructor(e, t, i, n) {
          this.kind = 0, this._oldContentWidth = e, this._oldContentHeight = t, this.contentWidth = i, this.contentHeight = n, this.contentWidthChanged = this._oldContentWidth !== this.contentWidth, this.contentHeightChanged = this._oldContentHeight !== this.contentHeight;
        }
        isNoOp() {
          return !this.contentWidthChanged && !this.contentHeightChanged;
        }
        attemptToMerge(e) {
          return e.kind !== this.kind ? null : new cI(this._oldContentWidth, this._oldContentHeight, e.contentWidth, e.contentHeight);
        }
      }
      class uI {
        constructor(e, t) {
          this.kind = 1, this.oldHasFocus = e, this.hasFocus = t;
        }
        isNoOp() {
          return this.oldHasFocus === this.hasFocus;
        }
        attemptToMerge(e) {
          return e.kind !== this.kind ? null : new uI(this.oldHasFocus, e.hasFocus);
        }
      }
      class hI {
        constructor(e, t, i, n, o, r, a, l) {
          this.kind = 2, this._oldScrollWidth = e, this._oldScrollLeft = t, this._oldScrollHeight = i, this._oldScrollTop = n, this.scrollWidth = o, this.scrollLeft = r, this.scrollHeight = a, this.scrollTop = l, this.scrollWidthChanged = this._oldScrollWidth !== this.scrollWidth, this.scrollLeftChanged = this._oldScrollLeft !== this.scrollLeft, this.scrollHeightChanged = this._oldScrollHeight !== this.scrollHeight, this.scrollTopChanged = this._oldScrollTop !== this.scrollTop;
        }
        isNoOp() {
          return !this.scrollWidthChanged && !this.scrollLeftChanged && !this.scrollHeightChanged && !this.scrollTopChanged;
        }
        attemptToMerge(e) {
          return e.kind !== this.kind ? null : new hI(this._oldScrollWidth, this._oldScrollLeft, this._oldScrollHeight, this._oldScrollTop, e.scrollWidth, e.scrollLeft, e.scrollHeight, e.scrollTop);
        }
      }
      class Sue {
        constructor() {
          this.kind = 3;
        }
        isNoOp() {
          return false;
        }
        attemptToMerge(e) {
          return e.kind !== this.kind ? null : this;
        }
      }
      class Lue {
        constructor() {
          this.kind = 4;
        }
        isNoOp() {
          return false;
        }
        attemptToMerge(e) {
          return e.kind !== this.kind ? null : this;
        }
      }
      class yC {
        constructor(e, t, i, n, o, r, a) {
          this.kind = 6, this.oldSelections = e, this.selections = t, this.oldModelVersionId = i, this.modelVersionId = n, this.source = o, this.reason = r, this.reachedMaxCursorCount = a;
        }
        static _selectionsAreEqual(e, t) {
          if (!e && !t) return true;
          if (!e || !t) return false;
          const i = e.length, n = t.length;
          if (i !== n) return false;
          for (let o = 0; o < i; o++) if (!e[o].equalsSelection(t[o])) return false;
          return true;
        }
        isNoOp() {
          return yC._selectionsAreEqual(this.oldSelections, this.selections) && this.oldModelVersionId === this.modelVersionId;
        }
        attemptToMerge(e) {
          return e.kind !== this.kind ? null : new yC(this.oldSelections, e.selections, this.oldModelVersionId, e.modelVersionId, e.source, e.reason, this.reachedMaxCursorCount || e.reachedMaxCursorCount);
        }
      }
      class xue {
        constructor() {
          this.kind = 5;
        }
        isNoOp() {
          return false;
        }
        attemptToMerge(e) {
          return e.kind !== this.kind ? null : this;
        }
      }
      class kue {
        constructor(e) {
          this.event = e, this.kind = 7;
        }
        isNoOp() {
          return false;
        }
        attemptToMerge(e) {
          return null;
        }
      }
      class Due {
        constructor(e) {
          this.event = e, this.kind = 8;
        }
        isNoOp() {
          return false;
        }
        attemptToMerge(e) {
          return null;
        }
      }
      class Eue {
        constructor(e) {
          this.event = e, this.kind = 9;
        }
        isNoOp() {
          return false;
        }
        attemptToMerge(e) {
          return null;
        }
      }
      class Tue {
        constructor(e) {
          this.event = e, this.kind = 10;
        }
        isNoOp() {
          return false;
        }
        attemptToMerge(e) {
          return null;
        }
      }
      class Nue {
        constructor(e) {
          this.event = e, this.kind = 11;
        }
        isNoOp() {
          return false;
        }
        attemptToMerge(e) {
          return null;
        }
      }
      class Iue {
        constructor(e) {
          this.event = e, this.kind = 12;
        }
        isNoOp() {
          return false;
        }
        attemptToMerge(e) {
          return null;
        }
      }
      class Mue extends he {
        constructor(e, t, i, n) {
          super(), this._model = e, this._knownModelVersionId = this._model.getVersionId(), this._viewModel = t, this._coordinatesConverter = i, this.context = new t7(this._model, this._viewModel, this._coordinatesConverter, n), this._cursors = new e7(this.context), this._hasFocus = false, this._isHandling = false, this._compositionState = null, this._columnSelectData = null, this._autoClosedActions = [], this._prevEditOperationType = 0;
        }
        dispose() {
          this._cursors.dispose(), this._autoClosedActions = On(this._autoClosedActions), super.dispose();
        }
        updateConfiguration(e) {
          this.context = new t7(this._model, this._viewModel, this._coordinatesConverter, e), this._cursors.updateContext(this.context);
        }
        onLineMappingChanged(e) {
          this._knownModelVersionId === this._model.getVersionId() && this.setStates(e, "viewModel", 0, this.getCursorStates());
        }
        setHasFocus(e) {
          this._hasFocus = e;
        }
        _validateAutoClosedActions() {
          if (this._autoClosedActions.length > 0) {
            const e = this._cursors.getSelections();
            for (let t = 0; t < this._autoClosedActions.length; t++) {
              const i = this._autoClosedActions[t];
              i.isValid(e) || (i.dispose(), this._autoClosedActions.splice(t, 1), t--);
            }
          }
        }
        getPrimaryCursorState() {
          return this._cursors.getPrimaryCursor();
        }
        getLastAddedCursorIndex() {
          return this._cursors.getLastAddedCursorIndex();
        }
        getCursorStates() {
          return this._cursors.getAll();
        }
        setStates(e, t, i, n) {
          let o = false;
          const r = this.context.cursorConfig.multiCursorLimit;
          n !== null && n.length > r && (n = n.slice(0, r), o = true);
          const a = zp.from(this._model, this);
          return this._cursors.setStates(n), this._cursors.normalize(), this._columnSelectData = null, this._validateAutoClosedActions(), this._emitStateChangedIfNecessary(e, t, i, a, o);
        }
        setCursorColumnSelectData(e) {
          this._columnSelectData = e;
        }
        revealAll(e, t, i, n, o, r) {
          const a = this._cursors.getViewPositions();
          let l = null, u = null;
          a.length > 1 ? u = this._cursors.getViewSelections() : l = z.fromPositions(a[0], a[0]), e.emitViewEvent(new Hp(t, i, l, u, n, o, r));
        }
        revealPrimary(e, t, i, n, o, r) {
          const l = [
            this._cursors.getPrimaryCursor().viewState.selection
          ];
          e.emitViewEvent(new Hp(t, i, null, l, n, o, r));
        }
        saveState() {
          const e = [], t = this._cursors.getSelections();
          for (let i = 0, n = t.length; i < n; i++) {
            const o = t[i];
            e.push({
              inSelectionMode: !o.isEmpty(),
              selectionStart: {
                lineNumber: o.selectionStartLineNumber,
                column: o.selectionStartColumn
              },
              position: {
                lineNumber: o.positionLineNumber,
                column: o.positionColumn
              }
            });
          }
          return e;
        }
        restoreState(e, t) {
          const i = [];
          for (let n = 0, o = t.length; n < o; n++) {
            const r = t[n];
            let a = 1, l = 1;
            r.position && r.position.lineNumber && (a = r.position.lineNumber), r.position && r.position.column && (l = r.position.column);
            let u = a, d = l;
            r.selectionStart && r.selectionStart.lineNumber && (u = r.selectionStart.lineNumber), r.selectionStart && r.selectionStart.column && (d = r.selectionStart.column), i.push({
              selectionStartLineNumber: u,
              selectionStartColumn: d,
              positionLineNumber: a,
              positionColumn: l
            });
          }
          this.setStates(e, "restoreState", 0, lt.fromModelSelections(i)), this.revealAll(e, "restoreState", false, 0, true, 1);
        }
        onModelContentChanged(e, t) {
          if (t instanceof RB) {
            if (this._isHandling) return;
            this._isHandling = true;
            try {
              this.setStates(e, "modelChange", 0, this.getCursorStates());
            } finally {
              this._isHandling = false;
            }
          } else {
            const i = t.rawContentChangedEvent;
            if (this._knownModelVersionId = i.versionId, this._isHandling) return;
            const n = i.containsEvent(1);
            if (this._prevEditOperationType = 0, n) this._cursors.dispose(), this._cursors = new e7(this.context), this._validateAutoClosedActions(), this._emitStateChangedIfNecessary(e, "model", 1, null, false);
            else if (this._hasFocus && i.resultingSelection && i.resultingSelection.length > 0) {
              const o = lt.fromModelSelections(i.resultingSelection);
              this.setStates(e, "modelChange", i.isUndoing ? 5 : i.isRedoing ? 6 : 2, o) && this.revealAll(e, "modelChange", false, 0, true, 0);
            } else {
              const o = this._cursors.readSelectionFromMarkers();
              this.setStates(e, "modelChange", 2, lt.fromModelSelections(o));
            }
          }
        }
        getSelection() {
          return this._cursors.getPrimaryCursor().modelState.selection;
        }
        getTopMostViewPosition() {
          return this._cursors.getTopMostViewPosition();
        }
        getBottomMostViewPosition() {
          return this._cursors.getBottomMostViewPosition();
        }
        getCursorColumnSelectData() {
          if (this._columnSelectData) return this._columnSelectData;
          const e = this._cursors.getPrimaryCursor(), t = e.viewState.selectionStart.getStartPosition(), i = e.viewState.position;
          return {
            isReal: false,
            fromViewLineNumber: t.lineNumber,
            fromViewVisualColumn: this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, t),
            toViewLineNumber: i.lineNumber,
            toViewVisualColumn: this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, i)
          };
        }
        getSelections() {
          return this._cursors.getSelections();
        }
        setSelections(e, t, i, n) {
          this.setStates(e, t, n, lt.fromModelSelections(i));
        }
        getPrevEditOperationType() {
          return this._prevEditOperationType;
        }
        setPrevEditOperationType(e) {
          this._prevEditOperationType = e;
        }
        _pushAutoClosedAction(e, t) {
          const i = [], n = [];
          for (let a = 0, l = e.length; a < l; a++) i.push({
            range: e[a],
            options: {
              description: "auto-closed-character",
              inlineClassName: "auto-closed-character",
              stickiness: 1
            }
          }), n.push({
            range: t[a],
            options: {
              description: "auto-closed-enclosing",
              stickiness: 1
            }
          });
          const o = this._model.deltaDecorations([], i), r = this._model.deltaDecorations([], n);
          this._autoClosedActions.push(new i7(this._model, o, r));
        }
        _executeEditOperation(e) {
          if (!e) return;
          e.shouldPushStackElementBefore && this._model.pushStackElement();
          const t = Aue.executeCommands(this._model, this._cursors.getSelections(), e.commands);
          if (t) {
            this._interpretCommandResult(t);
            const i = [], n = [];
            for (let o = 0; o < e.commands.length; o++) {
              const r = e.commands[o];
              r instanceof tI && r.enclosingRange && r.closeCharacterRange && (i.push(r.closeCharacterRange), n.push(r.enclosingRange));
            }
            i.length > 0 && this._pushAutoClosedAction(i, n), this._prevEditOperationType = e.type;
          }
          e.shouldPushStackElementAfter && this._model.pushStackElement();
        }
        _interpretCommandResult(e) {
          (!e || e.length === 0) && (e = this._cursors.readSelectionFromMarkers()), this._columnSelectData = null, this._cursors.setSelections(e), this._cursors.normalize();
        }
        _emitStateChangedIfNecessary(e, t, i, n, o) {
          const r = zp.from(this._model, this);
          if (r.equals(n)) return false;
          const a = this._cursors.getSelections(), l = this._cursors.getViewSelections();
          if (e.emitViewEvent(new fue(l, a, i)), !n || n.cursorState.length !== r.cursorState.length || r.cursorState.some((u, d) => !u.modelState.equals(n.cursorState[d].modelState))) {
            const u = n ? n.cursorState.map((f) => f.modelState.selection) : null, d = n ? n.modelVersionId : 0;
            e.emitOutgoingEvent(new yC(u, a, d, r.modelVersionId, t || "keyboard", i, o));
          }
          return true;
        }
        _findAutoClosingPairs(e) {
          if (!e.length) return null;
          const t = [];
          for (let i = 0, n = e.length; i < n; i++) {
            const o = e[i];
            if (!o.text || o.text.indexOf(`
`) >= 0) return null;
            const r = o.text.match(/([)\]}>'"`])([^)\]}>'"`]*)$/);
            if (!r) return null;
            const a = r[1], l = this.context.cursorConfig.autoClosingPairs.autoClosingPairsCloseSingleChar.get(a);
            if (!l || l.length !== 1) return null;
            const u = l[0].open, d = o.text.length - r[2].length - 1, f = o.text.lastIndexOf(u, d - 1);
            if (f === -1) return null;
            t.push([
              f,
              d
            ]);
          }
          return t;
        }
        executeEdits(e, t, i, n) {
          let o = null;
          t === "snippet" && (o = this._findAutoClosingPairs(i)), o && (i[0]._isTracked = true);
          const r = [], a = [], l = this._model.pushEditOperations(this.getSelections(), i, (u) => {
            if (o) for (let f = 0, m = o.length; f < m; f++) {
              const [_, b] = o[f], v = u[f], y = v.range.startLineNumber, x = v.range.startColumn - 1 + _, L = v.range.startColumn - 1 + b;
              r.push(new z(y, L + 1, y, L + 2)), a.push(new z(y, x + 1, y, L + 2));
            }
            const d = n(u);
            return d && (this._isHandling = true), d;
          });
          l && (this._isHandling = false, this.setSelections(e, t, l, 0)), r.length > 0 && this._pushAutoClosedAction(r, a);
        }
        _executeEdit(e, t, i, n = 0) {
          if (this.context.cursorConfig.readOnly) return;
          const o = zp.from(this._model, this);
          this._cursors.stopTrackingSelections(), this._isHandling = true;
          try {
            this._cursors.ensureValidState(), e();
          } catch (r) {
            qt(r);
          }
          this._isHandling = false, this._cursors.startTrackingSelections(), this._validateAutoClosedActions(), this._emitStateChangedIfNecessary(t, i, n, o, false) && this.revealAll(t, i, false, 0, true, 0);
        }
        getAutoClosedCharacters() {
          return i7.getAllAutoClosedCharacters(this._autoClosedActions);
        }
        startComposition(e) {
          this._compositionState = new Up(this._model, this.getSelections());
        }
        endComposition(e, t) {
          const i = this._compositionState ? this._compositionState.deduceOutcome(this._model, this.getSelections()) : null;
          this._compositionState = null, this._executeEdit(() => {
            t === "keyboard" && this._executeEditOperation(ch.compositionEndWithInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, i, this.getSelections(), this.getAutoClosedCharacters()));
          }, e, t);
        }
        type(e, t, i) {
          this._executeEdit(() => {
            if (i === "keyboard") {
              const n = t.length;
              let o = 0;
              for (; o < n; ) {
                const r = YE(t, o), a = t.substr(o, r);
                this._executeEditOperation(ch.typeWithInterceptors(!!this._compositionState, this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), this.getAutoClosedCharacters(), a)), o += r;
              }
            } else this._executeEditOperation(ch.typeWithoutInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), t));
          }, e, i);
        }
        compositionType(e, t, i, n, o, r) {
          if (t.length === 0 && i === 0 && n === 0) {
            if (o !== 0) {
              const a = this.getSelections().map((l) => {
                const u = l.getPosition();
                return new mt(u.lineNumber, u.column + o, u.lineNumber, u.column + o);
              });
              this.setSelections(e, r, a, 0);
            }
            return;
          }
          this._executeEdit(() => {
            this._executeEditOperation(ch.compositionType(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), t, i, n, o));
          }, e, r);
        }
        paste(e, t, i, n, o) {
          this._executeEdit(() => {
            this._executeEditOperation(ch.paste(this.context.cursorConfig, this._model, this.getSelections(), t, i, n || []));
          }, e, o, 4);
        }
        cut(e, t) {
          this._executeEdit(() => {
            this._executeEditOperation(Hh.cut(this.context.cursorConfig, this._model, this.getSelections()));
          }, e, t);
        }
        executeCommand(e, t, i) {
          this._executeEdit(() => {
            this._cursors.killSecondaryCursors(), this._executeEditOperation(new As(0, [
              t
            ], {
              shouldPushStackElementBefore: false,
              shouldPushStackElementAfter: false
            }));
          }, e, i);
        }
        executeCommands(e, t, i) {
          this._executeEdit(() => {
            this._executeEditOperation(new As(0, t, {
              shouldPushStackElementBefore: false,
              shouldPushStackElementAfter: false
            }));
          }, e, i);
        }
      }
      class zp {
        static from(e, t) {
          return new zp(e.getVersionId(), t.getCursorStates());
        }
        constructor(e, t) {
          this.modelVersionId = e, this.cursorState = t;
        }
        equals(e) {
          if (!e || this.modelVersionId !== e.modelVersionId || this.cursorState.length !== e.cursorState.length) return false;
          for (let t = 0, i = this.cursorState.length; t < i; t++) if (!this.cursorState[t].equals(e.cursorState[t])) return false;
          return true;
        }
      }
      class i7 {
        static getAllAutoClosedCharacters(e) {
          let t = [];
          for (const i of e) t = t.concat(i.getAutoClosedCharactersRanges());
          return t;
        }
        constructor(e, t, i) {
          this._model = e, this._autoClosedCharactersDecorations = t, this._autoClosedEnclosingDecorations = i;
        }
        dispose() {
          this._autoClosedCharactersDecorations = this._model.deltaDecorations(this._autoClosedCharactersDecorations, []), this._autoClosedEnclosingDecorations = this._model.deltaDecorations(this._autoClosedEnclosingDecorations, []);
        }
        getAutoClosedCharactersRanges() {
          const e = [];
          for (let t = 0; t < this._autoClosedCharactersDecorations.length; t++) {
            const i = this._model.getDecorationRange(this._autoClosedCharactersDecorations[t]);
            i && e.push(i);
          }
          return e;
        }
        isValid(e) {
          const t = [];
          for (let i = 0; i < this._autoClosedEnclosingDecorations.length; i++) {
            const n = this._model.getDecorationRange(this._autoClosedEnclosingDecorations[i]);
            if (n && (t.push(n), n.startLineNumber !== n.endLineNumber)) return false;
          }
          t.sort(z.compareRangesUsingStarts), e.sort(z.compareRangesUsingStarts);
          for (let i = 0; i < e.length; i++) if (i >= t.length || !t[i].strictContainsRange(e[i])) return false;
          return true;
        }
      }
      class Aue {
        static executeCommands(e, t, i) {
          const n = {
            model: e,
            selectionsBefore: t,
            trackedRanges: [],
            trackedRangesDirection: []
          }, o = this._innerExecuteCommands(n, i);
          for (let r = 0, a = n.trackedRanges.length; r < a; r++) n.model._setTrackedRange(n.trackedRanges[r], null, 0);
          return o;
        }
        static _innerExecuteCommands(e, t) {
          if (this._arrayIsEmpty(t)) return null;
          const i = this._getEditOperations(e, t);
          if (i.operations.length === 0) return null;
          const n = i.operations, o = this._getLoserCursorMap(n);
          if (o.hasOwnProperty("0")) return console.warn("Ignoring commands"), null;
          const r = [];
          for (let u = 0, d = n.length; u < d; u++) o.hasOwnProperty(n[u].identifier.major.toString()) || r.push(n[u]);
          i.hadTrackedEditOperation && r.length > 0 && (r[0]._isTracked = true);
          let a = e.model.pushEditOperations(e.selectionsBefore, r, (u) => {
            const d = [];
            for (let _ = 0; _ < e.selectionsBefore.length; _++) d[_] = [];
            for (const _ of u) _.identifier && d[_.identifier.major].push(_);
            const f = (_, b) => _.identifier.minor - b.identifier.minor, m = [];
            for (let _ = 0; _ < e.selectionsBefore.length; _++) d[_].length > 0 ? (d[_].sort(f), m[_] = t[_].computeCursorState(e.model, {
              getInverseEditOperations: () => d[_],
              getTrackedSelection: (b) => {
                const v = parseInt(b, 10), y = e.model._getTrackedRange(e.trackedRanges[v]);
                return e.trackedRangesDirection[v] === 0 ? new mt(y.startLineNumber, y.startColumn, y.endLineNumber, y.endColumn) : new mt(y.endLineNumber, y.endColumn, y.startLineNumber, y.startColumn);
              }
            })) : m[_] = e.selectionsBefore[_];
            return m;
          });
          a || (a = e.selectionsBefore);
          const l = [];
          for (const u in o) o.hasOwnProperty(u) && l.push(parseInt(u, 10));
          l.sort((u, d) => d - u);
          for (const u of l) a.splice(u, 1);
          return a;
        }
        static _arrayIsEmpty(e) {
          for (let t = 0, i = e.length; t < i; t++) if (e[t]) return false;
          return true;
        }
        static _getEditOperations(e, t) {
          let i = [], n = false;
          for (let o = 0, r = t.length; o < r; o++) {
            const a = t[o];
            if (a) {
              const l = this._getEditOperationsFromCommand(e, o, a);
              i = i.concat(l.operations), n = n || l.hadTrackedEditOperation;
            }
          }
          return {
            operations: i,
            hadTrackedEditOperation: n
          };
        }
        static _getEditOperationsFromCommand(e, t, i) {
          const n = [];
          let o = 0;
          const r = (f, m, _ = false) => {
            z.isEmpty(f) && m === "" || n.push({
              identifier: {
                major: t,
                minor: o++
              },
              range: f,
              text: m,
              forceMoveMarkers: _,
              isAutoWhitespaceEdit: i.insertsAutoWhitespace
            });
          };
          let a = false;
          const d = {
            addEditOperation: r,
            addTrackedEditOperation: (f, m, _) => {
              a = true, r(f, m, _);
            },
            trackSelection: (f, m) => {
              const _ = mt.liftSelection(f);
              let b;
              if (_.isEmpty()) if (typeof m == "boolean") m ? b = 2 : b = 3;
              else {
                const x = e.model.getLineMaxColumn(_.startLineNumber);
                _.startColumn === x ? b = 2 : b = 3;
              }
              else b = 1;
              const v = e.trackedRanges.length, y = e.model._setTrackedRange(null, _, b);
              return e.trackedRanges[v] = y, e.trackedRangesDirection[v] = _.getDirection(), v.toString();
            }
          };
          try {
            i.getEditOperations(e.model, d);
          } catch (f) {
            return qt(f), {
              operations: [],
              hadTrackedEditOperation: false
            };
          }
          return {
            operations: n,
            hadTrackedEditOperation: a
          };
        }
        static _getLoserCursorMap(e) {
          e = e.slice(0), e.sort((i, n) => -z.compareRangesUsingEnds(i.range, n.range));
          const t = {};
          for (let i = 1; i < e.length; i++) {
            const n = e[i - 1], o = e[i];
            if (z.getStartPosition(n.range).isBefore(z.getEndPosition(o.range))) {
              let r;
              n.identifier.major > o.identifier.major ? r = n.identifier.major : r = o.identifier.major, t[r.toString()] = true;
              for (let a = 0; a < e.length; a++) e[a].identifier.major === r && (e.splice(a, 1), a < i && i--, a--);
              i > 0 && i--;
            }
          }
          return t;
        }
      }
      class Rue {
        constructor(e, t, i) {
          this.text = e, this.startSelection = t, this.endSelection = i;
        }
      }
      class Up {
        static _capture(e, t) {
          const i = [];
          for (const n of t) {
            if (n.startLineNumber !== n.endLineNumber) return null;
            i.push(new Rue(e.getLineContent(n.startLineNumber), n.startColumn - 1, n.endColumn - 1));
          }
          return i;
        }
        constructor(e, t) {
          this._original = Up._capture(e, t);
        }
        deduceOutcome(e, t) {
          if (!this._original) return null;
          const i = Up._capture(e, t);
          if (!i || this._original.length !== i.length) return null;
          const n = [];
          for (let o = 0, r = this._original.length; o < r; o++) n.push(Up._deduceOutcome(this._original[o], i[o]));
          return n;
        }
        static _deduceOutcome(e, t) {
          const i = Math.min(e.startSelection, t.startSelection, Ok(e.text, t.text)), n = Math.min(e.text.length - e.endSelection, t.text.length - t.endSelection, Pk(e.text, t.text)), o = e.text.substring(i, e.text.length - n), r = t.text.substring(i, t.text.length - n);
          return new rce(o, e.startSelection - i, e.endSelection - i, r, t.startSelection - i, t.endSelection - i);
        }
      }
      class Oue {
        constructor() {
          this._hasPending = false, this._inserts = [], this._changes = [], this._removes = [];
        }
        insert(e) {
          this._hasPending = true, this._inserts.push(e);
        }
        change(e) {
          this._hasPending = true, this._changes.push(e);
        }
        remove(e) {
          this._hasPending = true, this._removes.push(e);
        }
        mustCommit() {
          return this._hasPending;
        }
        commit(e) {
          if (!this._hasPending) return;
          const t = this._inserts, i = this._changes, n = this._removes;
          this._hasPending = false, this._inserts = [], this._changes = [], this._removes = [], e._commitPendingChanges(t, i, n);
        }
      }
      class Pue {
        constructor(e, t, i, n, o) {
          this.id = e, this.afterLineNumber = t, this.ordinal = i, this.height = n, this.minWidth = o, this.prefixSum = 0;
        }
      }
      let Bue = (_o = class {
        constructor(e, t, i, n) {
          this._instanceId = E9(++_o.INSTANCE_COUNT), this._pendingChanges = new Oue(), this._lastWhitespaceId = 0, this._arr = [], this._prefixSumValidIndex = -1, this._minWidth = -1, this._lineCount = e, this._lineHeight = t, this._paddingTop = i, this._paddingBottom = n;
        }
        static findInsertionIndex(e, t, i) {
          let n = 0, o = e.length;
          for (; n < o; ) {
            const r = n + o >>> 1;
            t === e[r].afterLineNumber ? i < e[r].ordinal ? o = r : n = r + 1 : t < e[r].afterLineNumber ? o = r : n = r + 1;
          }
          return n;
        }
        setLineHeight(e) {
          this._checkPendingChanges(), this._lineHeight = e;
        }
        setPadding(e, t) {
          this._paddingTop = e, this._paddingBottom = t;
        }
        onFlushed(e) {
          this._checkPendingChanges(), this._lineCount = e;
        }
        changeWhitespace(e) {
          let t = false;
          try {
            e({
              insertWhitespace: (n, o, r, a) => {
                t = true, n = n | 0, o = o | 0, r = r | 0, a = a | 0;
                const l = this._instanceId + ++this._lastWhitespaceId;
                return this._pendingChanges.insert(new Pue(l, n, o, r, a)), l;
              },
              changeOneWhitespace: (n, o, r) => {
                t = true, o = o | 0, r = r | 0, this._pendingChanges.change({
                  id: n,
                  newAfterLineNumber: o,
                  newHeight: r
                });
              },
              removeWhitespace: (n) => {
                t = true, this._pendingChanges.remove({
                  id: n
                });
              }
            });
          } finally {
            this._pendingChanges.commit(this);
          }
          return t;
        }
        _commitPendingChanges(e, t, i) {
          if ((e.length > 0 || i.length > 0) && (this._minWidth = -1), e.length + t.length + i.length <= 1) {
            for (const l of e) this._insertWhitespace(l);
            for (const l of t) this._changeOneWhitespace(l.id, l.newAfterLineNumber, l.newHeight);
            for (const l of i) {
              const u = this._findWhitespaceIndex(l.id);
              u !== -1 && this._removeWhitespace(u);
            }
            return;
          }
          const n = /* @__PURE__ */ new Set();
          for (const l of i) n.add(l.id);
          const o = /* @__PURE__ */ new Map();
          for (const l of t) o.set(l.id, l);
          const r = (l) => {
            const u = [];
            for (const d of l) if (!n.has(d.id)) {
              if (o.has(d.id)) {
                const f = o.get(d.id);
                d.afterLineNumber = f.newAfterLineNumber, d.height = f.newHeight;
              }
              u.push(d);
            }
            return u;
          }, a = r(this._arr).concat(r(e));
          a.sort((l, u) => l.afterLineNumber === u.afterLineNumber ? l.ordinal - u.ordinal : l.afterLineNumber - u.afterLineNumber), this._arr = a, this._prefixSumValidIndex = -1;
        }
        _checkPendingChanges() {
          this._pendingChanges.mustCommit() && this._pendingChanges.commit(this);
        }
        _insertWhitespace(e) {
          const t = _o.findInsertionIndex(this._arr, e.afterLineNumber, e.ordinal);
          this._arr.splice(t, 0, e), this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, t - 1);
        }
        _findWhitespaceIndex(e) {
          const t = this._arr;
          for (let i = 0, n = t.length; i < n; i++) if (t[i].id === e) return i;
          return -1;
        }
        _changeOneWhitespace(e, t, i) {
          const n = this._findWhitespaceIndex(e);
          if (n !== -1 && (this._arr[n].height !== i && (this._arr[n].height = i, this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, n - 1)), this._arr[n].afterLineNumber !== t)) {
            const o = this._arr[n];
            this._removeWhitespace(n), o.afterLineNumber = t, this._insertWhitespace(o);
          }
        }
        _removeWhitespace(e) {
          this._arr.splice(e, 1), this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, e - 1);
        }
        onLinesDeleted(e, t) {
          this._checkPendingChanges(), e = e | 0, t = t | 0, this._lineCount -= t - e + 1;
          for (let i = 0, n = this._arr.length; i < n; i++) {
            const o = this._arr[i].afterLineNumber;
            e <= o && o <= t ? this._arr[i].afterLineNumber = e - 1 : o > t && (this._arr[i].afterLineNumber -= t - e + 1);
          }
        }
        onLinesInserted(e, t) {
          this._checkPendingChanges(), e = e | 0, t = t | 0, this._lineCount += t - e + 1;
          for (let i = 0, n = this._arr.length; i < n; i++) {
            const o = this._arr[i].afterLineNumber;
            e <= o && (this._arr[i].afterLineNumber += t - e + 1);
          }
        }
        getWhitespacesTotalHeight() {
          return this._checkPendingChanges(), this._arr.length === 0 ? 0 : this.getWhitespacesAccumulatedHeight(this._arr.length - 1);
        }
        getWhitespacesAccumulatedHeight(e) {
          this._checkPendingChanges(), e = e | 0;
          let t = Math.max(0, this._prefixSumValidIndex + 1);
          t === 0 && (this._arr[0].prefixSum = this._arr[0].height, t++);
          for (let i = t; i <= e; i++) this._arr[i].prefixSum = this._arr[i - 1].prefixSum + this._arr[i].height;
          return this._prefixSumValidIndex = Math.max(this._prefixSumValidIndex, e), this._arr[e].prefixSum;
        }
        getLinesTotalHeight() {
          this._checkPendingChanges();
          const e = this._lineHeight * this._lineCount, t = this.getWhitespacesTotalHeight();
          return e + t + this._paddingTop + this._paddingBottom;
        }
        getWhitespaceAccumulatedHeightBeforeLineNumber(e) {
          this._checkPendingChanges(), e = e | 0;
          const t = this._findLastWhitespaceBeforeLineNumber(e);
          return t === -1 ? 0 : this.getWhitespacesAccumulatedHeight(t);
        }
        _findLastWhitespaceBeforeLineNumber(e) {
          e = e | 0;
          const t = this._arr;
          let i = 0, n = t.length - 1;
          for (; i <= n; ) {
            const r = (n - i | 0) / 2 | 0, a = i + r | 0;
            if (t[a].afterLineNumber < e) {
              if (a + 1 >= t.length || t[a + 1].afterLineNumber >= e) return a;
              i = a + 1 | 0;
            } else n = a - 1 | 0;
          }
          return -1;
        }
        _findFirstWhitespaceAfterLineNumber(e) {
          e = e | 0;
          const i = this._findLastWhitespaceBeforeLineNumber(e) + 1;
          return i < this._arr.length ? i : -1;
        }
        getFirstWhitespaceIndexAfterLineNumber(e) {
          return this._checkPendingChanges(), e = e | 0, this._findFirstWhitespaceAfterLineNumber(e);
        }
        getVerticalOffsetForLineNumber(e, t = false) {
          this._checkPendingChanges(), e = e | 0;
          let i;
          e > 1 ? i = this._lineHeight * (e - 1) : i = 0;
          const n = this.getWhitespaceAccumulatedHeightBeforeLineNumber(e - (t ? 1 : 0));
          return i + n + this._paddingTop;
        }
        getVerticalOffsetAfterLineNumber(e, t = false) {
          this._checkPendingChanges(), e = e | 0;
          const i = this._lineHeight * e, n = this.getWhitespaceAccumulatedHeightBeforeLineNumber(e + (t ? 1 : 0));
          return i + n + this._paddingTop;
        }
        getWhitespaceMinWidth() {
          if (this._checkPendingChanges(), this._minWidth === -1) {
            let e = 0;
            for (let t = 0, i = this._arr.length; t < i; t++) e = Math.max(e, this._arr[t].minWidth);
            this._minWidth = e;
          }
          return this._minWidth;
        }
        isAfterLines(e) {
          this._checkPendingChanges();
          const t = this.getLinesTotalHeight();
          return e > t;
        }
        isInTopPadding(e) {
          return this._paddingTop === 0 ? false : (this._checkPendingChanges(), e < this._paddingTop);
        }
        isInBottomPadding(e) {
          if (this._paddingBottom === 0) return false;
          this._checkPendingChanges();
          const t = this.getLinesTotalHeight();
          return e >= t - this._paddingBottom;
        }
        getLineNumberAtOrAfterVerticalOffset(e) {
          if (this._checkPendingChanges(), e = e | 0, e < 0) return 1;
          const t = this._lineCount | 0, i = this._lineHeight;
          let n = 1, o = t;
          for (; n < o; ) {
            const r = (n + o) / 2 | 0, a = this.getVerticalOffsetForLineNumber(r) | 0;
            if (e >= a + i) n = r + 1;
            else {
              if (e >= a) return r;
              o = r;
            }
          }
          return n > t ? t : n;
        }
        getLinesViewportData(e, t) {
          this._checkPendingChanges(), e = e | 0, t = t | 0;
          const i = this._lineHeight, n = this.getLineNumberAtOrAfterVerticalOffset(e) | 0, o = this.getVerticalOffsetForLineNumber(n) | 0;
          let r = this._lineCount | 0, a = this.getFirstWhitespaceIndexAfterLineNumber(n) | 0;
          const l = this.getWhitespacesCount() | 0;
          let u, d;
          a === -1 ? (a = l, d = r + 1, u = 0) : (d = this.getAfterLineNumberForWhitespaceIndex(a) | 0, u = this.getHeightForWhitespaceIndex(a) | 0);
          let f = o, m = f;
          const _ = 5e5;
          let b = 0;
          o >= _ && (b = Math.floor(o / _) * _, b = Math.floor(b / i) * i, m -= b);
          const v = [], y = e + (t - e) / 2;
          let x = -1;
          for (let T = n; T <= r; T++) {
            if (x === -1) {
              const M = f, I = f + i;
              (M <= y && y < I || M > y) && (x = T);
            }
            for (f += i, v[T - n] = m, m += i; d === T; ) m += u, f += u, a++, a >= l ? d = r + 1 : (d = this.getAfterLineNumberForWhitespaceIndex(a) | 0, u = this.getHeightForWhitespaceIndex(a) | 0);
            if (f >= t) {
              r = T;
              break;
            }
          }
          x === -1 && (x = r);
          const L = this.getVerticalOffsetForLineNumber(r) | 0;
          let D = n, k = r;
          return D < k && o < e && D++, D < k && L + i > t && k--, {
            bigNumbersDelta: b,
            startLineNumber: n,
            endLineNumber: r,
            relativeVerticalOffset: v,
            centeredLineNumber: x,
            completelyVisibleStartLineNumber: D,
            completelyVisibleEndLineNumber: k,
            lineHeight: this._lineHeight
          };
        }
        getVerticalOffsetForWhitespaceIndex(e) {
          this._checkPendingChanges(), e = e | 0;
          const t = this.getAfterLineNumberForWhitespaceIndex(e);
          let i;
          t >= 1 ? i = this._lineHeight * t : i = 0;
          let n;
          return e > 0 ? n = this.getWhitespacesAccumulatedHeight(e - 1) : n = 0, i + n + this._paddingTop;
        }
        getWhitespaceIndexAtOrAfterVerticallOffset(e) {
          this._checkPendingChanges(), e = e | 0;
          let t = 0, i = this.getWhitespacesCount() - 1;
          if (i < 0) return -1;
          const n = this.getVerticalOffsetForWhitespaceIndex(i), o = this.getHeightForWhitespaceIndex(i);
          if (e >= n + o) return -1;
          for (; t < i; ) {
            const r = Math.floor((t + i) / 2), a = this.getVerticalOffsetForWhitespaceIndex(r), l = this.getHeightForWhitespaceIndex(r);
            if (e >= a + l) t = r + 1;
            else {
              if (e >= a) return r;
              i = r;
            }
          }
          return t;
        }
        getWhitespaceAtVerticalOffset(e) {
          this._checkPendingChanges(), e = e | 0;
          const t = this.getWhitespaceIndexAtOrAfterVerticallOffset(e);
          if (t < 0 || t >= this.getWhitespacesCount()) return null;
          const i = this.getVerticalOffsetForWhitespaceIndex(t);
          if (i > e) return null;
          const n = this.getHeightForWhitespaceIndex(t), o = this.getIdForWhitespaceIndex(t), r = this.getAfterLineNumberForWhitespaceIndex(t);
          return {
            id: o,
            afterLineNumber: r,
            verticalOffset: i,
            height: n
          };
        }
        getWhitespaceViewportData(e, t) {
          this._checkPendingChanges(), e = e | 0, t = t | 0;
          const i = this.getWhitespaceIndexAtOrAfterVerticallOffset(e), n = this.getWhitespacesCount() - 1;
          if (i < 0) return [];
          const o = [];
          for (let r = i; r <= n; r++) {
            const a = this.getVerticalOffsetForWhitespaceIndex(r), l = this.getHeightForWhitespaceIndex(r);
            if (a >= t) break;
            o.push({
              id: this.getIdForWhitespaceIndex(r),
              afterLineNumber: this.getAfterLineNumberForWhitespaceIndex(r),
              verticalOffset: a,
              height: l
            });
          }
          return o;
        }
        getWhitespaces() {
          return this._checkPendingChanges(), this._arr.slice(0);
        }
        getWhitespacesCount() {
          return this._checkPendingChanges(), this._arr.length;
        }
        getIdForWhitespaceIndex(e) {
          return this._checkPendingChanges(), e = e | 0, this._arr[e].id;
        }
        getAfterLineNumberForWhitespaceIndex(e) {
          return this._checkPendingChanges(), e = e | 0, this._arr[e].afterLineNumber;
        }
        getHeightForWhitespaceIndex(e) {
          return this._checkPendingChanges(), e = e | 0, this._arr[e].height;
        }
      }, _o.INSTANCE_COUNT = 0, _o);
      const Fue = 125;
      class up {
        constructor(e, t, i, n) {
          e = e | 0, t = t | 0, i = i | 0, n = n | 0, e < 0 && (e = 0), t < 0 && (t = 0), i < 0 && (i = 0), n < 0 && (n = 0), this.width = e, this.contentWidth = t, this.scrollWidth = Math.max(e, t), this.height = i, this.contentHeight = n, this.scrollHeight = Math.max(i, n);
        }
        equals(e) {
          return this.width === e.width && this.contentWidth === e.contentWidth && this.height === e.height && this.contentHeight === e.contentHeight;
        }
      }
      class Vue extends he {
        constructor(e, t) {
          super(), this._onDidContentSizeChange = this._register(new G()), this.onDidContentSizeChange = this._onDidContentSizeChange.event, this._dimensions = new up(0, 0, 0, 0), this._scrollable = this._register(new Dg({
            forceIntegerValues: true,
            smoothScrollDuration: e,
            scheduleAtNextAnimationFrame: t
          })), this.onDidScroll = this._scrollable.onScroll;
        }
        getScrollable() {
          return this._scrollable;
        }
        setSmoothScrollDuration(e) {
          this._scrollable.setSmoothScrollDuration(e);
        }
        validateScrollPosition(e) {
          return this._scrollable.validateScrollPosition(e);
        }
        getScrollDimensions() {
          return this._dimensions;
        }
        setScrollDimensions(e) {
          if (this._dimensions.equals(e)) return;
          const t = this._dimensions;
          this._dimensions = e, this._scrollable.setScrollDimensions({
            width: e.width,
            scrollWidth: e.scrollWidth,
            height: e.height,
            scrollHeight: e.scrollHeight
          }, true);
          const i = t.contentWidth !== e.contentWidth, n = t.contentHeight !== e.contentHeight;
          (i || n) && this._onDidContentSizeChange.fire(new cI(t.contentWidth, t.contentHeight, e.contentWidth, e.contentHeight));
        }
        getFutureScrollPosition() {
          return this._scrollable.getFutureScrollPosition();
        }
        getCurrentScrollPosition() {
          return this._scrollable.getCurrentScrollPosition();
        }
        setScrollPositionNow(e) {
          this._scrollable.setScrollPositionNow(e);
        }
        setScrollPositionSmooth(e) {
          this._scrollable.setScrollPositionSmooth(e);
        }
        hasPendingScrollAnimation() {
          return this._scrollable.hasPendingScrollAnimation();
        }
      }
      class Wue extends he {
        constructor(e, t, i) {
          super(), this._configuration = e;
          const n = this._configuration.options, o = n.get(146), r = n.get(84);
          this._linesLayout = new Bue(t, n.get(67), r.top, r.bottom), this._maxLineWidth = 0, this._overlayWidgetsMinWidth = 0, this._scrollable = this._register(new Vue(0, i)), this._configureSmoothScrollDuration(), this._scrollable.setScrollDimensions(new up(o.contentWidth, 0, o.height, 0)), this.onDidScroll = this._scrollable.onDidScroll, this.onDidContentSizeChange = this._scrollable.onDidContentSizeChange, this._updateHeight();
        }
        dispose() {
          super.dispose();
        }
        getScrollable() {
          return this._scrollable.getScrollable();
        }
        onHeightMaybeChanged() {
          this._updateHeight();
        }
        _configureSmoothScrollDuration() {
          this._scrollable.setSmoothScrollDuration(this._configuration.options.get(115) ? Fue : 0);
        }
        onConfigurationChanged(e) {
          const t = this._configuration.options;
          if (e.hasChanged(67) && this._linesLayout.setLineHeight(t.get(67)), e.hasChanged(84)) {
            const i = t.get(84);
            this._linesLayout.setPadding(i.top, i.bottom);
          }
          if (e.hasChanged(146)) {
            const i = t.get(146), n = i.contentWidth, o = i.height, r = this._scrollable.getScrollDimensions(), a = r.contentWidth;
            this._scrollable.setScrollDimensions(new up(n, r.contentWidth, o, this._getContentHeight(n, o, a)));
          } else this._updateHeight();
          e.hasChanged(115) && this._configureSmoothScrollDuration();
        }
        onFlushed(e) {
          this._linesLayout.onFlushed(e);
        }
        onLinesDeleted(e, t) {
          this._linesLayout.onLinesDeleted(e, t);
        }
        onLinesInserted(e, t) {
          this._linesLayout.onLinesInserted(e, t);
        }
        _getHorizontalScrollbarHeight(e, t) {
          const n = this._configuration.options.get(104);
          return n.horizontal === 2 || e >= t ? 0 : n.horizontalScrollbarSize;
        }
        _getContentHeight(e, t, i) {
          const n = this._configuration.options;
          let o = this._linesLayout.getLinesTotalHeight();
          return n.get(106) ? o += Math.max(0, t - n.get(67) - n.get(84).bottom) : n.get(104).ignoreHorizontalScrollbarInContentHeight || (o += this._getHorizontalScrollbarHeight(e, i)), o;
        }
        _updateHeight() {
          const e = this._scrollable.getScrollDimensions(), t = e.width, i = e.height, n = e.contentWidth;
          this._scrollable.setScrollDimensions(new up(t, e.contentWidth, i, this._getContentHeight(t, i, n)));
        }
        getCurrentViewport() {
          const e = this._scrollable.getScrollDimensions(), t = this._scrollable.getCurrentScrollPosition();
          return new x3(t.scrollTop, t.scrollLeft, e.width, e.height);
        }
        getFutureViewport() {
          const e = this._scrollable.getScrollDimensions(), t = this._scrollable.getFutureScrollPosition();
          return new x3(t.scrollTop, t.scrollLeft, e.width, e.height);
        }
        _computeContentWidth() {
          const e = this._configuration.options, t = this._maxLineWidth, i = e.get(147), n = e.get(50), o = e.get(146);
          if (i.isViewportWrapping) {
            const r = e.get(73);
            return t > o.contentWidth + n.typicalHalfwidthCharacterWidth && r.enabled && r.side === "right" ? t + o.verticalScrollbarWidth : t;
          } else {
            const r = e.get(105) * n.typicalHalfwidthCharacterWidth, a = this._linesLayout.getWhitespaceMinWidth();
            return Math.max(t + r + o.verticalScrollbarWidth, a, this._overlayWidgetsMinWidth);
          }
        }
        setMaxLineWidth(e) {
          this._maxLineWidth = e, this._updateContentWidth();
        }
        setOverlayWidgetsMinWidth(e) {
          this._overlayWidgetsMinWidth = e, this._updateContentWidth();
        }
        _updateContentWidth() {
          const e = this._scrollable.getScrollDimensions();
          this._scrollable.setScrollDimensions(new up(e.width, this._computeContentWidth(), e.height, e.contentHeight)), this._updateHeight();
        }
        saveState() {
          const e = this._scrollable.getFutureScrollPosition(), t = e.scrollTop, i = this._linesLayout.getLineNumberAtOrAfterVerticalOffset(t), n = this._linesLayout.getWhitespaceAccumulatedHeightBeforeLineNumber(i);
          return {
            scrollTop: t,
            scrollTopWithoutViewZones: t - n,
            scrollLeft: e.scrollLeft
          };
        }
        changeWhitespace(e) {
          const t = this._linesLayout.changeWhitespace(e);
          return t && this.onHeightMaybeChanged(), t;
        }
        getVerticalOffsetForLineNumber(e, t = false) {
          return this._linesLayout.getVerticalOffsetForLineNumber(e, t);
        }
        getVerticalOffsetAfterLineNumber(e, t = false) {
          return this._linesLayout.getVerticalOffsetAfterLineNumber(e, t);
        }
        isAfterLines(e) {
          return this._linesLayout.isAfterLines(e);
        }
        isInTopPadding(e) {
          return this._linesLayout.isInTopPadding(e);
        }
        isInBottomPadding(e) {
          return this._linesLayout.isInBottomPadding(e);
        }
        getLineNumberAtVerticalOffset(e) {
          return this._linesLayout.getLineNumberAtOrAfterVerticalOffset(e);
        }
        getWhitespaceAtVerticalOffset(e) {
          return this._linesLayout.getWhitespaceAtVerticalOffset(e);
        }
        getLinesViewportData() {
          const e = this.getCurrentViewport();
          return this._linesLayout.getLinesViewportData(e.top, e.top + e.height);
        }
        getLinesViewportDataAtScrollTop(e) {
          const t = this._scrollable.getScrollDimensions();
          return e + t.height > t.scrollHeight && (e = t.scrollHeight - t.height), e < 0 && (e = 0), this._linesLayout.getLinesViewportData(e, e + t.height);
        }
        getWhitespaceViewportData() {
          const e = this.getCurrentViewport();
          return this._linesLayout.getWhitespaceViewportData(e.top, e.top + e.height);
        }
        getWhitespaces() {
          return this._linesLayout.getWhitespaces();
        }
        getContentWidth() {
          return this._scrollable.getScrollDimensions().contentWidth;
        }
        getScrollWidth() {
          return this._scrollable.getScrollDimensions().scrollWidth;
        }
        getContentHeight() {
          return this._scrollable.getScrollDimensions().contentHeight;
        }
        getScrollHeight() {
          return this._scrollable.getScrollDimensions().scrollHeight;
        }
        getCurrentScrollLeft() {
          return this._scrollable.getCurrentScrollPosition().scrollLeft;
        }
        getCurrentScrollTop() {
          return this._scrollable.getCurrentScrollPosition().scrollTop;
        }
        validateScrollPosition(e) {
          return this._scrollable.validateScrollPosition(e);
        }
        setScrollPosition(e, t) {
          t === 1 ? this._scrollable.setScrollPositionNow(e) : this._scrollable.setScrollPositionSmooth(e);
        }
        hasPendingScrollAnimation() {
          return this._scrollable.hasPendingScrollAnimation();
        }
        deltaScrollNow(e, t) {
          const i = this._scrollable.getCurrentScrollPosition();
          this._scrollable.setScrollPositionNow({
            scrollLeft: i.scrollLeft + e,
            scrollTop: i.scrollTop + t
          });
        }
      }
      class Hue {
        constructor(e, t, i, n, o) {
          this.editorId = e, this.model = t, this.configuration = i, this._linesCollection = n, this._coordinatesConverter = o, this._decorationsCache = /* @__PURE__ */ Object.create(null), this._cachedModelDecorationsResolver = null, this._cachedModelDecorationsResolverViewRange = null;
        }
        _clearCachedModelDecorationsResolver() {
          this._cachedModelDecorationsResolver = null, this._cachedModelDecorationsResolverViewRange = null;
        }
        dispose() {
          this._decorationsCache = /* @__PURE__ */ Object.create(null), this._clearCachedModelDecorationsResolver();
        }
        reset() {
          this._decorationsCache = /* @__PURE__ */ Object.create(null), this._clearCachedModelDecorationsResolver();
        }
        onModelDecorationsChanged() {
          this._decorationsCache = /* @__PURE__ */ Object.create(null), this._clearCachedModelDecorationsResolver();
        }
        onLineMappingChanged() {
          this._decorationsCache = /* @__PURE__ */ Object.create(null), this._clearCachedModelDecorationsResolver();
        }
        _getOrCreateViewModelDecoration(e) {
          const t = e.id;
          let i = this._decorationsCache[t];
          if (!i) {
            const n = e.range, o = e.options;
            let r;
            if (o.isWholeLine) {
              const a = this._coordinatesConverter.convertModelPositionToViewPosition(new X(n.startLineNumber, 1), 0, false, true), l = this._coordinatesConverter.convertModelPositionToViewPosition(new X(n.endLineNumber, this.model.getLineMaxColumn(n.endLineNumber)), 1);
              r = new z(a.lineNumber, a.column, l.lineNumber, l.column);
            } else r = this._coordinatesConverter.convertModelRangeToViewRange(n, 1);
            i = new vF(r, o), this._decorationsCache[t] = i;
          }
          return i;
        }
        getMinimapDecorationsInRange(e) {
          return this._getDecorationsInRange(e, true, false).decorations;
        }
        getDecorationsViewportData(e) {
          let t = this._cachedModelDecorationsResolver !== null;
          return t = t && e.equalsRange(this._cachedModelDecorationsResolverViewRange), t || (this._cachedModelDecorationsResolver = this._getDecorationsInRange(e, false, false), this._cachedModelDecorationsResolverViewRange = e), this._cachedModelDecorationsResolver;
        }
        getInlineDecorationsOnLine(e, t = false, i = false) {
          const n = new z(e, this._linesCollection.getViewLineMinColumn(e), e, this._linesCollection.getViewLineMaxColumn(e));
          return this._getDecorationsInRange(n, t, i).inlineDecorations[0];
        }
        _getDecorationsInRange(e, t, i) {
          const n = this._linesCollection.getDecorationsInRange(e, this.editorId, G0(this.configuration.options), t, i), o = e.startLineNumber, r = e.endLineNumber, a = [];
          let l = 0;
          const u = [];
          for (let d = o; d <= r; d++) u[d - o] = [];
          for (let d = 0, f = n.length; d < f; d++) {
            const m = n[d], _ = m.options;
            if (!zue(this.model, m)) continue;
            const b = this._getOrCreateViewModelDecoration(m), v = b.range;
            if (a[l++] = b, _.inlineClassName) {
              const y = new Op(v, _.inlineClassName, _.inlineClassNameAffectsLetterSpacing ? 3 : 0), x = Math.max(o, v.startLineNumber), L = Math.min(r, v.endLineNumber);
              for (let D = x; D <= L; D++) u[D - o].push(y);
            }
            if (_.beforeContentClassName && o <= v.startLineNumber && v.startLineNumber <= r) {
              const y = new Op(new z(v.startLineNumber, v.startColumn, v.startLineNumber, v.startColumn), _.beforeContentClassName, 1);
              u[v.startLineNumber - o].push(y);
            }
            if (_.afterContentClassName && o <= v.endLineNumber && v.endLineNumber <= r) {
              const y = new Op(new z(v.endLineNumber, v.endColumn, v.endLineNumber, v.endColumn), _.afterContentClassName, 2);
              u[v.endLineNumber - o].push(y);
            }
          }
          return {
            decorations: a,
            inlineDecorations: u
          };
        }
      }
      function zue(s, e) {
        return !(e.options.hideInCommentTokens && Uue(s, e) || e.options.hideInStringTokens && $ue(s, e));
      }
      function Uue(s, e) {
        return zF(s, e.range, (t) => t === 1);
      }
      function $ue(s, e) {
        return zF(s, e.range, (t) => t === 2);
      }
      function zF(s, e, t) {
        for (let i = e.startLineNumber; i <= e.endLineNumber; i++) {
          const n = s.tokenization.getLineTokens(i), o = i === e.startLineNumber, r = i === e.endLineNumber;
          let a = o ? n.findTokenIndexAtOffset(e.startColumn - 1) : 0;
          for (; a < n.getCount() && !(r && n.getStartOffset(a) > e.endColumn - 1); ) {
            if (!t(n.getStandardTokenType(a))) return false;
            a++;
          }
        }
        return true;
      }
      function xx(s, e) {
        return s === null ? e ? jw.INSTANCE : Gw.INSTANCE : new que(s, e);
      }
      class que {
        constructor(e, t) {
          this._projectionData = e, this._isVisible = t;
        }
        isVisible() {
          return this._isVisible;
        }
        setVisible(e) {
          return this._isVisible = e, this;
        }
        getProjectionData() {
          return this._projectionData;
        }
        getViewLineCount() {
          return this._isVisible ? this._projectionData.getOutputLineCount() : 0;
        }
        getViewLineContent(e, t, i) {
          this._assertVisible();
          const n = i > 0 ? this._projectionData.breakOffsets[i - 1] : 0, o = this._projectionData.breakOffsets[i];
          let r;
          if (this._projectionData.injectionOffsets !== null) {
            const a = this._projectionData.injectionOffsets.map((u, d) => new Kr(0, 0, u + 1, this._projectionData.injectionOptions[d], 0));
            r = Kr.applyInjectedText(e.getLineContent(t), a).substring(n, o);
          } else r = e.getValueInRange({
            startLineNumber: t,
            startColumn: n + 1,
            endLineNumber: t,
            endColumn: o + 1
          });
          return i > 0 && (r = n7(this._projectionData.wrappedTextIndentLength) + r), r;
        }
        getViewLineLength(e, t, i) {
          return this._assertVisible(), this._projectionData.getLineLength(i);
        }
        getViewLineMinColumn(e, t, i) {
          return this._assertVisible(), this._projectionData.getMinOutputOffset(i) + 1;
        }
        getViewLineMaxColumn(e, t, i) {
          return this._assertVisible(), this._projectionData.getMaxOutputOffset(i) + 1;
        }
        getViewLineData(e, t, i) {
          const n = new Array();
          return this.getViewLinesData(e, t, i, 1, 0, [
            true
          ], n), n[0];
        }
        getViewLinesData(e, t, i, n, o, r, a) {
          this._assertVisible();
          const l = this._projectionData, u = l.injectionOffsets, d = l.injectionOptions;
          let f = null;
          if (u) {
            f = [];
            let _ = 0, b = 0;
            for (let v = 0; v < l.getOutputLineCount(); v++) {
              const y = new Array();
              f[v] = y;
              const x = v > 0 ? l.breakOffsets[v - 1] : 0, L = l.breakOffsets[v];
              for (; b < u.length; ) {
                const D = d[b].content.length, k = u[b] + _, T = k + D;
                if (k > L) break;
                if (x < T) {
                  const M = d[b];
                  if (M.inlineClassName) {
                    const I = v > 0 ? l.wrappedTextIndentLength : 0, R = I + Math.max(k - x, 0), A = I + Math.min(T - x, L - x);
                    R !== A && y.push(new Mae(R, A, M.inlineClassName, M.inlineClassNameAffectsLetterSpacing));
                  }
                }
                if (T <= L) _ += D, b++;
                else break;
              }
            }
          }
          let m;
          u ? m = e.tokenization.getLineTokens(t).withInserted(u.map((_, b) => ({
            offset: _,
            text: d[b].content,
            tokenMetadata: Fi.defaultTokenMetadata
          }))) : m = e.tokenization.getLineTokens(t);
          for (let _ = i; _ < i + n; _++) {
            const b = o + _ - i;
            if (!r[b]) {
              a[b] = null;
              continue;
            }
            a[b] = this._getViewLineData(m, f ? f[_] : null, _);
          }
        }
        _getViewLineData(e, t, i) {
          this._assertVisible();
          const n = this._projectionData, o = i > 0 ? n.wrappedTextIndentLength : 0, r = i > 0 ? n.breakOffsets[i - 1] : 0, a = n.breakOffsets[i], l = e.sliceAndInflate(r, a, o);
          let u = l.getLineContent();
          i > 0 && (u = n7(n.wrappedTextIndentLength) + u);
          const d = this._projectionData.getMinOutputOffset(i) + 1, f = u.length + 1, m = i + 1 < this.getViewLineCount(), _ = i === 0 ? 0 : n.breakOffsetsVisibleColumn[i - 1];
          return new KN(u, m, d, f, _, l, t);
        }
        getModelColumnOfViewPosition(e, t) {
          return this._assertVisible(), this._projectionData.translateToInputOffset(e, t - 1) + 1;
        }
        getViewPositionOfModelPosition(e, t, i = 2) {
          return this._assertVisible(), this._projectionData.translateToOutputPosition(t - 1, i).toPosition(e);
        }
        getViewLineNumberOfModelPosition(e, t) {
          this._assertVisible();
          const i = this._projectionData.translateToOutputPosition(t - 1);
          return e + i.outputLineIndex;
        }
        normalizePosition(e, t, i) {
          const n = t.lineNumber - e;
          return this._projectionData.normalizeOutputPosition(e, t.column - 1, i).toPosition(n);
        }
        getInjectedTextAt(e, t) {
          return this._projectionData.getInjectedText(e, t - 1);
        }
        _assertVisible() {
          if (!this._isVisible) throw new Error("Not supported");
        }
      }
      const _jw = class _jw {
        constructor() {
        }
        isVisible() {
          return true;
        }
        setVisible(e) {
          return e ? this : Gw.INSTANCE;
        }
        getProjectionData() {
          return null;
        }
        getViewLineCount() {
          return 1;
        }
        getViewLineContent(e, t, i) {
          return e.getLineContent(t);
        }
        getViewLineLength(e, t, i) {
          return e.getLineLength(t);
        }
        getViewLineMinColumn(e, t, i) {
          return e.getLineMinColumn(t);
        }
        getViewLineMaxColumn(e, t, i) {
          return e.getLineMaxColumn(t);
        }
        getViewLineData(e, t, i) {
          const n = e.tokenization.getLineTokens(t), o = n.getLineContent();
          return new KN(o, false, 1, o.length + 1, 0, n.inflate(), null);
        }
        getViewLinesData(e, t, i, n, o, r, a) {
          if (!r[o]) {
            a[o] = null;
            return;
          }
          a[o] = this.getViewLineData(e, t, 0);
        }
        getModelColumnOfViewPosition(e, t) {
          return t;
        }
        getViewPositionOfModelPosition(e, t) {
          return new X(e, t);
        }
        getViewLineNumberOfModelPosition(e, t) {
          return e;
        }
        normalizePosition(e, t, i) {
          return t;
        }
        getInjectedTextAt(e, t) {
          return null;
        }
      };
      _jw.INSTANCE = new _jw();
      let jw = _jw;
      const _Gw = class _Gw {
        constructor() {
        }
        isVisible() {
          return false;
        }
        setVisible(e) {
          return e ? jw.INSTANCE : this;
        }
        getProjectionData() {
          return null;
        }
        getViewLineCount() {
          return 0;
        }
        getViewLineContent(e, t, i) {
          throw new Error("Not supported");
        }
        getViewLineLength(e, t, i) {
          throw new Error("Not supported");
        }
        getViewLineMinColumn(e, t, i) {
          throw new Error("Not supported");
        }
        getViewLineMaxColumn(e, t, i) {
          throw new Error("Not supported");
        }
        getViewLineData(e, t, i) {
          throw new Error("Not supported");
        }
        getViewLinesData(e, t, i, n, o, r, a) {
          throw new Error("Not supported");
        }
        getModelColumnOfViewPosition(e, t) {
          throw new Error("Not supported");
        }
        getViewPositionOfModelPosition(e, t) {
          throw new Error("Not supported");
        }
        getViewLineNumberOfModelPosition(e, t) {
          throw new Error("Not supported");
        }
        normalizePosition(e, t, i) {
          throw new Error("Not supported");
        }
        getInjectedTextAt(e, t) {
          throw new Error("Not supported");
        }
      };
      _Gw.INSTANCE = new _Gw();
      let Gw = _Gw;
      const kx = [
        ""
      ];
      function n7(s) {
        if (s >= kx.length) for (let e = 1; e <= s; e++) kx[e] = Kue(e);
        return kx[s];
      }
      function Kue(s) {
        return new Array(s + 1).join(" ");
      }
      class jue {
        constructor(e, t, i, n, o, r, a, l, u, d) {
          this._editorId = e, this.model = t, this._validModelVersionId = -1, this._domLineBreaksComputerFactory = i, this._monospaceLineBreaksComputerFactory = n, this.fontInfo = o, this.tabSize = r, this.wrappingStrategy = a, this.wrappingColumn = l, this.wrappingIndent = u, this.wordBreak = d, this._constructLines(true, null);
        }
        dispose() {
          this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, []);
        }
        createCoordinatesConverter() {
          return new Yue(this);
        }
        _constructLines(e, t) {
          this.modelLineProjections = [], e && (this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, []));
          const i = this.model.getLinesContent(), n = this.model.getInjectedTextDecorations(this._editorId), o = i.length, r = this.createLineBreaksComputer(), a = new zl(Kr.fromDecorations(n));
          for (let v = 0; v < o; v++) {
            const y = a.takeWhile((x) => x.lineNumber === v + 1);
            r.addRequest(i[v], y, t ? t[v] : null);
          }
          const l = r.finalize(), u = [], d = this.hiddenAreasDecorationIds.map((v) => this.model.getDecorationRange(v)).sort(z.compareRangesUsingStarts);
          let f = 1, m = 0, _ = -1, b = _ + 1 < d.length ? m + 1 : o + 2;
          for (let v = 0; v < o; v++) {
            const y = v + 1;
            y === b && (_++, f = d[_].startLineNumber, m = d[_].endLineNumber, b = _ + 1 < d.length ? m + 1 : o + 2);
            const x = y >= f && y <= m, L = xx(l[v], !x);
            u[v] = L.getViewLineCount(), this.modelLineProjections[v] = L;
          }
          this._validModelVersionId = this.model.getVersionId(), this.projectedModelLineLineCounts = new PY(u);
        }
        getHiddenAreas() {
          return this.hiddenAreasDecorationIds.map((e) => this.model.getDecorationRange(e));
        }
        setHiddenAreas(e) {
          const t = e.map((m) => this.model.validateRange(m)), i = Gue(t), n = this.hiddenAreasDecorationIds.map((m) => this.model.getDecorationRange(m)).sort(z.compareRangesUsingStarts);
          if (i.length === n.length) {
            let m = false;
            for (let _ = 0; _ < i.length; _++) if (!i[_].equalsRange(n[_])) {
              m = true;
              break;
            }
            if (!m) return false;
          }
          const o = i.map((m) => ({
            range: m,
            options: Zi.EMPTY
          }));
          this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, o);
          const r = i;
          let a = 1, l = 0, u = -1, d = u + 1 < r.length ? l + 1 : this.modelLineProjections.length + 2, f = false;
          for (let m = 0; m < this.modelLineProjections.length; m++) {
            const _ = m + 1;
            _ === d && (u++, a = r[u].startLineNumber, l = r[u].endLineNumber, d = u + 1 < r.length ? l + 1 : this.modelLineProjections.length + 2);
            let b = false;
            if (_ >= a && _ <= l ? this.modelLineProjections[m].isVisible() && (this.modelLineProjections[m] = this.modelLineProjections[m].setVisible(false), b = true) : (f = true, this.modelLineProjections[m].isVisible() || (this.modelLineProjections[m] = this.modelLineProjections[m].setVisible(true), b = true)), b) {
              const v = this.modelLineProjections[m].getViewLineCount();
              this.projectedModelLineLineCounts.setValue(m, v);
            }
          }
          return f || this.setHiddenAreas([]), true;
        }
        modelPositionIsVisible(e, t) {
          return e < 1 || e > this.modelLineProjections.length ? false : this.modelLineProjections[e - 1].isVisible();
        }
        getModelLineViewLineCount(e) {
          return e < 1 || e > this.modelLineProjections.length ? 1 : this.modelLineProjections[e - 1].getViewLineCount();
        }
        setTabSize(e) {
          return this.tabSize === e ? false : (this.tabSize = e, this._constructLines(false, null), true);
        }
        setWrappingSettings(e, t, i, n, o) {
          const r = this.fontInfo.equals(e), a = this.wrappingStrategy === t, l = this.wrappingColumn === i, u = this.wrappingIndent === n, d = this.wordBreak === o;
          if (r && a && l && u && d) return false;
          const f = r && a && !l && u && d;
          this.fontInfo = e, this.wrappingStrategy = t, this.wrappingColumn = i, this.wrappingIndent = n, this.wordBreak = o;
          let m = null;
          if (f) {
            m = [];
            for (let _ = 0, b = this.modelLineProjections.length; _ < b; _++) m[_] = this.modelLineProjections[_].getProjectionData();
          }
          return this._constructLines(false, m), true;
        }
        createLineBreaksComputer() {
          return (this.wrappingStrategy === "advanced" ? this._domLineBreaksComputerFactory : this._monospaceLineBreaksComputerFactory).createLineBreaksComputer(this.fontInfo, this.tabSize, this.wrappingColumn, this.wrappingIndent, this.wordBreak);
        }
        onModelFlushed() {
          this._constructLines(true, null);
        }
        onModelLinesDeleted(e, t, i) {
          if (!e || e <= this._validModelVersionId) return null;
          const n = t === 1 ? 1 : this.projectedModelLineLineCounts.getPrefixSum(t - 1) + 1, o = this.projectedModelLineLineCounts.getPrefixSum(i);
          return this.modelLineProjections.splice(t - 1, i - t + 1), this.projectedModelLineLineCounts.removeValues(t - 1, i - t + 1), new sE(n, o);
        }
        onModelLinesInserted(e, t, i, n) {
          if (!e || e <= this._validModelVersionId) return null;
          const o = t > 2 && !this.modelLineProjections[t - 2].isVisible(), r = t === 1 ? 1 : this.projectedModelLineLineCounts.getPrefixSum(t - 1) + 1;
          let a = 0;
          const l = [], u = [];
          for (let d = 0, f = n.length; d < f; d++) {
            const m = xx(n[d], !o);
            l.push(m);
            const _ = m.getViewLineCount();
            a += _, u[d] = _;
          }
          return this.modelLineProjections = this.modelLineProjections.slice(0, t - 1).concat(l).concat(this.modelLineProjections.slice(t - 1)), this.projectedModelLineLineCounts.insertValues(t - 1, u), new oE(r, r + a - 1);
        }
        onModelLineChanged(e, t, i) {
          if (e !== null && e <= this._validModelVersionId) return [
            false,
            null,
            null,
            null
          ];
          const n = t - 1, o = this.modelLineProjections[n].getViewLineCount(), r = this.modelLineProjections[n].isVisible(), a = xx(i, r);
          this.modelLineProjections[n] = a;
          const l = this.modelLineProjections[n].getViewLineCount();
          let u = false, d = 0, f = -1, m = 0, _ = -1, b = 0, v = -1;
          o > l ? (d = this.projectedModelLineLineCounts.getPrefixSum(t - 1) + 1, f = d + l - 1, b = f + 1, v = b + (o - l) - 1, u = true) : o < l ? (d = this.projectedModelLineLineCounts.getPrefixSum(t - 1) + 1, f = d + o - 1, m = f + 1, _ = m + (l - o) - 1, u = true) : (d = this.projectedModelLineLineCounts.getPrefixSum(t - 1) + 1, f = d + l - 1), this.projectedModelLineLineCounts.setValue(n, l);
          const y = d <= f ? new HF(d, f - d + 1) : null, x = m <= _ ? new oE(m, _) : null, L = b <= v ? new sE(b, v) : null;
          return [
            u,
            y,
            x,
            L
          ];
        }
        acceptVersionId(e) {
          this._validModelVersionId = e, this.modelLineProjections.length === 1 && !this.modelLineProjections[0].isVisible() && this.setHiddenAreas([]);
        }
        getViewLineCount() {
          return this.projectedModelLineLineCounts.getTotalSum();
        }
        _toValidViewLineNumber(e) {
          if (e < 1) return 1;
          const t = this.getViewLineCount();
          return e > t ? t : e | 0;
        }
        getActiveIndentGuide(e, t, i) {
          e = this._toValidViewLineNumber(e), t = this._toValidViewLineNumber(t), i = this._toValidViewLineNumber(i);
          const n = this.convertViewPositionToModelPosition(e, this.getViewLineMinColumn(e)), o = this.convertViewPositionToModelPosition(t, this.getViewLineMinColumn(t)), r = this.convertViewPositionToModelPosition(i, this.getViewLineMinColumn(i)), a = this.model.guides.getActiveIndentGuide(n.lineNumber, o.lineNumber, r.lineNumber), l = this.convertModelPositionToViewPosition(a.startLineNumber, 1), u = this.convertModelPositionToViewPosition(a.endLineNumber, this.model.getLineMaxColumn(a.endLineNumber));
          return {
            startLineNumber: l.lineNumber,
            endLineNumber: u.lineNumber,
            indent: a.indent
          };
        }
        getViewLineInfo(e) {
          e = this._toValidViewLineNumber(e);
          const t = this.projectedModelLineLineCounts.getIndexOf(e - 1), i = t.index, n = t.remainder;
          return new s7(i + 1, n);
        }
        getMinColumnOfViewLine(e) {
          return this.modelLineProjections[e.modelLineNumber - 1].getViewLineMinColumn(this.model, e.modelLineNumber, e.modelLineWrappedLineIdx);
        }
        getMaxColumnOfViewLine(e) {
          return this.modelLineProjections[e.modelLineNumber - 1].getViewLineMaxColumn(this.model, e.modelLineNumber, e.modelLineWrappedLineIdx);
        }
        getModelStartPositionOfViewLine(e) {
          const t = this.modelLineProjections[e.modelLineNumber - 1], i = t.getViewLineMinColumn(this.model, e.modelLineNumber, e.modelLineWrappedLineIdx), n = t.getModelColumnOfViewPosition(e.modelLineWrappedLineIdx, i);
          return new X(e.modelLineNumber, n);
        }
        getModelEndPositionOfViewLine(e) {
          const t = this.modelLineProjections[e.modelLineNumber - 1], i = t.getViewLineMaxColumn(this.model, e.modelLineNumber, e.modelLineWrappedLineIdx), n = t.getModelColumnOfViewPosition(e.modelLineWrappedLineIdx, i);
          return new X(e.modelLineNumber, n);
        }
        getViewLineInfosGroupedByModelRanges(e, t) {
          const i = this.getViewLineInfo(e), n = this.getViewLineInfo(t), o = new Array();
          let r = this.getModelStartPositionOfViewLine(i), a = new Array();
          for (let l = i.modelLineNumber; l <= n.modelLineNumber; l++) {
            const u = this.modelLineProjections[l - 1];
            if (u.isVisible()) {
              const d = l === i.modelLineNumber ? i.modelLineWrappedLineIdx : 0, f = l === n.modelLineNumber ? n.modelLineWrappedLineIdx + 1 : u.getViewLineCount();
              for (let m = d; m < f; m++) a.push(new s7(l, m));
            }
            if (!u.isVisible() && r) {
              const d = new X(l - 1, this.model.getLineMaxColumn(l - 1) + 1), f = z.fromPositions(r, d);
              o.push(new o7(f, a)), a = [], r = null;
            } else u.isVisible() && !r && (r = new X(l, 1));
          }
          if (r) {
            const l = z.fromPositions(r, this.getModelEndPositionOfViewLine(n));
            o.push(new o7(l, a));
          }
          return o;
        }
        getViewLinesBracketGuides(e, t, i, n) {
          const o = i ? this.convertViewPositionToModelPosition(i.lineNumber, i.column) : null, r = [];
          for (const a of this.getViewLineInfosGroupedByModelRanges(e, t)) {
            const l = a.modelRange.startLineNumber, u = this.model.guides.getLinesBracketGuides(l, a.modelRange.endLineNumber, o, n);
            for (const d of a.viewLines) {
              const m = u[d.modelLineNumber - l].map((_) => {
                if (_.forWrappedLinesAfterColumn !== -1 && this.modelLineProjections[d.modelLineNumber - 1].getViewPositionOfModelPosition(0, _.forWrappedLinesAfterColumn).lineNumber >= d.modelLineWrappedLineIdx || _.forWrappedLinesBeforeOrAtColumn !== -1 && this.modelLineProjections[d.modelLineNumber - 1].getViewPositionOfModelPosition(0, _.forWrappedLinesBeforeOrAtColumn).lineNumber < d.modelLineWrappedLineIdx) return;
                if (!_.horizontalLine) return _;
                let b = -1;
                if (_.column !== -1) {
                  const x = this.modelLineProjections[d.modelLineNumber - 1].getViewPositionOfModelPosition(0, _.column);
                  if (x.lineNumber === d.modelLineWrappedLineIdx) b = x.column;
                  else if (x.lineNumber < d.modelLineWrappedLineIdx) b = this.getMinColumnOfViewLine(d);
                  else if (x.lineNumber > d.modelLineWrappedLineIdx) return;
                }
                const v = this.convertModelPositionToViewPosition(d.modelLineNumber, _.horizontalLine.endColumn), y = this.modelLineProjections[d.modelLineNumber - 1].getViewPositionOfModelPosition(0, _.horizontalLine.endColumn);
                return y.lineNumber === d.modelLineWrappedLineIdx ? new ph(_.visibleColumn, b, _.className, new kp(_.horizontalLine.top, v.column), -1, -1) : y.lineNumber < d.modelLineWrappedLineIdx || _.visibleColumn !== -1 ? void 0 : new ph(_.visibleColumn, b, _.className, new kp(_.horizontalLine.top, this.getMaxColumnOfViewLine(d)), -1, -1);
              });
              r.push(m.filter((_) => !!_));
            }
          }
          return r;
        }
        getViewLinesIndentGuides(e, t) {
          e = this._toValidViewLineNumber(e), t = this._toValidViewLineNumber(t);
          const i = this.convertViewPositionToModelPosition(e, this.getViewLineMinColumn(e)), n = this.convertViewPositionToModelPosition(t, this.getViewLineMaxColumn(t));
          let o = [];
          const r = [], a = [], l = i.lineNumber - 1, u = n.lineNumber - 1;
          let d = null;
          for (let b = l; b <= u; b++) {
            const v = this.modelLineProjections[b];
            if (v.isVisible()) {
              const y = v.getViewLineNumberOfModelPosition(0, b === l ? i.column : 1), x = v.getViewLineNumberOfModelPosition(0, this.model.getLineMaxColumn(b + 1)), L = x - y + 1;
              let D = 0;
              L > 1 && v.getViewLineMinColumn(this.model, b + 1, x) === 1 && (D = y === 0 ? 1 : 2), r.push(L), a.push(D), d === null && (d = new X(b + 1, 0));
            } else d !== null && (o = o.concat(this.model.guides.getLinesIndentGuides(d.lineNumber, b)), d = null);
          }
          d !== null && (o = o.concat(this.model.guides.getLinesIndentGuides(d.lineNumber, n.lineNumber)), d = null);
          const f = t - e + 1, m = new Array(f);
          let _ = 0;
          for (let b = 0, v = o.length; b < v; b++) {
            let y = o[b];
            const x = Math.min(f - _, r[b]), L = a[b];
            let D;
            L === 2 ? D = 0 : L === 1 ? D = 1 : D = x;
            for (let k = 0; k < x; k++) k === D && (y = 0), m[_++] = y;
          }
          return m;
        }
        getViewLineContent(e) {
          const t = this.getViewLineInfo(e);
          return this.modelLineProjections[t.modelLineNumber - 1].getViewLineContent(this.model, t.modelLineNumber, t.modelLineWrappedLineIdx);
        }
        getViewLineLength(e) {
          const t = this.getViewLineInfo(e);
          return this.modelLineProjections[t.modelLineNumber - 1].getViewLineLength(this.model, t.modelLineNumber, t.modelLineWrappedLineIdx);
        }
        getViewLineMinColumn(e) {
          const t = this.getViewLineInfo(e);
          return this.modelLineProjections[t.modelLineNumber - 1].getViewLineMinColumn(this.model, t.modelLineNumber, t.modelLineWrappedLineIdx);
        }
        getViewLineMaxColumn(e) {
          const t = this.getViewLineInfo(e);
          return this.modelLineProjections[t.modelLineNumber - 1].getViewLineMaxColumn(this.model, t.modelLineNumber, t.modelLineWrappedLineIdx);
        }
        getViewLineData(e) {
          const t = this.getViewLineInfo(e);
          return this.modelLineProjections[t.modelLineNumber - 1].getViewLineData(this.model, t.modelLineNumber, t.modelLineWrappedLineIdx);
        }
        getViewLinesData(e, t, i) {
          e = this._toValidViewLineNumber(e), t = this._toValidViewLineNumber(t);
          const n = this.projectedModelLineLineCounts.getIndexOf(e - 1);
          let o = e;
          const r = n.index, a = n.remainder, l = [];
          for (let u = r, d = this.model.getLineCount(); u < d; u++) {
            const f = this.modelLineProjections[u];
            if (!f.isVisible()) continue;
            const m = u === r ? a : 0;
            let _ = f.getViewLineCount() - m, b = false;
            if (o + _ > t && (b = true, _ = t - o + 1), f.getViewLinesData(this.model, u + 1, m, _, o - e, i, l), o += _, b) break;
          }
          return l;
        }
        validateViewPosition(e, t, i) {
          e = this._toValidViewLineNumber(e);
          const n = this.projectedModelLineLineCounts.getIndexOf(e - 1), o = n.index, r = n.remainder, a = this.modelLineProjections[o], l = a.getViewLineMinColumn(this.model, o + 1, r), u = a.getViewLineMaxColumn(this.model, o + 1, r);
          t < l && (t = l), t > u && (t = u);
          const d = a.getModelColumnOfViewPosition(r, t);
          return this.model.validatePosition(new X(o + 1, d)).equals(i) ? new X(e, t) : this.convertModelPositionToViewPosition(i.lineNumber, i.column);
        }
        validateViewRange(e, t) {
          const i = this.validateViewPosition(e.startLineNumber, e.startColumn, t.getStartPosition()), n = this.validateViewPosition(e.endLineNumber, e.endColumn, t.getEndPosition());
          return new z(i.lineNumber, i.column, n.lineNumber, n.column);
        }
        convertViewPositionToModelPosition(e, t) {
          const i = this.getViewLineInfo(e), n = this.modelLineProjections[i.modelLineNumber - 1].getModelColumnOfViewPosition(i.modelLineWrappedLineIdx, t);
          return this.model.validatePosition(new X(i.modelLineNumber, n));
        }
        convertViewRangeToModelRange(e) {
          const t = this.convertViewPositionToModelPosition(e.startLineNumber, e.startColumn), i = this.convertViewPositionToModelPosition(e.endLineNumber, e.endColumn);
          return new z(t.lineNumber, t.column, i.lineNumber, i.column);
        }
        convertModelPositionToViewPosition(e, t, i = 2, n = false, o = false) {
          const r = this.model.validatePosition(new X(e, t)), a = r.lineNumber, l = r.column;
          let u = a - 1, d = false;
          if (o) for (; u < this.modelLineProjections.length && !this.modelLineProjections[u].isVisible(); ) u++, d = true;
          else for (; u > 0 && !this.modelLineProjections[u].isVisible(); ) u--, d = true;
          if (u === 0 && !this.modelLineProjections[u].isVisible()) return new X(n ? 0 : 1, 1);
          const f = 1 + this.projectedModelLineLineCounts.getPrefixSum(u);
          let m;
          return d ? o ? m = this.modelLineProjections[u].getViewPositionOfModelPosition(f, 1, i) : m = this.modelLineProjections[u].getViewPositionOfModelPosition(f, this.model.getLineMaxColumn(u + 1), i) : m = this.modelLineProjections[a - 1].getViewPositionOfModelPosition(f, l, i), m;
        }
        convertModelRangeToViewRange(e, t = 0) {
          if (e.isEmpty()) {
            const i = this.convertModelPositionToViewPosition(e.startLineNumber, e.startColumn, t);
            return z.fromPositions(i);
          } else {
            const i = this.convertModelPositionToViewPosition(e.startLineNumber, e.startColumn, 1), n = this.convertModelPositionToViewPosition(e.endLineNumber, e.endColumn, 0);
            return new z(i.lineNumber, i.column, n.lineNumber, n.column);
          }
        }
        getViewLineNumberOfModelPosition(e, t) {
          let i = e - 1;
          if (this.modelLineProjections[i].isVisible()) {
            const o = 1 + this.projectedModelLineLineCounts.getPrefixSum(i);
            return this.modelLineProjections[i].getViewLineNumberOfModelPosition(o, t);
          }
          for (; i > 0 && !this.modelLineProjections[i].isVisible(); ) i--;
          if (i === 0 && !this.modelLineProjections[i].isVisible()) return 1;
          const n = 1 + this.projectedModelLineLineCounts.getPrefixSum(i);
          return this.modelLineProjections[i].getViewLineNumberOfModelPosition(n, this.model.getLineMaxColumn(i + 1));
        }
        getDecorationsInRange(e, t, i, n, o) {
          const r = this.convertViewPositionToModelPosition(e.startLineNumber, e.startColumn), a = this.convertViewPositionToModelPosition(e.endLineNumber, e.endColumn);
          if (a.lineNumber - r.lineNumber <= e.endLineNumber - e.startLineNumber) return this.model.getDecorationsInRange(new z(r.lineNumber, 1, a.lineNumber, a.column), t, i, n, o);
          let l = [];
          const u = r.lineNumber - 1, d = a.lineNumber - 1;
          let f = null;
          for (let v = u; v <= d; v++) if (this.modelLineProjections[v].isVisible()) f === null && (f = new X(v + 1, v === u ? r.column : 1));
          else if (f !== null) {
            const x = this.model.getLineMaxColumn(v);
            l = l.concat(this.model.getDecorationsInRange(new z(f.lineNumber, f.column, v, x), t, i, n)), f = null;
          }
          f !== null && (l = l.concat(this.model.getDecorationsInRange(new z(f.lineNumber, f.column, a.lineNumber, a.column), t, i, n)), f = null), l.sort((v, y) => {
            const x = z.compareRangesUsingStarts(v.range, y.range);
            return x === 0 ? v.id < y.id ? -1 : v.id > y.id ? 1 : 0 : x;
          });
          const m = [];
          let _ = 0, b = null;
          for (const v of l) {
            const y = v.id;
            b !== y && (b = y, m[_++] = v);
          }
          return m;
        }
        getInjectedTextAt(e) {
          const t = this.getViewLineInfo(e.lineNumber);
          return this.modelLineProjections[t.modelLineNumber - 1].getInjectedTextAt(t.modelLineWrappedLineIdx, e.column);
        }
        normalizePosition(e, t) {
          const i = this.getViewLineInfo(e.lineNumber);
          return this.modelLineProjections[i.modelLineNumber - 1].normalizePosition(i.modelLineWrappedLineIdx, e, t);
        }
        getLineIndentColumn(e) {
          const t = this.getViewLineInfo(e);
          return t.modelLineWrappedLineIdx === 0 ? this.model.getLineIndentColumn(t.modelLineNumber) : 0;
        }
      }
      function Gue(s) {
        if (s.length === 0) return [];
        const e = s.slice();
        e.sort(z.compareRangesUsingStarts);
        const t = [];
        let i = e[0].startLineNumber, n = e[0].endLineNumber;
        for (let o = 1, r = e.length; o < r; o++) {
          const a = e[o];
          a.startLineNumber > n + 1 ? (t.push(new z(i, 1, n, 1)), i = a.startLineNumber, n = a.endLineNumber) : a.endLineNumber > n && (n = a.endLineNumber);
        }
        return t.push(new z(i, 1, n, 1)), t;
      }
      class s7 {
        constructor(e, t) {
          this.modelLineNumber = e, this.modelLineWrappedLineIdx = t;
        }
      }
      class o7 {
        constructor(e, t) {
          this.modelRange = e, this.viewLines = t;
        }
      }
      class Yue {
        constructor(e) {
          this._lines = e;
        }
        convertViewPositionToModelPosition(e) {
          return this._lines.convertViewPositionToModelPosition(e.lineNumber, e.column);
        }
        convertViewRangeToModelRange(e) {
          return this._lines.convertViewRangeToModelRange(e);
        }
        validateViewPosition(e, t) {
          return this._lines.validateViewPosition(e.lineNumber, e.column, t);
        }
        validateViewRange(e, t) {
          return this._lines.validateViewRange(e, t);
        }
        convertModelPositionToViewPosition(e, t, i, n) {
          return this._lines.convertModelPositionToViewPosition(e.lineNumber, e.column, t, i, n);
        }
        convertModelRangeToViewRange(e, t) {
          return this._lines.convertModelRangeToViewRange(e, t);
        }
        modelPositionIsVisible(e) {
          return this._lines.modelPositionIsVisible(e.lineNumber, e.column);
        }
        getModelLineViewLineCount(e) {
          return this._lines.getModelLineViewLineCount(e);
        }
        getViewLineNumberOfModelPosition(e, t) {
          return this._lines.getViewLineNumberOfModelPosition(e, t);
        }
      }
      class Zue {
        constructor(e) {
          this.model = e;
        }
        dispose() {
        }
        createCoordinatesConverter() {
          return new Que(this);
        }
        getHiddenAreas() {
          return [];
        }
        setHiddenAreas(e) {
          return false;
        }
        setTabSize(e) {
          return false;
        }
        setWrappingSettings(e, t, i, n) {
          return false;
        }
        createLineBreaksComputer() {
          const e = [];
          return {
            addRequest: (t, i, n) => {
              e.push(null);
            },
            finalize: () => e
          };
        }
        onModelFlushed() {
        }
        onModelLinesDeleted(e, t, i) {
          return new sE(t, i);
        }
        onModelLinesInserted(e, t, i, n) {
          return new oE(t, i);
        }
        onModelLineChanged(e, t, i) {
          return [
            false,
            new HF(t, 1),
            null,
            null
          ];
        }
        acceptVersionId(e) {
        }
        getViewLineCount() {
          return this.model.getLineCount();
        }
        getActiveIndentGuide(e, t, i) {
          return {
            startLineNumber: e,
            endLineNumber: e,
            indent: 0
          };
        }
        getViewLinesBracketGuides(e, t, i) {
          return new Array(t - e + 1).fill([]);
        }
        getViewLinesIndentGuides(e, t) {
          const i = t - e + 1, n = new Array(i);
          for (let o = 0; o < i; o++) n[o] = 0;
          return n;
        }
        getViewLineContent(e) {
          return this.model.getLineContent(e);
        }
        getViewLineLength(e) {
          return this.model.getLineLength(e);
        }
        getViewLineMinColumn(e) {
          return this.model.getLineMinColumn(e);
        }
        getViewLineMaxColumn(e) {
          return this.model.getLineMaxColumn(e);
        }
        getViewLineData(e) {
          const t = this.model.tokenization.getLineTokens(e), i = t.getLineContent();
          return new KN(i, false, 1, i.length + 1, 0, t.inflate(), null);
        }
        getViewLinesData(e, t, i) {
          const n = this.model.getLineCount();
          e = Math.min(Math.max(1, e), n), t = Math.min(Math.max(1, t), n);
          const o = [];
          for (let r = e; r <= t; r++) {
            const a = r - e;
            o[a] = i[a] ? this.getViewLineData(r) : null;
          }
          return o;
        }
        getDecorationsInRange(e, t, i, n, o) {
          return this.model.getDecorationsInRange(e, t, i, n, o);
        }
        normalizePosition(e, t) {
          return this.model.normalizePosition(e, t);
        }
        getLineIndentColumn(e) {
          return this.model.getLineIndentColumn(e);
        }
        getInjectedTextAt(e) {
          return null;
        }
      }
      class Que {
        constructor(e) {
          this._lines = e;
        }
        _validPosition(e) {
          return this._lines.model.validatePosition(e);
        }
        _validRange(e) {
          return this._lines.model.validateRange(e);
        }
        convertViewPositionToModelPosition(e) {
          return this._validPosition(e);
        }
        convertViewRangeToModelRange(e) {
          return this._validRange(e);
        }
        validateViewPosition(e, t) {
          return this._validPosition(t);
        }
        validateViewRange(e, t) {
          return this._validRange(t);
        }
        convertModelPositionToViewPosition(e) {
          return this._validPosition(e);
        }
        convertModelRangeToViewRange(e) {
          return this._validRange(e);
        }
        modelPositionIsVisible(e) {
          const t = this._lines.model.getLineCount();
          return !(e.lineNumber < 1 || e.lineNumber > t);
        }
        getModelLineViewLineCount(e) {
          return 1;
        }
        getViewLineNumberOfModelPosition(e, t) {
          return e;
        }
      }
      const Uu = ru.Right;
      class Xue {
        constructor(e) {
          this.persist = 0, this._requiredLanes = 1, this.lanes = new Uint8Array(Math.ceil((e + 1) * Uu / 8));
        }
        reset(e) {
          const t = Math.ceil((e + 1) * Uu / 8);
          this.lanes.length < t ? this.lanes = new Uint8Array(t) : this.lanes.fill(0), this._requiredLanes = 1;
        }
        get requiredLanes() {
          return this._requiredLanes;
        }
        push(e, t, i) {
          i && (this.persist |= 1 << e - 1);
          for (let n = t.startLineNumber; n <= t.endLineNumber; n++) {
            const o = Uu * n + (e - 1);
            this.lanes[o >>> 3] |= 1 << o % 8, this._requiredLanes = Math.max(this._requiredLanes, this.countAtLine(n));
          }
        }
        getLanesAtLine(e) {
          const t = [];
          let i = Uu * e;
          for (let n = 0; n < Uu; n++) (this.persist & 1 << n || this.lanes[i >>> 3] & 1 << i % 8) && t.push(n + 1), i++;
          return t.length ? t : [
            ru.Center
          ];
        }
        countAtLine(e) {
          let t = Uu * e, i = 0;
          for (let n = 0; n < Uu; n++) (this.persist & 1 << n || this.lanes[t >>> 3] & 1 << t % 8) && i++, t++;
          return i;
        }
      }
      let Jue = class extends he {
        constructor(e, t, i, n, o, r, a, l, u, d) {
          if (super(), this.languageConfigurationService = a, this._themeService = l, this._attachedView = u, this._transactionalTarget = d, this.hiddenAreasModel = new the(), this.previousHiddenAreas = [], this._editorId = e, this._configuration = t, this.model = i, this._eventDispatcher = new wue(), this.onEvent = this._eventDispatcher.onEvent, this.cursorConfig = new tf(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService), this._updateConfigurationViewLineCount = this._register(new ns(() => this._updateConfigurationViewLineCountNow(), 0)), this._hasFocus = false, this._viewportStart = dI.create(this.model), this.glyphLanes = new Xue(0), this.model.isTooLargeForTokenization()) this._lines = new Zue(this.model);
          else {
            const f = this._configuration.options, m = f.get(50), _ = f.get(140), b = f.get(147), v = f.get(139), y = f.get(130);
            this._lines = new jue(this._editorId, this.model, n, o, m, this.model.getOptions().tabSize, _, b.wrappingColumn, v, y);
          }
          this.coordinatesConverter = this._lines.createCoordinatesConverter(), this._cursor = this._register(new Mue(i, this, this.coordinatesConverter, this.cursorConfig)), this.viewLayout = this._register(new Wue(this._configuration, this.getLineCount(), r)), this._register(this.viewLayout.onDidScroll((f) => {
            f.scrollTopChanged && this._handleVisibleLinesChanged(), f.scrollTopChanged && this._viewportStart.invalidate(), this._eventDispatcher.emitSingleViewEvent(new pue(f)), this._eventDispatcher.emitOutgoingEvent(new hI(f.oldScrollWidth, f.oldScrollLeft, f.oldScrollHeight, f.oldScrollTop, f.scrollWidth, f.scrollLeft, f.scrollHeight, f.scrollTop));
          })), this._register(this.viewLayout.onDidContentSizeChange((f) => {
            this._eventDispatcher.emitOutgoingEvent(f);
          })), this._decorations = new Hue(this._editorId, this.model, this._configuration, this._lines, this.coordinatesConverter), this._registerModelEvents(), this._register(this._configuration.onDidChangeFast((f) => {
            try {
              const m = this._eventDispatcher.beginEmitViewEvents();
              this._onConfigurationChanged(m, f);
            } finally {
              this._eventDispatcher.endEmitViewEvents();
            }
          })), this._register(qw.getInstance().onDidChange(() => {
            this._eventDispatcher.emitSingleViewEvent(new vue());
          })), this._register(this._themeService.onDidColorThemeChange((f) => {
            this._invalidateDecorationsColorCache(), this._eventDispatcher.emitSingleViewEvent(new _ue(f));
          })), this._updateConfigurationViewLineCountNow();
        }
        dispose() {
          super.dispose(), this._decorations.dispose(), this._lines.dispose(), this._viewportStart.dispose(), this._eventDispatcher.dispose();
        }
        createLineBreaksComputer() {
          return this._lines.createLineBreaksComputer();
        }
        addViewEventHandler(e) {
          this._eventDispatcher.addViewEventHandler(e);
        }
        removeViewEventHandler(e) {
          this._eventDispatcher.removeViewEventHandler(e);
        }
        _updateConfigurationViewLineCountNow() {
          this._configuration.setViewLineCount(this._lines.getViewLineCount());
        }
        getModelVisibleRanges() {
          const e = this.viewLayout.getLinesViewportData(), t = new z(e.startLineNumber, this.getLineMinColumn(e.startLineNumber), e.endLineNumber, this.getLineMaxColumn(e.endLineNumber));
          return this._toModelVisibleRanges(t);
        }
        visibleLinesStabilized() {
          const e = this.getModelVisibleRanges();
          this._attachedView.setVisibleLines(e, true);
        }
        _handleVisibleLinesChanged() {
          const e = this.getModelVisibleRanges();
          this._attachedView.setVisibleLines(e, false);
        }
        setHasFocus(e) {
          this._hasFocus = e, this._cursor.setHasFocus(e), this._eventDispatcher.emitSingleViewEvent(new gue(e)), this._eventDispatcher.emitOutgoingEvent(new uI(!e, e));
        }
        onCompositionStart() {
          this._eventDispatcher.emitSingleViewEvent(new uue());
        }
        onCompositionEnd() {
          this._eventDispatcher.emitSingleViewEvent(new hue());
        }
        _captureStableViewport() {
          if (this._viewportStart.isValid && this.viewLayout.getCurrentScrollTop() > 0) {
            const e = new X(this._viewportStart.viewLineNumber, this.getLineMinColumn(this._viewportStart.viewLineNumber)), t = this.coordinatesConverter.convertViewPositionToModelPosition(e);
            return new a7(t, this._viewportStart.startLineDelta);
          }
          return new a7(null, 0);
        }
        _onConfigurationChanged(e, t) {
          const i = this._captureStableViewport(), n = this._configuration.options, o = n.get(50), r = n.get(140), a = n.get(147), l = n.get(139), u = n.get(130);
          this._lines.setWrappingSettings(o, r, a.wrappingColumn, l, u) && (e.emitViewEvent(new r0()), e.emitViewEvent(new a0()), e.emitViewEvent(new zu(null)), this._cursor.onLineMappingChanged(e), this._decorations.onLineMappingChanged(), this.viewLayout.onFlushed(this.getLineCount()), this._updateConfigurationViewLineCount.schedule()), t.hasChanged(92) && (this._decorations.reset(), e.emitViewEvent(new zu(null))), t.hasChanged(99) && (this._decorations.reset(), e.emitViewEvent(new zu(null))), e.emitViewEvent(new due(t)), this.viewLayout.onConfigurationChanged(t), i.recoverViewportStart(this.coordinatesConverter, this.viewLayout), tf.shouldRecreate(t) && (this.cursorConfig = new tf(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService), this._cursor.updateConfiguration(this.cursorConfig));
        }
        _registerModelEvents() {
          this._register(this.model.onDidChangeContentOrInjectedText((e) => {
            try {
              const i = this._eventDispatcher.beginEmitViewEvents();
              let n = false, o = false;
              const r = e instanceof xh ? e.rawContentChangedEvent.changes : e.changes, a = e instanceof xh ? e.rawContentChangedEvent.versionId : null, l = this._lines.createLineBreaksComputer();
              for (const f of r) switch (f.changeType) {
                case 4: {
                  for (let m = 0; m < f.detail.length; m++) {
                    const _ = f.detail[m];
                    let b = f.injectedTexts[m];
                    b && (b = b.filter((v) => !v.ownerId || v.ownerId === this._editorId)), l.addRequest(_, b, null);
                  }
                  break;
                }
                case 2: {
                  let m = null;
                  f.injectedText && (m = f.injectedText.filter((_) => !_.ownerId || _.ownerId === this._editorId)), l.addRequest(f.detail, m, null);
                  break;
                }
              }
              const u = l.finalize(), d = new zl(u);
              for (const f of r) switch (f.changeType) {
                case 1: {
                  this._lines.onModelFlushed(), i.emitViewEvent(new r0()), this._decorations.reset(), this.viewLayout.onFlushed(this.getLineCount()), n = true;
                  break;
                }
                case 3: {
                  const m = this._lines.onModelLinesDeleted(a, f.fromLineNumber, f.toLineNumber);
                  m !== null && (i.emitViewEvent(m), this.viewLayout.onLinesDeleted(m.fromLineNumber, m.toLineNumber)), n = true;
                  break;
                }
                case 4: {
                  const m = d.takeCount(f.detail.length), _ = this._lines.onModelLinesInserted(a, f.fromLineNumber, f.toLineNumber, m);
                  _ !== null && (i.emitViewEvent(_), this.viewLayout.onLinesInserted(_.fromLineNumber, _.toLineNumber)), n = true;
                  break;
                }
                case 2: {
                  const m = d.dequeue(), [_, b, v, y] = this._lines.onModelLineChanged(a, f.lineNumber, m);
                  o = _, b && i.emitViewEvent(b), v && (i.emitViewEvent(v), this.viewLayout.onLinesInserted(v.fromLineNumber, v.toLineNumber)), y && (i.emitViewEvent(y), this.viewLayout.onLinesDeleted(y.fromLineNumber, y.toLineNumber));
                  break;
                }
                case 5:
                  break;
              }
              a !== null && this._lines.acceptVersionId(a), this.viewLayout.onHeightMaybeChanged(), !n && o && (i.emitViewEvent(new a0()), i.emitViewEvent(new zu(null)), this._cursor.onLineMappingChanged(i), this._decorations.onLineMappingChanged());
            } finally {
              this._eventDispatcher.endEmitViewEvents();
            }
            const t = this._viewportStart.isValid;
            if (this._viewportStart.invalidate(), this._configuration.setModelLineCount(this.model.getLineCount()), this._updateConfigurationViewLineCountNow(), !this._hasFocus && this.model.getAttachedEditorCount() >= 2 && t) {
              const i = this.model._getTrackedRange(this._viewportStart.modelTrackedRange);
              if (i) {
                const n = this.coordinatesConverter.convertModelPositionToViewPosition(i.getStartPosition()), o = this.viewLayout.getVerticalOffsetForLineNumber(n.lineNumber);
                this.viewLayout.setScrollPosition({
                  scrollTop: o + this._viewportStart.startLineDelta
                }, 1);
              }
            }
            try {
              const i = this._eventDispatcher.beginEmitViewEvents();
              e instanceof xh && i.emitOutgoingEvent(new Tue(e.contentChangedEvent)), this._cursor.onModelContentChanged(i, e);
            } finally {
              this._eventDispatcher.endEmitViewEvents();
            }
            this._handleVisibleLinesChanged();
          })), this._register(this.model.onDidChangeTokens((e) => {
            const t = [];
            for (let i = 0, n = e.ranges.length; i < n; i++) {
              const o = e.ranges[i], r = this.coordinatesConverter.convertModelPositionToViewPosition(new X(o.fromLineNumber, 1)).lineNumber, a = this.coordinatesConverter.convertModelPositionToViewPosition(new X(o.toLineNumber, this.model.getLineMaxColumn(o.toLineNumber))).lineNumber;
              t[i] = {
                fromLineNumber: r,
                toLineNumber: a
              };
            }
            this._eventDispatcher.emitSingleViewEvent(new bue(t)), this._eventDispatcher.emitOutgoingEvent(new Iue(e));
          })), this._register(this.model.onDidChangeLanguageConfiguration((e) => {
            this._eventDispatcher.emitSingleViewEvent(new mue()), this.cursorConfig = new tf(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService), this._cursor.updateConfiguration(this.cursorConfig), this._eventDispatcher.emitOutgoingEvent(new Eue(e));
          })), this._register(this.model.onDidChangeLanguage((e) => {
            this.cursorConfig = new tf(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService), this._cursor.updateConfiguration(this.cursorConfig), this._eventDispatcher.emitOutgoingEvent(new Due(e));
          })), this._register(this.model.onDidChangeOptions((e) => {
            if (this._lines.setTabSize(this.model.getOptions().tabSize)) {
              try {
                const t = this._eventDispatcher.beginEmitViewEvents();
                t.emitViewEvent(new r0()), t.emitViewEvent(new a0()), t.emitViewEvent(new zu(null)), this._cursor.onLineMappingChanged(t), this._decorations.onLineMappingChanged(), this.viewLayout.onFlushed(this.getLineCount());
              } finally {
                this._eventDispatcher.endEmitViewEvents();
              }
              this._updateConfigurationViewLineCount.schedule();
            }
            this.cursorConfig = new tf(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService), this._cursor.updateConfiguration(this.cursorConfig), this._eventDispatcher.emitOutgoingEvent(new Nue(e));
          })), this._register(this.model.onDidChangeDecorations((e) => {
            this._decorations.onModelDecorationsChanged(), this._eventDispatcher.emitSingleViewEvent(new zu(e)), this._eventDispatcher.emitOutgoingEvent(new kue(e));
          }));
        }
        setHiddenAreas(e, t) {
          var _a3;
          this.hiddenAreasModel.setHiddenAreas(t, e);
          const i = this.hiddenAreasModel.getMergedRanges();
          if (i === this.previousHiddenAreas) return;
          this.previousHiddenAreas = i;
          const n = this._captureStableViewport();
          let o = false;
          try {
            const r = this._eventDispatcher.beginEmitViewEvents();
            o = this._lines.setHiddenAreas(i), o && (r.emitViewEvent(new r0()), r.emitViewEvent(new a0()), r.emitViewEvent(new zu(null)), this._cursor.onLineMappingChanged(r), this._decorations.onLineMappingChanged(), this.viewLayout.onFlushed(this.getLineCount()), this.viewLayout.onHeightMaybeChanged());
            const a = (_a3 = n.viewportStartModelPosition) == null ? void 0 : _a3.lineNumber;
            a && i.some((u) => u.startLineNumber <= a && a <= u.endLineNumber) || n.recoverViewportStart(this.coordinatesConverter, this.viewLayout);
          } finally {
            this._eventDispatcher.endEmitViewEvents();
          }
          this._updateConfigurationViewLineCount.schedule(), o && this._eventDispatcher.emitOutgoingEvent(new Lue());
        }
        getVisibleRangesPlusViewportAboveBelow() {
          const e = this._configuration.options.get(146), t = this._configuration.options.get(67), i = Math.max(20, Math.round(e.height / t)), n = this.viewLayout.getLinesViewportData(), o = Math.max(1, n.completelyVisibleStartLineNumber - i), r = Math.min(this.getLineCount(), n.completelyVisibleEndLineNumber + i);
          return this._toModelVisibleRanges(new z(o, this.getLineMinColumn(o), r, this.getLineMaxColumn(r)));
        }
        getVisibleRanges() {
          const e = this.getCompletelyVisibleViewRange();
          return this._toModelVisibleRanges(e);
        }
        getHiddenAreas() {
          return this._lines.getHiddenAreas();
        }
        _toModelVisibleRanges(e) {
          const t = this.coordinatesConverter.convertViewRangeToModelRange(e), i = this._lines.getHiddenAreas();
          if (i.length === 0) return [
            t
          ];
          const n = [];
          let o = 0, r = t.startLineNumber, a = t.startColumn;
          const l = t.endLineNumber, u = t.endColumn;
          for (let d = 0, f = i.length; d < f; d++) {
            const m = i[d].startLineNumber, _ = i[d].endLineNumber;
            _ < r || m > l || (r < m && (n[o++] = new z(r, a, m - 1, this.model.getLineMaxColumn(m - 1))), r = _ + 1, a = 1);
          }
          return (r < l || r === l && a < u) && (n[o++] = new z(r, a, l, u)), n;
        }
        getCompletelyVisibleViewRange() {
          const e = this.viewLayout.getLinesViewportData(), t = e.completelyVisibleStartLineNumber, i = e.completelyVisibleEndLineNumber;
          return new z(t, this.getLineMinColumn(t), i, this.getLineMaxColumn(i));
        }
        getCompletelyVisibleViewRangeAtScrollTop(e) {
          const t = this.viewLayout.getLinesViewportDataAtScrollTop(e), i = t.completelyVisibleStartLineNumber, n = t.completelyVisibleEndLineNumber;
          return new z(i, this.getLineMinColumn(i), n, this.getLineMaxColumn(n));
        }
        saveState() {
          const e = this.viewLayout.saveState(), t = e.scrollTop, i = this.viewLayout.getLineNumberAtVerticalOffset(t), n = this.coordinatesConverter.convertViewPositionToModelPosition(new X(i, this.getLineMinColumn(i))), o = this.viewLayout.getVerticalOffsetForLineNumber(i) - t;
          return {
            scrollLeft: e.scrollLeft,
            firstPosition: n,
            firstPositionDeltaTop: o
          };
        }
        reduceRestoreState(e) {
          if (typeof e.firstPosition > "u") return this._reduceRestoreStateCompatibility(e);
          const t = this.model.validatePosition(e.firstPosition), i = this.coordinatesConverter.convertModelPositionToViewPosition(t), n = this.viewLayout.getVerticalOffsetForLineNumber(i.lineNumber) - e.firstPositionDeltaTop;
          return {
            scrollLeft: e.scrollLeft,
            scrollTop: n
          };
        }
        _reduceRestoreStateCompatibility(e) {
          return {
            scrollLeft: e.scrollLeft,
            scrollTop: e.scrollTopWithoutViewZones
          };
        }
        getTabSize() {
          return this.model.getOptions().tabSize;
        }
        getLineCount() {
          return this._lines.getViewLineCount();
        }
        setViewport(e, t, i) {
          this._viewportStart.update(this, e);
        }
        getActiveIndentGuide(e, t, i) {
          return this._lines.getActiveIndentGuide(e, t, i);
        }
        getLinesIndentGuides(e, t) {
          return this._lines.getViewLinesIndentGuides(e, t);
        }
        getBracketGuidesInRangeByLine(e, t, i, n) {
          return this._lines.getViewLinesBracketGuides(e, t, i, n);
        }
        getLineContent(e) {
          return this._lines.getViewLineContent(e);
        }
        getLineLength(e) {
          return this._lines.getViewLineLength(e);
        }
        getLineMinColumn(e) {
          return this._lines.getViewLineMinColumn(e);
        }
        getLineMaxColumn(e) {
          return this._lines.getViewLineMaxColumn(e);
        }
        getLineFirstNonWhitespaceColumn(e) {
          const t = qs(this.getLineContent(e));
          return t === -1 ? 0 : t + 1;
        }
        getLineLastNonWhitespaceColumn(e) {
          const t = qh(this.getLineContent(e));
          return t === -1 ? 0 : t + 2;
        }
        getMinimapDecorationsInRange(e) {
          return this._decorations.getMinimapDecorationsInRange(e);
        }
        getDecorationsInViewport(e) {
          return this._decorations.getDecorationsViewportData(e).decorations;
        }
        getInjectedTextAt(e) {
          return this._lines.getInjectedTextAt(e);
        }
        getViewportViewLineRenderingData(e, t) {
          const n = this._decorations.getDecorationsViewportData(e).inlineDecorations[t - e.startLineNumber];
          return this._getViewLineRenderingData(t, n);
        }
        getViewLineRenderingData(e) {
          const t = this._decorations.getInlineDecorationsOnLine(e);
          return this._getViewLineRenderingData(e, t);
        }
        _getViewLineRenderingData(e, t) {
          const i = this.model.mightContainRTL(), n = this.model.mightContainNonBasicASCII(), o = this.getTabSize(), r = this._lines.getViewLineData(e);
          return r.inlineDecorations && (t = [
            ...t,
            ...r.inlineDecorations.map((a) => a.toInlineDecoration(e))
          ]), new mo(r.minColumn, r.maxColumn, r.content, r.continuesWithWrappedLine, i, n, r.tokens, t, o, r.startVisibleColumn);
        }
        getViewLineData(e) {
          return this._lines.getViewLineData(e);
        }
        getMinimapLinesRenderingData(e, t, i) {
          const n = this._lines.getViewLinesData(e, t, i);
          return new Iae(this.getTabSize(), n);
        }
        getAllOverviewRulerDecorations(e) {
          const t = this.model.getOverviewRulerDecorations(this._editorId, G0(this._configuration.options)), i = new ehe();
          for (const n of t) {
            const o = n.options, r = o.overviewRuler;
            if (!r) continue;
            const a = r.position;
            if (a === 0) continue;
            const l = r.getColor(e.value), u = this.coordinatesConverter.getViewLineNumberOfModelPosition(n.range.startLineNumber, n.range.startColumn), d = this.coordinatesConverter.getViewLineNumberOfModelPosition(n.range.endLineNumber, n.range.endColumn);
            i.accept(l, o.zIndex, u, d, a);
          }
          return i.asArray;
        }
        _invalidateDecorationsColorCache() {
          var _a3, _b3;
          const e = this.model.getOverviewRulerDecorations();
          for (const t of e) (_a3 = t.options.overviewRuler) == null ? void 0 : _a3.invalidateCachedColor(), (_b3 = t.options.minimap) == null ? void 0 : _b3.invalidateCachedColor();
        }
        getValueInRange(e, t) {
          const i = this.coordinatesConverter.convertViewRangeToModelRange(e);
          return this.model.getValueInRange(i, t);
        }
        getValueLengthInRange(e, t) {
          const i = this.coordinatesConverter.convertViewRangeToModelRange(e);
          return this.model.getValueLengthInRange(i, t);
        }
        modifyPosition(e, t) {
          const i = this.coordinatesConverter.convertViewPositionToModelPosition(e), n = this.model.modifyPosition(i, t);
          return this.coordinatesConverter.convertModelPositionToViewPosition(n);
        }
        deduceModelPositionRelativeToViewPosition(e, t, i) {
          const n = this.coordinatesConverter.convertViewPositionToModelPosition(e);
          this.model.getEOL().length === 2 && (t < 0 ? t -= i : t += i);
          const r = this.model.getOffsetAt(n) + t;
          return this.model.getPositionAt(r);
        }
        getPlainTextToCopy(e, t, i) {
          const n = i ? `\r
` : this.model.getEOL();
          e = e.slice(0), e.sort(z.compareRangesUsingStarts);
          let o = false, r = false;
          for (const l of e) l.isEmpty() ? o = true : r = true;
          if (!r) {
            if (!t) return "";
            const l = e.map((d) => d.startLineNumber);
            let u = "";
            for (let d = 0; d < l.length; d++) d > 0 && l[d - 1] === l[d] || (u += this.model.getLineContent(l[d]) + n);
            return u;
          }
          if (o && t) {
            const l = [];
            let u = 0;
            for (const d of e) {
              const f = d.startLineNumber;
              d.isEmpty() ? f !== u && l.push(this.model.getLineContent(f)) : l.push(this.model.getValueInRange(d, i ? 2 : 0)), u = f;
            }
            return l.length === 1 ? l[0] : l;
          }
          const a = [];
          for (const l of e) l.isEmpty() || a.push(this.model.getValueInRange(l, i ? 2 : 0));
          return a.length === 1 ? a[0] : a;
        }
        getRichTextToCopy(e, t) {
          const i = this.model.getLanguageId();
          if (i === gr || e.length !== 1) return null;
          let n = e[0];
          if (n.isEmpty()) {
            if (!t) return null;
            const d = n.startLineNumber;
            n = new z(d, this.model.getLineMinColumn(d), d, this.model.getLineMaxColumn(d));
          }
          const o = this._configuration.options.get(50), r = this._getColorMap(), l = /[:;\\\/<>]/.test(o.fontFamily) || o.fontFamily === fo.fontFamily;
          let u;
          return l ? u = fo.fontFamily : (u = o.fontFamily, u = u.replace(/"/g, "'"), /[,']/.test(u) || /[+ ]/.test(u) && (u = `'${u}'`), u = `${u}, ${fo.fontFamily}`), {
            mode: i,
            html: `<div style="color: ${r[1]};background-color: ${r[2]};font-family: ${u};font-weight: ${o.fontWeight};font-size: ${o.fontSize}px;line-height: ${o.lineHeight}px;white-space: pre;">` + this._getHTMLToCopy(n, r) + "</div>"
          };
        }
        _getHTMLToCopy(e, t) {
          const i = e.startLineNumber, n = e.startColumn, o = e.endLineNumber, r = e.endColumn, a = this.getTabSize();
          let l = "";
          for (let u = i; u <= o; u++) {
            const d = this.model.tokenization.getLineTokens(u), f = d.getLineContent(), m = u === i ? n - 1 : 0, _ = u === o ? r - 1 : f.length;
            f === "" ? l += "<br>" : l += WJ(f, d.inflate(), t, m, _, a, Ks);
          }
          return l;
        }
        _getColorMap() {
          const e = Bi.getColorMap(), t = [
            "#000000"
          ];
          if (e) for (let i = 1, n = e.length; i < n; i++) t[i] = le.Format.CSS.formatHex(e[i]);
          return t;
        }
        getPrimaryCursorState() {
          return this._cursor.getPrimaryCursorState();
        }
        getLastAddedCursorIndex() {
          return this._cursor.getLastAddedCursorIndex();
        }
        getCursorStates() {
          return this._cursor.getCursorStates();
        }
        setCursorStates(e, t, i) {
          return this._withViewEventsCollector((n) => this._cursor.setStates(n, e, t, i));
        }
        getCursorColumnSelectData() {
          return this._cursor.getCursorColumnSelectData();
        }
        getCursorAutoClosedCharacters() {
          return this._cursor.getAutoClosedCharacters();
        }
        setCursorColumnSelectData(e) {
          this._cursor.setCursorColumnSelectData(e);
        }
        getPrevEditOperationType() {
          return this._cursor.getPrevEditOperationType();
        }
        setPrevEditOperationType(e) {
          this._cursor.setPrevEditOperationType(e);
        }
        getSelection() {
          return this._cursor.getSelection();
        }
        getSelections() {
          return this._cursor.getSelections();
        }
        getPosition() {
          return this._cursor.getPrimaryCursorState().modelState.position;
        }
        setSelections(e, t, i = 0) {
          this._withViewEventsCollector((n) => this._cursor.setSelections(n, e, t, i));
        }
        saveCursorState() {
          return this._cursor.saveState();
        }
        restoreCursorState(e) {
          this._withViewEventsCollector((t) => this._cursor.restoreState(t, e));
        }
        _executeCursorEdit(e) {
          if (this._cursor.context.cursorConfig.readOnly) {
            this._eventDispatcher.emitOutgoingEvent(new xue());
            return;
          }
          this._withViewEventsCollector(e);
        }
        executeEdits(e, t, i) {
          this._executeCursorEdit((n) => this._cursor.executeEdits(n, e, t, i));
        }
        startComposition() {
          this._executeCursorEdit((e) => this._cursor.startComposition(e));
        }
        endComposition(e) {
          this._executeCursorEdit((t) => this._cursor.endComposition(t, e));
        }
        type(e, t) {
          this._executeCursorEdit((i) => this._cursor.type(i, e, t));
        }
        compositionType(e, t, i, n, o) {
          this._executeCursorEdit((r) => this._cursor.compositionType(r, e, t, i, n, o));
        }
        paste(e, t, i, n) {
          this._executeCursorEdit((o) => this._cursor.paste(o, e, t, i, n));
        }
        cut(e) {
          this._executeCursorEdit((t) => this._cursor.cut(t, e));
        }
        executeCommand(e, t) {
          this._executeCursorEdit((i) => this._cursor.executeCommand(i, e, t));
        }
        executeCommands(e, t) {
          this._executeCursorEdit((i) => this._cursor.executeCommands(i, e, t));
        }
        revealAllCursors(e, t, i = false) {
          this._withViewEventsCollector((n) => this._cursor.revealAll(n, e, i, 0, t, 0));
        }
        revealPrimaryCursor(e, t, i = false) {
          this._withViewEventsCollector((n) => this._cursor.revealPrimary(n, e, i, 0, t, 0));
        }
        revealTopMostCursor(e) {
          const t = this._cursor.getTopMostViewPosition(), i = new z(t.lineNumber, t.column, t.lineNumber, t.column);
          this._withViewEventsCollector((n) => n.emitViewEvent(new Hp(e, false, i, null, 0, true, 0)));
        }
        revealBottomMostCursor(e) {
          const t = this._cursor.getBottomMostViewPosition(), i = new z(t.lineNumber, t.column, t.lineNumber, t.column);
          this._withViewEventsCollector((n) => n.emitViewEvent(new Hp(e, false, i, null, 0, true, 0)));
        }
        revealRange(e, t, i, n, o) {
          this._withViewEventsCollector((r) => r.emitViewEvent(new Hp(e, false, i, null, n, t, o)));
        }
        changeWhitespace(e) {
          this.viewLayout.changeWhitespace(e) && (this._eventDispatcher.emitSingleViewEvent(new Cue()), this._eventDispatcher.emitOutgoingEvent(new Sue()));
        }
        _withViewEventsCollector(e) {
          return this._transactionalTarget.batchChanges(() => {
            try {
              const t = this._eventDispatcher.beginEmitViewEvents();
              return e(t);
            } finally {
              this._eventDispatcher.endEmitViewEvents();
            }
          });
        }
        batchEvents(e) {
          this._withViewEventsCollector(() => {
            e();
          });
        }
        normalizePosition(e, t) {
          return this._lines.normalizePosition(e, t);
        }
        getLineIndentColumn(e) {
          return this._lines.getLineIndentColumn(e);
        }
      };
      class dI {
        static create(e) {
          const t = e._setTrackedRange(null, new z(1, 1, 1, 1), 1);
          return new dI(e, 1, false, t, 0);
        }
        get viewLineNumber() {
          return this._viewLineNumber;
        }
        get isValid() {
          return this._isValid;
        }
        get modelTrackedRange() {
          return this._modelTrackedRange;
        }
        get startLineDelta() {
          return this._startLineDelta;
        }
        constructor(e, t, i, n, o) {
          this._model = e, this._viewLineNumber = t, this._isValid = i, this._modelTrackedRange = n, this._startLineDelta = o;
        }
        dispose() {
          this._model._setTrackedRange(this._modelTrackedRange, null, 1);
        }
        update(e, t) {
          const i = e.coordinatesConverter.convertViewPositionToModelPosition(new X(t, e.getLineMinColumn(t))), n = e.model._setTrackedRange(this._modelTrackedRange, new z(i.lineNumber, i.column, i.lineNumber, i.column), 1), o = e.viewLayout.getVerticalOffsetForLineNumber(t), r = e.viewLayout.getCurrentScrollTop();
          this._viewLineNumber = t, this._isValid = true, this._modelTrackedRange = n, this._startLineDelta = r - o;
        }
        invalidate() {
          this._isValid = false;
        }
      }
      class ehe {
        constructor() {
          this._asMap = /* @__PURE__ */ Object.create(null), this.asArray = [];
        }
        accept(e, t, i, n, o) {
          const r = this._asMap[e];
          if (r) {
            const a = r.data, l = a[a.length - 3], u = a[a.length - 1];
            if (l === o && u + 1 >= i) {
              n > u && (a[a.length - 1] = n);
              return;
            }
            a.push(o, i, n);
          } else {
            const a = new y_(e, t, [
              o,
              i,
              n
            ]);
            this._asMap[e] = a, this.asArray.push(a);
          }
        }
      }
      class the {
        constructor() {
          this.hiddenAreas = /* @__PURE__ */ new Map(), this.shouldRecompute = false, this.ranges = [];
        }
        setHiddenAreas(e, t) {
          const i = this.hiddenAreas.get(e);
          i && r7(i, t) || (this.hiddenAreas.set(e, t), this.shouldRecompute = true);
        }
        getMergedRanges() {
          if (!this.shouldRecompute) return this.ranges;
          this.shouldRecompute = false;
          const e = Array.from(this.hiddenAreas.values()).reduce((t, i) => ihe(t, i), []);
          return r7(this.ranges, e) ? this.ranges : (this.ranges = e, this.ranges);
        }
      }
      function ihe(s, e) {
        const t = [];
        let i = 0, n = 0;
        for (; i < s.length && n < e.length; ) {
          const o = s[i], r = e[n];
          if (o.endLineNumber < r.startLineNumber - 1) t.push(s[i++]);
          else if (r.endLineNumber < o.startLineNumber - 1) t.push(e[n++]);
          else {
            const a = Math.min(o.startLineNumber, r.startLineNumber), l = Math.max(o.endLineNumber, r.endLineNumber);
            t.push(new z(a, 1, l, 1)), i++, n++;
          }
        }
        for (; i < s.length; ) t.push(s[i++]);
        for (; n < e.length; ) t.push(e[n++]);
        return t;
      }
      function r7(s, e) {
        if (s.length !== e.length) return false;
        for (let t = 0; t < s.length; t++) if (!s[t].equalsRange(e[t])) return false;
        return true;
      }
      class a7 {
        constructor(e, t) {
          this.viewportStartModelPosition = e, this.startLineDelta = t;
        }
        recoverViewportStart(e, t) {
          if (!this.viewportStartModelPosition) return;
          const i = e.convertModelPositionToViewPosition(this.viewportStartModelPosition), n = t.getVerticalOffsetForLineNumber(i.lineNumber);
          t.setScrollPosition({
            scrollTop: n + this.startLineDelta
          }, 1);
        }
      }
      var nhe = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      }, ul = function(s, e) {
        return function(t, i) {
          e(t, i, s);
        };
      }, Yu;
      let SC = (_p2 = class extends he {
        get isSimpleWidget() {
          return this._configuration.isSimpleWidget;
        }
        get contextMenuId() {
          return this._configuration.contextMenuId;
        }
        constructor(e, t, i, n, o, r, a, l, u, d, f, m) {
          super(), this.languageConfigurationService = f, this._deliveryQueue = U$(), this._contributions = this._register(new rue()), this._onDidDispose = this._register(new G()), this.onDidDispose = this._onDidDispose.event, this._onDidChangeModelContent = this._register(new G({
            deliveryQueue: this._deliveryQueue
          })), this.onDidChangeModelContent = this._onDidChangeModelContent.event, this._onDidChangeModelLanguage = this._register(new G({
            deliveryQueue: this._deliveryQueue
          })), this.onDidChangeModelLanguage = this._onDidChangeModelLanguage.event, this._onDidChangeModelLanguageConfiguration = this._register(new G({
            deliveryQueue: this._deliveryQueue
          })), this.onDidChangeModelLanguageConfiguration = this._onDidChangeModelLanguageConfiguration.event, this._onDidChangeModelOptions = this._register(new G({
            deliveryQueue: this._deliveryQueue
          })), this.onDidChangeModelOptions = this._onDidChangeModelOptions.event, this._onDidChangeModelDecorations = this._register(new G({
            deliveryQueue: this._deliveryQueue
          })), this.onDidChangeModelDecorations = this._onDidChangeModelDecorations.event, this._onDidChangeModelTokens = this._register(new G({
            deliveryQueue: this._deliveryQueue
          })), this.onDidChangeModelTokens = this._onDidChangeModelTokens.event, this._onDidChangeConfiguration = this._register(new G({
            deliveryQueue: this._deliveryQueue
          })), this.onDidChangeConfiguration = this._onDidChangeConfiguration.event, this._onWillChangeModel = this._register(new G({
            deliveryQueue: this._deliveryQueue
          })), this.onWillChangeModel = this._onWillChangeModel.event, this._onDidChangeModel = this._register(new G({
            deliveryQueue: this._deliveryQueue
          })), this.onDidChangeModel = this._onDidChangeModel.event, this._onDidChangeCursorPosition = this._register(new G({
            deliveryQueue: this._deliveryQueue
          })), this.onDidChangeCursorPosition = this._onDidChangeCursorPosition.event, this._onDidChangeCursorSelection = this._register(new G({
            deliveryQueue: this._deliveryQueue
          })), this.onDidChangeCursorSelection = this._onDidChangeCursorSelection.event, this._onDidAttemptReadOnlyEdit = this._register(new Qn(this._contributions, this._deliveryQueue)), this.onDidAttemptReadOnlyEdit = this._onDidAttemptReadOnlyEdit.event, this._onDidLayoutChange = this._register(new G({
            deliveryQueue: this._deliveryQueue
          })), this.onDidLayoutChange = this._onDidLayoutChange.event, this._editorTextFocus = this._register(new l7({
            deliveryQueue: this._deliveryQueue
          })), this.onDidFocusEditorText = this._editorTextFocus.onDidChangeToTrue, this.onDidBlurEditorText = this._editorTextFocus.onDidChangeToFalse, this._editorWidgetFocus = this._register(new l7({
            deliveryQueue: this._deliveryQueue
          })), this.onDidFocusEditorWidget = this._editorWidgetFocus.onDidChangeToTrue, this.onDidBlurEditorWidget = this._editorWidgetFocus.onDidChangeToFalse, this._onWillType = this._register(new Qn(this._contributions, this._deliveryQueue)), this.onWillType = this._onWillType.event, this._onDidType = this._register(new Qn(this._contributions, this._deliveryQueue)), this.onDidType = this._onDidType.event, this._onDidCompositionStart = this._register(new Qn(this._contributions, this._deliveryQueue)), this.onDidCompositionStart = this._onDidCompositionStart.event, this._onDidCompositionEnd = this._register(new Qn(this._contributions, this._deliveryQueue)), this.onDidCompositionEnd = this._onDidCompositionEnd.event, this._onDidPaste = this._register(new Qn(this._contributions, this._deliveryQueue)), this.onDidPaste = this._onDidPaste.event, this._onMouseUp = this._register(new Qn(this._contributions, this._deliveryQueue)), this.onMouseUp = this._onMouseUp.event, this._onMouseDown = this._register(new Qn(this._contributions, this._deliveryQueue)), this.onMouseDown = this._onMouseDown.event, this._onMouseDrag = this._register(new Qn(this._contributions, this._deliveryQueue)), this.onMouseDrag = this._onMouseDrag.event, this._onMouseDrop = this._register(new Qn(this._contributions, this._deliveryQueue)), this.onMouseDrop = this._onMouseDrop.event, this._onMouseDropCanceled = this._register(new Qn(this._contributions, this._deliveryQueue)), this.onMouseDropCanceled = this._onMouseDropCanceled.event, this._onDropIntoEditor = this._register(new Qn(this._contributions, this._deliveryQueue)), this.onDropIntoEditor = this._onDropIntoEditor.event, this._onContextMenu = this._register(new Qn(this._contributions, this._deliveryQueue)), this.onContextMenu = this._onContextMenu.event, this._onMouseMove = this._register(new Qn(this._contributions, this._deliveryQueue)), this.onMouseMove = this._onMouseMove.event, this._onMouseLeave = this._register(new Qn(this._contributions, this._deliveryQueue)), this.onMouseLeave = this._onMouseLeave.event, this._onMouseWheel = this._register(new Qn(this._contributions, this._deliveryQueue)), this.onMouseWheel = this._onMouseWheel.event, this._onKeyUp = this._register(new Qn(this._contributions, this._deliveryQueue)), this.onKeyUp = this._onKeyUp.event, this._onKeyDown = this._register(new Qn(this._contributions, this._deliveryQueue)), this.onKeyDown = this._onKeyDown.event, this._onDidContentSizeChange = this._register(new G({
            deliveryQueue: this._deliveryQueue
          })), this.onDidContentSizeChange = this._onDidContentSizeChange.event, this._onDidScrollChange = this._register(new G({
            deliveryQueue: this._deliveryQueue
          })), this.onDidScrollChange = this._onDidScrollChange.event, this._onDidChangeViewZones = this._register(new G({
            deliveryQueue: this._deliveryQueue
          })), this.onDidChangeViewZones = this._onDidChangeViewZones.event, this._onDidChangeHiddenAreas = this._register(new G({
            deliveryQueue: this._deliveryQueue
          })), this.onDidChangeHiddenAreas = this._onDidChangeHiddenAreas.event, this._updateCounter = 0, this._onBeginUpdate = this._register(new G()), this.onBeginUpdate = this._onBeginUpdate.event, this._onEndUpdate = this._register(new G()), this.onEndUpdate = this._onEndUpdate.event, this._actions = /* @__PURE__ */ new Map(), this._bannerDomNode = null, this._dropIntoEditorDecorations = this.createDecorationsCollection(), o.willCreateCodeEditor();
          const _ = {
            ...t
          };
          this._domElement = e, this._overflowWidgetsDomNode = _.overflowWidgetsDomNode, delete _.overflowWidgetsDomNode, this._id = ++she, this._decorationTypeKeysToIds = {}, this._decorationTypeSubtypes = {}, this._telemetryData = i.telemetryData, this._configuration = this._register(this._createConfiguration(i.isSimpleWidget || false, i.contextMenuId ?? (i.isSimpleWidget ? Q.SimpleEditorContext : Q.EditorContext), _, d)), this._register(this._configuration.onDidChange((y) => {
            this._onDidChangeConfiguration.fire(y);
            const x = this._configuration.options;
            if (y.hasChanged(146)) {
              const L = x.get(146);
              this._onDidLayoutChange.fire(L);
            }
          })), this._contextKeyService = this._register(a.createScoped(this._domElement)), this._notificationService = u, this._codeEditorService = o, this._commandService = r, this._themeService = l, this._register(new rhe(this, this._contextKeyService)), this._register(new ahe(this, this._contextKeyService, m)), this._instantiationService = this._register(n.createChild(new Mg([
            Mt,
            this._contextKeyService
          ]))), this._modelData = null, this._focusTracker = new lhe(e, this._overflowWidgetsDomNode), this._register(this._focusTracker.onChange(() => {
            this._editorWidgetFocus.setValue(this._focusTracker.hasFocus());
          })), this._contentWidgets = {}, this._overlayWidgets = {}, this._glyphMarginWidgets = {};
          let b;
          Array.isArray(i.contributions) ? b = i.contributions : b = Rf.getEditorContributions(), this._contributions.initialize(this, b, this._instantiationService);
          for (const y of Rf.getEditorActions()) {
            if (this._actions.has(y.id)) {
              qt(new Error(`Cannot have two actions with the same id ${y.id}`));
              continue;
            }
            const x = new VF(y.id, y.label, y.alias, y.metadata, y.precondition ?? void 0, (L) => this._instantiationService.invokeFunction((D) => Promise.resolve(y.runEditorCommand(D, this, L))), this._contextKeyService);
            this._actions.set(x.id, x);
          }
          const v = () => !this._configuration.options.get(92) && this._configuration.options.get(36).enabled;
          this._register(new YK(this._domElement, {
            onDragOver: (y) => {
              if (!v()) return;
              const x = this.getTargetAtClientPoint(y.clientX, y.clientY);
              (x == null ? void 0 : x.position) && this.showDropIndicatorAt(x.position);
            },
            onDrop: async (y) => {
              if (!v() || (this.removeDropIndicator(), !y.dataTransfer)) return;
              const x = this.getTargetAtClientPoint(y.clientX, y.clientY);
              (x == null ? void 0 : x.position) && this._onDropIntoEditor.fire({
                position: x.position,
                event: y
              });
            },
            onDragLeave: () => {
              this.removeDropIndicator();
            },
            onDragEnd: () => {
              this.removeDropIndicator();
            }
          })), this._codeEditorService.addCodeEditor(this);
        }
        writeScreenReaderContent(e) {
          var _a3;
          (_a3 = this._modelData) == null ? void 0 : _a3.view.writeScreenReaderContent(e);
        }
        _createConfiguration(e, t, i, n) {
          return new j2(e, t, i, this._domElement, n);
        }
        getId() {
          return this.getEditorType() + ":" + this._id;
        }
        getEditorType() {
          return $N.ICodeEditor;
        }
        dispose() {
          this._codeEditorService.removeCodeEditor(this), this._focusTracker.dispose(), this._actions.clear(), this._contentWidgets = {}, this._overlayWidgets = {}, this._removeDecorationTypes(), this._postDetachModelCleanup(this._detachModel()), this._onDidDispose.fire(), super.dispose();
        }
        invokeWithinContext(e) {
          return this._instantiationService.invokeFunction(e);
        }
        updateOptions(e) {
          this._configuration.updateOptions(e || {});
        }
        getOptions() {
          return this._configuration.options;
        }
        getOption(e) {
          return this._configuration.options.get(e);
        }
        getRawOptions() {
          return this._configuration.getRawOptions();
        }
        getOverflowWidgetsDomNode() {
          return this._overflowWidgetsDomNode;
        }
        getConfiguredWordAtPosition(e) {
          return this._modelData ? Ti.getWordAtPosition(this._modelData.model, this._configuration.options.get(132), this._configuration.options.get(131), e) : null;
        }
        getValue(e = null) {
          if (!this._modelData) return "";
          const t = !!(e && e.preserveBOM);
          let i = 0;
          return e && e.lineEnding && e.lineEnding === `
` ? i = 1 : e && e.lineEnding && e.lineEnding === `\r
` && (i = 2), this._modelData.model.getValue(i, t);
        }
        setValue(e) {
          try {
            if (this._beginUpdate(), !this._modelData) return;
            this._modelData.model.setValue(e);
          } finally {
            this._endUpdate();
          }
        }
        getModel() {
          return this._modelData ? this._modelData.model : null;
        }
        setModel(e = null) {
          var _a3;
          try {
            this._beginUpdate();
            const t = e;
            if (this._modelData === null && t === null || this._modelData && this._modelData.model === t) return;
            const i = {
              oldModelUrl: ((_a3 = this._modelData) == null ? void 0 : _a3.model.uri) || null,
              newModelUrl: (t == null ? void 0 : t.uri) || null
            };
            this._onWillChangeModel.fire(i);
            const n = this.hasTextFocus(), o = this._detachModel();
            this._attachModel(t), n && this.hasModel() && this.focus(), this._removeDecorationTypes(), this._onDidChangeModel.fire(i), this._postDetachModelCleanup(o), this._contributionsDisposable = this._contributions.onAfterModelAttached();
          } finally {
            this._endUpdate();
          }
        }
        _removeDecorationTypes() {
          if (this._decorationTypeKeysToIds = {}, this._decorationTypeSubtypes) {
            for (const e in this._decorationTypeSubtypes) {
              const t = this._decorationTypeSubtypes[e];
              for (const i in t) this._removeDecorationType(e + "-" + i);
            }
            this._decorationTypeSubtypes = {};
          }
        }
        getVisibleRanges() {
          return this._modelData ? this._modelData.viewModel.getVisibleRanges() : [];
        }
        getVisibleRangesPlusViewportAboveBelow() {
          return this._modelData ? this._modelData.viewModel.getVisibleRangesPlusViewportAboveBelow() : [];
        }
        getWhitespaces() {
          return this._modelData ? this._modelData.viewModel.viewLayout.getWhitespaces() : [];
        }
        static _getVerticalOffsetAfterPosition(e, t, i, n) {
          const o = e.model.validatePosition({
            lineNumber: t,
            column: i
          }), r = e.viewModel.coordinatesConverter.convertModelPositionToViewPosition(o);
          return e.viewModel.viewLayout.getVerticalOffsetAfterLineNumber(r.lineNumber, n);
        }
        getTopForLineNumber(e, t = false) {
          return this._modelData ? Yu._getVerticalOffsetForPosition(this._modelData, e, 1, t) : -1;
        }
        getTopForPosition(e, t) {
          return this._modelData ? Yu._getVerticalOffsetForPosition(this._modelData, e, t, false) : -1;
        }
        static _getVerticalOffsetForPosition(e, t, i, n = false) {
          const o = e.model.validatePosition({
            lineNumber: t,
            column: i
          }), r = e.viewModel.coordinatesConverter.convertModelPositionToViewPosition(o);
          return e.viewModel.viewLayout.getVerticalOffsetForLineNumber(r.lineNumber, n);
        }
        getBottomForLineNumber(e, t = false) {
          if (!this._modelData) return -1;
          const i = this._modelData.model.getLineMaxColumn(e);
          return Yu._getVerticalOffsetAfterPosition(this._modelData, e, i, t);
        }
        setHiddenAreas(e, t) {
          var _a3;
          (_a3 = this._modelData) == null ? void 0 : _a3.viewModel.setHiddenAreas(e.map((i) => z.lift(i)), t);
        }
        getVisibleColumnFromPosition(e) {
          if (!this._modelData) return e.column;
          const t = this._modelData.model.validatePosition(e), i = this._modelData.model.getOptions().tabSize;
          return Gi.visibleColumnFromColumn(this._modelData.model.getLineContent(t.lineNumber), t.column, i) + 1;
        }
        getPosition() {
          return this._modelData ? this._modelData.viewModel.getPosition() : null;
        }
        setPosition(e, t = "api") {
          if (this._modelData) {
            if (!X.isIPosition(e)) throw new Error("Invalid arguments");
            this._modelData.viewModel.setSelections(t, [
              {
                selectionStartLineNumber: e.lineNumber,
                selectionStartColumn: e.column,
                positionLineNumber: e.lineNumber,
                positionColumn: e.column
              }
            ]);
          }
        }
        _sendRevealRange(e, t, i, n) {
          if (!this._modelData) return;
          if (!z.isIRange(e)) throw new Error("Invalid arguments");
          const o = this._modelData.model.validateRange(e), r = this._modelData.viewModel.coordinatesConverter.convertModelRangeToViewRange(o);
          this._modelData.viewModel.revealRange("api", i, r, t, n);
        }
        revealLine(e, t = 0) {
          this._revealLine(e, 0, t);
        }
        revealLineInCenter(e, t = 0) {
          this._revealLine(e, 1, t);
        }
        revealLineInCenterIfOutsideViewport(e, t = 0) {
          this._revealLine(e, 2, t);
        }
        revealLineNearTop(e, t = 0) {
          this._revealLine(e, 5, t);
        }
        _revealLine(e, t, i) {
          if (typeof e != "number") throw new Error("Invalid arguments");
          this._sendRevealRange(new z(e, 1, e, 1), t, false, i);
        }
        revealPosition(e, t = 0) {
          this._revealPosition(e, 0, true, t);
        }
        revealPositionInCenter(e, t = 0) {
          this._revealPosition(e, 1, true, t);
        }
        revealPositionInCenterIfOutsideViewport(e, t = 0) {
          this._revealPosition(e, 2, true, t);
        }
        revealPositionNearTop(e, t = 0) {
          this._revealPosition(e, 5, true, t);
        }
        _revealPosition(e, t, i, n) {
          if (!X.isIPosition(e)) throw new Error("Invalid arguments");
          this._sendRevealRange(new z(e.lineNumber, e.column, e.lineNumber, e.column), t, i, n);
        }
        getSelection() {
          return this._modelData ? this._modelData.viewModel.getSelection() : null;
        }
        getSelections() {
          return this._modelData ? this._modelData.viewModel.getSelections() : null;
        }
        setSelection(e, t = "api") {
          const i = mt.isISelection(e), n = z.isIRange(e);
          if (!i && !n) throw new Error("Invalid arguments");
          if (i) this._setSelectionImpl(e, t);
          else if (n) {
            const o = {
              selectionStartLineNumber: e.startLineNumber,
              selectionStartColumn: e.startColumn,
              positionLineNumber: e.endLineNumber,
              positionColumn: e.endColumn
            };
            this._setSelectionImpl(o, t);
          }
        }
        _setSelectionImpl(e, t) {
          if (!this._modelData) return;
          const i = new mt(e.selectionStartLineNumber, e.selectionStartColumn, e.positionLineNumber, e.positionColumn);
          this._modelData.viewModel.setSelections(t, [
            i
          ]);
        }
        revealLines(e, t, i = 0) {
          this._revealLines(e, t, 0, i);
        }
        revealLinesInCenter(e, t, i = 0) {
          this._revealLines(e, t, 1, i);
        }
        revealLinesInCenterIfOutsideViewport(e, t, i = 0) {
          this._revealLines(e, t, 2, i);
        }
        revealLinesNearTop(e, t, i = 0) {
          this._revealLines(e, t, 5, i);
        }
        _revealLines(e, t, i, n) {
          if (typeof e != "number" || typeof t != "number") throw new Error("Invalid arguments");
          this._sendRevealRange(new z(e, 1, t, 1), i, false, n);
        }
        revealRange(e, t = 0, i = false, n = true) {
          this._revealRange(e, i ? 1 : 0, n, t);
        }
        revealRangeInCenter(e, t = 0) {
          this._revealRange(e, 1, true, t);
        }
        revealRangeInCenterIfOutsideViewport(e, t = 0) {
          this._revealRange(e, 2, true, t);
        }
        revealRangeNearTop(e, t = 0) {
          this._revealRange(e, 5, true, t);
        }
        revealRangeNearTopIfOutsideViewport(e, t = 0) {
          this._revealRange(e, 6, true, t);
        }
        revealRangeAtTop(e, t = 0) {
          this._revealRange(e, 3, true, t);
        }
        _revealRange(e, t, i, n) {
          if (!z.isIRange(e)) throw new Error("Invalid arguments");
          this._sendRevealRange(z.lift(e), t, i, n);
        }
        setSelections(e, t = "api", i = 0) {
          if (this._modelData) {
            if (!e || e.length === 0) throw new Error("Invalid arguments");
            for (let n = 0, o = e.length; n < o; n++) if (!mt.isISelection(e[n])) throw new Error("Invalid arguments");
            this._modelData.viewModel.setSelections(t, e, i);
          }
        }
        getContentWidth() {
          return this._modelData ? this._modelData.viewModel.viewLayout.getContentWidth() : -1;
        }
        getScrollWidth() {
          return this._modelData ? this._modelData.viewModel.viewLayout.getScrollWidth() : -1;
        }
        getScrollLeft() {
          return this._modelData ? this._modelData.viewModel.viewLayout.getCurrentScrollLeft() : -1;
        }
        getContentHeight() {
          return this._modelData ? this._modelData.viewModel.viewLayout.getContentHeight() : -1;
        }
        getScrollHeight() {
          return this._modelData ? this._modelData.viewModel.viewLayout.getScrollHeight() : -1;
        }
        getScrollTop() {
          return this._modelData ? this._modelData.viewModel.viewLayout.getCurrentScrollTop() : -1;
        }
        setScrollLeft(e, t = 1) {
          if (this._modelData) {
            if (typeof e != "number") throw new Error("Invalid arguments");
            this._modelData.viewModel.viewLayout.setScrollPosition({
              scrollLeft: e
            }, t);
          }
        }
        setScrollTop(e, t = 1) {
          if (this._modelData) {
            if (typeof e != "number") throw new Error("Invalid arguments");
            this._modelData.viewModel.viewLayout.setScrollPosition({
              scrollTop: e
            }, t);
          }
        }
        setScrollPosition(e, t = 1) {
          this._modelData && this._modelData.viewModel.viewLayout.setScrollPosition(e, t);
        }
        hasPendingScrollAnimation() {
          return this._modelData ? this._modelData.viewModel.viewLayout.hasPendingScrollAnimation() : false;
        }
        saveViewState() {
          if (!this._modelData) return null;
          const e = this._contributions.saveViewState(), t = this._modelData.viewModel.saveCursorState(), i = this._modelData.viewModel.saveState();
          return {
            cursorState: t,
            viewState: i,
            contributionsState: e
          };
        }
        restoreViewState(e) {
          if (!this._modelData || !this._modelData.hasRealView) return;
          const t = e;
          if (t && t.cursorState && t.viewState) {
            const i = t.cursorState;
            Array.isArray(i) ? i.length > 0 && this._modelData.viewModel.restoreCursorState(i) : this._modelData.viewModel.restoreCursorState([
              i
            ]), this._contributions.restoreViewState(t.contributionsState || {});
            const n = this._modelData.viewModel.reduceRestoreState(t.viewState);
            this._modelData.view.restoreState(n);
          }
        }
        handleInitialized() {
          var _a3;
          (_a3 = this._getViewModel()) == null ? void 0 : _a3.visibleLinesStabilized();
        }
        getContribution(e) {
          return this._contributions.get(e);
        }
        getActions() {
          return Array.from(this._actions.values());
        }
        getSupportedActions() {
          let e = this.getActions();
          return e = e.filter((t) => t.isSupported()), e;
        }
        getAction(e) {
          return this._actions.get(e) || null;
        }
        trigger(e, t, i) {
          i = i || {};
          try {
            switch (this._beginUpdate(), t) {
              case "compositionStart":
                this._startComposition();
                return;
              case "compositionEnd":
                this._endComposition(e);
                return;
              case "type": {
                const o = i;
                this._type(e, o.text || "");
                return;
              }
              case "replacePreviousChar": {
                const o = i;
                this._compositionType(e, o.text || "", o.replaceCharCnt || 0, 0, 0);
                return;
              }
              case "compositionType": {
                const o = i;
                this._compositionType(e, o.text || "", o.replacePrevCharCnt || 0, o.replaceNextCharCnt || 0, o.positionDelta || 0);
                return;
              }
              case "paste": {
                const o = i;
                this._paste(e, o.text || "", o.pasteOnNewLine || false, o.multicursorText || null, o.mode || null, o.clipboardEvent);
                return;
              }
              case "cut":
                this._cut(e);
                return;
            }
            const n = this.getAction(t);
            if (n) {
              Promise.resolve(n.run(i)).then(void 0, qt);
              return;
            }
            if (!this._modelData || this._triggerEditorCommand(e, t, i)) return;
            this._triggerCommand(t, i);
          } finally {
            this._endUpdate();
          }
        }
        _triggerCommand(e, t) {
          this._commandService.executeCommand(e, t);
        }
        _startComposition() {
          this._modelData && (this._modelData.viewModel.startComposition(), this._onDidCompositionStart.fire());
        }
        _endComposition(e) {
          this._modelData && (this._modelData.viewModel.endComposition(e), this._onDidCompositionEnd.fire());
        }
        _type(e, t) {
          !this._modelData || t.length === 0 || (e === "keyboard" && this._onWillType.fire(t), this._modelData.viewModel.type(t, e), e === "keyboard" && this._onDidType.fire(t));
        }
        _compositionType(e, t, i, n, o) {
          this._modelData && this._modelData.viewModel.compositionType(t, i, n, o, e);
        }
        _paste(e, t, i, n, o, r) {
          if (!this._modelData) return;
          const a = this._modelData.viewModel, l = a.getSelection().getStartPosition();
          a.paste(t, i, n, e);
          const u = a.getSelection().getStartPosition();
          e === "keyboard" && this._onDidPaste.fire({
            clipboardEvent: r,
            range: new z(l.lineNumber, l.column, u.lineNumber, u.column),
            languageId: o
          });
        }
        _cut(e) {
          this._modelData && this._modelData.viewModel.cut(e);
        }
        _triggerEditorCommand(e, t, i) {
          const n = Rf.getEditorCommand(t);
          return n ? (i = i || {}, i.source = e, this._instantiationService.invokeFunction((o) => {
            Promise.resolve(n.runEditorCommand(o, this, i)).then(void 0, qt);
          }), true) : false;
        }
        _getViewModel() {
          return this._modelData ? this._modelData.viewModel : null;
        }
        pushUndoStop() {
          return !this._modelData || this._configuration.options.get(92) ? false : (this._modelData.model.pushStackElement(), true);
        }
        popUndoStop() {
          return !this._modelData || this._configuration.options.get(92) ? false : (this._modelData.model.popStackElement(), true);
        }
        executeEdits(e, t, i) {
          if (!this._modelData || this._configuration.options.get(92)) return false;
          let n;
          return i ? Array.isArray(i) ? n = () => i : n = i : n = () => null, this._modelData.viewModel.executeEdits(e, t, n), true;
        }
        executeCommand(e, t) {
          this._modelData && this._modelData.viewModel.executeCommand(t, e);
        }
        executeCommands(e, t) {
          this._modelData && this._modelData.viewModel.executeCommands(t, e);
        }
        createDecorationsCollection(e) {
          return new che(this, e);
        }
        changeDecorations(e) {
          return this._modelData ? this._modelData.model.changeDecorations(e, this._id) : null;
        }
        getLineDecorations(e) {
          return this._modelData ? this._modelData.model.getLineDecorations(e, this._id, G0(this._configuration.options)) : null;
        }
        getDecorationsInRange(e) {
          return this._modelData ? this._modelData.model.getDecorationsInRange(e, this._id, G0(this._configuration.options)) : null;
        }
        deltaDecorations(e, t) {
          return this._modelData ? e.length === 0 && t.length === 0 ? e : this._modelData.model.deltaDecorations(e, t, this._id) : [];
        }
        removeDecorations(e) {
          !this._modelData || e.length === 0 || this._modelData.model.changeDecorations((t) => {
            t.deltaDecorations(e, []);
          });
        }
        removeDecorationsByType(e) {
          const t = this._decorationTypeKeysToIds[e];
          t && this.changeDecorations((i) => i.deltaDecorations(t, [])), this._decorationTypeKeysToIds.hasOwnProperty(e) && delete this._decorationTypeKeysToIds[e], this._decorationTypeSubtypes.hasOwnProperty(e) && delete this._decorationTypeSubtypes[e];
        }
        getLayoutInfo() {
          return this._configuration.options.get(146);
        }
        createOverviewRuler(e) {
          return !this._modelData || !this._modelData.hasRealView ? null : this._modelData.view.createOverviewRuler(e);
        }
        getContainerDomNode() {
          return this._domElement;
        }
        getDomNode() {
          return !this._modelData || !this._modelData.hasRealView ? null : this._modelData.view.domNode.domNode;
        }
        delegateVerticalScrollbarPointerDown(e) {
          !this._modelData || !this._modelData.hasRealView || this._modelData.view.delegateVerticalScrollbarPointerDown(e);
        }
        delegateScrollFromMouseWheelEvent(e) {
          !this._modelData || !this._modelData.hasRealView || this._modelData.view.delegateScrollFromMouseWheelEvent(e);
        }
        layout(e, t = false) {
          this._configuration.observeContainer(e), t || this.render();
        }
        focus() {
          !this._modelData || !this._modelData.hasRealView || this._modelData.view.focus();
        }
        hasTextFocus() {
          return !this._modelData || !this._modelData.hasRealView ? false : this._modelData.view.isFocused();
        }
        hasWidgetFocus() {
          return this._focusTracker && this._focusTracker.hasFocus();
        }
        addContentWidget(e) {
          const t = {
            widget: e,
            position: e.getPosition()
          };
          this._contentWidgets.hasOwnProperty(e.getId()) && console.warn("Overwriting a content widget with the same id:" + e.getId()), this._contentWidgets[e.getId()] = t, this._modelData && this._modelData.hasRealView && this._modelData.view.addContentWidget(t);
        }
        layoutContentWidget(e) {
          const t = e.getId();
          if (this._contentWidgets.hasOwnProperty(t)) {
            const i = this._contentWidgets[t];
            i.position = e.getPosition(), this._modelData && this._modelData.hasRealView && this._modelData.view.layoutContentWidget(i);
          }
        }
        removeContentWidget(e) {
          const t = e.getId();
          if (this._contentWidgets.hasOwnProperty(t)) {
            const i = this._contentWidgets[t];
            delete this._contentWidgets[t], this._modelData && this._modelData.hasRealView && this._modelData.view.removeContentWidget(i);
          }
        }
        addOverlayWidget(e) {
          const t = {
            widget: e,
            position: e.getPosition()
          };
          this._overlayWidgets.hasOwnProperty(e.getId()) && console.warn("Overwriting an overlay widget with the same id."), this._overlayWidgets[e.getId()] = t, this._modelData && this._modelData.hasRealView && this._modelData.view.addOverlayWidget(t);
        }
        layoutOverlayWidget(e) {
          const t = e.getId();
          if (this._overlayWidgets.hasOwnProperty(t)) {
            const i = this._overlayWidgets[t];
            i.position = e.getPosition(), this._modelData && this._modelData.hasRealView && this._modelData.view.layoutOverlayWidget(i);
          }
        }
        removeOverlayWidget(e) {
          const t = e.getId();
          if (this._overlayWidgets.hasOwnProperty(t)) {
            const i = this._overlayWidgets[t];
            delete this._overlayWidgets[t], this._modelData && this._modelData.hasRealView && this._modelData.view.removeOverlayWidget(i);
          }
        }
        addGlyphMarginWidget(e) {
          const t = {
            widget: e,
            position: e.getPosition()
          };
          this._glyphMarginWidgets.hasOwnProperty(e.getId()) && console.warn("Overwriting a glyph margin widget with the same id."), this._glyphMarginWidgets[e.getId()] = t, this._modelData && this._modelData.hasRealView && this._modelData.view.addGlyphMarginWidget(t);
        }
        layoutGlyphMarginWidget(e) {
          const t = e.getId();
          if (this._glyphMarginWidgets.hasOwnProperty(t)) {
            const i = this._glyphMarginWidgets[t];
            i.position = e.getPosition(), this._modelData && this._modelData.hasRealView && this._modelData.view.layoutGlyphMarginWidget(i);
          }
        }
        removeGlyphMarginWidget(e) {
          const t = e.getId();
          if (this._glyphMarginWidgets.hasOwnProperty(t)) {
            const i = this._glyphMarginWidgets[t];
            delete this._glyphMarginWidgets[t], this._modelData && this._modelData.hasRealView && this._modelData.view.removeGlyphMarginWidget(i);
          }
        }
        changeViewZones(e) {
          !this._modelData || !this._modelData.hasRealView || this._modelData.view.change(e);
        }
        getTargetAtClientPoint(e, t) {
          return !this._modelData || !this._modelData.hasRealView ? null : this._modelData.view.getTargetAtClientPoint(e, t);
        }
        getScrolledVisiblePosition(e) {
          if (!this._modelData || !this._modelData.hasRealView) return null;
          const t = this._modelData.model.validatePosition(e), i = this._configuration.options, n = i.get(146), o = Yu._getVerticalOffsetForPosition(this._modelData, t.lineNumber, t.column) - this.getScrollTop(), r = this._modelData.view.getOffsetForColumn(t.lineNumber, t.column) + n.glyphMarginWidth + n.lineNumbersWidth + n.decorationsWidth - this.getScrollLeft();
          return {
            top: o,
            left: r,
            height: i.get(67)
          };
        }
        getOffsetForColumn(e, t) {
          return !this._modelData || !this._modelData.hasRealView ? -1 : this._modelData.view.getOffsetForColumn(e, t);
        }
        render(e = false) {
          !this._modelData || !this._modelData.hasRealView || this._modelData.viewModel.batchEvents(() => {
            this._modelData.view.render(true, e);
          });
        }
        setAriaOptions(e) {
          !this._modelData || !this._modelData.hasRealView || this._modelData.view.setAriaOptions(e);
        }
        applyFontInfo(e) {
          Un(e, this._configuration.options.get(50));
        }
        setBanner(e, t) {
          this._bannerDomNode && this._domElement.contains(this._bannerDomNode) && this._bannerDomNode.remove(), this._bannerDomNode = e, this._configuration.setReservedHeight(e ? t : 0), this._bannerDomNode && this._domElement.prepend(this._bannerDomNode);
        }
        _attachModel(e) {
          if (!e) {
            this._modelData = null;
            return;
          }
          const t = [];
          this._domElement.setAttribute("data-mode-id", e.getLanguageId()), this._configuration.setIsDominatedByLongLines(e.isDominatedByLongLines()), this._configuration.setModelLineCount(e.getLineCount());
          const i = e.onBeforeAttached(), n = new Jue(this._id, this._configuration, e, aI.create(Oe(this._domElement)), lI.create(this._configuration.options), (a) => Gs(Oe(this._domElement), a), this.languageConfigurationService, this._themeService, i, {
            batchChanges: (a) => {
              try {
                return this._beginUpdate(), a();
              } finally {
                this._endUpdate();
              }
            }
          });
          t.push(e.onWillDispose(() => this.setModel(null))), t.push(n.onEvent((a) => {
            switch (a.kind) {
              case 0:
                this._onDidContentSizeChange.fire(a);
                break;
              case 1:
                this._editorTextFocus.setValue(a.hasFocus);
                break;
              case 2:
                this._onDidScrollChange.fire(a);
                break;
              case 3:
                this._onDidChangeViewZones.fire();
                break;
              case 4:
                this._onDidChangeHiddenAreas.fire();
                break;
              case 5:
                this._onDidAttemptReadOnlyEdit.fire();
                break;
              case 6: {
                if (a.reachedMaxCursorCount) {
                  const f = this.getOption(80), m = C("cursors.maximum", "The number of cursors has been limited to {0}. Consider using [find and replace](https://code.visualstudio.com/docs/editor/codebasics#_find-and-replace) for larger changes or increase the editor multi cursor limit setting.", f);
                  this._notificationService.prompt(YY.Warning, m, [
                    {
                      label: "Find and Replace",
                      run: () => {
                        this._commandService.executeCommand("editor.action.startFindReplaceAction");
                      }
                    },
                    {
                      label: C("goToSetting", "Increase Multi Cursor Limit"),
                      run: () => {
                        this._commandService.executeCommand("workbench.action.openSettings2", {
                          query: "editor.multiCursorLimit"
                        });
                      }
                    }
                  ]);
                }
                const l = [];
                for (let f = 0, m = a.selections.length; f < m; f++) l[f] = a.selections[f].getPosition();
                const u = {
                  position: l[0],
                  secondaryPositions: l.slice(1),
                  reason: a.reason,
                  source: a.source
                };
                this._onDidChangeCursorPosition.fire(u);
                const d = {
                  selection: a.selections[0],
                  secondarySelections: a.selections.slice(1),
                  modelVersionId: a.modelVersionId,
                  oldSelections: a.oldSelections,
                  oldModelVersionId: a.oldModelVersionId,
                  source: a.source,
                  reason: a.reason
                };
                this._onDidChangeCursorSelection.fire(d);
                break;
              }
              case 7:
                this._onDidChangeModelDecorations.fire(a.event);
                break;
              case 8:
                this._domElement.setAttribute("data-mode-id", e.getLanguageId()), this._onDidChangeModelLanguage.fire(a.event);
                break;
              case 9:
                this._onDidChangeModelLanguageConfiguration.fire(a.event);
                break;
              case 10:
                this._onDidChangeModelContent.fire(a.event);
                break;
              case 11:
                this._onDidChangeModelOptions.fire(a.event);
                break;
              case 12:
                this._onDidChangeModelTokens.fire(a.event);
                break;
            }
          }));
          const [o, r] = this._createView(n);
          if (r) {
            this._domElement.appendChild(o.domNode.domNode);
            let a = Object.keys(this._contentWidgets);
            for (let l = 0, u = a.length; l < u; l++) {
              const d = a[l];
              o.addContentWidget(this._contentWidgets[d]);
            }
            a = Object.keys(this._overlayWidgets);
            for (let l = 0, u = a.length; l < u; l++) {
              const d = a[l];
              o.addOverlayWidget(this._overlayWidgets[d]);
            }
            a = Object.keys(this._glyphMarginWidgets);
            for (let l = 0, u = a.length; l < u; l++) {
              const d = a[l];
              o.addGlyphMarginWidget(this._glyphMarginWidgets[d]);
            }
            o.render(false, true), o.domNode.domNode.setAttribute("data-uri", e.uri.toString());
          }
          this._modelData = new ohe(e, n, o, r, t, i);
        }
        _createView(e) {
          let t;
          this.isSimpleWidget ? t = {
            paste: (o, r, a, l) => {
              this._paste("keyboard", o, r, a, l);
            },
            type: (o) => {
              this._type("keyboard", o);
            },
            compositionType: (o, r, a, l) => {
              this._compositionType("keyboard", o, r, a, l);
            },
            startComposition: () => {
              this._startComposition();
            },
            endComposition: () => {
              this._endComposition("keyboard");
            },
            cut: () => {
              this._cut("keyboard");
            }
          } : t = {
            paste: (o, r, a, l) => {
              const u = {
                text: o,
                pasteOnNewLine: r,
                multicursorText: a,
                mode: l
              };
              this._commandService.executeCommand("paste", u);
            },
            type: (o) => {
              const r = {
                text: o
              };
              this._commandService.executeCommand("type", r);
            },
            compositionType: (o, r, a, l) => {
              if (a || l) {
                const u = {
                  text: o,
                  replacePrevCharCnt: r,
                  replaceNextCharCnt: a,
                  positionDelta: l
                };
                this._commandService.executeCommand("compositionType", u);
              } else {
                const u = {
                  text: o,
                  replaceCharCnt: r
                };
                this._commandService.executeCommand("replacePreviousChar", u);
              }
            },
            startComposition: () => {
              this._commandService.executeCommand("compositionStart", {});
            },
            endComposition: () => {
              this._commandService.executeCommand("compositionEnd", {});
            },
            cut: () => {
              this._commandService.executeCommand("cut", {});
            }
          };
          const i = new $w(e.coordinatesConverter);
          return i.onKeyDown = (o) => this._onKeyDown.fire(o), i.onKeyUp = (o) => this._onKeyUp.fire(o), i.onContextMenu = (o) => this._onContextMenu.fire(o), i.onMouseMove = (o) => this._onMouseMove.fire(o), i.onMouseLeave = (o) => this._onMouseLeave.fire(o), i.onMouseDown = (o) => this._onMouseDown.fire(o), i.onMouseUp = (o) => this._onMouseUp.fire(o), i.onMouseDrag = (o) => this._onMouseDrag.fire(o), i.onMouseDrop = (o) => this._onMouseDrop.fire(o), i.onMouseDropCanceled = (o) => this._onMouseDropCanceled.fire(o), i.onMouseWheel = (o) => this._onMouseWheel.fire(o), [
            new J2(t, this._configuration, this._themeService.getColorTheme(), e, i, this._overflowWidgetsDomNode, this._instantiationService),
            true
          ];
        }
        _postDetachModelCleanup(e) {
          e == null ? void 0 : e.removeAllDecorationsWithOwnerId(this._id);
        }
        _detachModel() {
          var _a3;
          if ((_a3 = this._contributionsDisposable) == null ? void 0 : _a3.dispose(), this._contributionsDisposable = void 0, !this._modelData) return null;
          const e = this._modelData.model, t = this._modelData.hasRealView ? this._modelData.view.domNode.domNode : null;
          return this._modelData.dispose(), this._modelData = null, this._domElement.removeAttribute("data-mode-id"), t && this._domElement.contains(t) && t.remove(), this._bannerDomNode && this._domElement.contains(this._bannerDomNode) && this._bannerDomNode.remove(), e;
        }
        _removeDecorationType(e) {
          this._codeEditorService.removeDecorationType(e);
        }
        hasModel() {
          return this._modelData !== null;
        }
        showDropIndicatorAt(e) {
          const t = [
            {
              range: new z(e.lineNumber, e.column, e.lineNumber, e.column),
              options: Yu.dropIntoEditorDecorationOptions
            }
          ];
          this._dropIntoEditorDecorations.set(t), this.revealPosition(e, 1);
        }
        removeDropIndicator() {
          this._dropIntoEditorDecorations.clear();
        }
        setContextValue(e, t) {
          this._contextKeyService.createKey(e, t);
        }
        _beginUpdate() {
          this._updateCounter++, this._updateCounter === 1 && this._onBeginUpdate.fire();
        }
        _endUpdate() {
          this._updateCounter--, this._updateCounter === 0 && this._onEndUpdate.fire();
        }
      }, Yu = _p2, _p2.dropIntoEditorDecorationOptions = Zi.register({
        description: "workbench-dnd-target",
        className: "dnd-target"
      }), _p2);
      SC = Yu = nhe([
        ul(3, Ft),
        ul(4, Xi),
        ul(5, po),
        ul(6, Mt),
        ul(7, vr),
        ul(8, Jr),
        ul(9, ea),
        ul(10, Pa),
        ul(11, jt)
      ], SC);
      let she = 0;
      class ohe {
        constructor(e, t, i, n, o, r) {
          this.model = e, this.viewModel = t, this.view = i, this.hasRealView = n, this.listenersToRemove = o, this.attachedView = r;
        }
        dispose() {
          On(this.listenersToRemove), this.model.onBeforeDetached(this.attachedView), this.hasRealView && this.view.dispose(), this.viewModel.dispose();
        }
      }
      class l7 extends he {
        constructor(e) {
          super(), this._emitterOptions = e, this._onDidChangeToTrue = this._register(new G(this._emitterOptions)), this.onDidChangeToTrue = this._onDidChangeToTrue.event, this._onDidChangeToFalse = this._register(new G(this._emitterOptions)), this.onDidChangeToFalse = this._onDidChangeToFalse.event, this._value = 0;
        }
        setValue(e) {
          const t = e ? 2 : 1;
          this._value !== t && (this._value = t, this._value === 2 ? this._onDidChangeToTrue.fire() : this._value === 1 && this._onDidChangeToFalse.fire());
        }
      }
      class Qn extends G {
        constructor(e, t) {
          super({
            deliveryQueue: t
          }), this._contributions = e;
        }
        fire(e) {
          this._contributions.onBeforeInteractionEvent(), super.fire(e);
        }
      }
      class rhe extends he {
        constructor(e, t) {
          super(), this._editor = e, t.createKey("editorId", e.getId()), this._editorSimpleInput = ke.editorSimpleInput.bindTo(t), this._editorFocus = ke.focus.bindTo(t), this._textInputFocus = ke.textInputFocus.bindTo(t), this._editorTextFocus = ke.editorTextFocus.bindTo(t), this._tabMovesFocus = ke.tabMovesFocus.bindTo(t), this._editorReadonly = ke.readOnly.bindTo(t), this._inDiffEditor = ke.inDiffEditor.bindTo(t), this._editorColumnSelection = ke.columnSelection.bindTo(t), this._hasMultipleSelections = ke.hasMultipleSelections.bindTo(t), this._hasNonEmptySelection = ke.hasNonEmptySelection.bindTo(t), this._canUndo = ke.canUndo.bindTo(t), this._canRedo = ke.canRedo.bindTo(t), this._register(this._editor.onDidChangeConfiguration(() => this._updateFromConfig())), this._register(this._editor.onDidChangeCursorSelection(() => this._updateFromSelection())), this._register(this._editor.onDidFocusEditorWidget(() => this._updateFromFocus())), this._register(this._editor.onDidBlurEditorWidget(() => this._updateFromFocus())), this._register(this._editor.onDidFocusEditorText(() => this._updateFromFocus())), this._register(this._editor.onDidBlurEditorText(() => this._updateFromFocus())), this._register(this._editor.onDidChangeModel(() => this._updateFromModel())), this._register(this._editor.onDidChangeConfiguration(() => this._updateFromModel())), this._register(fC.onDidChangeTabFocus((i) => this._tabMovesFocus.set(i))), this._updateFromConfig(), this._updateFromSelection(), this._updateFromFocus(), this._updateFromModel(), this._editorSimpleInput.set(this._editor.isSimpleWidget);
        }
        _updateFromConfig() {
          const e = this._editor.getOptions();
          this._tabMovesFocus.set(fC.getTabFocusMode()), this._editorReadonly.set(e.get(92)), this._inDiffEditor.set(e.get(61)), this._editorColumnSelection.set(e.get(22));
        }
        _updateFromSelection() {
          const e = this._editor.getSelections();
          e ? (this._hasMultipleSelections.set(e.length > 1), this._hasNonEmptySelection.set(e.some((t) => !t.isEmpty()))) : (this._hasMultipleSelections.reset(), this._hasNonEmptySelection.reset());
        }
        _updateFromFocus() {
          this._editorFocus.set(this._editor.hasWidgetFocus() && !this._editor.isSimpleWidget), this._editorTextFocus.set(this._editor.hasTextFocus() && !this._editor.isSimpleWidget), this._textInputFocus.set(this._editor.hasTextFocus());
        }
        _updateFromModel() {
          const e = this._editor.getModel();
          this._canUndo.set(!!(e && e.canUndo())), this._canRedo.set(!!(e && e.canRedo()));
        }
      }
      class ahe extends he {
        constructor(e, t, i) {
          super(), this._editor = e, this._contextKeyService = t, this._languageFeaturesService = i, this._langId = ke.languageId.bindTo(t), this._hasCompletionItemProvider = ke.hasCompletionItemProvider.bindTo(t), this._hasCodeActionsProvider = ke.hasCodeActionsProvider.bindTo(t), this._hasCodeLensProvider = ke.hasCodeLensProvider.bindTo(t), this._hasDefinitionProvider = ke.hasDefinitionProvider.bindTo(t), this._hasDeclarationProvider = ke.hasDeclarationProvider.bindTo(t), this._hasImplementationProvider = ke.hasImplementationProvider.bindTo(t), this._hasTypeDefinitionProvider = ke.hasTypeDefinitionProvider.bindTo(t), this._hasHoverProvider = ke.hasHoverProvider.bindTo(t), this._hasDocumentHighlightProvider = ke.hasDocumentHighlightProvider.bindTo(t), this._hasDocumentSymbolProvider = ke.hasDocumentSymbolProvider.bindTo(t), this._hasReferenceProvider = ke.hasReferenceProvider.bindTo(t), this._hasRenameProvider = ke.hasRenameProvider.bindTo(t), this._hasSignatureHelpProvider = ke.hasSignatureHelpProvider.bindTo(t), this._hasInlayHintsProvider = ke.hasInlayHintsProvider.bindTo(t), this._hasDocumentFormattingProvider = ke.hasDocumentFormattingProvider.bindTo(t), this._hasDocumentSelectionFormattingProvider = ke.hasDocumentSelectionFormattingProvider.bindTo(t), this._hasMultipleDocumentFormattingProvider = ke.hasMultipleDocumentFormattingProvider.bindTo(t), this._hasMultipleDocumentSelectionFormattingProvider = ke.hasMultipleDocumentSelectionFormattingProvider.bindTo(t), this._isInEmbeddedEditor = ke.isInEmbeddedEditor.bindTo(t);
          const n = () => this._update();
          this._register(e.onDidChangeModel(n)), this._register(e.onDidChangeModelLanguage(n)), this._register(i.completionProvider.onDidChange(n)), this._register(i.codeActionProvider.onDidChange(n)), this._register(i.codeLensProvider.onDidChange(n)), this._register(i.definitionProvider.onDidChange(n)), this._register(i.declarationProvider.onDidChange(n)), this._register(i.implementationProvider.onDidChange(n)), this._register(i.typeDefinitionProvider.onDidChange(n)), this._register(i.hoverProvider.onDidChange(n)), this._register(i.documentHighlightProvider.onDidChange(n)), this._register(i.documentSymbolProvider.onDidChange(n)), this._register(i.referenceProvider.onDidChange(n)), this._register(i.renameProvider.onDidChange(n)), this._register(i.documentFormattingEditProvider.onDidChange(n)), this._register(i.documentRangeFormattingEditProvider.onDidChange(n)), this._register(i.signatureHelpProvider.onDidChange(n)), this._register(i.inlayHintsProvider.onDidChange(n)), n();
        }
        dispose() {
          super.dispose();
        }
        reset() {
          this._contextKeyService.bufferChangeEvents(() => {
            this._langId.reset(), this._hasCompletionItemProvider.reset(), this._hasCodeActionsProvider.reset(), this._hasCodeLensProvider.reset(), this._hasDefinitionProvider.reset(), this._hasDeclarationProvider.reset(), this._hasImplementationProvider.reset(), this._hasTypeDefinitionProvider.reset(), this._hasHoverProvider.reset(), this._hasDocumentHighlightProvider.reset(), this._hasDocumentSymbolProvider.reset(), this._hasReferenceProvider.reset(), this._hasRenameProvider.reset(), this._hasDocumentFormattingProvider.reset(), this._hasDocumentSelectionFormattingProvider.reset(), this._hasSignatureHelpProvider.reset(), this._isInEmbeddedEditor.reset();
          });
        }
        _update() {
          const e = this._editor.getModel();
          if (!e) {
            this.reset();
            return;
          }
          this._contextKeyService.bufferChangeEvents(() => {
            this._langId.set(e.getLanguageId()), this._hasCompletionItemProvider.set(this._languageFeaturesService.completionProvider.has(e)), this._hasCodeActionsProvider.set(this._languageFeaturesService.codeActionProvider.has(e)), this._hasCodeLensProvider.set(this._languageFeaturesService.codeLensProvider.has(e)), this._hasDefinitionProvider.set(this._languageFeaturesService.definitionProvider.has(e)), this._hasDeclarationProvider.set(this._languageFeaturesService.declarationProvider.has(e)), this._hasImplementationProvider.set(this._languageFeaturesService.implementationProvider.has(e)), this._hasTypeDefinitionProvider.set(this._languageFeaturesService.typeDefinitionProvider.has(e)), this._hasHoverProvider.set(this._languageFeaturesService.hoverProvider.has(e)), this._hasDocumentHighlightProvider.set(this._languageFeaturesService.documentHighlightProvider.has(e)), this._hasDocumentSymbolProvider.set(this._languageFeaturesService.documentSymbolProvider.has(e)), this._hasReferenceProvider.set(this._languageFeaturesService.referenceProvider.has(e)), this._hasRenameProvider.set(this._languageFeaturesService.renameProvider.has(e)), this._hasSignatureHelpProvider.set(this._languageFeaturesService.signatureHelpProvider.has(e)), this._hasInlayHintsProvider.set(this._languageFeaturesService.inlayHintsProvider.has(e)), this._hasDocumentFormattingProvider.set(this._languageFeaturesService.documentFormattingEditProvider.has(e) || this._languageFeaturesService.documentRangeFormattingEditProvider.has(e)), this._hasDocumentSelectionFormattingProvider.set(this._languageFeaturesService.documentRangeFormattingEditProvider.has(e)), this._hasMultipleDocumentFormattingProvider.set(this._languageFeaturesService.documentFormattingEditProvider.all(e).length + this._languageFeaturesService.documentRangeFormattingEditProvider.all(e).length > 1), this._hasMultipleDocumentSelectionFormattingProvider.set(this._languageFeaturesService.documentRangeFormattingEditProvider.all(e).length > 1), this._isInEmbeddedEditor.set(e.uri.scheme === it.walkThroughSnippet || e.uri.scheme === it.vscodeChatCodeBlock);
          });
        }
      }
      class lhe extends he {
        constructor(e, t) {
          super(), this._onChange = this._register(new G()), this.onChange = this._onChange.event, this._hadFocus = void 0, this._hasDomElementFocus = false, this._domFocusTracker = this._register(Qp(e)), this._overflowWidgetsDomNodeHasFocus = false, this._register(this._domFocusTracker.onDidFocus(() => {
            this._hasDomElementFocus = true, this._update();
          })), this._register(this._domFocusTracker.onDidBlur(() => {
            this._hasDomElementFocus = false, this._update();
          })), t && (this._overflowWidgetsDomNode = this._register(Qp(t)), this._register(this._overflowWidgetsDomNode.onDidFocus(() => {
            this._overflowWidgetsDomNodeHasFocus = true, this._update();
          })), this._register(this._overflowWidgetsDomNode.onDidBlur(() => {
            this._overflowWidgetsDomNodeHasFocus = false, this._update();
          })));
        }
        _update() {
          const e = this._hasDomElementFocus || this._overflowWidgetsDomNodeHasFocus;
          this._hadFocus !== e && (this._hadFocus = e, this._onChange.fire(void 0));
        }
        hasFocus() {
          return this._hadFocus ?? false;
        }
      }
      class che {
        get length() {
          return this._decorationIds.length;
        }
        constructor(e, t) {
          this._editor = e, this._decorationIds = [], this._isChangingDecorations = false, Array.isArray(t) && t.length > 0 && this.set(t);
        }
        onDidChange(e, t, i) {
          return this._editor.onDidChangeModelDecorations((n) => {
            this._isChangingDecorations || e.call(t, n);
          }, i);
        }
        getRange(e) {
          return !this._editor.hasModel() || e >= this._decorationIds.length ? null : this._editor.getModel().getDecorationRange(this._decorationIds[e]);
        }
        getRanges() {
          if (!this._editor.hasModel()) return [];
          const e = this._editor.getModel(), t = [];
          for (const i of this._decorationIds) {
            const n = e.getDecorationRange(i);
            n && t.push(n);
          }
          return t;
        }
        has(e) {
          return this._decorationIds.includes(e.id);
        }
        clear() {
          this._decorationIds.length !== 0 && this.set([]);
        }
        set(e) {
          try {
            this._isChangingDecorations = true, this._editor.changeDecorations((t) => {
              this._decorationIds = t.deltaDecorations(this._decorationIds, e);
            });
          } finally {
            this._isChangingDecorations = false;
          }
          return this._decorationIds;
        }
        append(e) {
          let t = [];
          try {
            this._isChangingDecorations = true, this._editor.changeDecorations((i) => {
              t = i.deltaDecorations([], e), this._decorationIds = this._decorationIds.concat(t);
            });
          } finally {
            this._isChangingDecorations = false;
          }
          return t;
        }
      }
      const uhe = encodeURIComponent("<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 6 3' enable-background='new 0 0 6 3' height='3' width='6'><g fill='"), hhe = encodeURIComponent("'><polygon points='5.5,0 2.5,3 1.1,3 4.1,0'/><polygon points='4,0 6,2 6,0.6 5.4,0'/><polygon points='0,2 1,3 2.4,3 0,0.6'/></g></svg>");
      function Dx(s) {
        return uhe + encodeURIComponent(s.toString()) + hhe;
      }
      const dhe = encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" height="3" width="12"><g fill="'), fhe = encodeURIComponent('"><circle cx="1" cy="1" r="1"/><circle cx="5" cy="1" r="1"/><circle cx="9" cy="1" r="1"/></g></svg>');
      function ghe(s) {
        return dhe + encodeURIComponent(s.toString()) + fhe;
      }
      jl((s, e) => {
        const t = s.getColor(IT);
        t && e.addRule(`.monaco-editor .squiggly-error { background: url("data:image/svg+xml,${Dx(t)}") repeat-x bottom left; }`);
        const i = s.getColor(au);
        i && e.addRule(`.monaco-editor .squiggly-warning { background: url("data:image/svg+xml,${Dx(i)}") repeat-x bottom left; }`);
        const n = s.getColor(Bh);
        n && e.addRule(`.monaco-editor .squiggly-info { background: url("data:image/svg+xml,${Dx(n)}") repeat-x bottom left; }`);
        const o = s.getColor(PZ);
        o && e.addRule(`.monaco-editor .squiggly-hint { background: url("data:image/svg+xml,${ghe(o)}") no-repeat bottom left; }`);
        const r = s.getColor(yie);
        r && e.addRule(`.monaco-editor.showUnused .squiggly-inline-unnecessary { opacity: ${r.rgba.a}; }`);
      });
      class LC {
        static capture(e) {
          if (e.getScrollTop() === 0 || e.hasPendingScrollAnimation()) return new LC(e.getScrollTop(), e.getContentHeight(), null, 0, null);
          let t = null, i = 0;
          const n = e.getVisibleRanges();
          if (n.length > 0) {
            t = n[0].getStartPosition();
            const o = e.getTopForPosition(t.lineNumber, t.column);
            i = e.getScrollTop() - o;
          }
          return new LC(e.getScrollTop(), e.getContentHeight(), t, i, e.getPosition());
        }
        constructor(e, t, i, n, o) {
          this._initialScrollTop = e, this._initialContentHeight = t, this._visiblePosition = i, this._visiblePositionScrollDelta = n, this._cursorPosition = o;
        }
        restore(e) {
          if (!(this._initialContentHeight === e.getContentHeight() && this._initialScrollTop === e.getScrollTop()) && this._visiblePosition) {
            const t = e.getTopForPosition(this._visiblePosition.lineNumber, this._visiblePosition.column);
            e.setScrollTop(t + this._visiblePositionScrollDelta);
          }
        }
        restoreRelativeVerticalPositionOfCursor(e) {
          if (this._initialContentHeight === e.getContentHeight() && this._initialScrollTop === e.getScrollTop()) return;
          const t = e.getPosition();
          if (!this._cursorPosition || !t) return;
          const i = e.getTopForLineNumber(t.lineNumber) - e.getTopForLineNumber(this._cursorPosition.lineNumber);
          e.setScrollTop(e.getScrollTop() + i, 1);
        }
      }
      function mhe(s, e, t, i) {
        if (s.length === 0) return e;
        if (e.length === 0) return s;
        const n = [];
        let o = 0, r = 0;
        for (; o < s.length && r < e.length; ) {
          const a = s[o], l = e[r], u = t(a), d = t(l);
          u < d ? (n.push(a), o++) : u > d ? (n.push(l), r++) : (n.push(i(a, l)), o++, r++);
        }
        for (; o < s.length; ) n.push(s[o]), o++;
        for (; r < e.length; ) n.push(e[r]), r++;
        return n;
      }
      function xC(s, e) {
        const t = new Me(), i = s.createDecorationsCollection();
        return t.add(bw({
          debugName: () => `Apply decorations from ${e.debugName}`
        }, (n) => {
          const o = e.read(n);
          i.set(o);
        })), t.add({
          dispose: () => {
            i.clear();
          }
        }), t;
      }
      function hp(s, e) {
        return s.appendChild(e), Ze(() => {
          e.remove();
        });
      }
      function phe(s, e) {
        return s.prepend(e), Ze(() => {
          e.remove();
        });
      }
      class UF extends he {
        get width() {
          return this._width;
        }
        get height() {
          return this._height;
        }
        get automaticLayout() {
          return this._automaticLayout;
        }
        constructor(e, t) {
          super(), this._automaticLayout = false, this.elementSizeObserver = this._register(new yF(e, t)), this._width = Ct(this, this.elementSizeObserver.getWidth()), this._height = Ct(this, this.elementSizeObserver.getHeight()), this._register(this.elementSizeObserver.onDidChange((i) => Yi((n) => {
            this._width.set(this.elementSizeObserver.getWidth(), n), this._height.set(this.elementSizeObserver.getHeight(), n);
          })));
        }
        observe(e) {
          this.elementSizeObserver.observe(e);
        }
        setAutomaticLayout(e) {
          this._automaticLayout = e, e ? this.elementSizeObserver.startObserving() : this.elementSizeObserver.stopObserving();
        }
      }
      function c7(s, e, t) {
        let i = e.get(), n = i, o = i;
        const r = Ct("animatedValue", i);
        let a = -1;
        const l = 300;
        let u;
        t.add(vw({
          createEmptyChangeSummary: () => ({
            animate: false
          }),
          handleChange: (f, m) => (f.didChange(e) && (m.animate = m.animate || f.change), true)
        }, (f, m) => {
          u !== void 0 && (s.cancelAnimationFrame(u), u = void 0), n = o, i = e.read(f), a = Date.now() - (m.animate ? 0 : l), d();
        }));
        function d() {
          const f = Date.now() - a;
          o = Math.floor(_he(f, n, i - n, l)), f < l ? u = s.requestAnimationFrame(d) : o = i, r.set(o, void 0);
        }
        return r;
      }
      function _he(s, e, t, i) {
        return s === i ? e + t : t * (-Math.pow(2, -10 * s / i) + 1) + e;
      }
      class fI extends he {
        constructor(e, t, i) {
          super(), this._register(new gI(e, i)), this._register(hu(i, {
            height: t.actualHeight,
            top: t.actualTop
          }));
        }
      }
      class Ef {
        get afterLineNumber() {
          return this._afterLineNumber.get();
        }
        constructor(e, t) {
          this._afterLineNumber = e, this.heightInPx = t, this.domNode = document.createElement("div"), this._actualTop = Ct(this, void 0), this._actualHeight = Ct(this, void 0), this.actualTop = this._actualTop, this.actualHeight = this._actualHeight, this.showInHiddenAreas = true, this.onChange = this._afterLineNumber, this.onDomNodeTop = (i) => {
            this._actualTop.set(i, void 0);
          }, this.onComputedHeight = (i) => {
            this._actualHeight.set(i, void 0);
          };
        }
      }
      const _gI = class _gI {
        constructor(e, t) {
          this._editor = e, this._domElement = t, this._overlayWidgetId = `managedOverlayWidget-${_gI._counter++}`, this._overlayWidget = {
            getId: () => this._overlayWidgetId,
            getDomNode: () => this._domElement,
            getPosition: () => null
          }, this._editor.addOverlayWidget(this._overlayWidget);
        }
        dispose() {
          this._editor.removeOverlayWidget(this._overlayWidget);
        }
      };
      _gI._counter = 0;
      let gI = _gI;
      function hu(s, e) {
        return Dt((t) => {
          for (let [i, n] of Object.entries(e)) n && typeof n == "object" && "read" in n && (n = n.read(t)), typeof n == "number" && (n = `${n}px`), i = i.replace(/[A-Z]/g, (o) => "-" + o.toLowerCase()), s.style[i] = n;
        });
      }
      function kC(s, e, t, i) {
        const n = new Me(), o = [];
        return n.add(Ur((r, a) => {
          const l = e.read(r), u = /* @__PURE__ */ new Map(), d = /* @__PURE__ */ new Map();
          t && t(true), s.changeViewZones((f) => {
            for (const m of o) f.removeZone(m), i == null ? void 0 : i.delete(m);
            o.length = 0;
            for (const m of l) {
              const _ = f.addZone(m);
              m.setZoneId && m.setZoneId(_), o.push(_), i == null ? void 0 : i.add(_), u.set(m, _);
            }
          }), t && t(false), a.add(vw({
            createEmptyChangeSummary() {
              return {
                zoneIds: []
              };
            },
            handleChange(f, m) {
              const _ = d.get(f.changedObservable);
              return _ !== void 0 && m.zoneIds.push(_), true;
            }
          }, (f, m) => {
            for (const _ of l) _.onChange && (d.set(_.onChange, u.get(_)), _.onChange.read(f));
            t && t(true), s.changeViewZones((_) => {
              for (const b of m.zoneIds) _.layoutZone(b);
            }), t && t(false);
          }));
        })), n.add({
          dispose() {
            t && t(true), s.changeViewZones((r) => {
              for (const a of o) r.removeZone(a);
            }), i == null ? void 0 : i.clear(), t && t(false);
          }
        }), n;
      }
      function u7(s, e) {
        const t = gv(e, (n) => n.original.startLineNumber <= s.lineNumber);
        if (!t) return z.fromPositions(s);
        if (t.original.endLineNumberExclusive <= s.lineNumber) {
          const n = s.lineNumber - t.original.endLineNumberExclusive + t.modified.endLineNumberExclusive;
          return z.fromPositions(new X(n, s.column));
        }
        if (!t.innerChanges) return z.fromPositions(new X(t.modified.startLineNumber, 1));
        const i = gv(t.innerChanges, (n) => n.originalRange.getStartPosition().isBeforeOrEqual(s));
        if (!i) {
          const n = s.lineNumber - t.original.startLineNumber + t.modified.startLineNumber;
          return z.fromPositions(new X(n, s.column));
        }
        if (i.originalRange.containsPosition(s)) return i.modifiedRange;
        {
          const n = bhe(i.originalRange.getEndPosition(), s);
          return z.fromPositions(n.addToPosition(i.modifiedRange.getEndPosition()));
        }
      }
      function bhe(s, e) {
        return s.lineNumber === e.lineNumber ? new cr(0, e.column - s.column) : new cr(e.lineNumber - s.lineNumber, e.column - 1);
      }
      function vhe(s, e) {
        let t;
        return s.filter((i) => {
          const n = e(i, t);
          return t = i, n;
        });
      }
      class DC {
        static create(e, t = void 0) {
          return new h7(e, e, t);
        }
        static createWithDisposable(e, t, i = void 0) {
          const n = new Me();
          return n.add(t), n.add(e), new h7(e, n, i);
        }
      }
      class h7 extends DC {
        constructor(e, t, i) {
          super(), this.object = e, this._disposable = t, this._debugOwner = i, this._refCount = 1, this._isDisposed = false, this._owners = [], i && this._addOwner(i);
        }
        _addOwner(e) {
          e && this._owners.push(e);
        }
        createNewRef(e) {
          return this._refCount++, e && this._addOwner(e), new Che(this, e);
        }
        dispose() {
          this._isDisposed || (this._isDisposed = true, this._decreaseRefCount(this._debugOwner));
        }
        _decreaseRefCount(e) {
          if (this._refCount--, this._refCount === 0 && this._disposable.dispose(), e) {
            const t = this._owners.indexOf(e);
            t !== -1 && this._owners.splice(t, 1);
          }
        }
      }
      class Che extends DC {
        constructor(e, t) {
          super(), this._base = e, this._debugOwner = t, this._isDisposed = false;
        }
        get object() {
          return this._base.object;
        }
        createNewRef(e) {
          return this._base.createNewRef(e);
        }
        dispose() {
          this._isDisposed || (this._isDisposed = true, this._base._decreaseRefCount(this._debugOwner));
        }
      }
      var mI = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      }, pI = function(s, e) {
        return function(t, i) {
          e(t, i, s);
        };
      };
      const whe = mu("diff-review-insert", Te.add, C("accessibleDiffViewerInsertIcon", "Icon for 'Insert' in accessible diff viewer.")), yhe = mu("diff-review-remove", Te.remove, C("accessibleDiffViewerRemoveIcon", "Icon for 'Remove' in accessible diff viewer.")), She = mu("diff-review-close", Te.close, C("accessibleDiffViewerCloseIcon", "Icon for 'Close' in accessible diff viewer."));
      let bh = (_q2 = class extends he {
        constructor(e, t, i, n, o, r, a, l, u) {
          super(), this._parentNode = e, this._visible = t, this._setVisible = i, this._canClose = n, this._width = o, this._height = r, this._diffs = a, this._models = l, this._instantiationService = u, this._state = Tg(this, (d, f) => {
            const m = this._visible.read(d);
            if (this._parentNode.style.visibility = m ? "visible" : "hidden", !m) return null;
            const _ = f.add(this._instantiationService.createInstance(aE, this._diffs, this._models, this._setVisible, this._canClose)), b = f.add(this._instantiationService.createInstance(lE, this._parentNode, _, this._width, this._height, this._models));
            return {
              model: _,
              view: b
            };
          }).recomputeInitiallyAndOnChange(this._store);
        }
        next() {
          Yi((e) => {
            const t = this._visible.get();
            this._setVisible(true, e), t && this._state.get().model.nextGroup(e);
          });
        }
        prev() {
          Yi((e) => {
            this._setVisible(true, e), this._state.get().model.previousGroup(e);
          });
        }
        close() {
          Yi((e) => {
            this._setVisible(false, e);
          });
        }
      }, _q2._ttPolicy = Xh("diffReview", {
        createHTML: (e) => e
      }), _q2);
      bh = mI([
        pI(8, Ft)
      ], bh);
      let aE = class extends he {
        constructor(e, t, i, n, o) {
          super(), this._diffs = e, this._models = t, this._setVisible = i, this.canClose = n, this._accessibilitySignalService = o, this._groups = Ct(this, []), this._currentGroupIdx = Ct(this, 0), this._currentElementIdx = Ct(this, 0), this.groups = this._groups, this.currentGroup = this._currentGroupIdx.map((r, a) => this._groups.read(a)[r]), this.currentGroupIndex = this._currentGroupIdx, this.currentElement = this._currentElementIdx.map((r, a) => {
            var _a3;
            return (_a3 = this.currentGroup.read(a)) == null ? void 0 : _a3.lines[r];
          }), this._register(Dt((r) => {
            const a = this._diffs.read(r);
            if (!a) {
              this._groups.set([], void 0);
              return;
            }
            const l = Lhe(a, this._models.getOriginalModel().getLineCount(), this._models.getModifiedModel().getLineCount());
            Yi((u) => {
              const d = this._models.getModifiedPosition();
              if (d) {
                const f = l.findIndex((m) => (d == null ? void 0 : d.lineNumber) < m.range.modified.endLineNumberExclusive);
                f !== -1 && this._currentGroupIdx.set(f, u);
              }
              this._groups.set(l, u);
            });
          })), this._register(Dt((r) => {
            const a = this.currentElement.read(r);
            (a == null ? void 0 : a.type) === hs.Deleted ? this._accessibilitySignalService.playSignal(Bt.diffLineDeleted, {
              source: "accessibleDiffViewer.currentElementChanged"
            }) : (a == null ? void 0 : a.type) === hs.Added && this._accessibilitySignalService.playSignal(Bt.diffLineInserted, {
              source: "accessibleDiffViewer.currentElementChanged"
            });
          })), this._register(Dt((r) => {
            const a = this.currentElement.read(r);
            if (a && a.type !== hs.Header) {
              const l = a.modifiedLineNumber ?? a.diff.modified.startLineNumber;
              this._models.modifiedSetSelection(z.fromPositions(new X(l, 1)));
            }
          }));
        }
        _goToGroupDelta(e, t) {
          const i = this.groups.get();
          !i || i.length <= 1 || XT(t, (n) => {
            this._currentGroupIdx.set(Qe.ofLength(i.length).clipCyclic(this._currentGroupIdx.get() + e), n), this._currentElementIdx.set(0, n);
          });
        }
        nextGroup(e) {
          this._goToGroupDelta(1, e);
        }
        previousGroup(e) {
          this._goToGroupDelta(-1, e);
        }
        _goToLineDelta(e) {
          const t = this.currentGroup.get();
          !t || t.lines.length <= 1 || Yi((i) => {
            this._currentElementIdx.set(Qe.ofLength(t.lines.length).clip(this._currentElementIdx.get() + e), i);
          });
        }
        goToNextLine() {
          this._goToLineDelta(1);
        }
        goToPreviousLine() {
          this._goToLineDelta(-1);
        }
        goToLine(e) {
          const t = this.currentGroup.get();
          if (!t) return;
          const i = t.lines.indexOf(e);
          i !== -1 && Yi((n) => {
            this._currentElementIdx.set(i, n);
          });
        }
        revealCurrentElementInEditor() {
          if (!this.canClose.get()) return;
          this._setVisible(false, void 0);
          const e = this.currentElement.get();
          e && (e.type === hs.Deleted ? this._models.originalReveal(z.fromPositions(new X(e.originalLineNumber, 1))) : this._models.modifiedReveal(e.type !== hs.Header ? z.fromPositions(new X(e.modifiedLineNumber, 1)) : void 0));
        }
        close() {
          this.canClose.get() && (this._setVisible(false, void 0), this._models.modifiedFocus());
        }
      };
      aE = mI([
        pI(4, Fw)
      ], aE);
      const Zm = 3;
      function Lhe(s, e, t) {
        const i = [];
        for (const n of TE(s, (o, r) => r.modified.startLineNumber - o.modified.endLineNumberExclusive < 2 * Zm)) {
          const o = [];
          o.push(new khe());
          const r = new qe(Math.max(1, n[0].original.startLineNumber - Zm), Math.min(n[n.length - 1].original.endLineNumberExclusive + Zm, e + 1)), a = new qe(Math.max(1, n[0].modified.startLineNumber - Zm), Math.min(n[n.length - 1].modified.endLineNumberExclusive + Zm, t + 1));
          q7(n, (d, f) => {
            const m = new qe(d ? d.original.endLineNumberExclusive : r.startLineNumber, f ? f.original.startLineNumber : r.endLineNumberExclusive), _ = new qe(d ? d.modified.endLineNumberExclusive : a.startLineNumber, f ? f.modified.startLineNumber : a.endLineNumberExclusive);
            m.forEach((b) => {
              o.push(new The(b, _.startLineNumber + (b - m.startLineNumber)));
            }), f && (f.original.forEach((b) => {
              o.push(new Dhe(f, b));
            }), f.modified.forEach((b) => {
              o.push(new Ehe(f, b));
            }));
          });
          const l = n[0].modified.join(n[n.length - 1].modified), u = n[0].original.join(n[n.length - 1].original);
          i.push(new xhe(new is(l, u), o));
        }
        return i;
      }
      var hs;
      (function(s) {
        s[s.Header = 0] = "Header", s[s.Unchanged = 1] = "Unchanged", s[s.Deleted = 2] = "Deleted", s[s.Added = 3] = "Added";
      })(hs || (hs = {}));
      class xhe {
        constructor(e, t) {
          this.range = e, this.lines = t;
        }
      }
      class khe {
        constructor() {
          this.type = hs.Header;
        }
      }
      class Dhe {
        constructor(e, t) {
          this.diff = e, this.originalLineNumber = t, this.type = hs.Deleted, this.modifiedLineNumber = void 0;
        }
      }
      class Ehe {
        constructor(e, t) {
          this.diff = e, this.modifiedLineNumber = t, this.type = hs.Added, this.originalLineNumber = void 0;
        }
      }
      class The {
        constructor(e, t) {
          this.originalLineNumber = e, this.modifiedLineNumber = t, this.type = hs.Unchanged;
        }
      }
      let lE = class extends he {
        constructor(e, t, i, n, o, r) {
          super(), this._element = e, this._model = t, this._width = i, this._height = n, this._models = o, this._languageService = r, this.domNode = this._element, this.domNode.className = "monaco-component diff-review monaco-editor-background";
          const a = document.createElement("div");
          a.className = "diff-review-actions", this._actionBar = this._register(new Wl(a)), this._register(Dt((l) => {
            this._actionBar.clear(), this._model.canClose.read(l) && this._actionBar.push(new Bl("diffreview.close", C("label.close", "Close"), "close-diff-review " + wt.asClassName(She), true, async () => t.close()), {
              label: false,
              icon: true
            });
          })), this._content = document.createElement("div"), this._content.className = "diff-review-content", this._content.setAttribute("role", "code"), this._scrollbar = this._register(new PT(this._content, {})), gs(this.domNode, this._scrollbar.getDomNode(), a), this._register(Dt((l) => {
            this._height.read(l), this._width.read(l), this._scrollbar.scanDomNode();
          })), this._register(Ze(() => {
            gs(this.domNode);
          })), this._register(hu(this.domNode, {
            width: this._width,
            height: this._height
          })), this._register(hu(this._content, {
            width: this._width,
            height: this._height
          })), this._register(Ur((l, u) => {
            this._model.currentGroup.read(l), this._render(u);
          })), this._register(ln(this.domNode, "keydown", (l) => {
            (l.equals(18) || l.equals(2066) || l.equals(530)) && (l.preventDefault(), this._model.goToNextLine()), (l.equals(16) || l.equals(2064) || l.equals(528)) && (l.preventDefault(), this._model.goToPreviousLine()), (l.equals(9) || l.equals(2057) || l.equals(521) || l.equals(1033)) && (l.preventDefault(), this._model.close()), (l.equals(10) || l.equals(3)) && (l.preventDefault(), this._model.revealCurrentElementInEditor());
          }));
        }
        _render(e) {
          const t = this._models.getOriginalOptions(), i = this._models.getModifiedOptions(), n = document.createElement("div");
          n.className = "diff-review-table", n.setAttribute("role", "list"), n.setAttribute("aria-label", C("ariaLabel", "Accessible Diff Viewer. Use arrow up and down to navigate.")), Un(n, i.get(50)), gs(this._content, n);
          const o = this._models.getOriginalModel(), r = this._models.getModifiedModel();
          if (!o || !r) return;
          const a = o.getOptions(), l = r.getOptions(), u = i.get(67), d = this._model.currentGroup.get();
          for (const f of (d == null ? void 0 : d.lines) || []) {
            if (!d) break;
            let m;
            if (f.type === hs.Header) {
              const b = document.createElement("div");
              b.className = "diff-review-row", b.setAttribute("role", "listitem");
              const v = d.range, y = this._model.currentGroupIndex.get(), x = this._model.groups.get().length, L = (M) => M === 0 ? C("no_lines_changed", "no lines changed") : M === 1 ? C("one_line_changed", "1 line changed") : C("more_lines_changed", "{0} lines changed", M), D = L(v.original.length), k = L(v.modified.length);
              b.setAttribute("aria-label", C({
                key: "header",
                comment: [
                  "This is the ARIA label for a git diff header.",
                  "A git diff header looks like this: @@ -154,12 +159,39 @@.",
                  "That encodes that at original line 154 (which is now line 159), 12 lines were removed/changed with 39 lines.",
                  "Variables 0 and 1 refer to the diff index out of total number of diffs.",
                  "Variables 2 and 4 will be numbers (a line number).",
                  'Variables 3 and 5 will be "no lines changed", "1 line changed" or "X lines changed", localized separately.'
                ]
              }, "Difference {0} of {1}: original line {2}, {3}, modified line {4}, {5}", y + 1, x, v.original.startLineNumber, D, v.modified.startLineNumber, k));
              const T = document.createElement("div");
              T.className = "diff-review-cell diff-review-summary", T.appendChild(document.createTextNode(`${y + 1}/${x}: @@ -${v.original.startLineNumber},${v.original.length} +${v.modified.startLineNumber},${v.modified.length} @@`)), b.appendChild(T), m = b;
            } else m = this._createRow(f, u, this._width.get(), t, o, a, i, r, l);
            n.appendChild(m);
            const _ = Ye((b) => this._model.currentElement.read(b) === f);
            e.add(Dt((b) => {
              const v = _.read(b);
              m.tabIndex = v ? 0 : -1, v && m.focus();
            })), e.add(re(m, "focus", () => {
              this._model.goToLine(f);
            }));
          }
          this._scrollbar.scanDomNode();
        }
        _createRow(e, t, i, n, o, r, a, l, u) {
          const d = n.get(146), f = d.glyphMarginWidth + d.lineNumbersWidth, m = a.get(146), _ = 10 + m.glyphMarginWidth + m.lineNumbersWidth;
          let b = "diff-review-row", v = "";
          const y = "diff-review-spacer";
          let x = null;
          switch (e.type) {
            case hs.Added:
              b = "diff-review-row line-insert", v = " char-insert", x = whe;
              break;
            case hs.Deleted:
              b = "diff-review-row line-delete", v = " char-delete", x = yhe;
              break;
          }
          const L = document.createElement("div");
          L.style.minWidth = i + "px", L.className = b, L.setAttribute("role", "listitem"), L.ariaLevel = "";
          const D = document.createElement("div");
          D.className = "diff-review-cell", D.style.height = `${t}px`, L.appendChild(D);
          const k = document.createElement("span");
          k.style.width = f + "px", k.style.minWidth = f + "px", k.className = "diff-review-line-number" + v, e.originalLineNumber !== void 0 ? k.appendChild(document.createTextNode(String(e.originalLineNumber))) : k.innerText = "\xA0", D.appendChild(k);
          const T = document.createElement("span");
          T.style.width = _ + "px", T.style.minWidth = _ + "px", T.style.paddingRight = "10px", T.className = "diff-review-line-number" + v, e.modifiedLineNumber !== void 0 ? T.appendChild(document.createTextNode(String(e.modifiedLineNumber))) : T.innerText = "\xA0", D.appendChild(T);
          const M = document.createElement("span");
          if (M.className = y, x) {
            const A = document.createElement("span");
            A.className = wt.asClassName(x), A.innerText = "\xA0\xA0", M.appendChild(A);
          } else M.innerText = "\xA0\xA0";
          D.appendChild(M);
          let I;
          if (e.modifiedLineNumber !== void 0) {
            let A = this._getLineHtml(l, a, u.tabSize, e.modifiedLineNumber, this._languageService.languageIdCodec);
            bh._ttPolicy && (A = bh._ttPolicy.createHTML(A)), D.insertAdjacentHTML("beforeend", A), I = l.getLineContent(e.modifiedLineNumber);
          } else {
            let A = this._getLineHtml(o, n, r.tabSize, e.originalLineNumber, this._languageService.languageIdCodec);
            bh._ttPolicy && (A = bh._ttPolicy.createHTML(A)), D.insertAdjacentHTML("beforeend", A), I = o.getLineContent(e.originalLineNumber);
          }
          I.length === 0 && (I = C("blankLine", "blank"));
          let R = "";
          switch (e.type) {
            case hs.Unchanged:
              e.originalLineNumber === e.modifiedLineNumber ? R = C({
                key: "unchangedLine",
                comment: [
                  "The placeholders are contents of the line and should not be translated."
                ]
              }, "{0} unchanged line {1}", I, e.originalLineNumber) : R = C("equalLine", "{0} original line {1} modified line {2}", I, e.originalLineNumber, e.modifiedLineNumber);
              break;
            case hs.Added:
              R = C("insertLine", "+ {0} modified line {1}", I, e.modifiedLineNumber);
              break;
            case hs.Deleted:
              R = C("deleteLine", "- {0} original line {1}", I, e.originalLineNumber);
              break;
          }
          return L.setAttribute("aria-label", R), L;
        }
        _getLineHtml(e, t, i, n, o) {
          const r = e.getLineContent(n), a = t.get(50), l = Fi.createEmpty(r, o), u = mo.isBasicASCII(r, e.mightContainNonBasicASCII()), d = mo.containsRTL(r, u, e.mightContainRTL());
          return Vw(new Ag(a.isMonospace && !t.get(33), a.canUseHalfwidthRightwardsArrow, r, false, u, d, 0, l, [], i, 0, a.spaceWidth, a.middotWidth, a.wsmiddotWidth, t.get(118), t.get(100), t.get(95), t.get(51) !== Fr.OFF, null)).html;
        }
      };
      lE = mI([
        pI(5, un)
      ], lE);
      class Nhe {
        constructor(e) {
          this.editors = e;
        }
        getOriginalModel() {
          return this.editors.original.getModel();
        }
        getOriginalOptions() {
          return this.editors.original.getOptions();
        }
        originalReveal(e) {
          this.editors.original.revealRange(e), this.editors.original.setSelection(e), this.editors.original.focus();
        }
        getModifiedModel() {
          return this.editors.modified.getModel();
        }
        getModifiedOptions() {
          return this.editors.modified.getOptions();
        }
        modifiedReveal(e) {
          e && (this.editors.modified.revealRange(e), this.editors.modified.setSelection(e)), this.editors.modified.focus();
        }
        modifiedSetSelection(e) {
          this.editors.modified.setSelection(e);
        }
        modifiedFocus() {
          this.editors.modified.focus();
        }
        getModifiedPosition() {
          return this.editors.modified.getPosition() ?? void 0;
        }
      }
      B("diffEditor.move.border", "#8b8b8b9c", C("diffEditor.move.border", "The border color for text that got moved in the diff editor."));
      B("diffEditor.moveActive.border", "#FFA500", C("diffEditor.moveActive.border", "The active border color for text that got moved in the diff editor."));
      B("diffEditor.unchangedRegionShadow", {
        dark: "#000000",
        light: "#737373BF",
        hcDark: "#000000",
        hcLight: "#737373BF"
      }, C("diffEditor.unchangedRegionShadow", "The color of the shadow around unchanged region widgets."));
      const Ihe = mu("diff-insert", Te.add, C("diffInsertIcon", "Line decoration for inserts in the diff editor.")), $F = mu("diff-remove", Te.remove, C("diffRemoveIcon", "Line decoration for removals in the diff editor.")), d7 = Zi.register({
        className: "line-insert",
        description: "line-insert",
        isWholeLine: true,
        linesDecorationsClassName: "insert-sign " + wt.asClassName(Ihe),
        marginClassName: "gutter-insert"
      }), f7 = Zi.register({
        className: "line-delete",
        description: "line-delete",
        isWholeLine: true,
        linesDecorationsClassName: "delete-sign " + wt.asClassName($F),
        marginClassName: "gutter-delete"
      }), g7 = Zi.register({
        className: "line-insert",
        description: "line-insert",
        isWholeLine: true,
        marginClassName: "gutter-insert"
      }), m7 = Zi.register({
        className: "line-delete",
        description: "line-delete",
        isWholeLine: true,
        marginClassName: "gutter-delete"
      }), p7 = Zi.register({
        className: "char-insert",
        description: "char-insert",
        shouldFillLineOnLineBreak: true
      }), Mhe = Zi.register({
        className: "char-insert",
        description: "char-insert",
        isWholeLine: true
      }), Ahe = Zi.register({
        className: "char-insert diff-range-empty",
        description: "char-insert diff-range-empty"
      }), cE = Zi.register({
        className: "char-delete",
        description: "char-delete",
        shouldFillLineOnLineBreak: true
      }), Rhe = Zi.register({
        className: "char-delete",
        description: "char-delete",
        isWholeLine: true
      }), Ohe = Zi.register({
        className: "char-delete diff-range-empty",
        description: "char-delete diff-range-empty"
      });
      var qF = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      }, uE = function(s, e) {
        return function(t, i) {
          e(t, i, s);
        };
      }, Zu;
      const KF = pt("diffProviderFactoryService");
      let hE = class {
        constructor(e) {
          this.instantiationService = e;
        }
        createDiffProvider(e) {
          return this.instantiationService.createInstance(dE, e);
        }
      };
      hE = qF([
        uE(0, Ft)
      ], hE);
      Lt(KF, hE, 1);
      let dE = (_r2 = class {
        constructor(e, t, i) {
          this.editorWorkerService = t, this.telemetryService = i, this.onDidChangeEventEmitter = new G(), this.onDidChange = this.onDidChangeEventEmitter.event, this.diffAlgorithm = "advanced", this.diffAlgorithmOnDidChangeSubscription = void 0, this.setOptions(e);
        }
        dispose() {
          var _a3;
          (_a3 = this.diffAlgorithmOnDidChangeSubscription) == null ? void 0 : _a3.dispose();
        }
        async computeDiff(e, t, i, n) {
          if (typeof this.diffAlgorithm != "string") return this.diffAlgorithm.computeDiff(e, t, i, n);
          if (e.isDisposed() || t.isDisposed()) return {
            changes: [],
            identical: true,
            quitEarly: false,
            moves: []
          };
          if (e.getLineCount() === 1 && e.getLineMaxColumn(1) === 1) return t.getLineCount() === 1 && t.getLineMaxColumn(1) === 1 ? {
            changes: [],
            identical: true,
            quitEarly: false,
            moves: []
          } : {
            changes: [
              new go(new qe(1, 2), new qe(1, t.getLineCount() + 1), [
                new ro(e.getFullModelRange(), t.getFullModelRange())
              ])
            ],
            identical: false,
            quitEarly: false,
            moves: []
          };
          const o = JSON.stringify([
            e.uri.toString(),
            t.uri.toString()
          ]), r = JSON.stringify([
            e.id,
            t.id,
            e.getAlternativeVersionId(),
            t.getAlternativeVersionId(),
            JSON.stringify(i)
          ]), a = Zu.diffCache.get(o);
          if (a && a.context === r) return a.result;
          const l = $h.create(), u = await this.editorWorkerService.computeDiff(e.uri, t.uri, i, this.diffAlgorithm), d = l.elapsed();
          if (this.telemetryService.publicLog2("diffEditor.computeDiff", {
            timeMs: d,
            timedOut: (u == null ? void 0 : u.quitEarly) ?? true,
            detectedMoves: i.computeMoves ? (u == null ? void 0 : u.moves.length) ?? 0 : -1
          }), n.isCancellationRequested) return {
            changes: [],
            identical: false,
            quitEarly: true,
            moves: []
          };
          if (!u) throw new Error("no diff result available");
          return Zu.diffCache.size > 10 && Zu.diffCache.delete(Zu.diffCache.keys().next().value), Zu.diffCache.set(o, {
            result: u,
            context: r
          }), u;
        }
        setOptions(e) {
          var _a3;
          let t = false;
          e.diffAlgorithm && this.diffAlgorithm !== e.diffAlgorithm && ((_a3 = this.diffAlgorithmOnDidChangeSubscription) == null ? void 0 : _a3.dispose(), this.diffAlgorithmOnDidChangeSubscription = void 0, this.diffAlgorithm = e.diffAlgorithm, typeof e.diffAlgorithm != "string" && (this.diffAlgorithmOnDidChangeSubscription = e.diffAlgorithm.onDidChange(() => this.onDidChangeEventEmitter.fire())), t = true), t && this.onDidChangeEventEmitter.fire();
        }
      }, Zu = _r2, _r2.diffCache = /* @__PURE__ */ new Map(), _r2);
      dE = Zu = qF([
        uE(1, n1),
        uE(2, Qh)
      ], dE);
      function _I() {
        return Ox && !!Ox.VSCODE_DEV;
      }
      function jF(s) {
        if (_I()) {
          const e = Phe();
          return e.add(s), {
            dispose() {
              e.delete(s);
            }
          };
        } else return {
          dispose() {
          }
        };
      }
      function Phe() {
        l0 || (l0 = /* @__PURE__ */ new Set());
        const s = globalThis;
        return s.$hotReload_applyNewExports || (s.$hotReload_applyNewExports = (e) => {
          const t = {
            config: {
              mode: void 0
            },
            ...e
          }, i = [];
          for (const n of l0) {
            const o = n(t);
            o && i.push(o);
          }
          if (i.length > 0) return (n) => {
            let o = false;
            for (const r of i) r(n) && (o = true);
            return o;
          };
        }), l0;
      }
      let l0;
      _I() && jF(({ oldExports: s, newSrc: e, config: t }) => {
        if (t.mode === "patch-prototype") return (i) => {
          var _a3, _b3;
          for (const n in i) {
            const o = i[n];
            if (console.log(`[hot-reload] Patching prototype methods of '${n}'`, {
              exportedItem: o
            }), typeof o == "function" && o.prototype) {
              const r = s[n];
              if (r) {
                for (const a of Object.getOwnPropertyNames(o.prototype)) {
                  const l = Object.getOwnPropertyDescriptor(o.prototype, a), u = Object.getOwnPropertyDescriptor(r.prototype, a);
                  ((_a3 = l == null ? void 0 : l.value) == null ? void 0 : _a3.toString()) !== ((_b3 = u == null ? void 0 : u.value) == null ? void 0 : _b3.toString()) && console.log(`[hot-reload] Patching prototype method '${n}.${a}'`), Object.defineProperty(r.prototype, a, l);
                }
                i[n] = r;
              }
            }
          }
          return true;
        };
      });
      function or(s, e) {
        return Bhe([
          s
        ], e), s;
      }
      function Bhe(s, e) {
        _I() && Ao("reload", (i) => jF(({ oldExports: n }) => {
          if ([
            ...Object.values(n)
          ].some((o) => s.includes(o))) return (o) => (i(void 0), true);
        })).read(e);
      }
      var Fhe = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      }, Vhe = function(s, e) {
        return function(t, i) {
          e(t, i, s);
        };
      };
      let fE = class extends he {
        setActiveMovedText(e) {
          this._activeMovedText.set(e, void 0);
        }
        constructor(e, t, i) {
          super(), this.model = e, this._options = t, this._diffProviderFactoryService = i, this._isDiffUpToDate = Ct(this, false), this.isDiffUpToDate = this._isDiffUpToDate, this._diff = Ct(this, void 0), this.diff = this._diff, this._unchangedRegions = Ct(this, void 0), this.unchangedRegions = Ye(this, (a) => {
            var _a3;
            return this._options.hideUnchangedRegions.read(a) ? ((_a3 = this._unchangedRegions.read(a)) == null ? void 0 : _a3.regions) ?? [] : (Yi((l) => {
              var _a4;
              for (const u of ((_a4 = this._unchangedRegions.get()) == null ? void 0 : _a4.regions) || []) u.collapseAll(l);
            }), []);
          }), this.movedTextToCompare = Ct(this, void 0), this._activeMovedText = Ct(this, void 0), this._hoveredMovedText = Ct(this, void 0), this.activeMovedText = Ye(this, (a) => this.movedTextToCompare.read(a) ?? this._hoveredMovedText.read(a) ?? this._activeMovedText.read(a)), this._cancellationTokenSource = new Lg(), this._diffProvider = Ye(this, (a) => {
            const l = this._diffProviderFactoryService.createDiffProvider({
              diffAlgorithm: this._options.diffAlgorithm.read(a)
            }), u = Ao("onDidChange", l.onDidChange);
            return {
              diffProvider: l,
              onChangeSignal: u
            };
          }), this._register(Ze(() => this._cancellationTokenSource.cancel()));
          const n = tN("contentChangedSignal"), o = this._register(new ns(() => n.trigger(void 0), 200));
          this._register(Dt((a) => {
            const l = this._unchangedRegions.read(a);
            if (!l || l.regions.some((b) => b.isDragged.read(a))) return;
            const u = l.originalDecorationIds.map((b) => e.original.getDecorationRange(b)).map((b) => b ? qe.fromRangeInclusive(b) : void 0), d = l.modifiedDecorationIds.map((b) => e.modified.getDecorationRange(b)).map((b) => b ? qe.fromRangeInclusive(b) : void 0), f = l.regions.map((b, v) => !u[v] || !d[v] ? void 0 : new Gc(u[v].startLineNumber, d[v].startLineNumber, u[v].length, b.visibleLineCountTop.read(a), b.visibleLineCountBottom.read(a))).filter(Jf), m = [];
            let _ = false;
            for (const b of TE(f, (v, y) => v.getHiddenModifiedRange(a).endLineNumberExclusive === y.getHiddenModifiedRange(a).startLineNumber)) if (b.length > 1) {
              _ = true;
              const v = b.reduce((x, L) => x + L.lineCount, 0), y = new Gc(b[0].originalLineNumber, b[0].modifiedLineNumber, v, b[0].visibleLineCountTop.get(), b[b.length - 1].visibleLineCountBottom.get());
              m.push(y);
            } else m.push(b[0]);
            if (_) {
              const b = e.original.deltaDecorations(l.originalDecorationIds, m.map((y) => ({
                range: y.originalUnchangedRange.toInclusiveRange(),
                options: {
                  description: "unchanged"
                }
              }))), v = e.modified.deltaDecorations(l.modifiedDecorationIds, m.map((y) => ({
                range: y.modifiedUnchangedRange.toInclusiveRange(),
                options: {
                  description: "unchanged"
                }
              })));
              Yi((y) => {
                this._unchangedRegions.set({
                  regions: m,
                  originalDecorationIds: b,
                  modifiedDecorationIds: v
                }, y);
              });
            }
          }));
          const r = (a, l, u) => {
            const d = Gc.fromDiffs(a.changes, e.original.getLineCount(), e.modified.getLineCount(), this._options.hideUnchangedRegionsMinimumLineCount.read(u), this._options.hideUnchangedRegionsContextLineCount.read(u));
            let f;
            const m = this._unchangedRegions.get();
            if (m) {
              const y = m.originalDecorationIds.map((k) => e.original.getDecorationRange(k)).map((k) => k ? qe.fromRangeInclusive(k) : void 0), x = m.modifiedDecorationIds.map((k) => e.modified.getDecorationRange(k)).map((k) => k ? qe.fromRangeInclusive(k) : void 0);
              let D = vhe(m.regions.map((k, T) => {
                if (!y[T] || !x[T]) return;
                const M = y[T].length;
                return new Gc(y[T].startLineNumber, x[T].startLineNumber, M, Math.min(k.visibleLineCountTop.get(), M), Math.min(k.visibleLineCountBottom.get(), M - k.visibleLineCountTop.get()));
              }).filter(Jf), (k, T) => !T || k.modifiedLineNumber >= T.modifiedLineNumber + T.lineCount && k.originalLineNumber >= T.originalLineNumber + T.lineCount).map((k) => new is(k.getHiddenOriginalRange(u), k.getHiddenModifiedRange(u)));
              D = is.clip(D, qe.ofLength(1, e.original.getLineCount()), qe.ofLength(1, e.modified.getLineCount())), f = is.inverse(D, e.original.getLineCount(), e.modified.getLineCount());
            }
            const _ = [];
            if (f) for (const y of d) {
              const x = f.filter((L) => L.original.intersectsStrict(y.originalUnchangedRange) && L.modified.intersectsStrict(y.modifiedUnchangedRange));
              _.push(...y.setVisibleRanges(x, l));
            }
            else _.push(...d);
            const b = e.original.deltaDecorations((m == null ? void 0 : m.originalDecorationIds) || [], _.map((y) => ({
              range: y.originalUnchangedRange.toInclusiveRange(),
              options: {
                description: "unchanged"
              }
            }))), v = e.modified.deltaDecorations((m == null ? void 0 : m.modifiedDecorationIds) || [], _.map((y) => ({
              range: y.modifiedUnchangedRange.toInclusiveRange(),
              options: {
                description: "unchanged"
              }
            })));
            this._unchangedRegions.set({
              regions: _,
              originalDecorationIds: b,
              modifiedDecorationIds: v
            }, l);
          };
          this._register(e.modified.onDidChangeContent((a) => {
            if (this._diff.get()) {
              const u = Il.fromModelContentChanges(a.changes);
              this._lastDiff, e.original, e.modified;
            }
            this._isDiffUpToDate.set(false, void 0), o.schedule();
          })), this._register(e.original.onDidChangeContent((a) => {
            if (this._diff.get()) {
              const u = Il.fromModelContentChanges(a.changes);
              this._lastDiff, e.original, e.modified;
            }
            this._isDiffUpToDate.set(false, void 0), o.schedule();
          })), this._register(Ur(async (a, l) => {
            this._options.hideUnchangedRegionsMinimumLineCount.read(a), this._options.hideUnchangedRegionsContextLineCount.read(a), o.cancel(), n.read(a);
            const u = this._diffProvider.read(a);
            u.onChangeSignal.read(a), or(N8, a), or(oD, a), this._isDiffUpToDate.set(false, void 0);
            let d = [];
            l.add(e.original.onDidChangeContent((_) => {
              const b = Il.fromModelContentChanges(_.changes);
              d = qv(d, b);
            }));
            let f = [];
            l.add(e.modified.onDidChangeContent((_) => {
              const b = Il.fromModelContentChanges(_.changes);
              f = qv(f, b);
            }));
            let m = await u.diffProvider.computeDiff(e.original, e.modified, {
              ignoreTrimWhitespace: this._options.ignoreTrimWhitespace.read(a),
              maxComputationTimeMs: this._options.maxComputationTimeMs.read(a),
              computeMoves: this._options.showMoves.read(a)
            }, this._cancellationTokenSource.token);
            this._cancellationTokenSource.token.isCancellationRequested || e.original.isDisposed() || e.modified.isDisposed() || (m = Whe(m, e.original, e.modified), m = (e.original, e.modified, void 0) ?? m, m = (e.original, e.modified, void 0) ?? m, Yi((_) => {
              r(m, _), this._lastDiff = m;
              const b = bI.fromDiffResult(m);
              this._diff.set(b, _), this._isDiffUpToDate.set(true, _);
              const v = this.movedTextToCompare.get();
              this.movedTextToCompare.set(v ? this._lastDiff.moves.find((y) => y.lineRangeMapping.modified.intersect(v.lineRangeMapping.modified)) : void 0, _);
            }));
          }));
        }
        ensureModifiedLineIsVisible(e, t, i) {
          var _a3, _b3;
          if (((_a3 = this.diff.get()) == null ? void 0 : _a3.mappings.length) === 0) return;
          const n = ((_b3 = this._unchangedRegions.get()) == null ? void 0 : _b3.regions) || [];
          for (const o of n) if (o.getHiddenModifiedRange(void 0).contains(e)) {
            o.showModifiedLine(e, t, i);
            return;
          }
        }
        ensureOriginalLineIsVisible(e, t, i) {
          var _a3, _b3;
          if (((_a3 = this.diff.get()) == null ? void 0 : _a3.mappings.length) === 0) return;
          const n = ((_b3 = this._unchangedRegions.get()) == null ? void 0 : _b3.regions) || [];
          for (const o of n) if (o.getHiddenOriginalRange(void 0).contains(e)) {
            o.showOriginalLine(e, t, i);
            return;
          }
        }
        async waitForDiff() {
          await ite(this.isDiffUpToDate, (e) => e);
        }
        serializeState() {
          var _a3;
          return {
            collapsedRegions: (_a3 = this._unchangedRegions.get()) == null ? void 0 : _a3.regions.map((t) => ({
              range: t.getHiddenModifiedRange(void 0).serialize()
            }))
          };
        }
        restoreSerializedState(e) {
          var _a3;
          const t = (_a3 = e.collapsedRegions) == null ? void 0 : _a3.map((n) => qe.deserialize(n.range)), i = this._unchangedRegions.get();
          !i || !t || Yi((n) => {
            for (const o of i.regions) for (const r of t) if (o.modifiedUnchangedRange.intersect(r)) {
              o.setHiddenModifiedRange(r, n);
              break;
            }
          });
        }
      };
      fE = Fhe([
        Vhe(2, KF)
      ], fE);
      function Whe(s, e, t) {
        return {
          changes: s.changes.map((i) => new go(i.original, i.modified, i.innerChanges ? i.innerChanges.map((n) => Hhe(n, e, t)) : void 0)),
          moves: s.moves,
          identical: s.identical,
          quitEarly: s.quitEarly
        };
      }
      function Hhe(s, e, t) {
        let i = s.originalRange, n = s.modifiedRange;
        return i.startColumn === 1 && n.startColumn === 1 && (i.endColumn !== 1 || n.endColumn !== 1) && i.endColumn === e.getLineMaxColumn(i.endLineNumber) && n.endColumn === t.getLineMaxColumn(n.endLineNumber) && i.endLineNumber < e.getLineCount() && n.endLineNumber < t.getLineCount() && (i = i.setEndPosition(i.endLineNumber + 1, 1), n = n.setEndPosition(n.endLineNumber + 1, 1)), new ro(i, n);
      }
      class bI {
        static fromDiffResult(e) {
          return new bI(e.changes.map((t) => new GF(t)), e.moves || [], e.identical, e.quitEarly);
        }
        constructor(e, t, i, n) {
          this.mappings = e, this.movedTexts = t, this.identical = i, this.quitEarly = n;
        }
      }
      class GF {
        constructor(e) {
          this.lineRangeMapping = e;
        }
      }
      class Gc {
        static fromDiffs(e, t, i, n, o) {
          const r = go.inverse(e, t, i), a = [];
          for (const l of r) {
            let u = l.original.startLineNumber, d = l.modified.startLineNumber, f = l.original.length;
            const m = u === 1 && d === 1, _ = u + f === t + 1 && d + f === i + 1;
            (m || _) && f >= o + n ? (m && !_ && (f -= o), _ && !m && (u += o, d += o, f -= o), a.push(new Gc(u, d, f, 0, 0))) : f >= o * 2 + n && (u += o, d += o, f -= o * 2, a.push(new Gc(u, d, f, 0, 0)));
          }
          return a;
        }
        get originalUnchangedRange() {
          return qe.ofLength(this.originalLineNumber, this.lineCount);
        }
        get modifiedUnchangedRange() {
          return qe.ofLength(this.modifiedLineNumber, this.lineCount);
        }
        constructor(e, t, i, n, o) {
          this.originalLineNumber = e, this.modifiedLineNumber = t, this.lineCount = i, this._visibleLineCountTop = Ct(this, 0), this.visibleLineCountTop = this._visibleLineCountTop, this._visibleLineCountBottom = Ct(this, 0), this.visibleLineCountBottom = this._visibleLineCountBottom, this._shouldHideControls = Ye(this, (l) => this.visibleLineCountTop.read(l) + this.visibleLineCountBottom.read(l) === this.lineCount && !this.isDragged.read(l)), this.isDragged = Ct(this, void 0);
          const r = Math.max(Math.min(n, this.lineCount), 0), a = Math.max(Math.min(o, this.lineCount - n), 0);
          gO(n === r), gO(o === a), this._visibleLineCountTop.set(r, void 0), this._visibleLineCountBottom.set(a, void 0);
        }
        setVisibleRanges(e, t) {
          const i = [], n = new Mo(e.map((l) => l.modified)).subtractFrom(this.modifiedUnchangedRange);
          let o = this.originalLineNumber, r = this.modifiedLineNumber;
          const a = this.modifiedLineNumber + this.lineCount;
          if (n.ranges.length === 0) this.showAll(t), i.push(this);
          else {
            let l = 0;
            for (const u of n.ranges) {
              const d = l === n.ranges.length - 1;
              l++;
              const f = (d ? a : u.endLineNumberExclusive) - r, m = new Gc(o, r, f, 0, 0);
              m.setHiddenModifiedRange(u, t), i.push(m), o = m.originalUnchangedRange.endLineNumberExclusive, r = m.modifiedUnchangedRange.endLineNumberExclusive;
            }
          }
          return i;
        }
        shouldHideControls(e) {
          return this._shouldHideControls.read(e);
        }
        getHiddenOriginalRange(e) {
          return qe.ofLength(this.originalLineNumber + this._visibleLineCountTop.read(e), this.lineCount - this._visibleLineCountTop.read(e) - this._visibleLineCountBottom.read(e));
        }
        getHiddenModifiedRange(e) {
          return qe.ofLength(this.modifiedLineNumber + this._visibleLineCountTop.read(e), this.lineCount - this._visibleLineCountTop.read(e) - this._visibleLineCountBottom.read(e));
        }
        setHiddenModifiedRange(e, t) {
          const i = e.startLineNumber - this.modifiedLineNumber, n = this.modifiedLineNumber + this.lineCount - e.endLineNumberExclusive;
          this.setState(i, n, t);
        }
        getMaxVisibleLineCountTop() {
          return this.lineCount - this._visibleLineCountBottom.get();
        }
        getMaxVisibleLineCountBottom() {
          return this.lineCount - this._visibleLineCountTop.get();
        }
        showMoreAbove(e = 10, t) {
          const i = this.getMaxVisibleLineCountTop();
          this._visibleLineCountTop.set(Math.min(this._visibleLineCountTop.get() + e, i), t);
        }
        showMoreBelow(e = 10, t) {
          const i = this.lineCount - this._visibleLineCountTop.get();
          this._visibleLineCountBottom.set(Math.min(this._visibleLineCountBottom.get() + e, i), t);
        }
        showAll(e) {
          this._visibleLineCountBottom.set(this.lineCount - this._visibleLineCountTop.get(), e);
        }
        showModifiedLine(e, t, i) {
          const n = e + 1 - (this.modifiedLineNumber + this._visibleLineCountTop.get()), o = this.modifiedLineNumber - this._visibleLineCountBottom.get() + this.lineCount - e;
          t === 0 && n < o || t === 1 ? this._visibleLineCountTop.set(this._visibleLineCountTop.get() + n, i) : this._visibleLineCountBottom.set(this._visibleLineCountBottom.get() + o, i);
        }
        showOriginalLine(e, t, i) {
          const n = e - this.originalLineNumber, o = this.originalLineNumber + this.lineCount - e;
          t === 0 && n < o || t === 1 ? this._visibleLineCountTop.set(Math.min(this._visibleLineCountTop.get() + o - n, this.getMaxVisibleLineCountTop()), i) : this._visibleLineCountBottom.set(Math.min(this._visibleLineCountBottom.get() + n - o, this.getMaxVisibleLineCountBottom()), i);
        }
        collapseAll(e) {
          this._visibleLineCountTop.set(0, e), this._visibleLineCountBottom.set(0, e);
        }
        setState(e, t, i) {
          e = Math.max(Math.min(e, this.lineCount), 0), t = Math.max(Math.min(t, this.lineCount - e), 0), this._visibleLineCountTop.set(e, i), this._visibleLineCountBottom.set(t, i);
        }
      }
      class zhe extends he {
        get visibility() {
          return this._visibility;
        }
        set visibility(e) {
          this._visibility !== e && (this._visibility = e, this._diffActions.style.visibility = e ? "visible" : "hidden");
        }
        constructor(e, t, i, n, o, r, a, l, u) {
          super(), this._getViewZoneId = e, this._marginDomNode = t, this._modifiedEditor = i, this._diff = n, this._editor = o, this._viewLineCounts = r, this._originalTextModel = a, this._contextMenuService = l, this._clipboardService = u, this._visibility = false, this._marginDomNode.style.zIndex = "10", this._diffActions = document.createElement("div"), this._diffActions.className = wt.asClassName(Te.lightBulb) + " lightbulb-glyph", this._diffActions.style.position = "absolute";
          const d = this._modifiedEditor.getOption(67);
          this._diffActions.style.right = "0px", this._diffActions.style.visibility = "hidden", this._diffActions.style.height = `${d}px`, this._diffActions.style.lineHeight = `${d}px`, this._marginDomNode.appendChild(this._diffActions);
          let f = 0;
          const m = i.getOption(128) && !Ih, _ = (b, v) => {
            this._contextMenuService.showContextMenu({
              domForShadowRoot: m ? i.getDomNode() ?? void 0 : void 0,
              getAnchor: () => ({
                x: b,
                y: v
              }),
              getActions: () => {
                const y = [], x = n.modified.isEmpty;
                return y.push(new Bl("diff.clipboard.copyDeletedContent", x ? n.original.length > 1 ? C("diff.clipboard.copyDeletedLinesContent.label", "Copy deleted lines") : C("diff.clipboard.copyDeletedLinesContent.single.label", "Copy deleted line") : n.original.length > 1 ? C("diff.clipboard.copyChangedLinesContent.label", "Copy changed lines") : C("diff.clipboard.copyChangedLinesContent.single.label", "Copy changed line"), void 0, true, async () => {
                  const D = this._originalTextModel.getValueInRange(n.original.toExclusiveRange());
                  await this._clipboardService.writeText(D);
                })), n.original.length > 1 && y.push(new Bl("diff.clipboard.copyDeletedLineContent", x ? C("diff.clipboard.copyDeletedLineContent.label", "Copy deleted line ({0})", n.original.startLineNumber + f) : C("diff.clipboard.copyChangedLineContent.label", "Copy changed line ({0})", n.original.startLineNumber + f), void 0, true, async () => {
                  let D = this._originalTextModel.getLineContent(n.original.startLineNumber + f);
                  D === "" && (D = this._originalTextModel.getEndOfLineSequence() === 0 ? `
` : `\r
`), await this._clipboardService.writeText(D);
                })), i.getOption(92) || y.push(new Bl("diff.inline.revertChange", C("diff.inline.revertChange.label", "Revert this change"), void 0, true, async () => {
                  this._editor.revert(this._diff);
                })), y;
              },
              autoSelectFirstItem: true
            });
          };
          this._register(ln(this._diffActions, "mousedown", (b) => {
            if (!b.leftButton) return;
            const { top: v, height: y } = Bo(this._diffActions), x = Math.floor(d / 3);
            b.preventDefault(), _(b.posx, v + y + x);
          })), this._register(i.onMouseMove((b) => {
            (b.target.type === 8 || b.target.type === 5) && b.target.detail.viewZoneId === this._getViewZoneId() ? (f = this._updateLightBulbPosition(this._marginDomNode, b.event.browserEvent.y, d), this.visibility = true) : this.visibility = false;
          })), this._register(i.onMouseDown((b) => {
            b.event.leftButton && (b.target.type === 8 || b.target.type === 5) && b.target.detail.viewZoneId === this._getViewZoneId() && (b.event.preventDefault(), f = this._updateLightBulbPosition(this._marginDomNode, b.event.browserEvent.y, d), _(b.event.posx, b.event.posy + d));
          }));
        }
        _updateLightBulbPosition(e, t, i) {
          const { top: n } = Bo(e), o = t - n, r = Math.floor(o / i), a = r * i;
          if (this._diffActions.style.top = `${a}px`, this._viewLineCounts) {
            let l = 0;
            for (let u = 0; u < this._viewLineCounts.length; u++) if (l += this._viewLineCounts[u], r < l) return u;
          }
          return r;
        }
      }
      const _7 = Xh("diffEditorWidget", {
        createHTML: (s) => s
      });
      function Uhe(s, e, t, i) {
        Un(i, e.fontInfo);
        const n = t.length > 0, o = new iw(1e4);
        let r = 0, a = 0;
        const l = [];
        for (let m = 0; m < s.lineTokens.length; m++) {
          const _ = m + 1, b = s.lineTokens[m], v = s.lineBreakData[m], y = dr.filter(t, _, 1, Number.MAX_SAFE_INTEGER);
          if (v) {
            let x = 0;
            for (const L of v.breakOffsets) {
              const D = b.sliceAndInflate(x, L, 0);
              r = Math.max(r, b7(a, D, dr.extractWrapped(y, x, L), n, s.mightContainNonBasicASCII, s.mightContainRTL, e, o)), a++, x = L;
            }
            l.push(v.breakOffsets.length);
          } else l.push(1), r = Math.max(r, b7(a, b, y, n, s.mightContainNonBasicASCII, s.mightContainRTL, e, o)), a++;
        }
        r += e.scrollBeyondLastColumn;
        const u = o.build(), d = _7 ? _7.createHTML(u) : u;
        i.innerHTML = d;
        const f = r * e.typicalHalfwidthCharacterWidth;
        return {
          heightInLines: a,
          minWidthInPx: f,
          viewLineCounts: l
        };
      }
      class $he {
        constructor(e, t, i, n) {
          this.lineTokens = e, this.lineBreakData = t, this.mightContainNonBasicASCII = i, this.mightContainRTL = n;
        }
      }
      class vI {
        static fromEditor(e) {
          var _a3;
          const t = e.getOptions(), i = t.get(50), n = t.get(146);
          return new vI(((_a3 = e.getModel()) == null ? void 0 : _a3.getOptions().tabSize) || 0, i, t.get(33), i.typicalHalfwidthCharacterWidth, t.get(105), t.get(67), n.decorationsWidth, t.get(118), t.get(100), t.get(95), t.get(51));
        }
        constructor(e, t, i, n, o, r, a, l, u, d, f) {
          this.tabSize = e, this.fontInfo = t, this.disableMonospaceOptimizations = i, this.typicalHalfwidthCharacterWidth = n, this.scrollBeyondLastColumn = o, this.lineHeight = r, this.lineDecorationsWidth = a, this.stopRenderingLineAfter = l, this.renderWhitespace = u, this.renderControlCharacters = d, this.fontLigatures = f;
        }
      }
      function b7(s, e, t, i, n, o, r, a) {
        a.appendString('<div class="view-line'), i || a.appendString(" char-delete"), a.appendString('" style="top:'), a.appendString(String(s * r.lineHeight)), a.appendString('px;width:1000000px;">');
        const l = e.getLineContent(), u = mo.isBasicASCII(l, n), d = mo.containsRTL(l, u, o), f = qN(new Ag(r.fontInfo.isMonospace && !r.disableMonospaceOptimizations, r.fontInfo.canUseHalfwidthRightwardsArrow, l, false, u, d, 0, e, t, r.tabSize, 0, r.fontInfo.spaceWidth, r.fontInfo.middotWidth, r.fontInfo.wsmiddotWidth, r.stopRenderingLineAfter, r.renderWhitespace, r.renderControlCharacters, r.fontLigatures !== Fr.OFF, null), a);
        return a.appendString("</div>"), f.characterMapping.getHorizontalOffset(f.characterMapping.length);
      }
      var qhe = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      }, v7 = function(s, e) {
        return function(t, i) {
          e(t, i, s);
        };
      };
      let gE = class extends he {
        constructor(e, t, i, n, o, r, a, l, u, d) {
          super(), this._targetWindow = e, this._editors = t, this._diffModel = i, this._options = n, this._diffEditorWidget = o, this._canIgnoreViewZoneUpdateEvent = r, this._origViewZonesToIgnore = a, this._modViewZonesToIgnore = l, this._clipboardService = u, this._contextMenuService = d, this._originalTopPadding = Ct(this, 0), this._originalScrollOffset = Ct(this, 0), this._originalScrollOffsetAnimated = c7(this._targetWindow, this._originalScrollOffset, this._store), this._modifiedTopPadding = Ct(this, 0), this._modifiedScrollOffset = Ct(this, 0), this._modifiedScrollOffsetAnimated = c7(this._targetWindow, this._modifiedScrollOffset, this._store);
          const f = Ct("invalidateAlignmentsState", 0), m = this._register(new ns(() => {
            f.set(f.get() + 1, void 0);
          }, 0));
          this._register(this._editors.original.onDidChangeViewZones((D) => {
            this._canIgnoreViewZoneUpdateEvent() || m.schedule();
          })), this._register(this._editors.modified.onDidChangeViewZones((D) => {
            this._canIgnoreViewZoneUpdateEvent() || m.schedule();
          })), this._register(this._editors.original.onDidChangeConfiguration((D) => {
            (D.hasChanged(147) || D.hasChanged(67)) && m.schedule();
          })), this._register(this._editors.modified.onDidChangeConfiguration((D) => {
            (D.hasChanged(147) || D.hasChanged(67)) && m.schedule();
          }));
          const _ = this._diffModel.map((D) => D ? yi(this, D.model.original.onDidChangeTokens, () => D.model.original.tokenization.backgroundTokenizationState === 2) : void 0).map((D, k) => D == null ? void 0 : D.read(k)), b = Ye((D) => {
            const k = this._diffModel.read(D), T = k == null ? void 0 : k.diff.read(D);
            if (!k || !T) return null;
            f.read(D);
            const I = this._options.renderSideBySide.read(D);
            return C7(this._editors.original, this._editors.modified, T.mappings, this._origViewZonesToIgnore, this._modViewZonesToIgnore, I);
          }), v = Ye((D) => {
            var _a3;
            const k = (_a3 = this._diffModel.read(D)) == null ? void 0 : _a3.movedTextToCompare.read(D);
            if (!k) return null;
            f.read(D);
            const T = k.changes.map((M) => new GF(M));
            return C7(this._editors.original, this._editors.modified, T, this._origViewZonesToIgnore, this._modViewZonesToIgnore, true);
          });
          function y() {
            const D = document.createElement("div");
            return D.className = "diagonal-fill", D;
          }
          const x = this._register(new Me());
          this.viewZones = Tg(this, (D, k) => {
            var _a3, _b3, _c2, _d2;
            x.clear();
            const T = b.read(D) || [], M = [], I = [], R = this._modifiedTopPadding.read(D);
            R > 0 && I.push({
              afterLineNumber: 0,
              domNode: document.createElement("div"),
              heightInPx: R,
              showInHiddenAreas: true,
              suppressMouseDown: true
            });
            const A = this._originalTopPadding.read(D);
            A > 0 && M.push({
              afterLineNumber: 0,
              domNode: document.createElement("div"),
              heightInPx: A,
              showInHiddenAreas: true,
              suppressMouseDown: true
            });
            const Y = this._options.renderSideBySide.read(D), U = Y ? void 0 : (_a3 = this._editors.modified._getViewModel()) == null ? void 0 : _a3.createLineBreaksComputer();
            if (U) {
              const fe = this._editors.original.getModel();
              for (const W of T) if (W.diff) for (let ne = W.originalRange.startLineNumber; ne < W.originalRange.endLineNumberExclusive; ne++) {
                if (ne > fe.getLineCount()) return {
                  orig: M,
                  mod: I
                };
                U == null ? void 0 : U.addRequest(fe.getLineContent(ne), null, null);
              }
            }
            const j = (U == null ? void 0 : U.finalize()) ?? [];
            let ee = 0;
            const K = this._editors.modified.getOption(67), te = (_b3 = this._diffModel.read(D)) == null ? void 0 : _b3.movedTextToCompare.read(D), H = ((_c2 = this._editors.original.getModel()) == null ? void 0 : _c2.mightContainNonBasicASCII()) ?? false, se = ((_d2 = this._editors.original.getModel()) == null ? void 0 : _d2.mightContainRTL()) ?? false, de = vI.fromEditor(this._editors.modified);
            for (const fe of T) if (fe.diff && !Y && (!this._options.useTrueInlineDiffRendering.read(D) || !CI(fe.diff))) {
              if (!fe.originalRange.isEmpty) {
                _.read(D);
                const ne = document.createElement("div");
                ne.classList.add("view-lines", "line-delete", "monaco-mouse-cursor-text");
                const xe = this._editors.original.getModel();
                if (fe.originalRange.endLineNumberExclusive - 1 > xe.getLineCount()) return {
                  orig: M,
                  mod: I
                };
                const ye = new $he(fe.originalRange.mapToLineArray((ct) => xe.tokenization.getLineTokens(ct)), fe.originalRange.mapToLineArray((ct) => j[ee++]), H, se), Ae = [];
                for (const ct of fe.diff.innerChanges || []) Ae.push(new Op(ct.originalRange.delta(-(fe.diff.original.startLineNumber - 1)), cE.className, 0));
                const Ve = Uhe(ye, de, Ae, ne), We = document.createElement("div");
                if (We.className = "inline-deleted-margin-view-zone", Un(We, de.fontInfo), this._options.renderIndicators.read(D)) for (let ct = 0; ct < Ve.heightInLines; ct++) {
                  const hn = document.createElement("div");
                  hn.className = `delete-sign ${wt.asClassName($F)}`, hn.setAttribute("style", `position:absolute;top:${ct * K}px;width:${de.lineDecorationsWidth}px;height:${K}px;right:0;`), We.appendChild(hn);
                }
                let xi;
                x.add(new zhe(() => G7(xi), We, this._editors.modified, fe.diff, this._diffEditorWidget, Ve.viewLineCounts, this._editors.original.getModel(), this._contextMenuService, this._clipboardService));
                for (let ct = 0; ct < Ve.viewLineCounts.length; ct++) {
                  const hn = Ve.viewLineCounts[ct];
                  hn > 1 && M.push({
                    afterLineNumber: fe.originalRange.startLineNumber + ct,
                    domNode: y(),
                    heightInPx: (hn - 1) * K,
                    showInHiddenAreas: true,
                    suppressMouseDown: true
                  });
                }
                I.push({
                  afterLineNumber: fe.modifiedRange.startLineNumber - 1,
                  domNode: ne,
                  heightInPx: Ve.heightInLines * K,
                  minWidthInPx: Ve.minWidthInPx,
                  marginDomNode: We,
                  setZoneId(ct) {
                    xi = ct;
                  },
                  showInHiddenAreas: true,
                  suppressMouseDown: true
                });
              }
              const W = document.createElement("div");
              W.className = "gutter-delete", M.push({
                afterLineNumber: fe.originalRange.endLineNumberExclusive - 1,
                domNode: y(),
                heightInPx: fe.modifiedHeightInPx,
                marginDomNode: W,
                showInHiddenAreas: true,
                suppressMouseDown: true
              });
            } else {
              const W = fe.modifiedHeightInPx - fe.originalHeightInPx;
              if (W > 0) {
                if (te == null ? void 0 : te.lineRangeMapping.original.delta(-1).deltaLength(2).contains(fe.originalRange.endLineNumberExclusive - 1)) continue;
                M.push({
                  afterLineNumber: fe.originalRange.endLineNumberExclusive - 1,
                  domNode: y(),
                  heightInPx: W,
                  showInHiddenAreas: true,
                  suppressMouseDown: true
                });
              } else {
                let ne = function() {
                  const ye = document.createElement("div");
                  return ye.className = "arrow-revert-change " + wt.asClassName(Te.arrowRight), k.add(re(ye, "mousedown", (Ae) => Ae.stopPropagation())), k.add(re(ye, "click", (Ae) => {
                    Ae.stopPropagation(), o.revert(fe.diff);
                  })), He("div", {}, ye);
                };
                if (te == null ? void 0 : te.lineRangeMapping.modified.delta(-1).deltaLength(2).contains(fe.modifiedRange.endLineNumberExclusive - 1)) continue;
                let xe;
                fe.diff && fe.diff.modified.isEmpty && this._options.shouldRenderOldRevertArrows.read(D) && (xe = ne()), I.push({
                  afterLineNumber: fe.modifiedRange.endLineNumberExclusive - 1,
                  domNode: y(),
                  heightInPx: -W,
                  marginDomNode: xe,
                  showInHiddenAreas: true,
                  suppressMouseDown: true
                });
              }
            }
            for (const fe of v.read(D) ?? []) {
              if (!(te == null ? void 0 : te.lineRangeMapping.original.intersect(fe.originalRange)) || !(te == null ? void 0 : te.lineRangeMapping.modified.intersect(fe.modifiedRange))) continue;
              const W = fe.modifiedHeightInPx - fe.originalHeightInPx;
              W > 0 ? M.push({
                afterLineNumber: fe.originalRange.endLineNumberExclusive - 1,
                domNode: y(),
                heightInPx: W,
                showInHiddenAreas: true,
                suppressMouseDown: true
              }) : I.push({
                afterLineNumber: fe.modifiedRange.endLineNumberExclusive - 1,
                domNode: y(),
                heightInPx: -W,
                showInHiddenAreas: true,
                suppressMouseDown: true
              });
            }
            return {
              orig: M,
              mod: I
            };
          });
          let L = false;
          this._register(this._editors.original.onDidScrollChange((D) => {
            D.scrollLeftChanged && !L && (L = true, this._editors.modified.setScrollLeft(D.scrollLeft), L = false);
          })), this._register(this._editors.modified.onDidScrollChange((D) => {
            D.scrollLeftChanged && !L && (L = true, this._editors.original.setScrollLeft(D.scrollLeft), L = false);
          })), this._originalScrollTop = yi(this._editors.original.onDidScrollChange, () => this._editors.original.getScrollTop()), this._modifiedScrollTop = yi(this._editors.modified.onDidScrollChange, () => this._editors.modified.getScrollTop()), this._register(Dt((D) => {
            const k = this._originalScrollTop.read(D) - (this._originalScrollOffsetAnimated.get() - this._modifiedScrollOffsetAnimated.read(D)) - (this._originalTopPadding.get() - this._modifiedTopPadding.read(D));
            k !== this._editors.modified.getScrollTop() && this._editors.modified.setScrollTop(k, 1);
          })), this._register(Dt((D) => {
            const k = this._modifiedScrollTop.read(D) - (this._modifiedScrollOffsetAnimated.get() - this._originalScrollOffsetAnimated.read(D)) - (this._modifiedTopPadding.get() - this._originalTopPadding.read(D));
            k !== this._editors.original.getScrollTop() && this._editors.original.setScrollTop(k, 1);
          })), this._register(Dt((D) => {
            var _a3;
            const k = (_a3 = this._diffModel.read(D)) == null ? void 0 : _a3.movedTextToCompare.read(D);
            let T = 0;
            if (k) {
              const M = this._editors.original.getTopForLineNumber(k.lineRangeMapping.original.startLineNumber, true) - this._originalTopPadding.get();
              T = this._editors.modified.getTopForLineNumber(k.lineRangeMapping.modified.startLineNumber, true) - this._modifiedTopPadding.get() - M;
            }
            T > 0 ? (this._modifiedTopPadding.set(0, void 0), this._originalTopPadding.set(T, void 0)) : T < 0 ? (this._modifiedTopPadding.set(-T, void 0), this._originalTopPadding.set(0, void 0)) : setTimeout(() => {
              this._modifiedTopPadding.set(0, void 0), this._originalTopPadding.set(0, void 0);
            }, 400), this._editors.modified.hasTextFocus() ? this._originalScrollOffset.set(this._modifiedScrollOffset.get() - T, void 0, true) : this._modifiedScrollOffset.set(this._originalScrollOffset.get() + T, void 0, true);
          }));
        }
      };
      gE = qhe([
        v7(8, HN),
        v7(9, Gl)
      ], gE);
      function C7(s, e, t, i, n, o) {
        const r = new zl(w7(s, i)), a = new zl(w7(e, n)), l = s.getOption(67), u = e.getOption(67), d = [];
        let f = 0, m = 0;
        function _(b, v) {
          for (; ; ) {
            let y = r.peek(), x = a.peek();
            if (y && y.lineNumber >= b && (y = void 0), x && x.lineNumber >= v && (x = void 0), !y && !x) break;
            const L = y ? y.lineNumber - f : Number.MAX_VALUE, D = x ? x.lineNumber - m : Number.MAX_VALUE;
            L < D ? (r.dequeue(), x = {
              lineNumber: y.lineNumber - f + m,
              heightInPx: 0
            }) : L > D ? (a.dequeue(), y = {
              lineNumber: x.lineNumber - m + f,
              heightInPx: 0
            }) : (r.dequeue(), a.dequeue()), d.push({
              originalRange: qe.ofLength(y.lineNumber, 1),
              modifiedRange: qe.ofLength(x.lineNumber, 1),
              originalHeightInPx: l + y.heightInPx,
              modifiedHeightInPx: u + x.heightInPx,
              diff: void 0
            });
          }
        }
        for (const b of t) {
          let D = function(k, T, M = false) {
            var _a3, _b3;
            if (k < L || T < x) return;
            if (y) y = false;
            else if (!M && (k === L || T === x)) return;
            const I = new qe(L, k), R = new qe(x, T);
            if (I.isEmpty && R.isEmpty) return;
            const A = ((_a3 = r.takeWhile((U) => U.lineNumber < k)) == null ? void 0 : _a3.reduce((U, j) => U + j.heightInPx, 0)) ?? 0, Y = ((_b3 = a.takeWhile((U) => U.lineNumber < T)) == null ? void 0 : _b3.reduce((U, j) => U + j.heightInPx, 0)) ?? 0;
            d.push({
              originalRange: I,
              modifiedRange: R,
              originalHeightInPx: I.length * l + A,
              modifiedHeightInPx: R.length * u + Y,
              diff: b.lineRangeMapping
            }), L = k, x = T;
          };
          const v = b.lineRangeMapping;
          _(v.original.startLineNumber, v.modified.startLineNumber);
          let y = true, x = v.modified.startLineNumber, L = v.original.startLineNumber;
          if (o) for (const k of v.innerChanges || []) {
            k.originalRange.startColumn > 1 && k.modifiedRange.startColumn > 1 && D(k.originalRange.startLineNumber, k.modifiedRange.startLineNumber);
            const T = s.getModel(), M = k.originalRange.endLineNumber <= T.getLineCount() ? T.getLineMaxColumn(k.originalRange.endLineNumber) : Number.MAX_SAFE_INTEGER;
            k.originalRange.endColumn < M && D(k.originalRange.endLineNumber, k.modifiedRange.endLineNumber);
          }
          D(v.original.endLineNumberExclusive, v.modified.endLineNumberExclusive, true), f = v.original.endLineNumberExclusive, m = v.modified.endLineNumberExclusive;
        }
        return _(Number.MAX_VALUE, Number.MAX_VALUE), d;
      }
      function w7(s, e) {
        const t = [], i = [], n = s.getOption(147).wrappingColumn !== -1, o = s._getViewModel().coordinatesConverter, r = s.getOption(67);
        if (n) for (let l = 1; l <= s.getModel().getLineCount(); l++) {
          const u = o.getModelLineViewLineCount(l);
          u > 1 && i.push({
            lineNumber: l,
            heightInPx: r * (u - 1)
          });
        }
        for (const l of s.getWhitespaces()) {
          if (e.has(l.id)) continue;
          const u = l.afterLineNumber === 0 ? 0 : o.convertViewPositionToModelPosition(new X(l.afterLineNumber, 1)).lineNumber;
          t.push({
            lineNumber: u,
            heightInPx: l.height
          });
        }
        return mhe(t, i, (l) => l.lineNumber, (l, u) => ({
          lineNumber: l.lineNumber,
          heightInPx: l.heightInPx + u.heightInPx
        }));
      }
      function CI(s) {
        return s.innerChanges ? s.innerChanges.every((e) => y7(e.modifiedRange) && y7(e.originalRange) || e.originalRange.equalsRange(new z(1, 1, 1, 1))) : false;
      }
      function y7(s) {
        return s.startLineNumber === s.endLineNumber;
      }
      const _Th = class _Th extends he {
        constructor(e, t, i, n, o) {
          super(), this._rootElement = e, this._diffModel = t, this._originalEditorLayoutInfo = i, this._modifiedEditorLayoutInfo = n, this._editors = o, this._originalScrollTop = yi(this, this._editors.original.onDidScrollChange, () => this._editors.original.getScrollTop()), this._modifiedScrollTop = yi(this, this._editors.modified.onDidScrollChange, () => this._editors.modified.getScrollTop()), this._viewZonesChanged = Ao("onDidChangeViewZones", this._editors.modified.onDidChangeViewZones), this.width = Ct(this, 0), this._modifiedViewZonesChangedSignal = Ao("modified.onDidChangeViewZones", this._editors.modified.onDidChangeViewZones), this._originalViewZonesChangedSignal = Ao("original.onDidChangeViewZones", this._editors.original.onDidChangeViewZones), this._state = Tg(this, (d, f) => {
            var _a3;
            this._element.replaceChildren();
            const m = this._diffModel.read(d), _ = (_a3 = m == null ? void 0 : m.diff.read(d)) == null ? void 0 : _a3.movedTexts;
            if (!_ || _.length === 0) {
              this.width.set(0, void 0);
              return;
            }
            this._viewZonesChanged.read(d);
            const b = this._originalEditorLayoutInfo.read(d), v = this._modifiedEditorLayoutInfo.read(d);
            if (!b || !v) {
              this.width.set(0, void 0);
              return;
            }
            this._modifiedViewZonesChangedSignal.read(d), this._originalViewZonesChangedSignal.read(d);
            const y = _.map((I) => {
              function R(se, de) {
                const fe = de.getTopForLineNumber(se.startLineNumber, true), W = de.getTopForLineNumber(se.endLineNumberExclusive, true);
                return (fe + W) / 2;
              }
              const A = R(I.lineRangeMapping.original, this._editors.original), Y = this._originalScrollTop.read(d), U = R(I.lineRangeMapping.modified, this._editors.modified), j = this._modifiedScrollTop.read(d), ee = A - Y, K = U - j, te = Math.min(A, U), H = Math.max(A, U);
              return {
                range: new Qe(te, H),
                from: ee,
                to: K,
                fromWithoutScroll: A,
                toWithoutScroll: U,
                move: I
              };
            });
            y.sort(vU(fr((I) => I.fromWithoutScroll > I.toWithoutScroll, CU), fr((I) => I.fromWithoutScroll > I.toWithoutScroll ? I.fromWithoutScroll : -I.toWithoutScroll, Zc)));
            const x = wI.compute(y.map((I) => I.range)), L = 10, D = b.verticalScrollbarWidth, k = (x.getTrackCount() - 1) * 10 + L * 2, T = D + k + (v.contentLeft - _Th.movedCodeBlockPadding);
            let M = 0;
            for (const I of y) {
              const R = x.getTrack(M), A = D + L + R * 10, Y = 15, U = 15, j = T, ee = v.glyphMarginWidth + v.lineNumbersWidth, K = 18, te = document.createElementNS("http://www.w3.org/2000/svg", "rect");
              te.classList.add("arrow-rectangle"), te.setAttribute("x", `${j - ee}`), te.setAttribute("y", `${I.to - K / 2}`), te.setAttribute("width", `${ee}`), te.setAttribute("height", `${K}`), this._element.appendChild(te);
              const H = document.createElementNS("http://www.w3.org/2000/svg", "g"), se = document.createElementNS("http://www.w3.org/2000/svg", "path");
              se.setAttribute("d", `M 0 ${I.from} L ${A} ${I.from} L ${A} ${I.to} L ${j - U} ${I.to}`), se.setAttribute("fill", "none"), H.appendChild(se);
              const de = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
              de.classList.add("arrow"), f.add(Dt((fe) => {
                se.classList.toggle("currentMove", I.move === m.activeMovedText.read(fe)), de.classList.toggle("currentMove", I.move === m.activeMovedText.read(fe));
              })), de.setAttribute("points", `${j - U},${I.to - Y / 2} ${j},${I.to} ${j - U},${I.to + Y / 2}`), H.appendChild(de), this._element.appendChild(H), M++;
            }
            this.width.set(k, void 0);
          }), this._element = document.createElementNS("http://www.w3.org/2000/svg", "svg"), this._element.setAttribute("class", "moved-blocks-lines"), this._rootElement.appendChild(this._element), this._register(Ze(() => this._element.remove())), this._register(Dt((d) => {
            const f = this._originalEditorLayoutInfo.read(d), m = this._modifiedEditorLayoutInfo.read(d);
            !f || !m || (this._element.style.left = `${f.width - f.verticalScrollbarWidth}px`, this._element.style.height = `${f.height}px`, this._element.style.width = `${f.verticalScrollbarWidth + f.contentLeft - _Th.movedCodeBlockPadding + this.width.read(d)}px`);
          })), this._register(ww(this._state));
          const r = Ye((d) => {
            var _a3;
            const m = (_a3 = this._diffModel.read(d)) == null ? void 0 : _a3.diff.read(d);
            return m ? m.movedTexts.map((_) => ({
              move: _,
              original: new Ef(Ov(_.lineRangeMapping.original.startLineNumber - 1), 18),
              modified: new Ef(Ov(_.lineRangeMapping.modified.startLineNumber - 1), 18)
            })) : [];
          });
          this._register(kC(this._editors.original, r.map((d) => d.map((f) => f.original)))), this._register(kC(this._editors.modified, r.map((d) => d.map((f) => f.modified)))), this._register(Ur((d, f) => {
            const m = r.read(d);
            for (const _ of m) f.add(new S7(this._editors.original, _.original, _.move, "original", this._diffModel.get())), f.add(new S7(this._editors.modified, _.modified, _.move, "modified", this._diffModel.get()));
          }));
          const a = Ao("original.onDidFocusEditorWidget", (d) => this._editors.original.onDidFocusEditorWidget(() => setTimeout(() => d(void 0), 0))), l = Ao("modified.onDidFocusEditorWidget", (d) => this._editors.modified.onDidFocusEditorWidget(() => setTimeout(() => d(void 0), 0)));
          let u = "modified";
          this._register(vw({
            createEmptyChangeSummary: () => {
            },
            handleChange: (d, f) => (d.didChange(a) && (u = "original"), d.didChange(l) && (u = "modified"), true)
          }, (d) => {
            a.read(d), l.read(d);
            const f = this._diffModel.read(d);
            if (!f) return;
            const m = f.diff.read(d);
            let _;
            if (m && u === "original") {
              const b = this._editors.originalCursor.read(d);
              b && (_ = m.movedTexts.find((v) => v.lineRangeMapping.original.contains(b.lineNumber)));
            }
            if (m && u === "modified") {
              const b = this._editors.modifiedCursor.read(d);
              b && (_ = m.movedTexts.find((v) => v.lineRangeMapping.modified.contains(b.lineNumber)));
            }
            _ !== f.movedTextToCompare.get() && f.movedTextToCompare.set(void 0, void 0), f.setActiveMovedText(_);
          }));
        }
      };
      _Th.movedCodeBlockPadding = 4;
      let Th = _Th;
      class wI {
        static compute(e) {
          const t = [], i = [];
          for (const n of e) {
            let o = t.findIndex((r) => !r.intersectsStrict(n));
            o === -1 && (t.length >= 6 ? o = XG(t, fr((a) => a.intersectWithRangeLength(n), Zc)) : (o = t.length, t.push(new ST()))), t[o].addRange(n), i.push(o);
          }
          return new wI(t.length, i);
        }
        constructor(e, t) {
          this._trackCount = e, this.trackPerLineIdx = t;
        }
        getTrack(e) {
          return this.trackPerLineIdx[e];
        }
        getTrackCount() {
          return this._trackCount;
        }
      }
      class S7 extends fI {
        constructor(e, t, i, n, o) {
          const r = vt("div.diff-hidden-lines-widget");
          super(e, t, r.root), this._editor = e, this._move = i, this._kind = n, this._diffModel = o, this._nodes = vt("div.diff-moved-code-block", {
            style: {
              marginRight: "4px"
            }
          }, [
            vt("div.text-content@textContent"),
            vt("div.action-bar@actionBar")
          ]), r.root.appendChild(this._nodes.root);
          const a = yi(this._editor.onDidLayoutChange, () => this._editor.getLayoutInfo());
          this._register(hu(this._nodes.root, {
            paddingRight: a.map((m) => m.verticalScrollbarWidth)
          }));
          let l;
          i.changes.length > 0 ? l = this._kind === "original" ? C("codeMovedToWithChanges", "Code moved with changes to line {0}-{1}", this._move.lineRangeMapping.modified.startLineNumber, this._move.lineRangeMapping.modified.endLineNumberExclusive - 1) : C("codeMovedFromWithChanges", "Code moved with changes from line {0}-{1}", this._move.lineRangeMapping.original.startLineNumber, this._move.lineRangeMapping.original.endLineNumberExclusive - 1) : l = this._kind === "original" ? C("codeMovedTo", "Code moved to line {0}-{1}", this._move.lineRangeMapping.modified.startLineNumber, this._move.lineRangeMapping.modified.endLineNumberExclusive - 1) : C("codeMovedFrom", "Code moved from line {0}-{1}", this._move.lineRangeMapping.original.startLineNumber, this._move.lineRangeMapping.original.endLineNumberExclusive - 1);
          const u = this._register(new Wl(this._nodes.actionBar, {
            highlightToggledItems: true
          })), d = new Bl("", l, "", false);
          u.push(d, {
            icon: false,
            label: true
          });
          const f = new Bl("", "Compare", wt.asClassName(Te.compareChanges), true, () => {
            this._editor.focus(), this._diffModel.movedTextToCompare.set(this._diffModel.movedTextToCompare.get() === i ? void 0 : this._move, void 0);
          });
          this._register(Dt((m) => {
            const _ = this._diffModel.movedTextToCompare.read(m) === i;
            f.checked = _;
          })), u.push(f, {
            icon: false,
            label: true
          });
        }
      }
      class Khe extends he {
        constructor(e, t, i, n) {
          super(), this._editors = e, this._diffModel = t, this._options = i, this._decorations = Ye(this, (o) => {
            const r = this._diffModel.read(o), a = r == null ? void 0 : r.diff.read(o);
            if (!a) return null;
            const l = this._diffModel.read(o).movedTextToCompare.read(o), u = this._options.renderIndicators.read(o), d = this._options.showEmptyDecorations.read(o), f = [], m = [];
            if (!l) for (const b of a.mappings) if (b.lineRangeMapping.original.isEmpty || f.push({
              range: b.lineRangeMapping.original.toInclusiveRange(),
              options: u ? f7 : m7
            }), b.lineRangeMapping.modified.isEmpty || m.push({
              range: b.lineRangeMapping.modified.toInclusiveRange(),
              options: u ? d7 : g7
            }), b.lineRangeMapping.modified.isEmpty || b.lineRangeMapping.original.isEmpty) b.lineRangeMapping.original.isEmpty || f.push({
              range: b.lineRangeMapping.original.toInclusiveRange(),
              options: Rhe
            }), b.lineRangeMapping.modified.isEmpty || m.push({
              range: b.lineRangeMapping.modified.toInclusiveRange(),
              options: Mhe
            });
            else {
              const v = this._options.useTrueInlineDiffRendering.read(o) && CI(b.lineRangeMapping);
              for (const y of b.lineRangeMapping.innerChanges || []) if (b.lineRangeMapping.original.contains(y.originalRange.startLineNumber) && f.push({
                range: y.originalRange,
                options: y.originalRange.isEmpty() && d ? Ohe : cE
              }), b.lineRangeMapping.modified.contains(y.modifiedRange.startLineNumber) && m.push({
                range: y.modifiedRange,
                options: y.modifiedRange.isEmpty() && d && !v ? Ahe : p7
              }), v) {
                const x = r.model.original.getValueInRange(y.originalRange);
                m.push({
                  range: y.modifiedRange,
                  options: {
                    description: "deleted-text",
                    before: {
                      content: x,
                      inlineClassName: "inline-deleted-text"
                    },
                    zIndex: 1e5,
                    showIfCollapsed: true
                  }
                });
              }
            }
            if (l) for (const b of l.changes) {
              const v = b.original.toInclusiveRange();
              v && f.push({
                range: v,
                options: u ? f7 : m7
              });
              const y = b.modified.toInclusiveRange();
              y && m.push({
                range: y,
                options: u ? d7 : g7
              });
              for (const x of b.innerChanges || []) f.push({
                range: x.originalRange,
                options: cE
              }), m.push({
                range: x.modifiedRange,
                options: p7
              });
            }
            const _ = this._diffModel.read(o).activeMovedText.read(o);
            for (const b of a.movedTexts) f.push({
              range: b.lineRangeMapping.original.toInclusiveRange(),
              options: {
                description: "moved",
                blockClassName: "movedOriginal" + (b === _ ? " currentMove" : ""),
                blockPadding: [
                  Th.movedCodeBlockPadding,
                  0,
                  Th.movedCodeBlockPadding,
                  Th.movedCodeBlockPadding
                ]
              }
            }), m.push({
              range: b.lineRangeMapping.modified.toInclusiveRange(),
              options: {
                description: "moved",
                blockClassName: "movedModified" + (b === _ ? " currentMove" : ""),
                blockPadding: [
                  4,
                  0,
                  4,
                  4
                ]
              }
            });
            return {
              originalDecorations: f,
              modifiedDecorations: m
            };
          }), this._register(xC(this._editors.original, this._decorations.map((o) => (o == null ? void 0 : o.originalDecorations) || []))), this._register(xC(this._editors.modified, this._decorations.map((o) => (o == null ? void 0 : o.modifiedDecorations) || [])));
        }
      }
      class jhe {
        resetSash() {
          this._sashRatio.set(void 0, void 0);
        }
        constructor(e, t) {
          this._options = e, this.dimensions = t, this.sashLeft = eN(this, (i) => {
            const n = this._sashRatio.read(i) ?? this._options.splitViewDefaultRatio.read(i);
            return this._computeSashLeft(n, i);
          }, (i, n) => {
            const o = this.dimensions.width.get();
            this._sashRatio.set(i / o, n);
          }), this._sashRatio = Ct(this, void 0);
        }
        _computeSashLeft(e, t) {
          const i = this.dimensions.width.read(t), n = Math.floor(this._options.splitViewDefaultRatio.read(t) * i), o = this._options.enableSplitViewResizing.read(t) ? Math.floor(e * i) : n, r = 100;
          return i <= r * 2 ? n : o < r ? r : o > i - r ? i - r : o;
        }
      }
      class YF extends he {
        constructor(e, t, i, n, o, r) {
          super(), this._domNode = e, this._dimensions = t, this._enabled = i, this._boundarySashes = n, this.sashLeft = o, this._resetSash = r, this._sash = this._register(new To(this._domNode, {
            getVerticalSashTop: (a) => 0,
            getVerticalSashLeft: (a) => this.sashLeft.get(),
            getVerticalSashHeight: (a) => this._dimensions.height.get()
          }, {
            orientation: 0
          })), this._startSashPosition = void 0, this._register(this._sash.onDidStart(() => {
            this._startSashPosition = this.sashLeft.get();
          })), this._register(this._sash.onDidChange((a) => {
            this.sashLeft.set(this._startSashPosition + (a.currentX - a.startX), void 0);
          })), this._register(this._sash.onDidEnd(() => this._sash.layout())), this._register(this._sash.onDidReset(() => this._resetSash())), this._register(Dt((a) => {
            const l = this._boundarySashes.read(a);
            l && (this._sash.orthogonalEndSash = l.bottom);
          })), this._register(Dt((a) => {
            const l = this._enabled.read(a);
            this._sash.state = l ? 3 : 0, this.sashLeft.read(a), this._dimensions.height.read(a), this._sash.layout();
          }));
        }
      }
      class Ghe extends he {
        constructor(e, t, i) {
          super(), this._editor = e, this._domNode = t, this.itemProvider = i, this.scrollTop = yi(this, this._editor.onDidScrollChange, (r) => this._editor.getScrollTop()), this.isScrollTopZero = this.scrollTop.map((r) => r === 0), this.modelAttached = yi(this, this._editor.onDidChangeModel, (r) => this._editor.hasModel()), this.editorOnDidChangeViewZones = Ao("onDidChangeViewZones", this._editor.onDidChangeViewZones), this.editorOnDidContentSizeChange = Ao("onDidContentSizeChange", this._editor.onDidContentSizeChange), this.domNodeSizeChanged = tN("domNodeSizeChanged"), this.views = /* @__PURE__ */ new Map(), this._domNode.className = "gutter monaco-editor";
          const n = this._domNode.appendChild(vt("div.scroll-decoration", {
            role: "presentation",
            ariaHidden: "true",
            style: {
              width: "100%"
            }
          }).root), o = new ResizeObserver(() => {
            Yi((r) => {
              this.domNodeSizeChanged.trigger(r);
            });
          });
          o.observe(this._domNode), this._register(Ze(() => o.disconnect())), this._register(Dt((r) => {
            n.className = this.isScrollTopZero.read(r) ? "" : "scroll-decoration";
          })), this._register(Dt((r) => this.render(r)));
        }
        dispose() {
          super.dispose(), gs(this._domNode);
        }
        render(e) {
          if (!this.modelAttached.read(e)) return;
          this.domNodeSizeChanged.read(e), this.editorOnDidChangeViewZones.read(e), this.editorOnDidContentSizeChange.read(e);
          const t = this.scrollTop.read(e), i = this._editor.getVisibleRanges(), n = new Set(this.views.keys()), o = Qe.ofStartAndLength(0, this._domNode.clientHeight);
          if (!o.isEmpty) for (const r of i) {
            const a = new qe(r.startLineNumber, r.endLineNumber + 1), l = this.itemProvider.getIntersectingGutterItems(a, e);
            Yi((u) => {
              for (const d of l) {
                if (!d.range.intersect(a)) continue;
                n.delete(d.id);
                let f = this.views.get(d.id);
                if (f) f.item.set(d, u);
                else {
                  const v = document.createElement("div");
                  this._domNode.appendChild(v);
                  const y = Ct("item", d), x = this.itemProvider.createView(y, v);
                  f = new Yhe(y, x, v), this.views.set(d.id, f);
                }
                const m = d.range.startLineNumber <= this._editor.getModel().getLineCount() ? this._editor.getTopForLineNumber(d.range.startLineNumber, true) - t : this._editor.getBottomForLineNumber(d.range.startLineNumber - 1, false) - t, b = (d.range.endLineNumberExclusive === 1 ? Math.max(m, this._editor.getTopForLineNumber(d.range.startLineNumber, false) - t) : Math.max(m, this._editor.getBottomForLineNumber(d.range.endLineNumberExclusive - 1, true) - t)) - m;
                f.domNode.style.top = `${m}px`, f.domNode.style.height = `${b}px`, f.gutterItemView.layout(Qe.ofStartAndLength(m, b), o);
              }
            });
          }
          for (const r of n) {
            const a = this.views.get(r);
            a.gutterItemView.dispose(), a.domNode.remove(), this.views.delete(r);
          }
        }
      }
      class Yhe {
        constructor(e, t, i) {
          this.item = e, this.gutterItemView = t, this.domNode = i;
        }
      }
      class ZF extends Rh {
        constructor(e) {
          super(), this._getContext = e;
        }
        runAction(e, t) {
          const i = this._getContext();
          return super.runAction(e, i);
        }
      }
      class L7 extends D8 {
        constructor(e) {
          super(), this._textModel = e;
        }
        getValueOfRange(e) {
          return this._textModel.getValueInRange(e);
        }
        get length() {
          const e = this._textModel.getLineCount(), t = this._textModel.getLineLength(e);
          return new cr(e - 1, t);
        }
      }
      class Zhe extends he {
        constructor(e, t, i = {
          orientation: 0
        }) {
          super(), this.submenuActionViewItems = [], this.hasSecondaryActions = false, this._onDidChangeDropdownVisibility = this._register(new q$()), this.onDidChangeDropdownVisibility = this._onDidChangeDropdownVisibility.event, this.disposables = this._register(new Me()), i.hoverDelegate = i.hoverDelegate ?? this._register(iN()), this.options = i, this.toggleMenuAction = this._register(new T_(() => {
            var _a3;
            return (_a3 = this.toggleMenuActionViewItem) == null ? void 0 : _a3.show();
          }, i.toggleMenuTitle)), this.element = document.createElement("div"), this.element.className = "monaco-toolbar", e.appendChild(this.element), this.actionBar = this._register(new Wl(this.element, {
            orientation: i.orientation,
            ariaLabel: i.ariaLabel,
            actionRunner: i.actionRunner,
            allowContextMenu: i.allowContextMenu,
            highlightToggledItems: i.highlightToggledItems,
            hoverDelegate: i.hoverDelegate,
            actionViewItemProvider: (n, o) => {
              if (n.id === T_.ID) return this.toggleMenuActionViewItem = new Fv(n, n.menuActions, t, {
                actionViewItemProvider: this.options.actionViewItemProvider,
                actionRunner: this.actionRunner,
                keybindingProvider: this.options.getKeyBinding,
                classNames: wt.asClassNameArray(i.moreIcon ?? Te.toolBarMore),
                anchorAlignmentProvider: this.options.anchorAlignmentProvider,
                menuAsChild: !!this.options.renderDropdownAsChildElement,
                skipTelemetry: this.options.skipTelemetry,
                isMenu: true,
                hoverDelegate: this.options.hoverDelegate
              }), this.toggleMenuActionViewItem.setActionContext(this.actionBar.context), this.disposables.add(this._onDidChangeDropdownVisibility.add(this.toggleMenuActionViewItem.onDidChangeVisibility)), this.toggleMenuActionViewItem;
              if (i.actionViewItemProvider) {
                const r = i.actionViewItemProvider(n, o);
                if (r) return r;
              }
              if (n instanceof KC) {
                const r = new Fv(n, n.actions, t, {
                  actionViewItemProvider: this.options.actionViewItemProvider,
                  actionRunner: this.actionRunner,
                  keybindingProvider: this.options.getKeyBinding,
                  classNames: n.class,
                  anchorAlignmentProvider: this.options.anchorAlignmentProvider,
                  menuAsChild: !!this.options.renderDropdownAsChildElement,
                  skipTelemetry: this.options.skipTelemetry,
                  hoverDelegate: this.options.hoverDelegate
                });
                return r.setActionContext(this.actionBar.context), this.submenuActionViewItems.push(r), this.disposables.add(this._onDidChangeDropdownVisibility.add(r.onDidChangeVisibility)), r;
              }
            }
          }));
        }
        set actionRunner(e) {
          this.actionBar.actionRunner = e;
        }
        get actionRunner() {
          return this.actionBar.actionRunner;
        }
        getElement() {
          return this.element;
        }
        getItemAction(e) {
          return this.actionBar.getAction(e);
        }
        setActions(e, t) {
          this.clear();
          const i = e ? e.slice(0) : [];
          this.hasSecondaryActions = !!(t && t.length > 0), this.hasSecondaryActions && t && (this.toggleMenuAction.menuActions = t.slice(0), i.push(this.toggleMenuAction)), i.forEach((n) => {
            this.actionBar.push(n, {
              icon: this.options.icon ?? true,
              label: this.options.label ?? false,
              keybinding: this.getKeybindingLabel(n)
            });
          });
        }
        getKeybindingLabel(e) {
          var _a3, _b3, _c2;
          return ((_c2 = (_b3 = (_a3 = this.options).getKeyBinding) == null ? void 0 : _b3.call(_a3, e)) == null ? void 0 : _c2.getLabel()) ?? void 0;
        }
        clear() {
          this.submenuActionViewItems = [], this.disposables.clear(), this.actionBar.clear();
        }
        dispose() {
          this.clear(), this.disposables.dispose(), super.dispose();
        }
      }
      const _T_ = class _T_ extends Bl {
        constructor(e, t) {
          t = t || C("moreActions", "More Actions..."), super(_T_.ID, t, void 0, true), this._menuActions = [], this.toggleDropdownMenu = e;
        }
        async run() {
          this.toggleDropdownMenu();
        }
        get menuActions() {
          return this._menuActions;
        }
        set menuActions(e) {
          this._menuActions = e;
        }
      };
      _T_.ID = "toolbar.toggle.more";
      let T_ = _T_;
      var QF = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      }, ar = function(s, e) {
        return function(t, i) {
          e(t, i, s);
        };
      };
      let mE = class extends Zhe {
        constructor(e, t, i, n, o, r, a, l) {
          super(e, o, {
            getKeyBinding: (d) => r.lookupKeybinding(d.id) ?? void 0,
            ...t,
            allowContextMenu: true,
            skipTelemetry: typeof (t == null ? void 0 : t.telemetrySource) == "string"
          }), this._options = t, this._menuService = i, this._contextKeyService = n, this._contextMenuService = o, this._keybindingService = r, this._commandService = a, this._sessionDisposables = this._store.add(new Me());
          const u = t == null ? void 0 : t.telemetrySource;
          u && this._store.add(this.actionBar.onDidRun((d) => l.publicLog2("workbenchActionExecuted", {
            id: d.action.id,
            from: u
          })));
        }
        setActions(e, t = [], i) {
          var _a3, _b3, _c2;
          this._sessionDisposables.clear();
          const n = e.slice(), o = t.slice(), r = [];
          let a = 0;
          const l = [];
          let u = false;
          if (((_a3 = this._options) == null ? void 0 : _a3.hiddenItemStrategy) !== -1) for (let d = 0; d < n.length; d++) {
            const f = n[d];
            !(f instanceof Fl) && !(f instanceof vp) || f.hideActions && (r.push(f.hideActions.toggle), f.hideActions.toggle.checked && a++, f.hideActions.isHidden && (u = true, n[d] = void 0, ((_b3 = this._options) == null ? void 0 : _b3.hiddenItemStrategy) !== 0 && (l[d] = f)));
          }
          if (((_c2 = this._options) == null ? void 0 : _c2.overflowBehavior) !== void 0) {
            const d = Hie(new Set(this._options.overflowBehavior.exempted), kt.map(n, (_) => _ == null ? void 0 : _.id)), f = this._options.overflowBehavior.maxItems - d.size;
            let m = 0;
            for (let _ = 0; _ < n.length; _++) {
              const b = n[_];
              b && (m++, !d.has(b.id) && m >= f && (n[_] = void 0, l[_] = b));
            }
          }
          w4(n), w4(l), super.setActions(n, $n.join(l, o)), (r.length > 0 || n.length > 0) && this._sessionDisposables.add(re(this.getElement(), "contextmenu", (d) => {
            var _a4, _b4, _c3, _d2, _e2;
            const f = new Vr(Oe(this.getElement()), d), m = this.getItemAction(f.target);
            if (!m) return;
            f.preventDefault(), f.stopPropagation();
            const _ = [];
            if (m instanceof Fl && m.menuKeybinding) _.push(m.menuKeybinding);
            else if (!(m instanceof vp || m instanceof T_)) {
              const v = !!this._keybindingService.lookupKeybinding(m.id);
              _.push(gF(this._commandService, this._keybindingService, m.id, void 0, v));
            }
            if (r.length > 0) {
              let v = false;
              if (a === 1 && ((_a4 = this._options) == null ? void 0 : _a4.hiddenItemStrategy) === 0) {
                v = true;
                for (let y = 0; y < r.length; y++) if (r[y].checked) {
                  r[y] = Af({
                    id: m.id,
                    label: m.label,
                    checked: true,
                    enabled: false,
                    run() {
                    }
                  });
                  break;
                }
              }
              if (!v && (m instanceof Fl || m instanceof vp)) {
                if (!m.hideActions) return;
                _.push(m.hideActions.hide);
              } else _.push(Af({
                id: "label",
                label: C("hide", "Hide"),
                enabled: false,
                run() {
                }
              }));
            }
            const b = $n.join(_, r);
            ((_b4 = this._options) == null ? void 0 : _b4.resetMenu) && !i && (i = [
              this._options.resetMenu
            ]), u && i && (b.push(new $n()), b.push(Af({
              id: "resetThisMenu",
              label: C("resetThisMenu", "Reset Menu"),
              run: () => this._menuService.resetHiddenStates(i)
            }))), b.length !== 0 && this._contextMenuService.showContextMenu({
              getAnchor: () => f,
              getActions: () => b,
              menuId: (_c3 = this._options) == null ? void 0 : _c3.contextMenu,
              menuActionOptions: {
                renderShortTitle: true,
                ...(_d2 = this._options) == null ? void 0 : _d2.menuOptions
              },
              skipTelemetry: typeof ((_e2 = this._options) == null ? void 0 : _e2.telemetrySource) == "string",
              contextKeyService: this._contextKeyService
            });
          }));
        }
      };
      mE = QF([
        ar(2, Zh),
        ar(3, Mt),
        ar(4, Gl),
        ar(5, Pn),
        ar(6, po),
        ar(7, Qh)
      ], mE);
      let EC = class extends mE {
        constructor(e, t, i, n, o, r, a, l, u) {
          super(e, {
            resetMenu: t,
            ...i
          }, n, o, r, a, l, u), this._onDidChangeMenuItems = this._store.add(new G()), this.onDidChangeMenuItems = this._onDidChangeMenuItems.event;
          const d = this._store.add(n.createMenu(t, o, {
            emitEventsForSubmenuChanges: true
          })), f = () => {
            var _a3, _b3, _c2;
            const m = [], _ = [];
            Qte(d, i == null ? void 0 : i.menuOptions, {
              primary: m,
              secondary: _
            }, (_a3 = i == null ? void 0 : i.toolbarOptions) == null ? void 0 : _a3.primaryGroup, (_b3 = i == null ? void 0 : i.toolbarOptions) == null ? void 0 : _b3.shouldInlineSubmenu, (_c2 = i == null ? void 0 : i.toolbarOptions) == null ? void 0 : _c2.useSeparatorsInPrimaryActions), e.classList.toggle("has-no-actions", m.length === 0 && _.length === 0), super.setActions(m, _);
          };
          this._store.add(d.onDidChange(() => {
            f(), this._onDidChangeMenuItems.fire(this);
          })), f();
        }
        setActions() {
          throw new It("This toolbar is populated from a menu.");
        }
      };
      EC = QF([
        ar(3, Zh),
        ar(4, Mt),
        ar(5, Gl),
        ar(6, Pn),
        ar(7, po),
        ar(8, Qh)
      ], EC);
      var XF = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      }, W0 = function(s, e) {
        return function(t, i) {
          e(t, i, s);
        };
      };
      const Ex = [], c0 = 35;
      let pE = class extends he {
        constructor(e, t, i, n, o, r, a, l, u) {
          super(), this._diffModel = t, this._editors = i, this._options = n, this._sashLayout = o, this._boundarySashes = r, this._instantiationService = a, this._contextKeyService = l, this._menuService = u, this._menu = this._register(this._menuService.createMenu(Q.DiffEditorHunkToolbar, this._contextKeyService)), this._actions = yi(this, this._menu.onDidChange, () => this._menu.getActions()), this._hasActions = this._actions.map((d) => d.length > 0), this._showSash = Ye(this, (d) => this._options.renderSideBySide.read(d) && this._hasActions.read(d)), this.width = Ye(this, (d) => this._hasActions.read(d) ? c0 : 0), this.elements = vt("div.gutter@gutter", {
            style: {
              position: "absolute",
              height: "100%",
              width: c0 + "px"
            }
          }, []), this._currentDiff = Ye(this, (d) => {
            var _a3;
            const f = this._diffModel.read(d);
            if (!f) return;
            const m = (_a3 = f.diff.read(d)) == null ? void 0 : _a3.mappings, _ = this._editors.modifiedCursor.read(d);
            if (_) return m == null ? void 0 : m.find((b) => b.lineRangeMapping.modified.contains(_.lineNumber));
          }), this._selectedDiffs = Ye(this, (d) => {
            var _a3;
            const m = (_a3 = this._diffModel.read(d)) == null ? void 0 : _a3.diff.read(d);
            if (!m) return Ex;
            const _ = this._editors.modifiedSelections.read(d);
            if (_.every((x) => x.isEmpty())) return Ex;
            const b = new Mo(_.map((x) => qe.fromRangeInclusive(x))), y = m.mappings.filter((x) => x.lineRangeMapping.innerChanges && b.intersects(x.lineRangeMapping.modified)).map((x) => ({
              mapping: x,
              rangeMappings: x.lineRangeMapping.innerChanges.filter((L) => _.some((D) => z.areIntersecting(L.modifiedRange, D)))
            }));
            return y.length === 0 || y.every((x) => x.rangeMappings.length === 0) ? Ex : y;
          }), this._register(phe(e, this.elements.root)), this._register(re(this.elements.root, "click", () => {
            this._editors.modified.focus();
          })), this._register(hu(this.elements.root, {
            display: this._hasActions.map((d) => d ? "block" : "none")
          })), _a(this, (d) => this._showSash.read(d) ? new YF(e, this._sashLayout.dimensions, this._options.enableSplitViewResizing, this._boundarySashes, eN(this, (m) => this._sashLayout.sashLeft.read(m) - c0, (m, _) => this._sashLayout.sashLeft.set(m + c0, _)), () => this._sashLayout.resetSash()) : void 0).recomputeInitiallyAndOnChange(this._store), this._register(new Ghe(this._editors.modified, this.elements.root, {
            getIntersectingGutterItems: (d, f) => {
              const m = this._diffModel.read(f);
              if (!m) return [];
              const _ = m.diff.read(f);
              if (!_) return [];
              const b = this._selectedDiffs.read(f);
              if (b.length > 0) {
                const y = go.fromRangeMappings(b.flatMap((x) => x.rangeMappings));
                return [
                  new x7(y, true, Q.DiffEditorSelectionToolbar, void 0, m.model.original.uri, m.model.modified.uri)
                ];
              }
              const v = this._currentDiff.read(f);
              return _.mappings.map((y) => new x7(y.lineRangeMapping.withInnerChangesFromLineRanges(), y.lineRangeMapping === (v == null ? void 0 : v.lineRangeMapping), Q.DiffEditorHunkToolbar, void 0, m.model.original.uri, m.model.modified.uri));
            },
            createView: (d, f) => this._instantiationService.createInstance(_E, d, f, this)
          })), this._register(re(this.elements.gutter, Ce.MOUSE_WHEEL, (d) => {
            this._editors.modified.getOption(104).handleMouseWheel && this._editors.modified.delegateScrollFromMouseWheelEvent(d);
          }, {
            passive: false
          }));
        }
        computeStagedValue(e) {
          const t = e.innerChanges ?? [], i = new L7(this._editors.modifiedModel.get()), n = new L7(this._editors.original.getModel());
          return new eY(t.map((a) => a.toTextEdit(i))).apply(n);
        }
        layout(e) {
          this.elements.gutter.style.left = e + "px";
        }
      };
      pE = XF([
        W0(6, Ft),
        W0(7, Mt),
        W0(8, Zh)
      ], pE);
      class x7 {
        constructor(e, t, i, n, o, r) {
          this.mapping = e, this.showAlways = t, this.menuId = i, this.rangeOverride = n, this.originalUri = o, this.modifiedUri = r;
        }
        get id() {
          return this.mapping.modified.toString();
        }
        get range() {
          return this.rangeOverride ?? this.mapping.modified;
        }
      }
      let _E = class extends he {
        constructor(e, t, i, n) {
          super(), this._item = e, this._elements = vt("div.gutterItem", {
            style: {
              height: "20px",
              width: "34px"
            }
          }, [
            vt("div.background@background", {}, []),
            vt("div.buttons@buttons", {}, [])
          ]), this._showAlways = this._item.map(this, (r) => r.showAlways), this._menuId = this._item.map(this, (r) => r.menuId), this._isSmall = Ct(this, false), this._lastItemRange = void 0, this._lastViewRange = void 0;
          const o = this._register(n.createInstance(o_, "element", true, {
            position: {
              hoverPosition: 1
            }
          }));
          this._register(hp(t, this._elements.root)), this._register(Dt((r) => {
            const a = this._showAlways.read(r);
            this._elements.root.classList.toggle("noTransition", true), this._elements.root.classList.toggle("showAlways", a), setTimeout(() => {
              this._elements.root.classList.toggle("noTransition", false);
            }, 0);
          })), this._register(Ur((r, a) => {
            this._elements.buttons.replaceChildren();
            const l = a.add(n.createInstance(EC, this._elements.buttons, this._menuId.read(r), {
              orientation: 1,
              hoverDelegate: o,
              toolbarOptions: {
                primaryGroup: (u) => u.startsWith("primary")
              },
              overflowBehavior: {
                maxItems: this._isSmall.read(r) ? 1 : 3
              },
              hiddenItemStrategy: 0,
              actionRunner: new ZF(() => {
                const u = this._item.get(), d = u.mapping;
                return {
                  mapping: d,
                  originalWithModifiedChanges: i.computeStagedValue(d),
                  originalUri: u.originalUri,
                  modifiedUri: u.modifiedUri
                };
              }),
              menuOptions: {
                shouldForwardArgs: true
              }
            }));
            a.add(l.onDidChangeMenuItems(() => {
              this._lastItemRange && this.layout(this._lastItemRange, this._lastViewRange);
            }));
          }));
        }
        layout(e, t) {
          this._lastItemRange = e, this._lastViewRange = t;
          let i = this._elements.buttons.clientHeight;
          this._isSmall.set(this._item.get().mapping.original.startLineNumber === 1 && e.length < 30, void 0), i = this._elements.buttons.clientHeight;
          const n = e.length / 2 - i / 2, o = i;
          let r = e.start + n;
          const a = Qe.tryCreate(o, t.endExclusive - o - i), l = Qe.tryCreate(e.start + o, e.endExclusive - i - o);
          l && a && l.start < l.endExclusive && (r = a.clip(r), r = l.clip(r)), this._elements.buttons.style.top = `${r - e.start}px`;
        }
      };
      _E = XF([
        W0(3, Ft)
      ], _E);
      function N_(s) {
        return hh.get(s);
      }
      const _hh = class _hh extends he {
        static get(e) {
          let t = _hh._map.get(e);
          if (!t) {
            t = new _hh(e), _hh._map.set(e, t);
            const i = e.onDidDispose(() => {
              const n = _hh._map.get(e);
              n && (_hh._map.delete(e), n.dispose(), i.dispose());
            });
          }
          return t;
        }
        _beginUpdate() {
          this._updateCounter++, this._updateCounter === 1 && (this._currentTransaction = new J_(() => {
          }));
        }
        _endUpdate() {
          if (this._updateCounter--, this._updateCounter === 0) {
            const e = this._currentTransaction;
            this._currentTransaction = void 0, e.finish();
          }
        }
        constructor(e) {
          var _a3;
          super(), this.editor = e, this._updateCounter = 0, this._currentTransaction = void 0, this._model = Ct(this, this.editor.getModel()), this.model = this._model, this.isReadonly = yi(this, this.editor.onDidChangeConfiguration, () => this.editor.getOption(92)), this._versionId = UD({
            owner: this,
            lazy: true
          }, ((_a3 = this.editor.getModel()) == null ? void 0 : _a3.getVersionId()) ?? null), this.versionId = this._versionId, this._selections = UD({
            owner: this,
            equalsFn: rP(Vee(mt.selectionsEqual)),
            lazy: true
          }, this.editor.getSelections() ?? null), this.selections = this._selections, this.isFocused = yi(this, (t) => {
            const i = this.editor.onDidFocusEditorWidget(t), n = this.editor.onDidBlurEditorWidget(t);
            return {
              dispose() {
                i.dispose(), n.dispose();
              }
            };
          }, () => this.editor.hasWidgetFocus()), this.value = eN(this, (t) => {
            var _a4;
            return this.versionId.read(t), ((_a4 = this.model.read(t)) == null ? void 0 : _a4.getValue()) ?? "";
          }, (t, i) => {
            const n = this.model.get();
            n !== null && t !== n.getValue() && n.setValue(t);
          }), this.valueIsEmpty = Ye(this, (t) => {
            var _a4;
            return this.versionId.read(t), ((_a4 = this.editor.getModel()) == null ? void 0 : _a4.getValueLength()) === 0;
          }), this.cursorSelection = _w({
            owner: this,
            equalsFn: rP(mt.selectionsEqual)
          }, (t) => {
            var _a4;
            return ((_a4 = this.selections.read(t)) == null ? void 0 : _a4[0]) ?? null;
          }), this.onDidType = tN(this), this.scrollTop = yi(this.editor.onDidScrollChange, () => this.editor.getScrollTop()), this.scrollLeft = yi(this.editor.onDidScrollChange, () => this.editor.getScrollLeft()), this.layoutInfo = yi(this.editor.onDidLayoutChange, () => this.editor.getLayoutInfo()), this.layoutInfoContentLeft = this.layoutInfo.map((t) => t.contentLeft), this.layoutInfoDecorationsLeft = this.layoutInfo.map((t) => t.decorationsLeft), this.contentWidth = yi(this.editor.onDidContentSizeChange, () => this.editor.getContentWidth()), this._overlayWidgetCounter = 0, this._register(this.editor.onBeginUpdate(() => this._beginUpdate())), this._register(this.editor.onEndUpdate(() => this._endUpdate())), this._register(this.editor.onDidChangeModel(() => {
            this._beginUpdate();
            try {
              this._model.set(this.editor.getModel(), this._currentTransaction), this._forceUpdate();
            } finally {
              this._endUpdate();
            }
          })), this._register(this.editor.onDidType((t) => {
            this._beginUpdate();
            try {
              this._forceUpdate(), this.onDidType.trigger(this._currentTransaction, t);
            } finally {
              this._endUpdate();
            }
          })), this._register(this.editor.onDidChangeModelContent((t) => {
            var _a4;
            this._beginUpdate();
            try {
              this._versionId.set(((_a4 = this.editor.getModel()) == null ? void 0 : _a4.getVersionId()) ?? null, this._currentTransaction, t), this._forceUpdate();
            } finally {
              this._endUpdate();
            }
          })), this._register(this.editor.onDidChangeCursorSelection((t) => {
            this._beginUpdate();
            try {
              this._selections.set(this.editor.getSelections(), this._currentTransaction, t), this._forceUpdate();
            } finally {
              this._endUpdate();
            }
          }));
        }
        forceUpdate(e) {
          this._beginUpdate();
          try {
            return this._forceUpdate(), e ? e(this._currentTransaction) : void 0;
          } finally {
            this._endUpdate();
          }
        }
        _forceUpdate() {
          var _a3;
          this._beginUpdate();
          try {
            this._model.set(this.editor.getModel(), this._currentTransaction), this._versionId.set(((_a3 = this.editor.getModel()) == null ? void 0 : _a3.getVersionId()) ?? null, this._currentTransaction, void 0), this._selections.set(this.editor.getSelections(), this._currentTransaction, void 0);
          } finally {
            this._endUpdate();
          }
        }
        getOption(e) {
          return yi(this, (t) => this.editor.onDidChangeConfiguration((i) => {
            i.hasChanged(e) && t(void 0);
          }), () => this.editor.getOption(e));
        }
        setDecorations(e) {
          const t = new Me(), i = this.editor.createDecorationsCollection();
          return t.add(bw({
            owner: this,
            debugName: () => `Apply decorations from ${e.debugName}`
          }, (n) => {
            const o = e.read(n);
            i.set(o);
          })), t.add({
            dispose: () => {
              i.clear();
            }
          }), t;
        }
        createOverlayWidget(e) {
          const t = "observableOverlayWidget" + this._overlayWidgetCounter++, i = {
            getDomNode: () => e.domNode,
            getPosition: () => e.position.get(),
            getId: () => t,
            allowEditorOverflow: e.allowEditorOverflow,
            getMinContentWidthInPx: () => e.minContentWidthInPx.get()
          };
          this.editor.addOverlayWidget(i);
          const n = Dt((o) => {
            e.position.read(o), e.minContentWidthInPx.read(o), this.editor.layoutOverlayWidget(i);
          });
          return Ze(() => {
            n.dispose(), this.editor.removeOverlayWidget(i);
          });
        }
      };
      _hh._map = /* @__PURE__ */ new Map();
      let hh = _hh;
      var Qhe = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      }, Xhe = function(s, e) {
        return function(t, i) {
          e(t, i, s);
        };
      }, H0;
      let bE = (_s2 = class extends he {
        static setBreadcrumbsSourceFactory(e) {
          this._breadcrumbsSourceFactory.set(e, void 0);
        }
        get isUpdatingHiddenAreas() {
          return this._isUpdatingHiddenAreas;
        }
        constructor(e, t, i, n) {
          super(), this._editors = e, this._diffModel = t, this._options = i, this._instantiationService = n, this._modifiedOutlineSource = _a(this, (l) => {
            const u = this._editors.modifiedModel.read(l), d = H0._breadcrumbsSourceFactory.read(l);
            return !u || !d ? void 0 : d(u, this._instantiationService);
          }), this._isUpdatingHiddenAreas = false, this._register(this._editors.original.onDidChangeCursorPosition((l) => {
            if (l.reason === 1) return;
            const u = this._diffModel.get();
            Yi((d) => {
              for (const f of this._editors.original.getSelections() || []) u == null ? void 0 : u.ensureOriginalLineIsVisible(f.getStartPosition().lineNumber, 0, d), u == null ? void 0 : u.ensureOriginalLineIsVisible(f.getEndPosition().lineNumber, 0, d);
            });
          })), this._register(this._editors.modified.onDidChangeCursorPosition((l) => {
            if (l.reason === 1) return;
            const u = this._diffModel.get();
            Yi((d) => {
              for (const f of this._editors.modified.getSelections() || []) u == null ? void 0 : u.ensureModifiedLineIsVisible(f.getStartPosition().lineNumber, 0, d), u == null ? void 0 : u.ensureModifiedLineIsVisible(f.getEndPosition().lineNumber, 0, d);
            });
          }));
          const o = this._diffModel.map((l, u) => {
            var _a3;
            const d = (l == null ? void 0 : l.unchangedRegions.read(u)) ?? [];
            return d.length === 1 && d[0].modifiedLineNumber === 1 && d[0].lineCount === ((_a3 = this._editors.modifiedModel.read(u)) == null ? void 0 : _a3.getLineCount()) ? [] : d;
          });
          this.viewZones = Tg(this, (l, u) => {
            const d = this._modifiedOutlineSource.read(l);
            if (!d) return {
              origViewZones: [],
              modViewZones: []
            };
            const f = [], m = [], _ = this._options.renderSideBySide.read(l), b = this._options.compactMode.read(l), v = o.read(l);
            for (let y = 0; y < v.length; y++) {
              const x = v[y];
              if (!x.shouldHideControls(l) && !(b && (y === 0 || y === v.length - 1))) if (b) {
                {
                  const L = Ye(this, (k) => x.getHiddenOriginalRange(k).startLineNumber - 1), D = new Ef(L, 12);
                  f.push(D), u.add(new k7(this._editors.original, D, x, !_));
                }
                {
                  const L = Ye(this, (k) => x.getHiddenModifiedRange(k).startLineNumber - 1), D = new Ef(L, 12);
                  m.push(D), u.add(new k7(this._editors.modified, D, x));
                }
              } else {
                {
                  const L = Ye(this, (k) => x.getHiddenOriginalRange(k).startLineNumber - 1), D = new Ef(L, 24);
                  f.push(D), u.add(new D7(this._editors.original, D, x, x.originalUnchangedRange, !_, d, (k) => this._diffModel.get().ensureModifiedLineIsVisible(k, 2, void 0), this._options));
                }
                {
                  const L = Ye(this, (k) => x.getHiddenModifiedRange(k).startLineNumber - 1), D = new Ef(L, 24);
                  m.push(D), u.add(new D7(this._editors.modified, D, x, x.modifiedUnchangedRange, false, d, (k) => this._diffModel.get().ensureModifiedLineIsVisible(k, 2, void 0), this._options));
                }
              }
            }
            return {
              origViewZones: f,
              modViewZones: m
            };
          });
          const r = {
            description: "unchanged lines",
            className: "diff-unchanged-lines",
            isWholeLine: true
          }, a = {
            description: "Fold Unchanged",
            glyphMarginHoverMessage: new M6(void 0, {
              isTrusted: true,
              supportThemeIcons: true
            }).appendMarkdown(C("foldUnchanged", "Fold Unchanged Region")),
            glyphMarginClassName: "fold-unchanged " + wt.asClassName(Te.fold),
            zIndex: 10001
          };
          this._register(xC(this._editors.original, Ye(this, (l) => {
            const u = o.read(l), d = u.map((f) => ({
              range: f.originalUnchangedRange.toInclusiveRange(),
              options: r
            }));
            for (const f of u) f.shouldHideControls(l) && d.push({
              range: z.fromPositions(new X(f.originalLineNumber, 1)),
              options: a
            });
            return d;
          }))), this._register(xC(this._editors.modified, Ye(this, (l) => {
            const u = o.read(l), d = u.map((f) => ({
              range: f.modifiedUnchangedRange.toInclusiveRange(),
              options: r
            }));
            for (const f of u) f.shouldHideControls(l) && d.push({
              range: qe.ofLength(f.modifiedLineNumber, 1).toInclusiveRange(),
              options: a
            });
            return d;
          }))), this._register(Dt((l) => {
            const u = o.read(l);
            this._isUpdatingHiddenAreas = true;
            try {
              this._editors.original.setHiddenAreas(u.map((d) => d.getHiddenOriginalRange(l).toInclusiveRange()).filter(Jf)), this._editors.modified.setHiddenAreas(u.map((d) => d.getHiddenModifiedRange(l).toInclusiveRange()).filter(Jf));
            } finally {
              this._isUpdatingHiddenAreas = false;
            }
          })), this._register(this._editors.modified.onMouseUp((l) => {
            var _a3;
            if (!l.event.rightButton && l.target.position && ((_a3 = l.target.element) == null ? void 0 : _a3.className.includes("fold-unchanged"))) {
              const u = l.target.position.lineNumber, d = this._diffModel.get();
              if (!d) return;
              const f = d.unchangedRegions.get().find((m) => m.modifiedUnchangedRange.includes(u));
              if (!f) return;
              f.collapseAll(void 0), l.event.stopPropagation(), l.event.preventDefault();
            }
          })), this._register(this._editors.original.onMouseUp((l) => {
            var _a3;
            if (!l.event.rightButton && l.target.position && ((_a3 = l.target.element) == null ? void 0 : _a3.className.includes("fold-unchanged"))) {
              const u = l.target.position.lineNumber, d = this._diffModel.get();
              if (!d) return;
              const f = d.unchangedRegions.get().find((m) => m.originalUnchangedRange.includes(u));
              if (!f) return;
              f.collapseAll(void 0), l.event.stopPropagation(), l.event.preventDefault();
            }
          }));
        }
      }, H0 = _s2, _s2._breadcrumbsSourceFactory = Ct(H0, () => ({
        dispose() {
        },
        getBreadcrumbItems(e, t) {
          return [];
        }
      })), _s2);
      bE = H0 = Qhe([
        Xhe(3, Ft)
      ], bE);
      class k7 extends fI {
        constructor(e, t, i, n = false) {
          const o = vt("div.diff-hidden-lines-widget");
          super(e, t, o.root), this._unchangedRegion = i, this._hide = n, this._nodes = vt("div.diff-hidden-lines-compact", [
            vt("div.line-left", []),
            vt("div.text@text", []),
            vt("div.line-right", [])
          ]), o.root.appendChild(this._nodes.root), this._hide && this._nodes.root.replaceChildren(), this._register(Dt((r) => {
            if (!this._hide) {
              const a = this._unchangedRegion.getHiddenModifiedRange(r).length, l = C("hiddenLines", "{0} hidden lines", a);
              this._nodes.text.innerText = l;
            }
          }));
        }
      }
      class D7 extends fI {
        constructor(e, t, i, n, o, r, a, l) {
          const u = vt("div.diff-hidden-lines-widget");
          super(e, t, u.root), this._editor = e, this._unchangedRegion = i, this._unchangedRegionRange = n, this._hide = o, this._modifiedOutlineSource = r, this._revealModifiedHiddenLine = a, this._options = l, this._nodes = vt("div.diff-hidden-lines", [
            vt("div.top@top", {
              title: C("diff.hiddenLines.top", "Click or drag to show more above")
            }),
            vt("div.center@content", {
              style: {
                display: "flex"
              }
            }, [
              vt("div@first", {
                style: {
                  display: "flex",
                  justifyContent: "center",
                  alignItems: "center",
                  flexShrink: "0"
                }
              }, [
                He("a", {
                  title: C("showUnchangedRegion", "Show Unchanged Region"),
                  role: "button",
                  onclick: () => {
                    this._unchangedRegion.showAll(void 0);
                  }
                }, ...wh("$(unfold)"))
              ]),
              vt("div@others", {
                style: {
                  display: "flex",
                  justifyContent: "center",
                  alignItems: "center"
                }
              })
            ]),
            vt("div.bottom@bottom", {
              title: C("diff.bottom", "Click or drag to show more below"),
              role: "button"
            })
          ]), u.root.appendChild(this._nodes.root), this._hide ? gs(this._nodes.first) : this._register(hu(this._nodes.first, {
            width: N_(this._editor).layoutInfoContentLeft
          })), this._register(Dt((f) => {
            const m = this._unchangedRegion.visibleLineCountTop.read(f) + this._unchangedRegion.visibleLineCountBottom.read(f) === this._unchangedRegion.lineCount;
            this._nodes.bottom.classList.toggle("canMoveTop", !m), this._nodes.bottom.classList.toggle("canMoveBottom", this._unchangedRegion.visibleLineCountBottom.read(f) > 0), this._nodes.top.classList.toggle("canMoveTop", this._unchangedRegion.visibleLineCountTop.read(f) > 0), this._nodes.top.classList.toggle("canMoveBottom", !m);
            const _ = this._unchangedRegion.isDragged.read(f), b = this._editor.getDomNode();
            b && (b.classList.toggle("draggingUnchangedRegion", !!_), _ === "top" ? (b.classList.toggle("canMoveTop", this._unchangedRegion.visibleLineCountTop.read(f) > 0), b.classList.toggle("canMoveBottom", !m)) : _ === "bottom" ? (b.classList.toggle("canMoveTop", !m), b.classList.toggle("canMoveBottom", this._unchangedRegion.visibleLineCountBottom.read(f) > 0)) : (b.classList.toggle("canMoveTop", false), b.classList.toggle("canMoveBottom", false)));
          }));
          const d = this._editor;
          this._register(re(this._nodes.top, "mousedown", (f) => {
            if (f.button !== 0) return;
            this._nodes.top.classList.toggle("dragging", true), this._nodes.root.classList.toggle("dragging", true), f.preventDefault();
            const m = f.clientY;
            let _ = false;
            const b = this._unchangedRegion.visibleLineCountTop.get();
            this._unchangedRegion.isDragged.set("top", void 0);
            const v = Oe(this._nodes.top), y = re(v, "mousemove", (L) => {
              const k = L.clientY - m;
              _ = _ || Math.abs(k) > 2;
              const T = Math.round(k / d.getOption(67)), M = Math.max(0, Math.min(b + T, this._unchangedRegion.getMaxVisibleLineCountTop()));
              this._unchangedRegion.visibleLineCountTop.set(M, void 0);
            }), x = re(v, "mouseup", (L) => {
              _ || this._unchangedRegion.showMoreAbove(this._options.hideUnchangedRegionsRevealLineCount.get(), void 0), this._nodes.top.classList.toggle("dragging", false), this._nodes.root.classList.toggle("dragging", false), this._unchangedRegion.isDragged.set(void 0, void 0), y.dispose(), x.dispose();
            });
          })), this._register(re(this._nodes.bottom, "mousedown", (f) => {
            if (f.button !== 0) return;
            this._nodes.bottom.classList.toggle("dragging", true), this._nodes.root.classList.toggle("dragging", true), f.preventDefault();
            const m = f.clientY;
            let _ = false;
            const b = this._unchangedRegion.visibleLineCountBottom.get();
            this._unchangedRegion.isDragged.set("bottom", void 0);
            const v = Oe(this._nodes.bottom), y = re(v, "mousemove", (L) => {
              const k = L.clientY - m;
              _ = _ || Math.abs(k) > 2;
              const T = Math.round(k / d.getOption(67)), M = Math.max(0, Math.min(b - T, this._unchangedRegion.getMaxVisibleLineCountBottom())), I = this._unchangedRegionRange.endLineNumberExclusive > d.getModel().getLineCount() ? d.getContentHeight() : d.getTopForLineNumber(this._unchangedRegionRange.endLineNumberExclusive);
              this._unchangedRegion.visibleLineCountBottom.set(M, void 0);
              const R = this._unchangedRegionRange.endLineNumberExclusive > d.getModel().getLineCount() ? d.getContentHeight() : d.getTopForLineNumber(this._unchangedRegionRange.endLineNumberExclusive);
              d.setScrollTop(d.getScrollTop() + (R - I));
            }), x = re(v, "mouseup", (L) => {
              if (this._unchangedRegion.isDragged.set(void 0, void 0), !_) {
                const D = d.getTopForLineNumber(this._unchangedRegionRange.endLineNumberExclusive);
                this._unchangedRegion.showMoreBelow(this._options.hideUnchangedRegionsRevealLineCount.get(), void 0);
                const k = d.getTopForLineNumber(this._unchangedRegionRange.endLineNumberExclusive);
                d.setScrollTop(d.getScrollTop() + (k - D));
              }
              this._nodes.bottom.classList.toggle("dragging", false), this._nodes.root.classList.toggle("dragging", false), y.dispose(), x.dispose();
            });
          })), this._register(Dt((f) => {
            const m = [];
            if (!this._hide) {
              const _ = i.getHiddenModifiedRange(f).length, b = C("hiddenLines", "{0} hidden lines", _), v = He("span", {
                title: C("diff.hiddenLines.expandAll", "Double click to unfold")
              }, b);
              v.addEventListener("dblclick", (L) => {
                L.button === 0 && (L.preventDefault(), this._unchangedRegion.showAll(void 0));
              }), m.push(v);
              const y = this._unchangedRegion.getHiddenModifiedRange(f), x = this._modifiedOutlineSource.getBreadcrumbItems(y, f);
              if (x.length > 0) {
                m.push(He("span", void 0, "\xA0\xA0|\xA0\xA0"));
                for (let L = 0; L < x.length; L++) {
                  const D = x[L], k = Vx.toIcon(D.kind), T = vt("div.breadcrumb-item", {
                    style: {
                      display: "flex",
                      alignItems: "center"
                    }
                  }, [
                    Lv(k),
                    "\xA0",
                    D.name,
                    ...L === x.length - 1 ? [] : [
                      Lv(Te.chevronRight)
                    ]
                  ]).root;
                  m.push(T), T.onclick = () => {
                    this._revealModifiedHiddenLine(D.startLineNumber);
                  };
                }
              }
            }
            gs(this._nodes.others, ...m);
          }));
        }
      }
      var Jhe = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      }, ede = function(s, e) {
        return function(t, i) {
          e(t, i, s);
        };
      }, Ir;
      let I_ = (_t2 = class extends he {
        constructor(e, t, i, n, o, r, a) {
          super(), this._editors = e, this._rootElement = t, this._diffModel = i, this._rootWidth = n, this._rootHeight = o, this._modifiedEditorLayoutInfo = r, this._themeService = a, this.width = Ir.ENTIRE_DIFF_OVERVIEW_WIDTH;
          const l = yi(this._themeService.onDidColorThemeChange, () => this._themeService.getColorTheme()), u = Ye((m) => {
            const _ = l.read(m), b = _.getColor(zZ) || (_.getColor(WZ) || _D).transparent(2), v = _.getColor(UZ) || (_.getColor(HZ) || bD).transparent(2);
            return {
              insertColor: b,
              removeColor: v
            };
          }), d = St(document.createElement("div"));
          d.setClassName("diffViewport"), d.setPosition("absolute");
          const f = vt("div.diffOverview", {
            style: {
              position: "absolute",
              top: "0px",
              width: Ir.ENTIRE_DIFF_OVERVIEW_WIDTH + "px"
            }
          }).root;
          this._register(hp(f, d.domNode)), this._register(ln(f, Ce.POINTER_DOWN, (m) => {
            this._editors.modified.delegateVerticalScrollbarPointerDown(m);
          })), this._register(re(f, Ce.MOUSE_WHEEL, (m) => {
            this._editors.modified.delegateScrollFromMouseWheelEvent(m);
          }, {
            passive: false
          })), this._register(hp(this._rootElement, f)), this._register(Ur((m, _) => {
            const b = this._diffModel.read(m), v = this._editors.original.createOverviewRuler("original diffOverviewRuler");
            v && (_.add(v), _.add(hp(f, v.getDomNode())));
            const y = this._editors.modified.createOverviewRuler("modified diffOverviewRuler");
            if (y && (_.add(y), _.add(hp(f, y.getDomNode()))), !v || !y) return;
            const x = Ao("viewZoneChanged", this._editors.original.onDidChangeViewZones), L = Ao("viewZoneChanged", this._editors.modified.onDidChangeViewZones), D = Ao("hiddenRangesChanged", this._editors.original.onDidChangeHiddenAreas), k = Ao("hiddenRangesChanged", this._editors.modified.onDidChangeHiddenAreas);
            _.add(Dt((T) => {
              var _a3;
              x.read(T), L.read(T), D.read(T), k.read(T);
              const M = u.read(T), I = (_a3 = b == null ? void 0 : b.diff.read(T)) == null ? void 0 : _a3.mappings;
              function R(U, j, ee) {
                const K = ee._getViewModel();
                return K ? U.filter((te) => te.length > 0).map((te) => {
                  const H = K.coordinatesConverter.convertModelPositionToViewPosition(new X(te.startLineNumber, 1)), se = K.coordinatesConverter.convertModelPositionToViewPosition(new X(te.endLineNumberExclusive, 1)), de = se.lineNumber - H.lineNumber;
                  return new FF(H.lineNumber, se.lineNumber, de, j.toString());
                }) : [];
              }
              const A = R((I || []).map((U) => U.lineRangeMapping.original), M.removeColor, this._editors.original), Y = R((I || []).map((U) => U.lineRangeMapping.modified), M.insertColor, this._editors.modified);
              v == null ? void 0 : v.setZones(A), y == null ? void 0 : y.setZones(Y);
            })), _.add(Dt((T) => {
              const M = this._rootHeight.read(T), I = this._rootWidth.read(T), R = this._modifiedEditorLayoutInfo.read(T);
              if (R) {
                const A = Ir.ENTIRE_DIFF_OVERVIEW_WIDTH - 2 * Ir.ONE_OVERVIEW_WIDTH;
                v.setLayout({
                  top: 0,
                  height: M,
                  right: A + Ir.ONE_OVERVIEW_WIDTH,
                  width: Ir.ONE_OVERVIEW_WIDTH
                }), y.setLayout({
                  top: 0,
                  height: M,
                  right: 0,
                  width: Ir.ONE_OVERVIEW_WIDTH
                });
                const Y = this._editors.modifiedScrollTop.read(T), U = this._editors.modifiedScrollHeight.read(T), j = this._editors.modified.getOption(104), ee = new fg(j.verticalHasArrows ? j.arrowSize : 0, j.verticalScrollbarSize, 0, R.height, U, Y);
                d.setTop(ee.getSliderPosition()), d.setHeight(ee.getSliderSize());
              } else d.setTop(0), d.setHeight(0);
              f.style.height = M + "px", f.style.left = I - Ir.ENTIRE_DIFF_OVERVIEW_WIDTH + "px", d.setWidth(Ir.ENTIRE_DIFF_OVERVIEW_WIDTH);
            }));
          }));
        }
      }, Ir = _t2, _t2.ONE_OVERVIEW_WIDTH = 15, _t2.ENTIRE_DIFF_OVERVIEW_WIDTH = _t2.ONE_OVERVIEW_WIDTH * 2, _t2);
      I_ = Ir = Jhe([
        ede(6, vr)
      ], I_);
      const Tx = [];
      class tde extends he {
        constructor(e, t, i, n) {
          super(), this._editors = e, this._diffModel = t, this._options = i, this._widget = n, this._selectedDiffs = Ye(this, (o) => {
            var _a3;
            const a = (_a3 = this._diffModel.read(o)) == null ? void 0 : _a3.diff.read(o);
            if (!a) return Tx;
            const l = this._editors.modifiedSelections.read(o);
            if (l.every((m) => m.isEmpty())) return Tx;
            const u = new Mo(l.map((m) => qe.fromRangeInclusive(m))), f = a.mappings.filter((m) => m.lineRangeMapping.innerChanges && u.intersects(m.lineRangeMapping.modified)).map((m) => ({
              mapping: m,
              rangeMappings: m.lineRangeMapping.innerChanges.filter((_) => l.some((b) => z.areIntersecting(_.modifiedRange, b)))
            }));
            return f.length === 0 || f.every((m) => m.rangeMappings.length === 0) ? Tx : f;
          }), this._register(Ur((o, r) => {
            if (!this._options.shouldRenderOldRevertArrows.read(o)) return;
            const a = this._diffModel.read(o), l = a == null ? void 0 : a.diff.read(o);
            if (!a || !l || a.movedTextToCompare.read(o)) return;
            const u = [], d = this._selectedDiffs.read(o), f = new Set(d.map((m) => m.mapping));
            if (d.length > 0) {
              const m = this._editors.modifiedSelections.read(o), _ = r.add(new TC(m[m.length - 1].positionLineNumber, this._widget, d.flatMap((b) => b.rangeMappings), true));
              this._editors.modified.addGlyphMarginWidget(_), u.push(_);
            }
            for (const m of l.mappings) if (!f.has(m) && !m.lineRangeMapping.modified.isEmpty && m.lineRangeMapping.innerChanges) {
              const _ = r.add(new TC(m.lineRangeMapping.modified.startLineNumber, this._widget, m.lineRangeMapping, false));
              this._editors.modified.addGlyphMarginWidget(_), u.push(_);
            }
            r.add(Ze(() => {
              for (const m of u) this._editors.modified.removeGlyphMarginWidget(m);
            }));
          }));
        }
      }
      const _TC = class _TC extends he {
        getId() {
          return this._id;
        }
        constructor(e, t, i, n) {
          super(), this._lineNumber = e, this._widget = t, this._diffs = i, this._revertSelection = n, this._id = `revertButton${_TC.counter++}`, this._domNode = vt("div.revertButton", {
            title: this._revertSelection ? C("revertSelectedChanges", "Revert Selected Changes") : C("revertChange", "Revert Change")
          }, [
            Lv(Te.arrowRight)
          ]).root, this._register(re(this._domNode, Ce.MOUSE_DOWN, (o) => {
            o.button !== 2 && (o.stopPropagation(), o.preventDefault());
          })), this._register(re(this._domNode, Ce.MOUSE_UP, (o) => {
            o.stopPropagation(), o.preventDefault();
          })), this._register(re(this._domNode, Ce.CLICK, (o) => {
            this._diffs instanceof is ? this._widget.revert(this._diffs) : this._widget.revertRangeMappings(this._diffs), o.stopPropagation(), o.preventDefault();
          }));
        }
        getDomNode() {
          return this._domNode;
        }
        getPosition() {
          return {
            lane: ru.Right,
            range: {
              startColumn: 1,
              startLineNumber: this._lineNumber,
              endColumn: 1,
              endLineNumber: this._lineNumber
            },
            zIndex: 10001
          };
        }
      };
      _TC.counter = 0;
      let TC = _TC;
      function hl(s, e, t) {
        const i = s.bindTo(e);
        return bw({
          debugName: () => `Set Context Key "${s.key}"`
        }, (n) => {
          i.set(t(n));
        });
      }
      var ide = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      }, E7 = function(s, e) {
        return function(t, i) {
          e(t, i, s);
        };
      };
      let vE = class extends he {
        get onDidContentSizeChange() {
          return this._onDidContentSizeChange.event;
        }
        constructor(e, t, i, n, o, r, a) {
          super(), this.originalEditorElement = e, this.modifiedEditorElement = t, this._options = i, this._argCodeEditorWidgetOptions = n, this._createInnerEditor = o, this._instantiationService = r, this._keybindingService = a, this.original = this._register(this._createLeftHandSideEditor(this._options.editorOptions.get(), this._argCodeEditorWidgetOptions.originalEditor || {})), this.modified = this._register(this._createRightHandSideEditor(this._options.editorOptions.get(), this._argCodeEditorWidgetOptions.modifiedEditor || {})), this._onDidContentSizeChange = this._register(new G()), this.modifiedScrollTop = yi(this, this.modified.onDidScrollChange, () => this.modified.getScrollTop()), this.modifiedScrollHeight = yi(this, this.modified.onDidScrollChange, () => this.modified.getScrollHeight()), this.modifiedObs = N_(this.modified), this.originalObs = N_(this.original), this.modifiedModel = this.modifiedObs.model, this.modifiedSelections = yi(this, this.modified.onDidChangeCursorSelection, () => this.modified.getSelections() ?? []), this.modifiedCursor = _w({
            owner: this,
            equalsFn: X.equals
          }, (l) => {
            var _a3;
            return ((_a3 = this.modifiedSelections.read(l)[0]) == null ? void 0 : _a3.getPosition()) ?? new X(1, 1);
          }), this.originalCursor = yi(this, this.original.onDidChangeCursorPosition, () => this.original.getPosition() ?? new X(1, 1)), this._argCodeEditorWidgetOptions = null, this._register(vw({
            createEmptyChangeSummary: () => ({}),
            handleChange: (l, u) => (l.didChange(i.editorOptions) && Object.assign(u, l.change.changedOptions), true)
          }, (l, u) => {
            i.editorOptions.read(l), this._options.renderSideBySide.read(l), this.modified.updateOptions(this._adjustOptionsForRightHandSide(l, u)), this.original.updateOptions(this._adjustOptionsForLeftHandSide(l, u));
          }));
        }
        _createLeftHandSideEditor(e, t) {
          const i = this._adjustOptionsForLeftHandSide(void 0, e), n = this._constructInnerEditor(this._instantiationService, this.originalEditorElement, i, t);
          return n.setContextValue("isInDiffLeftEditor", true), n;
        }
        _createRightHandSideEditor(e, t) {
          const i = this._adjustOptionsForRightHandSide(void 0, e), n = this._constructInnerEditor(this._instantiationService, this.modifiedEditorElement, i, t);
          return n.setContextValue("isInDiffRightEditor", true), n;
        }
        _constructInnerEditor(e, t, i, n) {
          const o = this._createInnerEditor(e, t, i, n);
          return this._register(o.onDidContentSizeChange((r) => {
            const a = this.original.getContentWidth() + this.modified.getContentWidth() + I_.ENTIRE_DIFF_OVERVIEW_WIDTH, l = Math.max(this.modified.getContentHeight(), this.original.getContentHeight());
            this._onDidContentSizeChange.fire({
              contentHeight: l,
              contentWidth: a,
              contentHeightChanged: r.contentHeightChanged,
              contentWidthChanged: r.contentWidthChanged
            });
          })), o;
        }
        _adjustOptionsForLeftHandSide(e, t) {
          const i = this._adjustOptionsForSubEditor(t);
          return this._options.renderSideBySide.get() ? (i.unicodeHighlight = this._options.editorOptions.get().unicodeHighlight || {}, i.wordWrapOverride1 = this._options.diffWordWrap.get()) : (i.wordWrapOverride1 = "off", i.wordWrapOverride2 = "off", i.stickyScroll = {
            enabled: false
          }, i.unicodeHighlight = {
            nonBasicASCII: false,
            ambiguousCharacters: false,
            invisibleCharacters: false
          }), i.glyphMargin = this._options.renderSideBySide.get(), t.originalAriaLabel && (i.ariaLabel = t.originalAriaLabel), i.ariaLabel = this._updateAriaLabel(i.ariaLabel), i.readOnly = !this._options.originalEditable.get(), i.dropIntoEditor = {
            enabled: !i.readOnly
          }, i.extraEditorClassName = "original-in-monaco-diff-editor", i;
        }
        _adjustOptionsForRightHandSide(e, t) {
          const i = this._adjustOptionsForSubEditor(t);
          return t.modifiedAriaLabel && (i.ariaLabel = t.modifiedAriaLabel), i.ariaLabel = this._updateAriaLabel(i.ariaLabel), i.wordWrapOverride1 = this._options.diffWordWrap.get(), i.revealHorizontalRightPadding = Uh.revealHorizontalRightPadding.defaultValue + I_.ENTIRE_DIFF_OVERVIEW_WIDTH, i.scrollbar.verticalHasArrows = false, i.extraEditorClassName = "modified-in-monaco-diff-editor", i;
        }
        _adjustOptionsForSubEditor(e) {
          const t = {
            ...e,
            dimension: {
              height: 0,
              width: 0
            }
          };
          return t.inDiffEditor = true, t.automaticLayout = false, t.scrollbar = {
            ...t.scrollbar || {}
          }, t.folding = false, t.codeLens = this._options.diffCodeLens.get(), t.fixedOverflowWidgets = true, t.minimap = {
            ...t.minimap || {}
          }, t.minimap.enabled = false, this._options.hideUnchangedRegions.get() ? t.stickyScroll = {
            enabled: false
          } : t.stickyScroll = this._options.editorOptions.get().stickyScroll, t;
        }
        _updateAriaLabel(e) {
          var _a3;
          e || (e = "");
          const t = C("diff-aria-navigation-tip", " use {0} to open the accessibility help.", (_a3 = this._keybindingService.lookupKeybinding("editor.action.accessibilityHelp")) == null ? void 0 : _a3.getAriaLabel());
          return this._options.accessibilityVerbose.get() ? e + t : e ? e.replaceAll(t, "") : "";
        }
      };
      vE = ide([
        E7(5, Ft),
        E7(6, Pn)
      ], vE);
      const _yI = class _yI extends he {
        constructor() {
          super(...arguments), this._id = ++_yI.idCounter, this._onDidDispose = this._register(new G()), this.onDidDispose = this._onDidDispose.event;
        }
        getId() {
          return this.getEditorType() + ":v2:" + this._id;
        }
        getVisibleColumnFromPosition(e) {
          return this._targetEditor.getVisibleColumnFromPosition(e);
        }
        getPosition() {
          return this._targetEditor.getPosition();
        }
        setPosition(e, t = "api") {
          this._targetEditor.setPosition(e, t);
        }
        revealLine(e, t = 0) {
          this._targetEditor.revealLine(e, t);
        }
        revealLineInCenter(e, t = 0) {
          this._targetEditor.revealLineInCenter(e, t);
        }
        revealLineInCenterIfOutsideViewport(e, t = 0) {
          this._targetEditor.revealLineInCenterIfOutsideViewport(e, t);
        }
        revealLineNearTop(e, t = 0) {
          this._targetEditor.revealLineNearTop(e, t);
        }
        revealPosition(e, t = 0) {
          this._targetEditor.revealPosition(e, t);
        }
        revealPositionInCenter(e, t = 0) {
          this._targetEditor.revealPositionInCenter(e, t);
        }
        revealPositionInCenterIfOutsideViewport(e, t = 0) {
          this._targetEditor.revealPositionInCenterIfOutsideViewport(e, t);
        }
        revealPositionNearTop(e, t = 0) {
          this._targetEditor.revealPositionNearTop(e, t);
        }
        getSelection() {
          return this._targetEditor.getSelection();
        }
        getSelections() {
          return this._targetEditor.getSelections();
        }
        setSelection(e, t = "api") {
          this._targetEditor.setSelection(e, t);
        }
        setSelections(e, t = "api") {
          this._targetEditor.setSelections(e, t);
        }
        revealLines(e, t, i = 0) {
          this._targetEditor.revealLines(e, t, i);
        }
        revealLinesInCenter(e, t, i = 0) {
          this._targetEditor.revealLinesInCenter(e, t, i);
        }
        revealLinesInCenterIfOutsideViewport(e, t, i = 0) {
          this._targetEditor.revealLinesInCenterIfOutsideViewport(e, t, i);
        }
        revealLinesNearTop(e, t, i = 0) {
          this._targetEditor.revealLinesNearTop(e, t, i);
        }
        revealRange(e, t = 0, i = false, n = true) {
          this._targetEditor.revealRange(e, t, i, n);
        }
        revealRangeInCenter(e, t = 0) {
          this._targetEditor.revealRangeInCenter(e, t);
        }
        revealRangeInCenterIfOutsideViewport(e, t = 0) {
          this._targetEditor.revealRangeInCenterIfOutsideViewport(e, t);
        }
        revealRangeNearTop(e, t = 0) {
          this._targetEditor.revealRangeNearTop(e, t);
        }
        revealRangeNearTopIfOutsideViewport(e, t = 0) {
          this._targetEditor.revealRangeNearTopIfOutsideViewport(e, t);
        }
        revealRangeAtTop(e, t = 0) {
          this._targetEditor.revealRangeAtTop(e, t);
        }
        getSupportedActions() {
          return this._targetEditor.getSupportedActions();
        }
        focus() {
          this._targetEditor.focus();
        }
        trigger(e, t, i) {
          this._targetEditor.trigger(e, t, i);
        }
        createDecorationsCollection(e) {
          return this._targetEditor.createDecorationsCollection(e);
        }
        changeDecorations(e) {
          return this._targetEditor.changeDecorations(e);
        }
      };
      _yI.idCounter = 0;
      let yI = _yI;
      var nde = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      }, sde = function(s, e) {
        return function(t, i) {
          e(t, i, s);
        };
      };
      let CE = class {
        get editorOptions() {
          return this._options;
        }
        constructor(e, t) {
          this._accessibilityService = t, this._diffEditorWidth = Ct(this, 0), this._screenReaderMode = yi(this, this._accessibilityService.onDidChangeScreenReaderOptimized, () => this._accessibilityService.isScreenReaderOptimized()), this.couldShowInlineViewBecauseOfSize = Ye(this, (n) => this._options.read(n).renderSideBySide && this._diffEditorWidth.read(n) <= this._options.read(n).renderSideBySideInlineBreakpoint), this.renderOverviewRuler = Ye(this, (n) => this._options.read(n).renderOverviewRuler), this.renderSideBySide = Ye(this, (n) => this.compactMode.read(n) && this.shouldRenderInlineViewInSmartMode.read(n) ? false : this._options.read(n).renderSideBySide && !(this._options.read(n).useInlineViewWhenSpaceIsLimited && this.couldShowInlineViewBecauseOfSize.read(n) && !this._screenReaderMode.read(n))), this.readOnly = Ye(this, (n) => this._options.read(n).readOnly), this.shouldRenderOldRevertArrows = Ye(this, (n) => !(!this._options.read(n).renderMarginRevertIcon || !this.renderSideBySide.read(n) || this.readOnly.read(n) || this.shouldRenderGutterMenu.read(n))), this.shouldRenderGutterMenu = Ye(this, (n) => this._options.read(n).renderGutterMenu), this.renderIndicators = Ye(this, (n) => this._options.read(n).renderIndicators), this.enableSplitViewResizing = Ye(this, (n) => this._options.read(n).enableSplitViewResizing), this.splitViewDefaultRatio = Ye(this, (n) => this._options.read(n).splitViewDefaultRatio), this.ignoreTrimWhitespace = Ye(this, (n) => this._options.read(n).ignoreTrimWhitespace), this.maxComputationTimeMs = Ye(this, (n) => this._options.read(n).maxComputationTime), this.showMoves = Ye(this, (n) => this._options.read(n).experimental.showMoves && this.renderSideBySide.read(n)), this.isInEmbeddedEditor = Ye(this, (n) => this._options.read(n).isInEmbeddedEditor), this.diffWordWrap = Ye(this, (n) => this._options.read(n).diffWordWrap), this.originalEditable = Ye(this, (n) => this._options.read(n).originalEditable), this.diffCodeLens = Ye(this, (n) => this._options.read(n).diffCodeLens), this.accessibilityVerbose = Ye(this, (n) => this._options.read(n).accessibilityVerbose), this.diffAlgorithm = Ye(this, (n) => this._options.read(n).diffAlgorithm), this.showEmptyDecorations = Ye(this, (n) => this._options.read(n).experimental.showEmptyDecorations), this.onlyShowAccessibleDiffViewer = Ye(this, (n) => this._options.read(n).onlyShowAccessibleDiffViewer), this.compactMode = Ye(this, (n) => this._options.read(n).compactMode), this.trueInlineDiffRenderingEnabled = Ye(this, (n) => this._options.read(n).experimental.useTrueInlineView), this.useTrueInlineDiffRendering = Ye(this, (n) => !this.renderSideBySide.read(n) && this.trueInlineDiffRenderingEnabled.read(n)), this.hideUnchangedRegions = Ye(this, (n) => this._options.read(n).hideUnchangedRegions.enabled), this.hideUnchangedRegionsRevealLineCount = Ye(this, (n) => this._options.read(n).hideUnchangedRegions.revealLineCount), this.hideUnchangedRegionsContextLineCount = Ye(this, (n) => this._options.read(n).hideUnchangedRegions.contextLineCount), this.hideUnchangedRegionsMinimumLineCount = Ye(this, (n) => this._options.read(n).hideUnchangedRegions.minimumLineCount), this._model = Ct(this, void 0), this.shouldRenderInlineViewInSmartMode = this._model.map(this, (n) => tte(this, (o) => {
            const r = n == null ? void 0 : n.diff.read(o);
            return r ? ode(r, this.trueInlineDiffRenderingEnabled.read(o)) : void 0;
          })).flatten().map(this, (n) => !!n), this.inlineViewHideOriginalLineNumbers = this.compactMode;
          const i = {
            ...e,
            ...T7(e, Tn)
          };
          this._options = Ct(this, i);
        }
        updateOptions(e) {
          const t = T7(e, this._options.get()), i = {
            ...this._options.get(),
            ...e,
            ...t
          };
          this._options.set(i, void 0, {
            changedOptions: e
          });
        }
        setWidth(e) {
          this._diffEditorWidth.set(e, void 0);
        }
        setModel(e) {
          this._model.set(e, void 0);
        }
      };
      CE = nde([
        sde(1, ea)
      ], CE);
      function ode(s, e) {
        return s.mappings.every((t) => rde(t.lineRangeMapping) || ade(t.lineRangeMapping) || e && CI(t.lineRangeMapping));
      }
      function rde(s) {
        return s.original.length === 0;
      }
      function ade(s) {
        return s.modified.length === 0;
      }
      function T7(s, e) {
        var _a3, _b3, _c2, _d2, _e2, _f3, _g3, _h3;
        return {
          enableSplitViewResizing: Ee(s.enableSplitViewResizing, e.enableSplitViewResizing),
          splitViewDefaultRatio: UU(s.splitViewDefaultRatio, 0.5, 0.1, 0.9),
          renderSideBySide: Ee(s.renderSideBySide, e.renderSideBySide),
          renderMarginRevertIcon: Ee(s.renderMarginRevertIcon, e.renderMarginRevertIcon),
          maxComputationTime: $u(s.maxComputationTime, e.maxComputationTime, 0, 1073741824),
          maxFileSize: $u(s.maxFileSize, e.maxFileSize, 0, 1073741824),
          ignoreTrimWhitespace: Ee(s.ignoreTrimWhitespace, e.ignoreTrimWhitespace),
          renderIndicators: Ee(s.renderIndicators, e.renderIndicators),
          originalEditable: Ee(s.originalEditable, e.originalEditable),
          diffCodeLens: Ee(s.diffCodeLens, e.diffCodeLens),
          renderOverviewRuler: Ee(s.renderOverviewRuler, e.renderOverviewRuler),
          diffWordWrap: di(s.diffWordWrap, e.diffWordWrap, [
            "off",
            "on",
            "inherit"
          ]),
          diffAlgorithm: di(s.diffAlgorithm, e.diffAlgorithm, [
            "legacy",
            "advanced"
          ], {
            smart: "legacy",
            experimental: "advanced"
          }),
          accessibilityVerbose: Ee(s.accessibilityVerbose, e.accessibilityVerbose),
          experimental: {
            showMoves: Ee((_a3 = s.experimental) == null ? void 0 : _a3.showMoves, e.experimental.showMoves),
            showEmptyDecorations: Ee((_b3 = s.experimental) == null ? void 0 : _b3.showEmptyDecorations, e.experimental.showEmptyDecorations),
            useTrueInlineView: Ee((_c2 = s.experimental) == null ? void 0 : _c2.useTrueInlineView, e.experimental.useTrueInlineView)
          },
          hideUnchangedRegions: {
            enabled: Ee(((_d2 = s.hideUnchangedRegions) == null ? void 0 : _d2.enabled) ?? ((_e2 = s.experimental) == null ? void 0 : _e2.collapseUnchangedRegions), e.hideUnchangedRegions.enabled),
            contextLineCount: $u((_f3 = s.hideUnchangedRegions) == null ? void 0 : _f3.contextLineCount, e.hideUnchangedRegions.contextLineCount, 0, 1073741824),
            minimumLineCount: $u((_g3 = s.hideUnchangedRegions) == null ? void 0 : _g3.minimumLineCount, e.hideUnchangedRegions.minimumLineCount, 0, 1073741824),
            revealLineCount: $u((_h3 = s.hideUnchangedRegions) == null ? void 0 : _h3.revealLineCount, e.hideUnchangedRegions.revealLineCount, 0, 1073741824)
          },
          isInEmbeddedEditor: Ee(s.isInEmbeddedEditor, e.isInEmbeddedEditor),
          onlyShowAccessibleDiffViewer: Ee(s.onlyShowAccessibleDiffViewer, e.onlyShowAccessibleDiffViewer),
          renderSideBySideInlineBreakpoint: $u(s.renderSideBySideInlineBreakpoint, e.renderSideBySideInlineBreakpoint, 0, 1073741824),
          useInlineViewWhenSpaceIsLimited: Ee(s.useInlineViewWhenSpaceIsLimited, e.useInlineViewWhenSpaceIsLimited),
          renderGutterMenu: Ee(s.renderGutterMenu, e.renderGutterMenu),
          compactMode: Ee(s.compactMode, e.compactMode)
        };
      }
      var lde = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      }, Qm = function(s, e) {
        return function(t, i) {
          e(t, i, s);
        };
      };
      let NC = class extends yI {
        get onDidContentSizeChange() {
          return this._editors.onDidContentSizeChange;
        }
        constructor(e, t, i, n, o, r, a, l) {
          super(), this._domElement = e, this._parentContextKeyService = n, this._parentInstantiationService = o, this._accessibilitySignalService = a, this._editorProgressService = l, this.elements = vt("div.monaco-diff-editor.side-by-side", {
            style: {
              position: "relative",
              height: "100%"
            }
          }, [
            vt("div.editor.original@original", {
              style: {
                position: "absolute",
                height: "100%"
              }
            }),
            vt("div.editor.modified@modified", {
              style: {
                position: "absolute",
                height: "100%"
              }
            }),
            vt("div.accessibleDiffViewer@accessibleDiffViewer", {
              style: {
                position: "absolute",
                height: "100%"
              }
            })
          ]), this._diffModelSrc = this._register(q6(this, void 0)), this._diffModel = Ye(this, (k) => {
            var _a3;
            return (_a3 = this._diffModelSrc.read(k)) == null ? void 0 : _a3.object;
          }), this.onDidChangeModel = be.fromObservableLight(this._diffModel), this._contextKeyService = this._register(this._parentContextKeyService.createScoped(this._domElement)), this._instantiationService = this._register(this._parentInstantiationService.createChild(new Mg([
            Mt,
            this._contextKeyService
          ]))), this._boundarySashes = Ct(this, void 0), this._accessibleDiffViewerShouldBeVisible = Ct(this, false), this._accessibleDiffViewerVisible = Ye(this, (k) => this._options.onlyShowAccessibleDiffViewer.read(k) ? true : this._accessibleDiffViewerShouldBeVisible.read(k)), this._movedBlocksLinesPart = Ct(this, void 0), this._layoutInfo = Ye(this, (k) => {
            var _a3, _b3;
            const T = this._rootSizeObserver.width.read(k), M = this._rootSizeObserver.height.read(k);
            this._rootSizeObserver.automaticLayout ? this.elements.root.style.height = "100%" : this.elements.root.style.height = M + "px";
            const I = this._sash.read(k), R = this._gutter.read(k), A = (R == null ? void 0 : R.width.read(k)) ?? 0, Y = ((_a3 = this._overviewRulerPart.read(k)) == null ? void 0 : _a3.width) ?? 0;
            let U, j, ee, K, te;
            if (!!I) {
              const se = I.sashLeft.read(k), de = ((_b3 = this._movedBlocksLinesPart.read(k)) == null ? void 0 : _b3.width.read(k)) ?? 0;
              U = 0, j = se - A - de, te = se - A, ee = se, K = T - ee - Y;
            } else {
              te = 0;
              const se = this._options.inlineViewHideOriginalLineNumbers.read(k);
              U = A, se ? j = 0 : j = Math.max(5, this._editors.originalObs.layoutInfoDecorationsLeft.read(k)), ee = A + j, K = T - ee - Y;
            }
            return this.elements.original.style.left = U + "px", this.elements.original.style.width = j + "px", this._editors.original.layout({
              width: j,
              height: M
            }, true), R == null ? void 0 : R.layout(te), this.elements.modified.style.left = ee + "px", this.elements.modified.style.width = K + "px", this._editors.modified.layout({
              width: K,
              height: M
            }, true), {
              modifiedEditor: this._editors.modified.getLayoutInfo(),
              originalEditor: this._editors.original.getLayoutInfo()
            };
          }), this._diffValue = this._diffModel.map((k, T) => k == null ? void 0 : k.diff.read(T)), this.onDidUpdateDiff = be.fromObservableLight(this._diffValue), r.willCreateDiffEditor(), this._contextKeyService.createKey("isInDiffEditor", true), this._domElement.appendChild(this.elements.root), this._register(Ze(() => this.elements.root.remove())), this._rootSizeObserver = this._register(new UF(this.elements.root, t.dimension)), this._rootSizeObserver.setAutomaticLayout(t.automaticLayout ?? false), this._options = this._instantiationService.createInstance(CE, t), this._register(Dt((k) => {
            this._options.setWidth(this._rootSizeObserver.width.read(k));
          })), this._contextKeyService.createKey(ke.isEmbeddedDiffEditor.key, false), this._register(hl(ke.isEmbeddedDiffEditor, this._contextKeyService, (k) => this._options.isInEmbeddedEditor.read(k))), this._register(hl(ke.comparingMovedCode, this._contextKeyService, (k) => {
            var _a3;
            return !!((_a3 = this._diffModel.read(k)) == null ? void 0 : _a3.movedTextToCompare.read(k));
          })), this._register(hl(ke.diffEditorRenderSideBySideInlineBreakpointReached, this._contextKeyService, (k) => this._options.couldShowInlineViewBecauseOfSize.read(k))), this._register(hl(ke.diffEditorInlineMode, this._contextKeyService, (k) => !this._options.renderSideBySide.read(k))), this._register(hl(ke.hasChanges, this._contextKeyService, (k) => {
            var _a3, _b3;
            return (((_b3 = (_a3 = this._diffModel.read(k)) == null ? void 0 : _a3.diff.read(k)) == null ? void 0 : _b3.mappings.length) ?? 0) > 0;
          })), this._editors = this._register(this._instantiationService.createInstance(vE, this.elements.original, this.elements.modified, this._options, i, (k, T, M, I) => this._createInnerEditor(k, T, M, I))), this._register(hl(ke.diffEditorOriginalWritable, this._contextKeyService, (k) => this._options.originalEditable.read(k))), this._register(hl(ke.diffEditorModifiedWritable, this._contextKeyService, (k) => !this._options.readOnly.read(k))), this._register(hl(ke.diffEditorOriginalUri, this._contextKeyService, (k) => {
            var _a3;
            return ((_a3 = this._diffModel.read(k)) == null ? void 0 : _a3.model.original.uri.toString()) ?? "";
          })), this._register(hl(ke.diffEditorModifiedUri, this._contextKeyService, (k) => {
            var _a3;
            return ((_a3 = this._diffModel.read(k)) == null ? void 0 : _a3.model.modified.uri.toString()) ?? "";
          })), this._overviewRulerPart = _a(this, (k) => this._options.renderOverviewRuler.read(k) ? this._instantiationService.createInstance(or(I_, k), this._editors, this.elements.root, this._diffModel, this._rootSizeObserver.width, this._rootSizeObserver.height, this._layoutInfo.map((T) => T.modifiedEditor)) : void 0).recomputeInitiallyAndOnChange(this._store);
          const u = {
            height: this._rootSizeObserver.height,
            width: this._rootSizeObserver.width.map((k, T) => {
              var _a3;
              return k - (((_a3 = this._overviewRulerPart.read(T)) == null ? void 0 : _a3.width) ?? 0);
            })
          };
          this._sashLayout = new jhe(this._options, u), this._sash = _a(this, (k) => {
            const T = this._options.renderSideBySide.read(k);
            return this.elements.root.classList.toggle("side-by-side", T), T ? new YF(this.elements.root, u, this._options.enableSplitViewResizing, this._boundarySashes, this._sashLayout.sashLeft, () => this._sashLayout.resetSash()) : void 0;
          }).recomputeInitiallyAndOnChange(this._store);
          const d = _a(this, (k) => this._instantiationService.createInstance(or(bE, k), this._editors, this._diffModel, this._options)).recomputeInitiallyAndOnChange(this._store);
          _a(this, (k) => this._instantiationService.createInstance(or(Khe, k), this._editors, this._diffModel, this._options, this)).recomputeInitiallyAndOnChange(this._store);
          const f = /* @__PURE__ */ new Set(), m = /* @__PURE__ */ new Set();
          let _ = false;
          const b = _a(this, (k) => this._instantiationService.createInstance(or(gE, k), Oe(this._domElement), this._editors, this._diffModel, this._options, this, () => _ || d.get().isUpdatingHiddenAreas, f, m)).recomputeInitiallyAndOnChange(this._store), v = Ye(this, (k) => {
            const T = b.read(k).viewZones.read(k).orig, M = d.read(k).viewZones.read(k).origViewZones;
            return T.concat(M);
          }), y = Ye(this, (k) => {
            const T = b.read(k).viewZones.read(k).mod, M = d.read(k).viewZones.read(k).modViewZones;
            return T.concat(M);
          });
          this._register(kC(this._editors.original, v, (k) => {
            _ = k;
          }, f));
          let x;
          this._register(kC(this._editors.modified, y, (k) => {
            _ = k, _ ? x = LC.capture(this._editors.modified) : (x == null ? void 0 : x.restore(this._editors.modified), x = void 0);
          }, m)), this._accessibleDiffViewer = _a(this, (k) => this._instantiationService.createInstance(or(bh, k), this.elements.accessibleDiffViewer, this._accessibleDiffViewerVisible, (T, M) => this._accessibleDiffViewerShouldBeVisible.set(T, M), this._options.onlyShowAccessibleDiffViewer.map((T) => !T), this._rootSizeObserver.width, this._rootSizeObserver.height, this._diffModel.map((T, M) => {
            var _a3;
            return (_a3 = T == null ? void 0 : T.diff.read(M)) == null ? void 0 : _a3.mappings.map((I) => I.lineRangeMapping);
          }), new Nhe(this._editors))).recomputeInitiallyAndOnChange(this._store);
          const L = this._accessibleDiffViewerVisible.map((k) => k ? "hidden" : "visible");
          this._register(hu(this.elements.modified, {
            visibility: L
          })), this._register(hu(this.elements.original, {
            visibility: L
          })), this._createDiffEditorContributions(), r.addDiffEditor(this), this._gutter = _a(this, (k) => this._options.shouldRenderGutterMenu.read(k) ? this._instantiationService.createInstance(or(pE, k), this.elements.root, this._diffModel, this._editors, this._options, this._sashLayout, this._boundarySashes) : void 0), this._register(ww(this._layoutInfo)), _a(this, (k) => new (or(Th, k))(this.elements.root, this._diffModel, this._layoutInfo.map((T) => T.originalEditor), this._layoutInfo.map((T) => T.modifiedEditor), this._editors)).recomputeInitiallyAndOnChange(this._store, (k) => {
            this._movedBlocksLinesPart.set(k, void 0);
          }), this._register(be.runAndSubscribe(this._editors.modified.onDidChangeCursorPosition, (k) => this._handleCursorPositionChange(k, true))), this._register(be.runAndSubscribe(this._editors.original.onDidChangeCursorPosition, (k) => this._handleCursorPositionChange(k, false)));
          const D = this._diffModel.map(this, (k, T) => {
            if (k) return k.diff.read(T) === void 0 && !k.isDiffUpToDate.read(T);
          });
          this._register(Ur((k, T) => {
            if (D.read(k) === true) {
              const M = this._editorProgressService.show(true, 1e3);
              T.add(Ze(() => M.done()));
            }
          })), this._register(Ur((k, T) => {
            T.add(new (or(tde, k))(this._editors, this._diffModel, this._options, this));
          })), this._register(Ur((k, T) => {
            const M = this._diffModel.read(k);
            if (M) for (const I of [
              M.model.original,
              M.model.modified
            ]) T.add(I.onWillDispose((R) => {
              qt(new It("TextModel got disposed before DiffEditorWidget model got reset")), this.setModel(null);
            }));
          })), this._register(Dt((k) => {
            this._options.setModel(this._diffModel.read(k));
          }));
        }
        _createInnerEditor(e, t, i, n) {
          return e.createInstance(SC, t, i, n);
        }
        _createDiffEditorContributions() {
          const e = Rf.getDiffEditorContributions();
          for (const t of e) try {
            this._register(this._instantiationService.createInstance(t.ctor, this));
          } catch (i) {
            qt(i);
          }
        }
        get _targetEditor() {
          return this._editors.modified;
        }
        getEditorType() {
          return $N.IDiffEditor;
        }
        layout(e) {
          this._rootSizeObserver.observe(e);
        }
        hasTextFocus() {
          return this._editors.original.hasTextFocus() || this._editors.modified.hasTextFocus();
        }
        saveViewState() {
          var _a3;
          const e = this._editors.original.saveViewState(), t = this._editors.modified.saveViewState();
          return {
            original: e,
            modified: t,
            modelState: (_a3 = this._diffModel.get()) == null ? void 0 : _a3.serializeState()
          };
        }
        restoreViewState(e) {
          var _a3;
          if (e && e.original && e.modified) {
            const t = e;
            this._editors.original.restoreViewState(t.original), this._editors.modified.restoreViewState(t.modified), t.modelState && ((_a3 = this._diffModel.get()) == null ? void 0 : _a3.restoreSerializedState(t.modelState));
          }
        }
        handleInitialized() {
          this._editors.original.handleInitialized(), this._editors.modified.handleInitialized();
        }
        createViewModel(e) {
          return this._instantiationService.createInstance(fE, e, this._options);
        }
        getModel() {
          var _a3;
          return ((_a3 = this._diffModel.get()) == null ? void 0 : _a3.model) ?? null;
        }
        setModel(e) {
          const t = e ? "model" in e ? DC.create(e).createNewRef(this) : DC.create(this.createViewModel(e), this) : null;
          this.setDiffModel(t);
        }
        setDiffModel(e, t) {
          const i = this._diffModel.get();
          !e && i && this._accessibleDiffViewer.get().close(), this._diffModel.get() !== (e == null ? void 0 : e.object) && XT(t, (n) => {
            var _a3;
            const o = e == null ? void 0 : e.object;
            yi.batchEventsGlobally(n, () => {
              this._editors.original.setModel(o ? o.model.original : null), this._editors.modified.setModel(o ? o.model.modified : null);
            });
            const r = (_a3 = this._diffModelSrc.get()) == null ? void 0 : _a3.createNewRef(this);
            this._diffModelSrc.set(e == null ? void 0 : e.createNewRef(this), n), setTimeout(() => {
              r == null ? void 0 : r.dispose();
            }, 0);
          });
        }
        updateOptions(e) {
          this._options.updateOptions(e);
        }
        getContainerDomNode() {
          return this._domElement;
        }
        getOriginalEditor() {
          return this._editors.original;
        }
        getModifiedEditor() {
          return this._editors.modified;
        }
        getLineChanges() {
          var _a3;
          const e = (_a3 = this._diffModel.get()) == null ? void 0 : _a3.diff.get();
          return e ? cde(e) : null;
        }
        revert(e) {
          const t = this._diffModel.get();
          !t || !t.isDiffUpToDate.get() || this._editors.modified.executeEdits("diffEditor", [
            {
              range: e.modified.toExclusiveRange(),
              text: t.model.original.getValueInRange(e.original.toExclusiveRange())
            }
          ]);
        }
        revertRangeMappings(e) {
          const t = this._diffModel.get();
          if (!t || !t.isDiffUpToDate.get()) return;
          const i = e.map((n) => ({
            range: n.modifiedRange,
            text: t.model.original.getValueInRange(n.originalRange)
          }));
          this._editors.modified.executeEdits("diffEditor", i);
        }
        _goTo(e) {
          this._editors.modified.setPosition(new X(e.lineRangeMapping.modified.startLineNumber, 1)), this._editors.modified.revealRangeInCenter(e.lineRangeMapping.modified.toExclusiveRange());
        }
        goToDiff(e) {
          var _a3, _b3;
          const t = (_b3 = (_a3 = this._diffModel.get()) == null ? void 0 : _a3.diff.get()) == null ? void 0 : _b3.mappings;
          if (!t || t.length === 0) return;
          const i = this._editors.modified.getPosition().lineNumber;
          let n;
          e === "next" ? n = t.find((o) => o.lineRangeMapping.modified.startLineNumber > i) ?? t[0] : n = gv(t, (o) => o.lineRangeMapping.modified.startLineNumber < i) ?? t[t.length - 1], this._goTo(n), n.lineRangeMapping.modified.isEmpty ? this._accessibilitySignalService.playSignal(Bt.diffLineDeleted, {
            source: "diffEditor.goToDiff"
          }) : n.lineRangeMapping.original.isEmpty ? this._accessibilitySignalService.playSignal(Bt.diffLineInserted, {
            source: "diffEditor.goToDiff"
          }) : n && this._accessibilitySignalService.playSignal(Bt.diffLineModified, {
            source: "diffEditor.goToDiff"
          });
        }
        revealFirstDiff() {
          const e = this._diffModel.get();
          e && this.waitForDiff().then(() => {
            var _a3;
            const t = (_a3 = e.diff.get()) == null ? void 0 : _a3.mappings;
            !t || t.length === 0 || this._goTo(t[0]);
          });
        }
        accessibleDiffViewerNext() {
          this._accessibleDiffViewer.get().next();
        }
        accessibleDiffViewerPrev() {
          this._accessibleDiffViewer.get().prev();
        }
        async waitForDiff() {
          const e = this._diffModel.get();
          e && await e.waitForDiff();
        }
        mapToOtherSide() {
          var _a3, _b3;
          const e = this._editors.modified.hasWidgetFocus(), t = e ? this._editors.modified : this._editors.original, i = e ? this._editors.original : this._editors.modified;
          let n;
          const o = t.getSelection();
          if (o) {
            const r = (_b3 = (_a3 = this._diffModel.get()) == null ? void 0 : _a3.diff.get()) == null ? void 0 : _b3.mappings.map((a) => e ? a.lineRangeMapping.flip() : a.lineRangeMapping);
            if (r) {
              const a = u7(o.getStartPosition(), r), l = u7(o.getEndPosition(), r);
              n = z.plusRange(a, l);
            }
          }
          return {
            destination: i,
            destinationSelection: n
          };
        }
        switchSide() {
          const { destination: e, destinationSelection: t } = this.mapToOtherSide();
          e.focus(), t && e.setSelection(t);
        }
        exitCompareMove() {
          const e = this._diffModel.get();
          e && e.movedTextToCompare.set(void 0, void 0);
        }
        collapseAllUnchangedRegions() {
          var _a3;
          const e = (_a3 = this._diffModel.get()) == null ? void 0 : _a3.unchangedRegions.get();
          e && Yi((t) => {
            for (const i of e) i.collapseAll(t);
          });
        }
        showAllUnchangedRegions() {
          var _a3;
          const e = (_a3 = this._diffModel.get()) == null ? void 0 : _a3.unchangedRegions.get();
          e && Yi((t) => {
            for (const i of e) i.showAll(t);
          });
        }
        _handleCursorPositionChange(e, t) {
          var _a3, _b3;
          if ((e == null ? void 0 : e.reason) === 3) {
            const i = (_b3 = (_a3 = this._diffModel.get()) == null ? void 0 : _a3.diff.get()) == null ? void 0 : _b3.mappings.find((n) => t ? n.lineRangeMapping.modified.contains(e.position.lineNumber) : n.lineRangeMapping.original.contains(e.position.lineNumber));
            (i == null ? void 0 : i.lineRangeMapping.modified.isEmpty) ? this._accessibilitySignalService.playSignal(Bt.diffLineDeleted, {
              source: "diffEditor.cursorPositionChanged"
            }) : (i == null ? void 0 : i.lineRangeMapping.original.isEmpty) ? this._accessibilitySignalService.playSignal(Bt.diffLineInserted, {
              source: "diffEditor.cursorPositionChanged"
            }) : i && this._accessibilitySignalService.playSignal(Bt.diffLineModified, {
              source: "diffEditor.cursorPositionChanged"
            });
          }
        }
      };
      NC = lde([
        Qm(3, Mt),
        Qm(4, Ft),
        Qm(5, Xi),
        Qm(6, Fw),
        Qm(7, YT)
      ], NC);
      function cde(s) {
        return s.mappings.map((e) => {
          const t = e.lineRangeMapping;
          let i, n, o, r, a = t.innerChanges;
          return t.original.isEmpty ? (i = t.original.startLineNumber - 1, n = 0, a = void 0) : (i = t.original.startLineNumber, n = t.original.endLineNumberExclusive - 1), t.modified.isEmpty ? (o = t.modified.startLineNumber - 1, r = 0, a = void 0) : (o = t.modified.startLineNumber, r = t.modified.endLineNumberExclusive - 1), {
            originalStartLineNumber: i,
            originalEndLineNumber: n,
            modifiedStartLineNumber: o,
            modifiedEndLineNumber: r,
            charChanges: a == null ? void 0 : a.map((l) => ({
              originalStartLineNumber: l.originalRange.startLineNumber,
              originalStartColumn: l.originalRange.startColumn,
              originalEndLineNumber: l.originalRange.endLineNumber,
              originalEndColumn: l.originalRange.endColumn,
              modifiedStartLineNumber: l.modifiedRange.startLineNumber,
              modifiedStartColumn: l.modifiedRange.startColumn,
              modifiedEndLineNumber: l.modifiedRange.endLineNumber,
              modifiedEndColumn: l.modifiedRange.endColumn
            }))
          };
        });
      }
      var SI = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      }, Yt = function(s, e) {
        return function(t, i) {
          e(t, i, s);
        };
      };
      let ude = 0, N7 = false;
      function hde(s) {
        if (!s) {
          if (N7) return;
          N7 = true;
        }
        $J(s || Kt.document.body);
      }
      let IC = class extends SC {
        constructor(e, t, i, n, o, r, a, l, u, d, f, m, _) {
          const b = {
            ...t
          };
          b.ariaLabel = b.ariaLabel || VD.editorViewAccessibleLabel, super(e, b, {}, i, n, o, r, u, d, f, m, _), l instanceof vg ? this._standaloneKeybindingService = l : this._standaloneKeybindingService = null, hde(b.ariaContainerElement), ate((v, y) => i.createInstance(o_, v, y, {})), lte(a);
        }
        addCommand(e, t, i) {
          if (!this._standaloneKeybindingService) return console.warn("Cannot add command because the editor is configured with an unrecognized KeybindingService"), null;
          const n = "DYNAMIC_" + ++ude, o = Ot.deserialize(i);
          return this._standaloneKeybindingService.addDynamicKeybinding(n, e, t, o), n;
        }
        createContextKey(e, t) {
          return this._contextKeyService.createKey(e, t);
        }
        addAction(e) {
          if (typeof e.id != "string" || typeof e.label != "string" || typeof e.run != "function") throw new Error("Invalid action descriptor, `id`, `label` and `run` are required properties!");
          if (!this._standaloneKeybindingService) return console.warn("Cannot add keybinding because the editor is configured with an unrecognized KeybindingService"), he.None;
          const t = e.id, i = e.label, n = Ot.and(Ot.equals("editorId", this.getId()), Ot.deserialize(e.precondition)), o = e.keybindings, r = Ot.and(n, Ot.deserialize(e.keybindingContext)), a = e.contextMenuGroupId || null, l = e.contextMenuOrder || 0, u = (_, ...b) => Promise.resolve(e.run(this, ...b)), d = new Me(), f = this.getId() + ":" + t;
          if (d.add(Os.registerCommand(f, u)), a) {
            const _ = {
              command: {
                id: f,
                title: i
              },
              when: n,
              group: a,
              order: l
            };
            d.add(sg.appendMenuItem(Q.EditorContext, _));
          }
          if (Array.isArray(o)) for (const _ of o) d.add(this._standaloneKeybindingService.addDynamicKeybinding(f, _, u, r));
          const m = new VF(f, i, i, void 0, n, (..._) => Promise.resolve(e.run(this, ..._)), this._contextKeyService);
          return this._actions.set(t, m), d.add(Ze(() => {
            this._actions.delete(t);
          })), d;
        }
        _triggerCommand(e, t) {
          if (this._codeEditorService instanceof _v) try {
            this._codeEditorService.setActiveCodeEditor(this), super._triggerCommand(e, t);
          } finally {
            this._codeEditorService.setActiveCodeEditor(null);
          }
          else super._triggerCommand(e, t);
        }
      };
      IC = SI([
        Yt(2, Ft),
        Yt(3, Xi),
        Yt(4, po),
        Yt(5, Mt),
        Yt(6, Z_),
        Yt(7, Pn),
        Yt(8, vr),
        Yt(9, Jr),
        Yt(10, ea),
        Yt(11, Pa),
        Yt(12, jt)
      ], IC);
      let wE = class extends IC {
        constructor(e, t, i, n, o, r, a, l, u, d, f, m, _, b, v, y) {
          const x = {
            ...t
          };
          cC(f, x, false);
          const L = u.registerEditorContainer(e);
          typeof x.theme == "string" && u.setTheme(x.theme), typeof x.autoDetectHighContrast < "u" && u.setAutoDetectHighContrast(!!x.autoDetectHighContrast);
          const D = x.model;
          delete x.model, super(e, x, i, n, o, r, a, l, u, d, m, v, y), this._configurationService = f, this._standaloneThemeService = u, this._register(L);
          let k;
          if (typeof D > "u") {
            const T = b.getLanguageIdByMimeType(x.language) || x.language || gr;
            k = JF(_, b, x.value || "", T, void 0), this._ownsModel = true;
          } else k = D, this._ownsModel = false;
          if (this._attachModel(k), k) {
            const T = {
              oldModelUrl: null,
              newModelUrl: k.uri
            };
            this._onDidChangeModel.fire(T);
          }
        }
        dispose() {
          super.dispose();
        }
        updateOptions(e) {
          cC(this._configurationService, e, false), typeof e.theme == "string" && this._standaloneThemeService.setTheme(e.theme), typeof e.autoDetectHighContrast < "u" && this._standaloneThemeService.setAutoDetectHighContrast(!!e.autoDetectHighContrast), super.updateOptions(e);
        }
        _postDetachModelCleanup(e) {
          super._postDetachModelCleanup(e), e && this._ownsModel && (e.dispose(), this._ownsModel = false);
        }
      };
      wE = SI([
        Yt(2, Ft),
        Yt(3, Xi),
        Yt(4, po),
        Yt(5, Mt),
        Yt(6, Z_),
        Yt(7, Pn),
        Yt(8, wr),
        Yt(9, Jr),
        Yt(10, Si),
        Yt(11, ea),
        Yt(12, _s),
        Yt(13, un),
        Yt(14, Pa),
        Yt(15, jt)
      ], wE);
      let yE = class extends NC {
        constructor(e, t, i, n, o, r, a, l, u, d, f, m) {
          const _ = {
            ...t
          };
          cC(l, _, true);
          const b = r.registerEditorContainer(e);
          typeof _.theme == "string" && r.setTheme(_.theme), typeof _.autoDetectHighContrast < "u" && r.setAutoDetectHighContrast(!!_.autoDetectHighContrast), super(e, _, {}, n, i, o, m, d), this._configurationService = l, this._standaloneThemeService = r, this._register(b);
        }
        dispose() {
          super.dispose();
        }
        updateOptions(e) {
          cC(this._configurationService, e, true), typeof e.theme == "string" && this._standaloneThemeService.setTheme(e.theme), typeof e.autoDetectHighContrast < "u" && this._standaloneThemeService.setAutoDetectHighContrast(!!e.autoDetectHighContrast), super.updateOptions(e);
        }
        _createInnerEditor(e, t, i) {
          return e.createInstance(IC, t, i);
        }
        getOriginalEditor() {
          return super.getOriginalEditor();
        }
        getModifiedEditor() {
          return super.getModifiedEditor();
        }
        addCommand(e, t, i) {
          return this.getModifiedEditor().addCommand(e, t, i);
        }
        createContextKey(e, t) {
          return this.getModifiedEditor().createContextKey(e, t);
        }
        addAction(e) {
          return this.getModifiedEditor().addAction(e);
        }
      };
      yE = SI([
        Yt(2, Ft),
        Yt(3, Mt),
        Yt(4, Xi),
        Yt(5, wr),
        Yt(6, Jr),
        Yt(7, Si),
        Yt(8, Gl),
        Yt(9, YT),
        Yt(10, HN),
        Yt(11, Fw)
      ], yE);
      function JF(s, e, t, i, n) {
        if (t = t || "", !i) {
          const o = t.indexOf(`
`);
          let r = t;
          return o !== -1 && (r = t.substring(0, o)), I7(s, t, e.createByFilepathOrFirstLine(n || null, r), n);
        }
        return I7(s, t, e.createById(i), n);
      }
      function I7(s, e, t, i) {
        return s.createModel(e, t, i);
      }
      var dde = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      }, M7 = function(s, e) {
        return function(t, i) {
          e(t, i, s);
        };
      };
      class fde {
        constructor(e, t) {
          this.viewModel = e, this.deltaScrollVertical = t;
        }
        getId() {
          return this.viewModel;
        }
      }
      let MC = class extends he {
        constructor(e, t, i, n, o) {
          super(), this._container = e, this._overflowWidgetsDomNode = t, this._workbenchUIElementFactory = i, this._instantiationService = n, this._viewModel = Ct(this, void 0), this._collapsed = Ye(this, (l) => {
            var _a3;
            return (_a3 = this._viewModel.read(l)) == null ? void 0 : _a3.collapsed.read(l);
          }), this._editorContentHeight = Ct(this, 500), this.contentHeight = Ye(this, (l) => (this._collapsed.read(l) ? 0 : this._editorContentHeight.read(l)) + this._outerEditorHeight), this._modifiedContentWidth = Ct(this, 0), this._modifiedWidth = Ct(this, 0), this._originalContentWidth = Ct(this, 0), this._originalWidth = Ct(this, 0), this.maxScroll = Ye(this, (l) => {
            const u = this._modifiedContentWidth.read(l) - this._modifiedWidth.read(l), d = this._originalContentWidth.read(l) - this._originalWidth.read(l);
            return u > d ? {
              maxScroll: u,
              width: this._modifiedWidth.read(l)
            } : {
              maxScroll: d,
              width: this._originalWidth.read(l)
            };
          }), this._elements = vt("div.multiDiffEntry", [
            vt("div.header@header", [
              vt("div.header-content", [
                vt("div.collapse-button@collapseButton"),
                vt("div.file-path", [
                  vt("div.title.modified.show-file-icons@primaryPath", []),
                  vt("div.status.deleted@status", [
                    "R"
                  ]),
                  vt("div.title.original.show-file-icons@secondaryPath", [])
                ]),
                vt("div.actions@actions")
              ])
            ]),
            vt("div.editorParent", [
              vt("div.editorContainer@editor")
            ])
          ]), this.editor = this._register(this._instantiationService.createInstance(NC, this._elements.editor, {
            overflowWidgetsDomNode: this._overflowWidgetsDomNode
          }, {})), this.isModifedFocused = N_(this.editor.getModifiedEditor()).isFocused, this.isOriginalFocused = N_(this.editor.getOriginalEditor()).isFocused, this.isFocused = Ye(this, (l) => this.isModifedFocused.read(l) || this.isOriginalFocused.read(l)), this._resourceLabel = this._workbenchUIElementFactory.createResourceLabel ? this._register(this._workbenchUIElementFactory.createResourceLabel(this._elements.primaryPath)) : void 0, this._resourceLabel2 = this._workbenchUIElementFactory.createResourceLabel ? this._register(this._workbenchUIElementFactory.createResourceLabel(this._elements.secondaryPath)) : void 0, this._dataStore = this._register(new Me()), this._headerHeight = 40, this._lastScrollTop = -1, this._isSettingScrollTop = false;
          const r = new p2(this._elements.collapseButton, {});
          this._register(Dt((l) => {
            r.element.className = "", r.icon = this._collapsed.read(l) ? Te.chevronRight : Te.chevronDown;
          })), this._register(r.onDidClick(() => {
            var _a3;
            (_a3 = this._viewModel.get()) == null ? void 0 : _a3.collapsed.set(!this._collapsed.get(), void 0);
          })), this._register(Dt((l) => {
            this._elements.editor.style.display = this._collapsed.read(l) ? "none" : "block";
          })), this._register(this.editor.getModifiedEditor().onDidLayoutChange((l) => {
            const u = this.editor.getModifiedEditor().getLayoutInfo().contentWidth;
            this._modifiedWidth.set(u, void 0);
          })), this._register(this.editor.getOriginalEditor().onDidLayoutChange((l) => {
            const u = this.editor.getOriginalEditor().getLayoutInfo().contentWidth;
            this._originalWidth.set(u, void 0);
          })), this._register(this.editor.onDidContentSizeChange((l) => {
            op((u) => {
              this._editorContentHeight.set(l.contentHeight, u), this._modifiedContentWidth.set(this.editor.getModifiedEditor().getContentWidth(), u), this._originalContentWidth.set(this.editor.getOriginalEditor().getContentWidth(), u);
            });
          })), this._register(this.editor.getOriginalEditor().onDidScrollChange((l) => {
            if (this._isSettingScrollTop || !l.scrollTopChanged || !this._data) return;
            const u = l.scrollTop - this._lastScrollTop;
            this._data.deltaScrollVertical(u);
          })), this._register(Dt((l) => {
            var _a3;
            const u = (_a3 = this._viewModel.read(l)) == null ? void 0 : _a3.isActive.read(l);
            this._elements.root.classList.toggle("active", u);
          })), this._container.appendChild(this._elements.root), this._outerEditorHeight = this._headerHeight, this._contextKeyService = this._register(o.createScoped(this._elements.actions));
          const a = this._register(this._instantiationService.createChild(new Mg([
            Mt,
            this._contextKeyService
          ])));
          this._register(a.createInstance(EC, this._elements.actions, Q.MultiDiffEditorFileToolbar, {
            actionRunner: this._register(new ZF(() => {
              var _a3;
              return (_a3 = this._viewModel.get()) == null ? void 0 : _a3.modifiedUri;
            })),
            menuOptions: {
              shouldForwardArgs: true
            },
            toolbarOptions: {
              primaryGroup: (l) => l.startsWith("navigation")
            },
            actionViewItemProvider: (l, u) => Xte(a, l, u)
          }));
        }
        setScrollLeft(e) {
          this._modifiedContentWidth.get() - this._modifiedWidth.get() > this._originalContentWidth.get() - this._originalWidth.get() ? this.editor.getModifiedEditor().setScrollLeft(e) : this.editor.getOriginalEditor().setScrollLeft(e);
        }
        setData(e) {
          this._data = e;
          function t(n) {
            return {
              ...n,
              scrollBeyondLastLine: false,
              hideUnchangedRegions: {
                enabled: true
              },
              scrollbar: {
                vertical: "hidden",
                horizontal: "hidden",
                handleMouseWheel: false,
                useShadows: false
              },
              renderOverviewRuler: false,
              fixedOverflowWidgets: true,
              overviewRulerBorder: false
            };
          }
          if (!e) {
            op((n) => {
              this._viewModel.set(void 0, n), this.editor.setDiffModel(null, n), this._dataStore.clear();
            });
            return;
          }
          const i = e.viewModel.documentDiffItem;
          if (op((n) => {
            var _a3, _b3;
            (_a3 = this._resourceLabel) == null ? void 0 : _a3.setUri(e.viewModel.modifiedUri ?? e.viewModel.originalUri, {
              strikethrough: e.viewModel.modifiedUri === void 0
            });
            let o = false, r = false, a = false, l = "";
            e.viewModel.modifiedUri && e.viewModel.originalUri && e.viewModel.modifiedUri.path !== e.viewModel.originalUri.path ? (l = "R", o = true) : e.viewModel.modifiedUri ? e.viewModel.originalUri || (l = "A", a = true) : (l = "D", r = true), this._elements.status.classList.toggle("renamed", o), this._elements.status.classList.toggle("deleted", r), this._elements.status.classList.toggle("added", a), this._elements.status.innerText = l, (_b3 = this._resourceLabel2) == null ? void 0 : _b3.setUri(o ? e.viewModel.originalUri : void 0, {
              strikethrough: true
            }), this._dataStore.clear(), this._viewModel.set(e.viewModel, n), this.editor.setDiffModel(e.viewModel.diffEditorViewModelRef, n), this.editor.updateOptions(t(i.options ?? {}));
          }), i.onOptionsDidChange && this._dataStore.add(i.onOptionsDidChange(() => {
            this.editor.updateOptions(t(i.options ?? {}));
          })), e.viewModel.isAlive.recomputeInitiallyAndOnChange(this._dataStore, (n) => {
            n || this.setData(void 0);
          }), e.viewModel.documentDiffItem.contextKeys) for (const [n, o] of Object.entries(e.viewModel.documentDiffItem.contextKeys)) this._contextKeyService.createKey(n, o);
        }
        render(e, t, i, n) {
          this._elements.root.style.visibility = "visible", this._elements.root.style.top = `${e.start}px`, this._elements.root.style.height = `${e.length}px`, this._elements.root.style.width = `${t}px`, this._elements.root.style.position = "absolute";
          const o = e.length - this._headerHeight, r = Math.max(0, Math.min(n.start - e.start, o));
          this._elements.header.style.transform = `translateY(${r}px)`, op((a) => {
            this.editor.layout({
              width: t - 2 * 8 - 2 * 1,
              height: e.length - this._outerEditorHeight
            });
          });
          try {
            this._isSettingScrollTop = true, this._lastScrollTop = i, this.editor.getOriginalEditor().setScrollTop(i);
          } finally {
            this._isSettingScrollTop = false;
          }
          this._elements.header.classList.toggle("shadow", r > 0 || i > 0), this._elements.header.classList.toggle("collapsed", r === o);
        }
        hide() {
          this._elements.root.style.top = "-100000px", this._elements.root.style.visibility = "hidden";
        }
      };
      MC = dde([
        M7(3, Ft),
        M7(4, Mt)
      ], MC);
      class gde {
        constructor(e) {
          this._create = e, this._unused = /* @__PURE__ */ new Set(), this._used = /* @__PURE__ */ new Set(), this._itemData = /* @__PURE__ */ new Map();
        }
        getUnusedObj(e) {
          let t;
          if (this._unused.size === 0) t = this._create(e), this._itemData.set(t, e);
          else {
            const i = [
              ...this._unused.values()
            ];
            t = i.find((n) => this._itemData.get(n).getId() === e.getId()) ?? i[0], this._unused.delete(t), this._itemData.set(t, e), t.setData(e);
          }
          return this._used.add(t), {
            object: t,
            dispose: () => {
              this._used.delete(t), this._unused.size > 5 ? t.dispose() : this._unused.add(t);
            }
          };
        }
        dispose() {
          for (const e of this._used) e.dispose();
          for (const e of this._unused) e.dispose();
          this._used.clear(), this._unused.clear();
        }
      }
      var mde = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      }, A7 = function(s, e) {
        return function(t, i) {
          e(t, i, s);
        };
      };
      let SE = class extends he {
        constructor(e, t, i, n, o, r) {
          super(), this._element = e, this._dimension = t, this._viewModel = i, this._workbenchUIElementFactory = n, this._parentContextKeyService = o, this._parentInstantiationService = r, this._scrollableElements = vt("div.scrollContent", [
            vt("div@content", {
              style: {
                overflow: "hidden"
              }
            }),
            vt("div.monaco-editor@overflowWidgetsDomNode", {})
          ]), this._scrollable = this._register(new Dg({
            forceIntegerValues: false,
            scheduleAtNextAnimationFrame: (l) => Gs(Oe(this._element), l),
            smoothScrollDuration: 100
          })), this._scrollableElement = this._register(new dw(this._scrollableElements.root, {
            vertical: 1,
            horizontal: 1,
            useShadows: false
          }, this._scrollable)), this._elements = vt("div.monaco-component.multiDiffEditor", {}, [
            vt("div", {}, [
              this._scrollableElement.getDomNode()
            ]),
            vt("div.placeholder@placeholder", {}, [
              vt("div", [
                C("noChangedFiles", "No Changed Files")
              ])
            ])
          ]), this._sizeObserver = this._register(new UF(this._element, void 0)), this._objectPool = this._register(new gde((l) => {
            const u = this._instantiationService.createInstance(MC, this._scrollableElements.content, this._scrollableElements.overflowWidgetsDomNode, this._workbenchUIElementFactory);
            return u.setData(l), u;
          })), this.scrollTop = yi(this, this._scrollableElement.onScroll, () => this._scrollableElement.getScrollPosition().scrollTop), this.scrollLeft = yi(this, this._scrollableElement.onScroll, () => this._scrollableElement.getScrollPosition().scrollLeft), this._viewItemsInfo = Tg(this, (l, u) => {
            const d = this._viewModel.read(l);
            if (!d) return {
              items: [],
              getItem: (b) => {
                throw new It();
              }
            };
            const f = d.items.read(l), m = /* @__PURE__ */ new Map();
            return {
              items: f.map((b) => {
                var _a3;
                const v = u.add(new pde(b, this._objectPool, this.scrollLeft, (x) => {
                  this._scrollableElement.setScrollPosition({
                    scrollTop: this._scrollableElement.getScrollPosition().scrollTop + x
                  });
                })), y = (_a3 = this._lastDocStates) == null ? void 0 : _a3[v.getKey()];
                return y && Yi((x) => {
                  v.setViewState(y, x);
                }), m.set(b, v), v;
              }),
              getItem: (b) => m.get(b)
            };
          }), this._viewItems = this._viewItemsInfo.map(this, (l) => l.items), this._spaceBetweenPx = 0, this._totalHeight = this._viewItems.map(this, (l, u) => l.reduce((d, f) => d + f.contentHeight.read(u) + this._spaceBetweenPx, 0)), this._contextKeyService = this._register(this._parentContextKeyService.createScoped(this._element)), this._instantiationService = this._register(this._parentInstantiationService.createChild(new Mg([
            Mt,
            this._contextKeyService
          ]))), this._lastDocStates = {}, this._contextKeyService.createKey(ke.inMultiDiffEditor.key, true), this._register(Ur((l, u) => {
            const d = this._viewModel.read(l);
            if (d && d.contextKeys) for (const [f, m] of Object.entries(d.contextKeys)) {
              const _ = this._contextKeyService.createKey(f, void 0);
              _.set(m), u.add(Ze(() => _.reset()));
            }
          }));
          const a = this._parentContextKeyService.createKey(ke.multiDiffEditorAllCollapsed.key, false);
          this._register(Dt((l) => {
            const u = this._viewModel.read(l);
            if (u) {
              const d = u.items.read(l).every((f) => f.collapsed.read(l));
              a.set(d);
            }
          })), this._register(Dt((l) => {
            const u = this._dimension.read(l);
            this._sizeObserver.observe(u);
          })), this._register(Dt((l) => {
            const u = this._viewItems.read(l);
            this._elements.placeholder.classList.toggle("visible", u.length === 0);
          })), this._scrollableElements.content.style.position = "relative", this._register(Dt((l) => {
            const u = this._sizeObserver.height.read(l);
            this._scrollableElements.root.style.height = `${u}px`;
            const d = this._totalHeight.read(l);
            this._scrollableElements.content.style.height = `${d}px`;
            const f = this._sizeObserver.width.read(l);
            let m = f;
            const _ = this._viewItems.read(l), b = k8(_, fr((v) => v.maxScroll.read(l).maxScroll, Zc));
            if (b) {
              const v = b.maxScroll.read(l);
              m = f + v.maxScroll;
            }
            this._scrollableElement.setScrollDimensions({
              width: f,
              height: u,
              scrollHeight: d,
              scrollWidth: m
            });
          })), e.replaceChildren(this._elements.root), this._register(Ze(() => {
            e.replaceChildren();
          })), this._register(this._register(Dt((l) => {
            op((u) => {
              this.render(l);
            });
          })));
        }
        render(e) {
          const t = this.scrollTop.read(e);
          let i = 0, n = 0, o = 0;
          const r = this._sizeObserver.height.read(e), a = Qe.ofStartAndLength(t, r), l = this._sizeObserver.width.read(e);
          for (const u of this._viewItems.read(e)) {
            const d = u.contentHeight.read(e), f = Math.min(d, r), m = Qe.ofStartAndLength(n, f), _ = Qe.ofStartAndLength(o, d);
            if (_.isBefore(a)) i -= d - f, u.hide();
            else if (_.isAfter(a)) u.hide();
            else {
              const b = Math.max(0, Math.min(a.start - _.start, d - f));
              i -= b;
              const v = Qe.ofStartAndLength(t + i, r);
              u.render(m, b, l, v);
            }
            n += f + this._spaceBetweenPx, o += d + this._spaceBetweenPx;
          }
          this._scrollableElements.content.style.transform = `translateY(${-(t + i)}px)`;
        }
      };
      SE = mde([
        A7(4, Mt),
        A7(5, Ft)
      ], SE);
      class pde extends he {
        constructor(e, t, i, n) {
          super(), this.viewModel = e, this._objectPool = t, this._scrollLeft = i, this._deltaScrollVertical = n, this._templateRef = this._register(q6(this, void 0)), this.contentHeight = Ye(this, (o) => {
            var _a3, _b3;
            return ((_b3 = (_a3 = this._templateRef.read(o)) == null ? void 0 : _a3.object.contentHeight) == null ? void 0 : _b3.read(o)) ?? this.viewModel.lastTemplateData.read(o).contentHeight;
          }), this.maxScroll = Ye(this, (o) => {
            var _a3;
            return ((_a3 = this._templateRef.read(o)) == null ? void 0 : _a3.object.maxScroll.read(o)) ?? {
              maxScroll: 0,
              scrollWidth: 0
            };
          }), this.template = Ye(this, (o) => {
            var _a3;
            return (_a3 = this._templateRef.read(o)) == null ? void 0 : _a3.object;
          }), this._isHidden = Ct(this, false), this._isFocused = Ye(this, (o) => {
            var _a3;
            return ((_a3 = this.template.read(o)) == null ? void 0 : _a3.isFocused.read(o)) ?? false;
          }), this.viewModel.setIsFocused(this._isFocused, void 0), this._register(Dt((o) => {
            var _a3;
            const r = this._scrollLeft.read(o);
            (_a3 = this._templateRef.read(o)) == null ? void 0 : _a3.object.setScrollLeft(r);
          })), this._register(Dt((o) => {
            const r = this._templateRef.read(o);
            !r || !this._isHidden.read(o) || r.object.isFocused.read(o) || this._clear();
          }));
        }
        dispose() {
          this._clear(), super.dispose();
        }
        toString() {
          var _a3;
          return `VirtualViewItem(${(_a3 = this.viewModel.documentDiffItem.modified) == null ? void 0 : _a3.uri.toString()})`;
        }
        getKey() {
          return this.viewModel.getKey();
        }
        setViewState(e, t) {
          var _a3;
          this.viewModel.collapsed.set(e.collapsed, t), this._updateTemplateData(t);
          const i = this.viewModel.lastTemplateData.get(), n = (_a3 = e.selections) == null ? void 0 : _a3.map(mt.liftSelection);
          this.viewModel.lastTemplateData.set({
            ...i,
            selections: n
          }, t);
          const o = this._templateRef.get();
          o && n && o.object.editor.setSelections(n);
        }
        _updateTemplateData(e) {
          const t = this._templateRef.get();
          t && this.viewModel.lastTemplateData.set({
            contentHeight: t.object.contentHeight.get(),
            selections: t.object.editor.getSelections() ?? void 0
          }, e);
        }
        _clear() {
          const e = this._templateRef.get();
          e && Yi((t) => {
            this._updateTemplateData(t), e.object.hide(), this._templateRef.set(void 0, t);
          });
        }
        hide() {
          this._isHidden.set(true, void 0);
        }
        render(e, t, i, n) {
          this._isHidden.set(false, void 0);
          let o = this._templateRef.get();
          if (!o) {
            o = this._objectPool.getUnusedObj(new fde(this.viewModel, this._deltaScrollVertical)), this._templateRef.set(o, void 0);
            const r = this.viewModel.lastTemplateData.get().selections;
            r && o.object.editor.setSelections(r);
          }
          o.object.render(e, i, t, n);
        }
      }
      B("multiDiffEditor.headerBackground", {
        dark: "#262626",
        light: "tab.inactiveBackground",
        hcDark: "tab.inactiveBackground",
        hcLight: "tab.inactiveBackground"
      }, C("multiDiffEditor.headerBackground", "The background color of the diff editor's header"));
      B("multiDiffEditor.background", qr, C("multiDiffEditor.background", "The background color of the multi file diff editor"));
      B("multiDiffEditor.border", {
        dark: "sideBarSectionHeader.border",
        light: "#cccccc",
        hcDark: "sideBarSectionHeader.border",
        hcLight: "#cccccc"
      }, C("multiDiffEditor.border", "The border color of the multi file diff editor"));
      var _de = function(s, e, t, i) {
        var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
        else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
        return n > 3 && o && Object.defineProperty(e, t, o), o;
      }, bde = function(s, e) {
        return function(t, i) {
          e(t, i, s);
        };
      };
      let LE = class extends he {
        constructor(e, t, i) {
          super(), this._element = e, this._workbenchUIElementFactory = t, this._instantiationService = i, this._dimension = Ct(this, void 0), this._viewModel = Ct(this, void 0), this._widgetImpl = Tg(this, (n, o) => (or(MC, n), o.add(this._instantiationService.createInstance(or(SE, n), this._element, this._dimension, this._viewModel, this._workbenchUIElementFactory)))), this._register(ww(this._widgetImpl));
        }
      };
      LE = _de([
        bde(2, Ft)
      ], LE);
      function vde(s, e, t) {
        return Pe.initialize(t || {}).createInstance(wE, s, e);
      }
      function Cde(s) {
        return Pe.get(Xi).onCodeEditorAdd((t) => {
          s(t);
        });
      }
      function wde(s) {
        return Pe.get(Xi).onDiffEditorAdd((t) => {
          s(t);
        });
      }
      function yde() {
        return Pe.get(Xi).listCodeEditors();
      }
      function Sde() {
        return Pe.get(Xi).listDiffEditors();
      }
      function Lde(s, e, t) {
        return Pe.initialize(t || {}).createInstance(yE, s, e);
      }
      function xde(s, e) {
        const t = Pe.initialize(e || {});
        return new LE(s, {}, t);
      }
      function kde(s) {
        if (typeof s.id != "string" || typeof s.run != "function") throw new Error("Invalid command descriptor, `id` and `run` are required properties!");
        return Os.registerCommand(s.id, s.run);
      }
      function Dde(s) {
        if (typeof s.id != "string" || typeof s.label != "string" || typeof s.run != "function") throw new Error("Invalid action descriptor, `id`, `label` and `run` are required properties!");
        const e = Ot.deserialize(s.precondition), t = (n, ...o) => Ph.runEditorCommand(n, o, e, (r, a, l) => Promise.resolve(s.run(a, ...l))), i = new Me();
        if (i.add(Os.registerCommand(s.id, t)), s.contextMenuGroupId) {
          const n = {
            command: {
              id: s.id,
              title: s.label
            },
            when: e,
            group: s.contextMenuGroupId,
            order: s.contextMenuOrder || 0
          };
          i.add(sg.appendMenuItem(Q.EditorContext, n));
        }
        if (Array.isArray(s.keybindings)) {
          const n = Pe.get(Pn);
          if (!(n instanceof vg)) console.warn("Cannot add keybinding because the editor is configured with an unrecognized KeybindingService");
          else {
            const o = Ot.and(e, Ot.deserialize(s.keybindingContext));
            i.add(n.addDynamicKeybindings(s.keybindings.map((r) => ({
              keybinding: r,
              command: s.id,
              when: o
            }))));
          }
        }
        return i;
      }
      function Ede(s) {
        return eV([
          s
        ]);
      }
      function eV(s) {
        const e = Pe.get(Pn);
        return e instanceof vg ? e.addDynamicKeybindings(s.map((t) => ({
          keybinding: t.keybinding,
          command: t.command,
          commandArgs: t.commandArgs,
          when: Ot.deserialize(t.when)
        }))) : (console.warn("Cannot add keybinding because the editor is configured with an unrecognized KeybindingService"), he.None);
      }
      function Tde(s, e, t) {
        const i = Pe.get(un), n = i.getLanguageIdByMimeType(e) || e;
        return JF(Pe.get(_s), i, s, n, t);
      }
      function Nde(s, e) {
        const t = Pe.get(un), i = t.getLanguageIdByMimeType(e) || e || gr;
        s.setLanguage(t.createById(i));
      }
      function Ide(s, e, t) {
        s && Pe.get(td).changeOne(e, s.uri, t);
      }
      function Mde(s) {
        Pe.get(td).changeAll(s, []);
      }
      function Ade(s) {
        return Pe.get(td).read(s);
      }
      function Rde(s) {
        return Pe.get(td).onMarkerChanged(s);
      }
      function Ode(s) {
        return Pe.get(_s).getModel(s);
      }
      function Pde() {
        return Pe.get(_s).getModels();
      }
      function Bde(s) {
        return Pe.get(_s).onModelAdded(s);
      }
      function Fde(s) {
        return Pe.get(_s).onModelRemoved(s);
      }
      function Vde(s) {
        return Pe.get(_s).onModelLanguageChanged((t) => {
          s({
            model: t.model,
            oldLanguage: t.oldLanguageId
          });
        });
      }
      function Wde(s) {
        return _ae(Pe.get(_s), s);
      }
      function Hde(s, e) {
        const t = Pe.get(un), i = Pe.get(wr);
        return jN.colorizeElement(i, t, s, e).then(() => {
          i.registerEditorContainer(s);
        });
      }
      function zde(s, e, t) {
        const i = Pe.get(un);
        return Pe.get(wr).registerEditorContainer(Kt.document.body), jN.colorize(i, s, e, t);
      }
      function Ude(s, e, t = 4) {
        return Pe.get(wr).registerEditorContainer(Kt.document.body), jN.colorizeModelLine(s, e, t);
      }
      function $de(s) {
        const e = Bi.get(s);
        return e || {
          getInitialState: () => a_,
          tokenize: (t, i, n) => B6(s, n)
        };
      }
      function qde(s, e) {
        Bi.getOrCreate(e);
        const t = $de(e), i = xg(s), n = [];
        let o = t.getInitialState();
        for (let r = 0, a = i.length; r < a; r++) {
          const l = i[r], u = t.tokenize(l, true, o);
          n[r] = u.tokens, o = u.endState;
        }
        return n;
      }
      function Kde(s, e) {
        Pe.get(wr).defineTheme(s, e);
      }
      function jde(s) {
        Pe.get(wr).setTheme(s);
      }
      function Gde() {
        Gk.clearAllFontInfos();
      }
      function Yde(s, e) {
        return Os.registerCommand({
          id: s,
          handler: e
        });
      }
      function Zde(s) {
        return Pe.get(X_).registerOpener({
          async open(t) {
            return typeof t == "string" && (t = st.parse(t)), s.open(t);
          }
        });
      }
      function Qde(s) {
        return Pe.get(Xi).registerCodeEditorOpenHandler(async (t, i, n) => {
          var _a3;
          if (!i) return null;
          const o = (_a3 = t.options) == null ? void 0 : _a3.selection;
          let r;
          return o && typeof o.endLineNumber == "number" && typeof o.endColumn == "number" ? r = o : o && (r = {
            lineNumber: o.startLineNumber,
            column: o.startColumn
          }), await s.openCodeEditor(i, t.resource, r) ? i : null;
        });
      }
      function Xde() {
        return {
          create: vde,
          getEditors: yde,
          getDiffEditors: Sde,
          onDidCreateEditor: Cde,
          onDidCreateDiffEditor: wde,
          createDiffEditor: Lde,
          addCommand: kde,
          addEditorAction: Dde,
          addKeybindingRule: Ede,
          addKeybindingRules: eV,
          createModel: Tde,
          setModelLanguage: Nde,
          setModelMarkers: Ide,
          getModelMarkers: Ade,
          removeAllMarkers: Mde,
          onDidChangeMarkers: Rde,
          getModels: Pde,
          getModel: Ode,
          onDidCreateModel: Bde,
          onWillDisposeModel: Fde,
          onDidChangeModelLanguage: Vde,
          createWebWorker: Wde,
          colorizeElement: Hde,
          colorize: zde,
          colorizeModelLine: Ude,
          tokenize: qde,
          defineTheme: Kde,
          setTheme: jde,
          remeasureFonts: Gde,
          registerCommand: Yde,
          registerLinkOpener: Zde,
          registerEditorOpener: Qde,
          AccessibilitySupport: Hx,
          ContentWidgetPositionPreference: jx,
          CursorChangeReason: Gx,
          DefaultEndOfLine: Yx,
          EditorAutoIndentStrategy: Qx,
          EditorOption: Xx,
          EndOfLinePreference: Jx,
          EndOfLineSequence: ek,
          MinimapPosition: hk,
          MinimapSectionHeaderStyle: dk,
          MouseTargetType: fk,
          OverlayWidgetPositionPreference: pk,
          OverviewRulerLane: _k,
          GlyphMarginLane: tk,
          RenderLineNumbersType: Ck,
          RenderMinimap: wk,
          ScrollbarVisibility: Sk,
          ScrollType: yk,
          TextEditorCursorBlinkingStyle: Tk,
          TextEditorCursorStyle: Nk,
          TrackedRangeStickiness: Ik,
          WrappingIndent: Mk,
          InjectedTextCursorStops: sk,
          PositionAffinity: vk,
          ShowLightbulbIconMode: xk,
          ConfigurationChangedEvent: o9,
          BareFontInfo: Ch,
          FontInfo: jk,
          TextModelResolvedOptions: C0,
          FindMatch: e_,
          ApplyUpdateResult: gp,
          EditorZoom: Ic,
          createMultiFileDiffEditor: xde,
          EditorType: $N,
          EditorOptions: Uh
        };
      }
      function Jde(s, e) {
        if (!e || !Array.isArray(e)) return false;
        for (const t of e) if (!s(t)) return false;
        return true;
      }
      function u0(s, e) {
        return typeof s == "boolean" ? s : e;
      }
      function R7(s, e) {
        return typeof s == "string" ? s : e;
      }
      function efe(s) {
        const e = {};
        for (const t of s) e[t] = true;
        return e;
      }
      function O7(s, e = false) {
        e && (s = s.map(function(i) {
          return i.toLowerCase();
        }));
        const t = efe(s);
        return e ? function(i) {
          return t[i.toLowerCase()] !== void 0 && t.hasOwnProperty(i.toLowerCase());
        } : function(i) {
          return t[i] !== void 0 && t.hasOwnProperty(i);
        };
      }
      function xE(s, e, t) {
        e = e.replace(/@@/g, "");
        let i = 0, n;
        do
          n = false, e = e.replace(/@(\w+)/g, function(r, a) {
            n = true;
            let l = "";
            if (typeof s[a] == "string") l = s[a];
            else if (s[a] && s[a] instanceof RegExp) l = s[a].source;
            else throw s[a] === void 0 ? ni(s, "language definition does not contain attribute '" + a + "', used at: " + e) : ni(s, "attribute reference '" + a + "' must be a string, used at: " + e);
            return rh(l) ? "" : "(?:" + l + ")";
          }), i++;
        while (n && i < 5);
        e = e.replace(/\x01/g, "@");
        const o = (s.ignoreCase ? "i" : "") + (s.unicode ? "u" : "");
        if (t && e.match(/\$[sS](\d\d?)/g)) {
          let a = null, l = null;
          return (u) => (l && a === u || (a = u, l = new RegExp(Pae(s, e, u), o)), l);
        }
        return new RegExp(e, o);
      }
      function tfe(s, e, t, i) {
        if (i < 0) return s;
        if (i < e.length) return e[i];
        if (i >= 100) {
          i = i - 100;
          const n = t.split(".");
          if (n.unshift(t), i < n.length) return n[i];
        }
        return null;
      }
      function ife(s, e, t, i) {
        let n = -1, o = t, r = t.match(/^\$(([sS]?)(\d\d?)|#)(.*)$/);
        r && (r[3] && (n = parseInt(r[3]), r[2] && (n = n + 100)), o = r[4]);
        let a = "~", l = o;
        !o || o.length === 0 ? (a = "!=", l = "") : /^\w*$/.test(l) ? a = "==" : (r = o.match(/^(@|!@|~|!~|==|!=)(.*)$/), r && (a = r[1], l = r[2]));
        let u;
        if ((a === "~" || a === "!~") && /^(\w|\|)*$/.test(l)) {
          const d = O7(l.split("|"), s.ignoreCase);
          u = function(f) {
            return a === "~" ? d(f) : !d(f);
          };
        } else if (a === "@" || a === "!@") {
          const d = s[l];
          if (!d) throw ni(s, "the @ match target '" + l + "' is not defined, in rule: " + e);
          if (!Jde(function(m) {
            return typeof m == "string";
          }, d)) throw ni(s, "the @ match target '" + l + "' must be an array of strings, in rule: " + e);
          const f = O7(d, s.ignoreCase);
          u = function(m) {
            return a === "@" ? f(m) : !f(m);
          };
        } else if (a === "~" || a === "!~") if (l.indexOf("$") < 0) {
          const d = xE(s, "^" + l + "$", false);
          u = function(f) {
            return a === "~" ? d.test(f) : !d.test(f);
          };
        } else u = function(d, f, m, _) {
          return xE(s, "^" + Bc(s, l, f, m, _) + "$", false).test(d);
        };
        else if (l.indexOf("$") < 0) {
          const d = Hl(s, l);
          u = function(f) {
            return a === "==" ? f === d : f !== d;
          };
        } else {
          const d = Hl(s, l);
          u = function(f, m, _, b, v) {
            const y = Bc(s, d, m, _, b);
            return a === "==" ? f === y : f !== y;
          };
        }
        return n === -1 ? {
          name: t,
          value: i,
          test: function(d, f, m, _) {
            return u(d, d, f, m, _);
          }
        } : {
          name: t,
          value: i,
          test: function(d, f, m, _) {
            const b = tfe(d, f, m, n);
            return u(b || "", d, f, m, _);
          }
        };
      }
      function kE(s, e, t) {
        if (t) {
          if (typeof t == "string") return t;
          if (t.token || t.token === "") {
            if (typeof t.token != "string") throw ni(s, "a 'token' attribute must be of type string, in rule: " + e);
            {
              const i = {
                token: t.token
              };
              if (t.token.indexOf("$") >= 0 && (i.tokenSubst = true), typeof t.bracket == "string") if (t.bracket === "@open") i.bracket = 1;
              else if (t.bracket === "@close") i.bracket = -1;
              else throw ni(s, "a 'bracket' attribute must be either '@open' or '@close', in rule: " + e);
              if (t.next) {
                if (typeof t.next != "string") throw ni(s, "the next state must be a string value in rule: " + e);
                {
                  let n = t.next;
                  if (!/^(@pop|@push|@popall)$/.test(n) && (n[0] === "@" && (n = n.substr(1)), n.indexOf("$") < 0 && !Bae(s, Bc(s, n, "", [], "")))) throw ni(s, "the next state '" + t.next + "' is not defined in rule: " + e);
                  i.next = n;
                }
              }
              return typeof t.goBack == "number" && (i.goBack = t.goBack), typeof t.switchTo == "string" && (i.switchTo = t.switchTo), typeof t.log == "string" && (i.log = t.log), typeof t.nextEmbedded == "string" && (i.nextEmbedded = t.nextEmbedded, s.usesEmbedded = true), i;
            }
          } else if (Array.isArray(t)) {
            const i = [];
            for (let n = 0, o = t.length; n < o; n++) i[n] = kE(s, e, t[n]);
            return {
              group: i
            };
          } else if (t.cases) {
            const i = [];
            for (const o in t.cases) if (t.cases.hasOwnProperty(o)) {
              const r = kE(s, e, t.cases[o]);
              o === "@default" || o === "@" || o === "" ? i.push({
                test: void 0,
                value: r,
                name: o
              }) : o === "@eos" ? i.push({
                test: function(a, l, u, d) {
                  return d;
                },
                value: r,
                name: o
              }) : i.push(ife(s, e, o, r));
            }
            const n = s.defaultToken;
            return {
              test: function(o, r, a, l) {
                for (const u of i) if (!u.test || u.test(o, r, a, l)) return u.value;
                return n;
              }
            };
          } else throw ni(s, "an action must be a string, an object with a 'token' or 'cases' attribute, or an array of actions; in rule: " + e);
        } else return {
          token: ""
        };
      }
      class nfe {
        constructor(e) {
          this.regex = new RegExp(""), this.action = {
            token: ""
          }, this.matchOnlyAtLineStart = false, this.name = "", this.name = e;
        }
        setRegex(e, t) {
          let i;
          if (typeof t == "string") i = t;
          else if (t instanceof RegExp) i = t.source;
          else throw ni(e, "rules must start with a match string or regular expression: " + this.name);
          this.matchOnlyAtLineStart = i.length > 0 && i[0] === "^", this.name = this.name + ": " + i, this.regex = xE(e, "^(?:" + (this.matchOnlyAtLineStart ? i.substr(1) : i) + ")", true);
        }
        setAction(e, t) {
          this.action = kE(e, this.name, t);
        }
        resolveRegex(e) {
          return this.regex instanceof RegExp ? this.regex : this.regex(e);
        }
      }
      function tV(s, e) {
        if (!e || typeof e != "object") throw new Error("Monarch: expecting a language definition object");
        const t = {
          languageId: s,
          includeLF: u0(e.includeLF, false),
          noThrow: false,
          maxStack: 100,
          start: typeof e.start == "string" ? e.start : null,
          ignoreCase: u0(e.ignoreCase, false),
          unicode: u0(e.unicode, false),
          tokenPostfix: R7(e.tokenPostfix, "." + s),
          defaultToken: R7(e.defaultToken, "source"),
          usesEmbedded: false,
          stateNames: {},
          tokenizer: {},
          brackets: []
        }, i = e;
        i.languageId = s, i.includeLF = t.includeLF, i.ignoreCase = t.ignoreCase, i.unicode = t.unicode, i.noThrow = t.noThrow, i.usesEmbedded = t.usesEmbedded, i.stateNames = e.tokenizer, i.defaultToken = t.defaultToken;
        function n(r, a, l) {
          for (const u of l) {
            let d = u.include;
            if (d) {
              if (typeof d != "string") throw ni(t, "an 'include' attribute must be a string at: " + r);
              if (d[0] === "@" && (d = d.substr(1)), !e.tokenizer[d]) throw ni(t, "include target '" + d + "' is not defined at: " + r);
              n(r + "." + d, a, e.tokenizer[d]);
            } else {
              const f = new nfe(r);
              if (Array.isArray(u) && u.length >= 1 && u.length <= 3) if (f.setRegex(i, u[0]), u.length >= 3) if (typeof u[1] == "string") f.setAction(i, {
                token: u[1],
                next: u[2]
              });
              else if (typeof u[1] == "object") {
                const m = u[1];
                m.next = u[2], f.setAction(i, m);
              } else throw ni(t, "a next state as the last element of a rule can only be given if the action is either an object or a string, at: " + r);
              else f.setAction(i, u[1]);
              else {
                if (!u.regex) throw ni(t, "a rule must either be an array, or an object with a 'regex' or 'include' field at: " + r);
                u.name && typeof u.name == "string" && (f.name = u.name), u.matchOnlyAtStart && (f.matchOnlyAtLineStart = u0(u.matchOnlyAtLineStart, false)), f.setRegex(i, u.regex), f.setAction(i, u.action);
              }
              a.push(f);
            }
          }
        }
        if (!e.tokenizer || typeof e.tokenizer != "object") throw ni(t, "a language definition must define the 'tokenizer' attribute as an object");
        t.tokenizer = [];
        for (const r in e.tokenizer) if (e.tokenizer.hasOwnProperty(r)) {
          t.start || (t.start = r);
          const a = e.tokenizer[r];
          t.tokenizer[r] = new Array(), n("tokenizer." + r, t.tokenizer[r], a);
        }
        if (t.usesEmbedded = i.usesEmbedded, e.brackets) {
          if (!Array.isArray(e.brackets)) throw ni(t, "the 'brackets' attribute must be defined as an array");
        } else e.brackets = [
          {
            open: "{",
            close: "}",
            token: "delimiter.curly"
          },
          {
            open: "[",
            close: "]",
            token: "delimiter.square"
          },
          {
            open: "(",
            close: ")",
            token: "delimiter.parenthesis"
          },
          {
            open: "<",
            close: ">",
            token: "delimiter.angle"
          }
        ];
        const o = [];
        for (const r of e.brackets) {
          let a = r;
          if (a && Array.isArray(a) && a.length === 3 && (a = {
            token: a[2],
            open: a[0],
            close: a[1]
          }), a.open === a.close) throw ni(t, "open and close brackets in a 'brackets' attribute must be different: " + a.open + `
 hint: use the 'bracket' attribute if matching on equal brackets is required.`);
          if (typeof a.open == "string" && typeof a.token == "string" && typeof a.close == "string") o.push({
            token: a.token + t.tokenPostfix,
            open: Hl(t, a.open),
            close: Hl(t, a.close)
          });
          else throw ni(t, "every element in the 'brackets' array must be a '{open,close,token}' object or array");
        }
        return t.brackets = o, t.noThrow = true, t;
      }
      function sfe(s) {
        og.registerLanguage(s);
      }
      function ofe() {
        let s = [];
        return s = s.concat(og.getLanguages()), s;
      }
      function rfe(s) {
        return Pe.get(un).languageIdCodec.encodeLanguageId(s);
      }
      function afe(s, e) {
        return Pe.withServices(() => {
          const i = Pe.get(un).onDidRequestRichLanguageFeatures((n) => {
            n === s && (i.dispose(), e());
          });
          return i;
        });
      }
      function lfe(s, e) {
        return Pe.withServices(() => {
          const i = Pe.get(un).onDidRequestBasicLanguageFeatures((n) => {
            n === s && (i.dispose(), e());
          });
          return i;
        });
      }
      function cfe(s, e) {
        if (!Pe.get(un).isRegisteredLanguageId(s)) throw new Error(`Cannot set configuration for unknown language ${s}`);
        return Pe.get(Pa).register(s, e, 100);
      }
      class ufe {
        constructor(e, t) {
          this._languageId = e, this._actual = t;
        }
        dispose() {
        }
        getInitialState() {
          return this._actual.getInitialState();
        }
        tokenize(e, t, i) {
          if (typeof this._actual.tokenize == "function") return M_.adaptTokenize(this._languageId, this._actual, e, i);
          throw new Error("Not supported!");
        }
        tokenizeEncoded(e, t, i) {
          const n = this._actual.tokenizeEncoded(e, i);
          return new VC(n.tokens, n.endState);
        }
      }
      class M_ {
        constructor(e, t, i, n) {
          this._languageId = e, this._actual = t, this._languageService = i, this._standaloneThemeService = n;
        }
        dispose() {
        }
        getInitialState() {
          return this._actual.getInitialState();
        }
        static _toClassicTokens(e, t) {
          const i = [];
          let n = 0;
          for (let o = 0, r = e.length; o < r; o++) {
            const a = e[o];
            let l = a.startIndex;
            o === 0 ? l = 0 : l < n && (l = n), i[o] = new Gp(l, a.scopes, t), n = l;
          }
          return i;
        }
        static adaptTokenize(e, t, i, n) {
          const o = t.tokenize(i, n), r = M_._toClassicTokens(o.tokens, e);
          let a;
          return o.endState.equals(n) ? a = n : a = o.endState, new $E(r, a);
        }
        tokenize(e, t, i) {
          return M_.adaptTokenize(this._languageId, this._actual, e, i);
        }
        _toBinaryTokens(e, t) {
          const i = e.encodeLanguageId(this._languageId), n = this._standaloneThemeService.getColorTheme().tokenTheme, o = [];
          let r = 0, a = 0;
          for (let u = 0, d = t.length; u < d; u++) {
            const f = t[u], m = n.match(i, f.scopes) | 1024;
            if (r > 0 && o[r - 1] === m) continue;
            let _ = f.startIndex;
            u === 0 ? _ = 0 : _ < a && (_ = a), o[r++] = _, o[r++] = m, a = _;
          }
          const l = new Uint32Array(r);
          for (let u = 0; u < r; u++) l[u] = o[u];
          return l;
        }
        tokenizeEncoded(e, t, i) {
          const n = this._actual.tokenize(e, i), o = this._toBinaryTokens(this._languageService.languageIdCodec, n.tokens);
          let r;
          return n.endState.equals(i) ? r = i : r = n.endState, new VC(o, r);
        }
      }
      function hfe(s) {
        return typeof s.getInitialState == "function";
      }
      function dfe(s) {
        return "tokenizeEncoded" in s;
      }
      function iV(s) {
        return s && typeof s.then == "function";
      }
      function ffe(s) {
        const e = Pe.get(wr);
        if (s) {
          const t = [
            null
          ];
          for (let i = 1, n = s.length; i < n; i++) t[i] = le.fromHex(s[i]);
          e.setColorMapOverride(t);
        } else e.setColorMapOverride(null);
      }
      function nV(s, e) {
        return dfe(e) ? new ufe(s, e) : new M_(s, e, Pe.get(un), Pe.get(wr));
      }
      function LI(s, e) {
        const t = new wq(async () => {
          const i = await Promise.resolve(e.create());
          return i ? hfe(i) ? nV(s, i) : new L_(Pe.get(un), Pe.get(wr), s, tV(s, i), Pe.get(Si)) : null;
        });
        return Bi.registerFactory(s, t);
      }
      function gfe(s, e) {
        if (!Pe.get(un).isRegisteredLanguageId(s)) throw new Error(`Cannot set tokens provider for unknown language ${s}`);
        return iV(e) ? LI(s, {
          create: () => e
        }) : Bi.register(s, nV(s, e));
      }
      function mfe(s, e) {
        const t = (i) => new L_(Pe.get(un), Pe.get(wr), s, tV(s, i), Pe.get(Si));
        return iV(e) ? LI(s, {
          create: () => e
        }) : Bi.register(s, t(e));
      }
      function pfe(s, e) {
        return Pe.get(jt).referenceProvider.register(s, e);
      }
      function _fe(s, e) {
        return Pe.get(jt).renameProvider.register(s, e);
      }
      function bfe(s, e) {
        return Pe.get(jt).newSymbolNamesProvider.register(s, e);
      }
      function vfe(s, e) {
        return Pe.get(jt).signatureHelpProvider.register(s, e);
      }
      function Cfe(s, e) {
        return Pe.get(jt).hoverProvider.register(s, {
          provideHover: async (i, n, o, r) => {
            const a = i.getWordAtPosition(n);
            return Promise.resolve(e.provideHover(i, n, o, r)).then((l) => {
              if (l) return !l.range && a && (l.range = new z(n.lineNumber, a.startColumn, n.lineNumber, a.endColumn)), l.range || (l.range = new z(n.lineNumber, n.column, n.lineNumber, n.column)), l;
            });
          }
        });
      }
      function wfe(s, e) {
        return Pe.get(jt).documentSymbolProvider.register(s, e);
      }
      function yfe(s, e) {
        return Pe.get(jt).documentHighlightProvider.register(s, e);
      }
      function Sfe(s, e) {
        return Pe.get(jt).linkedEditingRangeProvider.register(s, e);
      }
      function Lfe(s, e) {
        return Pe.get(jt).definitionProvider.register(s, e);
      }
      function xfe(s, e) {
        return Pe.get(jt).implementationProvider.register(s, e);
      }
      function kfe(s, e) {
        return Pe.get(jt).typeDefinitionProvider.register(s, e);
      }
      function Dfe(s, e) {
        return Pe.get(jt).codeLensProvider.register(s, e);
      }
      function Efe(s, e, t) {
        return Pe.get(jt).codeActionProvider.register(s, {
          providedCodeActionKinds: t == null ? void 0 : t.providedCodeActionKinds,
          documentation: t == null ? void 0 : t.documentation,
          provideCodeActions: (n, o, r, a) => {
            const u = Pe.get(td).read({
              resource: n.uri
            }).filter((d) => z.areIntersectingOrTouching(d, o));
            return e.provideCodeActions(n, o, {
              markers: u,
              only: r.only,
              trigger: r.trigger
            }, a);
          },
          resolveCodeAction: e.resolveCodeAction
        });
      }
      function Tfe(s, e) {
        return Pe.get(jt).documentFormattingEditProvider.register(s, e);
      }
      function Nfe(s, e) {
        return Pe.get(jt).documentRangeFormattingEditProvider.register(s, e);
      }
      function Ife(s, e) {
        return Pe.get(jt).onTypeFormattingEditProvider.register(s, e);
      }
      function Mfe(s, e) {
        return Pe.get(jt).linkProvider.register(s, e);
      }
      function Afe(s, e) {
        return Pe.get(jt).completionProvider.register(s, e);
      }
      function Rfe(s, e) {
        return Pe.get(jt).colorProvider.register(s, e);
      }
      function Ofe(s, e) {
        return Pe.get(jt).foldingRangeProvider.register(s, e);
      }
      function Pfe(s, e) {
        return Pe.get(jt).declarationProvider.register(s, e);
      }
      function Bfe(s, e) {
        return Pe.get(jt).selectionRangeProvider.register(s, e);
      }
      function Ffe(s, e) {
        return Pe.get(jt).documentSemanticTokensProvider.register(s, e);
      }
      function Vfe(s, e) {
        return Pe.get(jt).documentRangeSemanticTokensProvider.register(s, e);
      }
      function Wfe(s, e) {
        return Pe.get(jt).inlineCompletionsProvider.register(s, e);
      }
      function Hfe(s, e) {
        return Pe.get(jt).inlineEditProvider.register(s, e);
      }
      function zfe(s, e) {
        return Pe.get(jt).inlayHintsProvider.register(s, e);
      }
      function Ufe() {
        return {
          register: sfe,
          getLanguages: ofe,
          onLanguage: afe,
          onLanguageEncountered: lfe,
          getEncodedLanguageId: rfe,
          setLanguageConfiguration: cfe,
          setColorMap: ffe,
          registerTokensProviderFactory: LI,
          setTokensProvider: gfe,
          setMonarchTokensProvider: mfe,
          registerReferenceProvider: pfe,
          registerRenameProvider: _fe,
          registerNewSymbolNameProvider: bfe,
          registerCompletionItemProvider: Afe,
          registerSignatureHelpProvider: vfe,
          registerHoverProvider: Cfe,
          registerDocumentSymbolProvider: wfe,
          registerDocumentHighlightProvider: yfe,
          registerLinkedEditingRangeProvider: Sfe,
          registerDefinitionProvider: Lfe,
          registerImplementationProvider: xfe,
          registerTypeDefinitionProvider: kfe,
          registerCodeLensProvider: Dfe,
          registerCodeActionProvider: Efe,
          registerDocumentFormattingEditProvider: Tfe,
          registerDocumentRangeFormattingEditProvider: Nfe,
          registerOnTypeFormattingEditProvider: Ife,
          registerLinkProvider: Mfe,
          registerColorProvider: Rfe,
          registerFoldingRangeProvider: Ofe,
          registerDeclarationProvider: Pfe,
          registerSelectionRangeProvider: Bfe,
          registerDocumentSemanticTokensProvider: Ffe,
          registerDocumentRangeSemanticTokensProvider: Vfe,
          registerInlineCompletionsProvider: Wfe,
          registerInlineEditProvider: Hfe,
          registerInlayHintsProvider: zfe,
          DocumentHighlightKind: Zx,
          CompletionItemKind: $x,
          CompletionItemTag: qx,
          CompletionItemInsertTextRule: Ux,
          SymbolKind: Dk,
          SymbolTag: Ek,
          IndentAction: nk,
          CompletionTriggerKind: Kx,
          SignatureHelpTriggerKind: kk,
          InlayHintKind: ok,
          InlineCompletionTriggerKind: rk,
          InlineEditTriggerKind: ak,
          CodeActionTriggerType: zx,
          NewSymbolNameTag: gk,
          NewSymbolNameTriggerKind: mk,
          PartialAcceptTriggerKind: bk,
          HoverVerbosityAction: ik,
          FoldingRangeKind: pl,
          SelectedSuggestionInfo: Cq
        };
      }
      const sV = pt("IEditorCancelService"), oV = new Ie("cancellableOperation", false, C("cancellableOperation", "Whether the editor runs a cancellable operation, e.g. like 'Peek References'"));
      Lt(sV, class {
        constructor() {
          this._tokens = /* @__PURE__ */ new WeakMap();
        }
        add(s, e) {
          let t = this._tokens.get(s);
          t || (t = s.invokeWithinContext((n) => {
            const o = oV.bindTo(n.get(Mt)), r = new Us();
            return {
              key: o,
              tokens: r
            };
          }), this._tokens.set(s, t));
          let i;
          return t.key.set(true), i = t.tokens.push(e), () => {
            i && (i(), t.key.set(!t.tokens.isEmpty()), i = void 0);
          };
        }
        cancel(s) {
          const e = this._tokens.get(s);
          if (!e) return;
          const t = e.tokens.pop();
          t && (t.cancel(), e.key.set(!e.tokens.isEmpty()));
        }
      }, 1);
      Ge(new class extends Ph {
        constructor() {
          super({
            id: "editor.cancelOperation",
            kbOpts: {
              weight: 100,
              primary: 9
            },
            precondition: oV
          });
        }
        runEditorCommand(s, e) {
          s.get(sV).cancel(e);
        }
      }());
      class P7 {
        constructor(e) {
          this.value = e, this._lower = e.toLowerCase();
        }
        static toKey(e) {
          return typeof e == "string" ? e.toLowerCase() : e._lower;
        }
      }
      class $fe {
        constructor(e) {
          if (this._set = /* @__PURE__ */ new Set(), e) for (const t of e) this.add(t);
        }
        add(e) {
          this._set.add(P7.toKey(e));
        }
        has(e) {
          return this._set.has(P7.toKey(e));
        }
      }
      function qfe(s, e, t) {
        const i = [], n = new $fe(), o = s.ordered(t);
        for (const a of o) i.push(a), a.extensionId && n.add(a.extensionId);
        const r = e.ordered(t);
        for (const a of r) {
          if (a.extensionId) {
            if (n.has(a.extensionId)) continue;
            n.add(a.extensionId);
          }
          i.push({
            displayName: a.displayName,
            extensionId: a.extensionId,
            provideDocumentFormattingEdits(l, u, d) {
              return a.provideDocumentRangeFormattingEdits(l, l.getFullModelRange(), u, d);
            }
          });
        }
        return i;
      }
      const _AC = class _AC {
        static setFormatterSelector(e) {
          return {
            dispose: _AC._selectors.unshift(e)
          };
        }
        static async select(e, t, i, n) {
          if (e.length === 0) return;
          const o = kt.first(_AC._selectors);
          if (o) return await o(e, t, i, n);
        }
      };
      _AC._selectors = new Us();
      let AC = _AC;
      async function Kfe(s, e, t, i, n, o) {
        const r = e.documentRangeFormattingEditProvider.ordered(t);
        for (const a of r) {
          const l = await Promise.resolve(a.provideDocumentRangeFormattingEdits(t, i, n, o)).catch(BE);
          if (OC(l)) return await s.computeMoreMinimalEdits(t.uri, l);
        }
      }
      async function jfe(s, e, t, i, n) {
        const o = qfe(e.documentFormattingEditProvider, e.documentRangeFormattingEditProvider, t);
        for (const r of o) {
          const a = await Promise.resolve(r.provideDocumentFormattingEdits(t, i, n)).catch(BE);
          if (OC(a)) return await s.computeMoreMinimalEdits(t.uri, a);
        }
      }
      function Gfe(s, e, t, i, n, o, r) {
        const a = e.onTypeFormattingEditProvider.ordered(t);
        return a.length === 0 || a[0].autoFormatTriggerCharacters.indexOf(n) < 0 ? Promise.resolve(void 0) : Promise.resolve(a[0].provideOnTypeFormattingEdits(t, i, n, o, r)).catch(BE).then((l) => s.computeMoreMinimalEdits(t.uri, l));
      }
      Os.registerCommand("_executeFormatRangeProvider", async function(s, ...e) {
        const [t, i, n] = e;
        Qc(st.isUri(t)), Qc(z.isIRange(i));
        const o = s.get(qC), r = s.get(n1), a = s.get(jt), l = await o.createModelReference(t);
        try {
          return Kfe(r, a, l.object.textEditorModel, z.lift(i), n, mr.None);
        } finally {
          l.dispose();
        }
      });
      Os.registerCommand("_executeFormatDocumentProvider", async function(s, ...e) {
        const [t, i] = e;
        Qc(st.isUri(t));
        const n = s.get(qC), o = s.get(n1), r = s.get(jt), a = await n.createModelReference(t);
        try {
          return jfe(o, r, a.object.textEditorModel, i, mr.None);
        } finally {
          a.dispose();
        }
      });
      Os.registerCommand("_executeFormatOnTypeProvider", async function(s, ...e) {
        const [t, i, n, o] = e;
        Qc(st.isUri(t)), Qc(X.isIPosition(i)), Qc(typeof n == "string");
        const r = s.get(qC), a = s.get(n1), l = s.get(jt), u = await r.createModelReference(t);
        try {
          return Gfe(a, l, u.object.textEditorModel, X.lift(i), n, o, mr.None);
        } finally {
          u.dispose();
        }
      });
      Uh.wrappingIndent.defaultValue = 0;
      Uh.glyphMargin.defaultValue = false;
      Uh.autoIndent.defaultValue = 3;
      Uh.overviewRulerLanes.defaultValue = 2;
      AC.setFormatterSelector((s, e, t) => Promise.resolve(s[0]));
      const bs = y9();
      bs.editor = Xde();
      bs.languages = Ufe();
      bs.CancellationTokenSource;
      bs.Emitter;
      bs.KeyCode;
      bs.KeyMod;
      bs.Position;
      const Yfe = bs.Range;
      bs.Selection;
      bs.SelectionDirection;
      bs.MarkerSeverity;
      bs.MarkerTag;
      bs.Uri;
      bs.Token;
      bs.editor;
      bs.languages;
      const Zfe = globalThis.MonacoEnvironment;
      ((Zfe == null ? void 0 : Zfe.globalAPI) || typeof define == "function" && define.amd) && (globalThis.monaco = bs);
      typeof globalThis.require < "u" && typeof globalThis.require.config == "function" && globalThis.require.config({
        ignoreDuplicateModules: [
          "vscode-languageserver-types",
          "vscode-languageserver-types/main",
          "vscode-languageserver-textdocument",
          "vscode-languageserver-textdocument/main",
          "vscode-nls",
          "vscode-nls/vscode-nls",
          "jsonc-parser",
          "jsonc-parser/main",
          "vscode-uri",
          "vscode-uri/index",
          "vs/basic-languages/typescript/typescript"
        ]
      });
      const dp = {}, Qfe = async () => {
        const s = Object.assign({
          "../../crates/compiler/src/tests/pipeline/000/main.gom": () => Be(() => import("./main-DnzVtdrD.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/001/main.gom": () => Be(() => import("./main-TQVXrVCY.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/002/main.gom": () => Be(() => import("./main-ZzRFrjSS.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/003/main.gom": () => Be(() => import("./main-8_81D1Hj.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/004/main.gom": () => Be(() => import("./main-B4exbt42.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/005/main.gom": () => Be(() => import("./main-CVKZp8-v.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/006/main.gom": () => Be(() => import("./main-B7m0N4j3.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/007_expr_pattern_matching/main.gom": () => Be(() => import("./main-CNG0ZU0p.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/008/main.gom": () => Be(() => import("./main-Dk4lKizZ.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/009/main.gom": () => Be(() => import("./main-D3o1o6eN.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/010/main.gom": () => Be(() => import("./main-BGlhCZAq.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/011/main.gom": () => Be(() => import("./main-Dgv8MSXP.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/012/main.gom": () => Be(() => import("./main-Cs-z2hqX.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/013/main.gom": () => Be(() => import("./main-truYuUNI.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/014/main.gom": () => Be(() => import("./main-Cf4QXqkB.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/015/main.gom": () => Be(() => import("./main-C82cS6Zl.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/016/main.gom": () => Be(() => import("./main-DjPDD_D8.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/017/main.gom": () => Be(() => import("./main-pzL5RvIt.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/018_overloading/main.gom": () => Be(() => import("./main-CmSCCbd5.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/019/main.gom": () => Be(() => import("./main-BSvcPkd3.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/020/main.gom": () => Be(() => import("./main-BUIvcc_l.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/021/main.gom": () => Be(() => import("./main-B3g77Bkj.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/022/main.gom": () => Be(() => import("./main-Dnz3keE5.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/023/main.gom": () => Be(() => import("./main-Fpg2-kXa.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/024/main.gom": () => Be(() => import("./main-DQTCuyem.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/025_missing_match/main.gom": () => Be(() => import("./main-BRcXB8mY.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/026_arith_logic/main.gom": () => Be(() => import("./main-CUqUFPQd.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/027_if_basic/main.gom": () => Be(() => import("./main-CM3Zlugp.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/028_if_nested/main.gom": () => Be(() => import("./main-BedmeTyp.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/029_trait_impl/main.gom": () => Be(() => import("./main-htmDqvX2.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/030_array_type/main.gom": () => Be(() => import("./main-BrEhupy2.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/031_array_literal/main.gom": () => Be(() => import("./main-2nLfD8xv.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/032_array_builtins/main.gom": () => Be(() => import("./main-t_XxZzX4.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/033_closure/main.gom": () => Be(() => import("./main-8J2Q99id.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/034_first_class_function/main.gom": () => Be(() => import("./main-Dv37rWxp.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/035_higher_order_calls/main.gom": () => Be(() => import("./main-DiNY5kZo.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/036_ref_updates/main.gom": () => Be(() => import("./main-DxX3aws6.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/037_deep_nested_closure/main.gom": () => Be(() => import("./main-CTolnpX-.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/038_counter_closure/main.gom": () => Be(() => import("./main-DeImaYY-.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/039_sum_100/main.gom": () => Be(() => import("./main-JIdKqoYr.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/040_all_features/main.gom": () => Be(() => import("./main-CvDdJ0J6.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/041_while_loop/main.gom": () => Be(() => import("./main-tlWH-fXv.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/042_go_statement/main.gom": () => Be(() => import("./main-DICoF4WO.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/043_extern_type_stub/main.gom": () => Be(() => import("./main-i27Aoztr.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/044_count_down/main.gom": () => Be(() => import("./main-BjBc_How.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/045_int8_arithmetic/main.gom": () => Be(() => import("./main-DFhjbWLk.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/046_let_annotation/main.gom": () => Be(() => import("./main-BX4cqWhb.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/047_struct_field_access/main.gom": () => Be(() => import("./main-CkXE8Jyr.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/048_int_widths/main.gom": () => Be(() => import("./main-BU4iswPa.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/049_uint_widths/main.gom": () => Be(() => import("./main-B7OyxQk7.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/050_float_ops/main.gom": () => Be(() => import("./main-CuJzN6oi.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/051_int_pattern_matching/main.gom": () => Be(() => import("./main-CootM_fa.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/052_uint_pattern_matching/main.gom": () => Be(() => import("./main-fV_DGASF.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/053_float_pattern_matching/main.gom": () => Be(() => import("./main-C_SqKkVh.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/054_impl_type_name/main.gom": () => Be(() => import("./main-CxJ8zc6Q.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/054_tojson_derive/main.gom": () => Be(() => import("./main-BE97nkbj.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/055_inherent_impl_method_calls/main.gom": () => Be(() => import("./main-lyew5nKk.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/056_builtin_int32_to_string/main.gom": () => Be(() => import("./main-C2oySO2R.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/057/main.gom": () => Be(() => import("./main-D8LwHWJl.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/058_lowercase_constructors/main.gom": () => Be(() => import("./main-Dsf8p5il.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/059_enum_namespace_constructors/main.gom": () => Be(() => import("./main-2LG9ulTt.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/060_attributes/main.gom": () => Be(() => import("./main-CgfJ2D73.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/061/main.gom": () => Be(() => import("./main-CBpMEQ3E.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/062_multiline_string/main.gom": () => Be(() => import("./main-JVPIefon.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/063_comparison_operators/main.gom": () => Be(() => import("./main-DsJVptE1.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/064_vec_builtin/main.gom": () => Be(() => import("./main-CdR0LIBa.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/065_vec_multiple_types/main.gom": () => Be(() => import("./main-Bjp8hx2W.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/066_generic_impl/main.gom": () => Be(() => import("./main-DWzd-X93.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/067_packages_basic/main.gom": () => Be(() => import("./main-IXc7R-vv.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/068_lisp_interp/main.gom": () => Be(() => import("./main-D5C-ZlEf.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/069_dyn_trait/main.gom": () => Be(() => import("./main-CNK0Znmg.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/070_dyn_trait_complex/main.gom": () => Be(() => import("./main-C2bdRd3v.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/071_trait_bound_sets/main.gom": () => Be(() => import("./main-BEDbhaFn.js"), []).then((t) => t.default),
          "../../crates/compiler/src/tests/pipeline/072_trait_bounds_complex/main.gom": () => Be(() => import("./main-BQTzYdzW.js"), []).then((t) => t.default)
        });
        (await Promise.all(Object.entries(s).map(async ([t, i]) => {
          const n = t.split("/"), o = n[n.length - 2] || "unknown", r = await i();
          return [
            o,
            r
          ];
        }))).sort(([t], [i]) => t.localeCompare(i)).forEach(([t, i]) => {
          dp[t] = i;
        });
      }, Xfe = (s) => s instanceof Error ? s.message : String(s), B7 = (s, e) => {
        try {
          return s(e);
        } catch (t) {
          return console.error(t), `error: ${Xfe(t)}`;
        }
      };
      function Jfe() {
        const s = kz(), [e, t] = ft.useState(""), [i, n] = ft.useState(""), [o, r] = ft.useState(""), [a, l] = ft.useState(""), [u, d] = ft.useState("go"), f = ft.useMemo(() => ({
          cst: rU,
          ast: aU,
          tast: lU,
          core: iU,
          mono: nU,
          anf: sU,
          go: oU
        }), []);
        ft.useEffect(() => {
          Qfe().then(() => {
            const v = Object.keys(dp)[0];
            v && (l(v), t(dp[v]));
          });
        }, []), ft.useEffect(() => {
          s && (s.languages.register({
            id: "simple"
          }), s.languages.setMonarchTokensProvider("simple", {
            keywords: [
              "fn",
              "let",
              "in"
            ],
            tokenizer: {
              root: [
                [
                  /\b(fn|struct|enum|trait|impl|for|match|if|else|let|in|return|true|false|unit|bool|int8|int16|int32|int64|uint8|uint16|uint32|uint64|string)\b/,
                  "keyword"
                ],
                [
                  /\b[A-Z][a-zA-Z0-9_]*\b/,
                  "type"
                ],
                [
                  /\b\d+\b/,
                  "number"
                ],
                [
                  /[a-zA-Z_]\w*(?=\s*\()/,
                  "function"
                ],
                [
                  /[a-zA-Z_]\w*/,
                  "identifier"
                ],
                [
                  /[{}()\[\]]/,
                  "@brackets"
                ],
                [
                  /[;,.]/,
                  "delimiter"
                ],
                [
                  /".*?"/,
                  "string"
                ],
                [
                  /\/\/.*/,
                  "comment"
                ]
              ]
            }
          }), s.editor.defineTheme("simpleTheme", {
            base: "vs",
            inherit: true,
            rules: [
              {
                token: "keyword",
                foreground: "0000FF"
              },
              {
                token: "type",
                foreground: "216C86"
              },
              {
                token: "number",
                foreground: "09885A"
              },
              {
                token: "identifier",
                foreground: "001080"
              },
              {
                token: "string",
                foreground: "A31515"
              },
              {
                token: "function",
                foreground: "654D1D"
              }
            ],
            colors: {}
          }), s.languages.registerHoverProvider("simple", {
            provideHover: async (b, v) => {
              const y = v.lineNumber - 1, x = v.column - 1, L = b.getValue(), D = cU(L, y, x);
              return D ? {
                contents: [
                  {
                    value: `\`\`\`simple
${D}
\`\`\``
                  }
                ]
              } : null;
            }
          }), s.languages.registerCompletionItemProvider("simple", {
            triggerCharacters: [
              ".",
              ":"
            ],
            provideCompletionItems: (b, v) => {
              const y = v.lineNumber - 1, x = v.column - 1, L = b.getValue(), D = b.getWordUntilPosition(v), k = D.startColumn - 1, T = b.getLineContent(v.lineNumber), M = k >= 2 && T.slice(k - 2, k) === "::", I = k >= 1 && T[k - 1] === ".", R = new Yfe(v.lineNumber, D.startColumn, v.lineNumber, D.endColumn);
              if (I) {
                let A = [];
                try {
                  const U = uU(L, y, x);
                  A = JSON.parse(U);
                } catch (U) {
                  console.error("dot completion failed", U);
                }
                return {
                  suggestions: A.map((U) => ({
                    label: U.name,
                    kind: U.kind === "method" ? s.languages.CompletionItemKind.Method : s.languages.CompletionItemKind.Field,
                    insertText: U.name,
                    detail: U.detail,
                    range: R
                  }))
                };
              }
              if (M) {
                let A = [];
                try {
                  const U = hU(L, y, x);
                  A = JSON.parse(U);
                } catch (U) {
                  console.error(":: completion failed", U);
                }
                return {
                  suggestions: A.map((U) => ({
                    label: U.name,
                    kind: (() => {
                      switch (U.kind) {
                        case "type":
                          return s.languages.CompletionItemKind.Class;
                        case "trait":
                          return s.languages.CompletionItemKind.Interface;
                        case "variant":
                          return s.languages.CompletionItemKind.EnumMember;
                        case "method":
                          return s.languages.CompletionItemKind.Method;
                        case "value":
                        default:
                          return s.languages.CompletionItemKind.Function;
                      }
                    })(),
                    insertText: U.name,
                    detail: U.detail,
                    range: R
                  }))
                };
              }
              return {
                suggestions: []
              };
            }
          }), s.editor.setTheme("simpleTheme"));
        }, [
          s
        ]), ft.useEffect(() => {
          n(B7(tU, e));
        }, [
          e
        ]), ft.useEffect(() => {
          const b = f[u];
          r(B7(b, e));
        }, [
          e,
          f,
          u
        ]);
        const m = (b) => {
          const v = b.target.value;
          l(v);
          const y = dp[v];
          y !== void 0 && t(y);
        }, _ = (b) => {
          d(b.target.value);
        };
        return Ei.jsxs("div", {
          className: "h-screen flex flex-col",
          children: [
            Ei.jsxs("div", {
              className: "bg-gray-100 p-2 flex items-center",
              children: [
                Ei.jsx("label", {
                  className: "mr-2 font-medium",
                  children: "Select Demo:"
                }),
                Ei.jsx("select", {
                  value: a,
                  onChange: m,
                  className: "border rounded p-1 mr-4",
                  children: Object.keys(dp).map((b) => Ei.jsx("option", {
                    value: b,
                    children: b.replace(/_/g, " ")
                  }, b))
                }),
                Ei.jsx("label", {
                  className: "mr-2 font-medium",
                  children: "View Mode:"
                }),
                Ei.jsxs("select", {
                  value: u,
                  onChange: _,
                  className: "border rounded p-1",
                  children: [
                    Ei.jsx("option", {
                      value: "cst",
                      children: "CST"
                    }),
                    Ei.jsx("option", {
                      value: "ast",
                      children: "AST"
                    }),
                    Ei.jsx("option", {
                      value: "tast",
                      children: "TAST"
                    }),
                    Ei.jsx("option", {
                      value: "core",
                      children: "Core"
                    }),
                    Ei.jsx("option", {
                      value: "mono",
                      children: "Mono"
                    }),
                    Ei.jsx("option", {
                      value: "anf",
                      children: "ANF"
                    }),
                    Ei.jsx("option", {
                      value: "go",
                      children: "Go"
                    })
                  ]
                })
              ]
            }),
            Ei.jsxs("div", {
              className: "flex flex-1",
              children: [
                Ei.jsx("div", {
                  className: "w-1/2 border-r border-gray-300 flex flex-col",
                  children: Ei.jsx(C4, {
                    height: "100%",
                    language: "simple",
                    theme: "simpleTheme",
                    value: e,
                    onChange: (b) => t(b || ""),
                    options: {
                      fontSize: 14,
                      minimap: {
                        enabled: false
                      },
                      automaticLayout: true,
                      stickyScroll: {
                        enabled: false
                      }
                    }
                  })
                }),
                Ei.jsxs("div", {
                  className: "w-1/2 flex flex-col h-full min-h-0",
                  children: [
                    Ei.jsxs("div", {
                      className: "flex-1 min-h-0 overflow-hidden p-4 flex flex-col",
                      children: [
                        Ei.jsx("h2", {
                          className: "text-xl font-bold mb-2",
                          children: u.toUpperCase()
                        }),
                        Ei.jsx("div", {
                          className: "flex-1 min-h-0",
                          children: Ei.jsx(C4, {
                            height: "100%",
                            language: "plaintext",
                            value: o,
                            options: {
                              fontSize: 14,
                              minimap: {
                                enabled: false
                              },
                              readOnly: true,
                              stickyScroll: {
                                enabled: false
                              }
                            }
                          })
                        })
                      ]
                    }),
                    Ei.jsxs("div", {
                      className: "h-[20%] overflow-auto p-4 border-t border-gray-300",
                      children: [
                        Ei.jsx("h2", {
                          className: "text-sm font-bold mb-1",
                          children: "Stdout"
                        }),
                        Ei.jsx("pre", {
                          className: "bg-gray-100 p-2 rounded whitespace-pre-wrap text-sm",
                          children: i
                        })
                      ]
                    })
                  ]
                })
              ]
            })
          ]
        });
      }
      yH.createRoot(document.getElementById("root")).render(Ei.jsx(ft.StrictMode, {
        children: Ei.jsx(Jfe, {})
      }));
    })();
  }
});
export default require_stdin();
