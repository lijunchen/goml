fn make_counter() -> (() -> int, () -> unit) {
  let cell/0: Ref[int] = (ref : (int) -> Ref[int])(0) in
  let next/2: () -> int = || => let next/1: int = (ref_get : (Ref[int]) -> int)((cell/0 : Ref[int])) + 1 in
  let _ : unit = (ref_set : (Ref[int], int) -> unit)((cell/0 : Ref[int]), (next/1 : int)) in
  (next/1 : int) in
  let reset/3: () -> unit = || => let _ : unit = (ref_set : (Ref[int], int) -> unit)((cell/0 : Ref[int]), 0) in
  () in
  ((next/2 : () -> int), (reset/3 : () -> unit))
}

fn main() -> unit {
  let counter/4: (() -> int, () -> unit) = (make_counter : () -> (() -> int, () -> unit))() in
  let (next/5: () -> int, reset/6: () -> unit) = (counter/4 : (() -> int, () -> unit)) in
  let first/7: int = (next/5 : () -> int)() in
  let second/8: int = (next/5 : () -> int)() in
  let _ : unit = (reset/6 : () -> unit)() in
  let third/9: int = (next/5 : () -> int)() in
  let new_counter/10: (() -> int, () -> unit) = (make_counter : () -> (() -> int, () -> unit))() in
  let (new_next/11: () -> int, _ : () -> unit) = (new_counter/10 : (() -> int, () -> unit)) in
  let fourth/12: int = (new_next/11 : () -> int)() in
  let _ : unit = (string_println : (string) -> unit)((int_to_string : (int) -> string)((first/7 : int))) in
  let _ : unit = (string_println : (string) -> unit)((int_to_string : (int) -> string)((second/8 : int))) in
  let _ : unit = (string_println : (string) -> unit)((int_to_string : (int) -> string)((third/9 : int))) in
  let _ : unit = (string_println : (string) -> unit)((int_to_string : (int) -> string)((fourth/12 : int))) in
  ()
}