fn make_point() -> Point {
  Point { x: 0, y: 0 }
}

fn flip(point/0: Point) -> Point {
  let Point { x: x/1: int, y: y/2: int } = (point/0 : Point) in
  Point { x: (y/2 : int), y: (x/1 : int) }
}

fn wrap_int(x/3: int) -> Wrapper[int] {
  Wrapper { value: (x/3 : int) }
}

fn x_add_1(p/4: Point) -> Point {
  let Point { x: x/5: int, y: y/6: int } = (p/4 : Point) in
  Point { x: (x/5 : int) + 1, y: (y/6 : int) }
}

fn get_x(p/7: Point) -> int {
  let Point { x: x/8: int, y: y/9: int } = (p/7 : Point) in
  (x/8 : int)
}

fn get_y(p/10: Point) -> int {
  let Point { x: x/11: int, y: y/12: int } = (p/10 : Point) in
  (y/12 : int)
}

fn point_to_string(p/13: Point) -> string {
  let Point { x: x/14: int, y: y/15: int } = (p/13 : Point) in
  (string_add : (string, string) -> string)((string_add : (string, string) -> string)((string_add : (string, string) -> string)("Point { x: ", (int_to_string : (int) -> string)((x/14 : int))), (string_add : (string, string) -> string)(", y: ", (int_to_string : (int) -> string)((y/15 : int)))), "}")
}

fn main() -> unit {
  let start/16: Point = (make_point : () -> Point)() in
  let _ : unit = (string_println : (string) -> unit)((point_to_string : (Point) -> string)((start/16 : Point))) in
  let swapped/17: Point = (flip : (Point) -> Point)(Point { x: 1, y: 2 }) in
  let _ : unit = (string_println : (string) -> unit)((point_to_string : (Point) -> string)((swapped/17 : Point))) in
  let boxed/18: Wrapper[int] = (wrap_int : (int) -> Wrapper[int])(3) in
  let point_box/19: Wrapper[Point] = Wrapper { value: (swapped/17 : Point) } in
  let a/20: Point = (x_add_1 : (Point) -> Point)((start/16 : Point)) in
  let _ : unit = (string_println : (string) -> unit)((point_to_string : (Point) -> string)((a/20 : Point))) in
  let a/21: Point = (flip : (Point) -> Point)((x_add_1 : (Point) -> Point)((start/16 : Point))) in
  let _ : unit = (string_println : (string) -> unit)((point_to_string : (Point) -> string)((a/21 : Point))) in
  ()
}