fn double(x/0: int) -> int {
  int_mul(x/0, 2)
}

fn increment(x/1: int) -> int {
  int_add(x/1, 1)
}

fn make(adder/2: int) -> (int) -> int {
  ClosureEnv0 { adder_2_0: adder/2 }
}

fn chooser(flag/4: bool) -> (int) -> int {
  if flag/4 {
    double
  } else {
    increment
  }
}

fn main() -> unit {
  let t9 = chooser(true) in
  let result_direct/5 = t9(3) in
  let chosen/6 = chooser(false) in
  let result_from_var/7 = chosen/6(4) in
  let apply/10 = ClosureEnv1 {} in
  let t10 = make(5) in
  let closure_call/11 = __closure_apply7(apply/10, t10, 1) in
  let t11 = make(6) in
  let composed/12 = t11(2) in
  let generator/13 = make(7) in
  let from_generator/14 = generator/13(3) in
  let printer/15 = string_println in
  let t12 = int_to_string(result_direct/5) in
  let mtmp0 = printer/15(t12) in
  let t13 = int_to_string(result_from_var/7) in
  let mtmp1 = printer/15(t13) in
  let t14 = int_to_string(closure_call/11) in
  let mtmp2 = printer/15(t14) in
  let t15 = int_to_string(composed/12) in
  let mtmp3 = printer/15(t15) in
  let t16 = int_to_string(from_generator/14) in
  let mtmp4 = printer/15(t16) in
  ()
}

fn __closure_apply5(env6: ClosureEnv0, value/3: int) -> int {
  let adder/2 = ClosureEnv0.adder_2_0(env6) in
  int_add(value/3, adder/2)
}

fn __closure_apply7(env8: ClosureEnv1, f/8: (int) -> int, value/9: int) -> int {
  f/8(value/9)
}