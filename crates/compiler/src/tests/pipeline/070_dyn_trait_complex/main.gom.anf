fn trait_impl#Display#Point#show(self/0: Point) -> string {
  let t17 = Point.x(self/0) in
  let t16 = int32_to_string(t17) in
  let t15 = ("Point(" + t16) in
  let t14 = (t15 + ",") in
  let t19 = Point.y(self/0) in
  let t18 = int32_to_string(t19) in
  let t13 = (t14 + t18) in
  (t13 + ")")
}

fn trait_impl#Display#Point#show_with(self/1: Point, prefix/2: string, suffix/3: string) -> string {
  let t24 = (prefix/2 + "Point(") in
  let t26 = Point.x(self/1) in
  let t25 = int32_to_string(t26) in
  let t23 = (t24 + t25) in
  let t22 = (t23 + ",") in
  let t28 = Point.y(self/1) in
  let t27 = int32_to_string(t28) in
  let t21 = (t22 + t27) in
  let t20 = (t21 + ")") in
  (t20 + suffix/3)
}

fn trait_impl#Display#Point#tick(self/4: Point) -> unit {
  ()
}

fn trait_impl#Display#Point#bump(self/5: Point, delta/6: int32) -> int32 {
  let t30 = Point.x(self/5) in
  let t31 = Point.y(self/5) in
  let t29 = (t30 + t31) in
  (t29 + delta/6)
}

fn trait_impl#Display#Flag#show(self/7: Flag) -> string {
  let t32 = Flag.value(self/7) in
  if t32 {
    "Flag(true)"
  } else {
    "Flag(false)"
  }
}

fn trait_impl#Display#Flag#show_with(self/8: Flag, prefix/9: string, suffix/10: string) -> string {
  let t33 = Flag.value(self/8) in
  if t33 {
    let t34 = (prefix/9 + "Flag(true)") in
    (t34 + suffix/10)
  } else {
    let t35 = (prefix/9 + "Flag(false)") in
    (t35 + suffix/10)
  }
}

fn trait_impl#Display#Flag#tick(self/11: Flag) -> unit {
  ()
}

fn trait_impl#Display#Flag#bump(self/12: Flag, delta/13: int32) -> int32 {
  let t36 = Flag.value(self/12) in
  if t36 {
    delta/13
  } else {
    (-delta/13)
  }
}

fn trait_impl#Display#Counter#show(self/14: Counter) -> string {
  let t40 = Counter.cell(self/14) in
  let t39 = ref_get(t40) in
  let t38 = int32_to_string(t39) in
  let t37 = ("Counter(" + t38) in
  (t37 + ")")
}

fn trait_impl#Display#Counter#show_with(self/15: Counter, prefix/16: string, suffix/17: string) -> string {
  let t43 = (prefix/16 + "Counter(") in
  let t46 = Counter.cell(self/15) in
  let t45 = ref_get(t46) in
  let t44 = int32_to_string(t45) in
  let t42 = (t43 + t44) in
  let t41 = (t42 + ")") in
  (t41 + suffix/17)
}

fn trait_impl#Display#Counter#tick(self/18: Counter) -> unit {
  let t48 = Counter.cell(self/18) in
  let t47 = ref_get(t48) in
  let next/19 = (t47 + 1) in
  let t49 = Counter.cell(self/18) in
  let mtmp0 = ref_set(t49, next/19) in
  ()
}

fn trait_impl#Display#Counter#bump(self/20: Counter, delta/21: int32) -> int32 {
  let t51 = Counter.cell(self/20) in
  let t50 = ref_get(t51) in
  let next/22 = (t50 + delta/21) in
  let t52 = Counter.cell(self/20) in
  let mtmp1 = ref_set(t52, next/22) in
  next/22
}

fn show_dyn(x/23: dyn Display) -> string {
  dyn_call[Display::show_with](x/23, "<", ">")
}

fn call_via_closure(x/24: dyn Display, tag/25: string) -> string {
  let f/28 = closure_env_f_0 {} in
  inherent#closure_env_f_0#closure_env_f_0#apply(f/28, x/24, tag/25)
}

fn make_renderer(tag/29: string) -> closure_env_make_renderer_1 {
  closure_env_make_renderer_1 { tag_0: tag/29 }
}

fn bump_and_show(x/31: dyn Display, delta/32: int32) -> string {
  let mtmp2 = dyn_call[Display::tick](x/31) in
  let t54 = dyn_call[Display::show_with](x/31, "[", "]") in
  let t53 = (t54 + ":") in
  let t56 = dyn_call[Display::bump](x/31, delta/32) in
  let t55 = int32_to_string(t56) in
  (t53 + t55)
}

fn main() -> unit {
  let p1/33 = Point { x: 1, y: 2 } in
  let p2/34 = Point { x: 3, y: 4 } in
  let f1/35 = Flag { value: true } in
  let f2/36 = Flag { value: false } in
  let t57 = ref(10) in
  let c/37 = Counter { cell: t57 } in
  let dp1/38 = to_dyn[Display]{Point}(p1/33) in
  let dp2/39 = to_dyn[Display]{Point}(p2/34) in
  let df1/40 = to_dyn[Display]{Flag}(f1/35) in
  let df2/41 = to_dyn[Display]{Flag}(f2/36) in
  let dc/42 = to_dyn[Display]{Counter}(c/37) in
  let render_star/43 = make_renderer("*") in
  let render_angle/44 = make_renderer("<") in
  let s0/45 = show_dyn(dp2/39) in
  let s1/46 = call_via_closure(df2/41, "*") in
  let t59 = inherent#closure_env_make_renderer_1#closure_env_make_renderer_1#apply(render_star/43, dp1/38) in
  let t58 = (t59 + "|") in
  let t60 = inherent#closure_env_make_renderer_1#closure_env_make_renderer_1#apply(render_angle/44, df1/40) in
  let s2/47 = (t58 + t60) in
  let v/48 = vec_new() in
  let v/49 = vec_push(v/48, dp1/38) in
  let v/50 = vec_push(v/49, df1/40) in
  let v/51 = vec_push(v/50, dc/42) in
  let vlen/52 = vec_len(v/51) in
  let delta/53 = match vlen/52 {
    2 => {
      3
    },
    _ => 5,
  } in
  let mtmp3 = string_println(s0/45) in
  let mtmp4 = string_println(s1/46) in
  let mtmp5 = string_println(s2/47) in
  let i/54 = ref(0) in
  let mtmp8 = while let t61 = ref_get(i/54) in
  (t61 < 3) {
    let line/55 = bump_and_show(dc/42, delta/53) in
    let _wild6 = string_println(line/55) in
    let t63 = ref_get(i/54) in
    let t62 = (t63 + 1) in
    let mtmp7 = ref_set(i/54, t62) in
    ()
  } in
  let t65 = int32_to_string(vlen/52) in
  let t64 = ("len:" + t65) in
  let mtmp9 = string_println(t64) in
  let t67 = int32_to_string(delta/53) in
  let t66 = ("delta:" + t67) in
  let mtmp10 = string_println(t66) in
  ()
}

fn inherent#closure_env_f_0#closure_env_f_0#apply(env11: closure_env_f_0, v/26: dyn Display, t/27: string) -> string {
  dyn_call[Display::show_with](v/26, t/27, t/27)
}

fn inherent#closure_env_make_renderer_1#closure_env_make_renderer_1#apply(env12: closure_env_make_renderer_1, x/30: dyn Display) -> string {
  let tag/29 = closure_env_make_renderer_1.tag_0(env12) in
  dyn_call[Display::show_with](x/30, tag/29, tag/29)
}