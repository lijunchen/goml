fn impl_inherent_Point_to_string(self/0: Point) -> string {
  let mtmp0 = self/0 in
  let x1 = Point.x(mtmp0) in
  let x2 = Point.y(mtmp0) in
  let y/2 = x2 in
  let x/1 = x1 in
  (((((("Point { " + "x: ") + int32_to_string(x/1)) + ", ") + "y: ") + int32_to_string(y/2)) + " }")
}

fn impl_inherent_Message_to_string(self/3: Message) -> string {
  match self/3 {
    Message::Quit => {
      "Message::Quit"
    },
    Message::Move(x3, x4) => {
      let x3 = Message::Move._0(self/3) in
      let x4 = Message::Move._1(self/3) in
      let __field1/5 = x4 in
      let __field0/4 = x3 in
      (((("Message::Move(" + int32_to_string(__field0/4)) + ", ") + int32_to_string(__field1/5)) + ")")
    },
    Message::Write(x5) => {
      let x5 = Message::Write._0(self/3) in
      let __field0/6 = x5 in
      (("Message::Write(" + __field0/6) + ")")
    },
  }
}

fn main() -> unit {
  let point/7 = Point { x: 4, y: 7 } in
  let summary/8 = impl_inherent_Point_to_string(point/7) in
  let mv/9 = impl_inherent_Message_to_string(Message::Move(1, 2)) in
  let text/10 = impl_inherent_Message_to_string(Message::Write("done")) in
  let exit/11 = impl_inherent_Message_to_string(Message::Quit) in
  let mtmp6 = string_println(summary/8) in
  let mtmp7 = string_println(mv/9) in
  let mtmp8 = string_println(text/10) in
  let mtmp9 = string_println(exit/11) in
  ()
}