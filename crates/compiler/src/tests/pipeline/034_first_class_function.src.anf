fn double(x/0: int) -> int {
  int_mul(x/0, 2)
}

fn increment(x/1: int) -> int {
  int_add(x/1, 1)
}

fn apply_once(f/2: (int) -> int, value/3: int) -> int {
  f/2(value/3)
}

fn compose(f/4: (int) -> int, g/5: (int) -> int, value/6: int) -> int {
  let t10 = g/5(value/6) in
  f/4(t10)
}

fn main() -> unit {
  let local/7 = double in
  let first/8 = apply_once(local/7, 4) in
  let composed/9 = compose(double, increment, first/8) in
  let closure_apply/11 = ClosureEnv0 {} in
  let closure_result/12 = __closure_apply4(closure_apply/11, composed/9) in
  let global_invoker/15 = ClosureEnv1 {} in
  let invoked_with_global/16 = __closure_apply6(global_invoker/15, double, 3) in
  let composer_closure/18 = ClosureEnv2 {} in
  let composed_by_closure/19 = __closure_apply8(composer_closure/18, 5) in
  let printer/20 = string_println in
  let t11 = int_to_string(composed/9) in
  let mtmp0 = printer/20(t11) in
  let t12 = int_to_string(closure_result/12) in
  let mtmp1 = printer/20(t12) in
  let t13 = int_to_string(invoked_with_global/16) in
  let mtmp2 = printer/20(t13) in
  let t14 = int_to_string(composed_by_closure/19) in
  let mtmp3 = printer/20(t14) in
  ()
}

fn __closure_apply4(env5: ClosureEnv0, value/10: int) -> int {
  apply_once(increment, value/10)
}

fn __closure_apply6(env7: ClosureEnv1, func_to_call/13: (int) -> int, value/14: int) -> int {
  apply_once(func_to_call/13, value/14)
}

fn __closure_apply8(env9: ClosureEnv2, value/17: int) -> int {
  compose(double, increment, value/17)
}