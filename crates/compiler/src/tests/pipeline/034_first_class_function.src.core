fn double(x/0: int) -> int {
  int_mul(x/0, 2)
}

fn increment(x/1: int) -> int {
  int_add(x/1, 1)
}

fn apply_once(f/2: (int) -> int, value/3: int) -> int {
  f/2(value/3)
}

fn compose(f/4: (int) -> int, g/5: (int) -> int, value/6: int) -> int {
  f/4(g/5(value/6))
}

fn main() -> unit {
  let local/7 = double in
  let first/8 = apply_once(local/7, 4) in
  let composed/9 = compose(double, increment, first/8) in
  let closure_apply/11 = |value/10: int| => apply_once(increment, value/10) in
  let closure_result/12 = closure_apply/11(composed/9) in
  let global_invoker/15 = |func_to_call/13: (int) -> int, value/14: int| => apply_once(func_to_call/13, value/14) in
  let invoked_with_global/16 = global_invoker/15(double, 3) in
  let composer_closure/18 = |value/17: int| => compose(double, increment, value/17) in
  let composed_by_closure/19 = composer_closure/18(5) in
  let printer/20 = string_println in
  let mtmp0 = printer/20(int_to_string(composed/9)) in
  let mtmp1 = printer/20(int_to_string(closure_result/12)) in
  let mtmp2 = printer/20(int_to_string(invoked_with_global/16)) in
  let mtmp3 = printer/20(int_to_string(composed_by_closure/19)) in
  ()
}