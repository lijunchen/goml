fn test() -> unit {
  let y/0 = 3 in
  let z/1 = 5 in
  let f/3 = ClosureEnv0 { y_0_0: y/0, z_1_1: z/1 } in
  let mtmp0 = string_println(int_to_string(__closure_apply4(f/3, 2))) in
  string_println(int_to_string(__closure_apply4(f/3, 3)))
}

fn call_int_id(f/4: (int) -> int, v/5: int) -> int {
  f/4(v/5)
}

fn main() -> unit {
  let base/6 = 5 in
  let add_base/8 = ClosureEnv1 { base_6_0: base/6 } in
  let result/9 = __closure_apply6(add_base/8, 7) in
  let printer/13 = ClosureEnv2 {} in
  let mtmp1 = __closure_apply8(printer/13, "result: ", result/9) in
  let unused/15 = ClosureEnv3 { result_9_0: result/9 } in
  let no_capture/17 = ClosureEnv4 {} in
  let doubled/18 = __closure_apply12(no_capture/17, 3) in
  let mtmp2 = string_println(int_to_string(doubled/18)) in
  let mtmp3 = test() in
  ()
}

fn __closure_apply4(env5: ClosureEnv0, x/2: int) -> int {
  let y/0 = ClosureEnv0.y_0_0(env5) in
  let z/1 = ClosureEnv0.z_1_1(env5) in
  int_mul(int_mul(x/2, y/0), z/1)
}

fn __closure_apply6(env7: ClosureEnv1, x/7: int) -> int {
  let base/6 = ClosureEnv1.base_6_0(env7) in
  int_add(x/7, base/6)
}

fn __closure_apply8(env9: ClosureEnv2, prefix/10: string, value/11: int) -> unit {
  let message/12 = string_add(prefix/10, int_to_string(value/11)) in
  string_println(message/12)
}

fn __closure_apply10(env11: ClosureEnv3, y/14: int) -> int {
  let result/9 = ClosureEnv3.result_9_0(env11) in
  int_add(y/14, result/9)
}

fn __closure_apply12(env13: ClosureEnv4, z/16: int) -> int {
  int_mul(z/16, 2)
}