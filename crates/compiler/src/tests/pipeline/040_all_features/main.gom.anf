fn impl_Describe_Tracker_describe(self/0: Tracker) -> string {
  let mtmp0 = self/0 in
  let x1 = Tracker.label(mtmp0) in
  let x2 = Tracker.count(mtmp0) in
  let x3 = Tracker.toggled(mtmp0) in
  let toggled/3 = x3 in
  let count/2 = x2 in
  let label/1 = x1 in
  let current/4 = ref_get(count/2) in
  let flag/5 = ref_get(toggled/3) in
  let with_label/6 = ("Tracker(" + label/1) in
  let with_count_label/7 = (with_label/6 + ", count: ") in
  let t35 = int32_to_string(current/4) in
  let with_count/8 = (with_count_label/7 + t35) in
  let with_flag_label/9 = (with_count/8 + ", toggled: ") in
  let t37 = bool_to_string(flag/5) in
  let t36 = (with_flag_label/9 + t37) in
  (t36 + ")")
}

fn impl_Describe_Record_int32_describe(self/10: Record__int32) -> string {
  match self/10 {
    Tag_0 => {
      let x4 = Record__int32::Value._0(self/10) in
      let value/11 = x4 in
      let t39 = int32_to_string(value/11) in
      let t38 = ("Value(" + t39) in
      (t38 + ")")
    },
    Tag_1 => {
      let x5 = Record__int32::Pair._0(self/10) in
      let x6 = Record__int32::Pair._1(self/10) in
      let after/13 = x6 in
      let before/12 = x5 in
      let t40 = int32_to_string(before/12) in
      let prefix/14 = ("Pair(" + t40) in
      let t42 = (prefix/14 + ", ") in
      let t43 = int32_to_string(after/13) in
      let t41 = (t42 + t43) in
      (t41 + ")")
    },
    Tag_2 => {
      "Empty"
    },
  }
}

fn impl_Describe_Record_string_describe(self/15: Record__string) -> string {
  match self/15 {
    Tag_0 => {
      let x7 = Record__string::Value._0(self/15) in
      let text/16 = x7 in
      let t44 = ("Value(" + text/16) in
      (t44 + ")")
    },
    Tag_1 => {
      let x8 = Record__string::Pair._0(self/15) in
      let x9 = Record__string::Pair._1(self/15) in
      let after/18 = x9 in
      let before/17 = x8 in
      let prefix/19 = ("Pair(" + before/17) in
      let t46 = (prefix/19 + ", ") in
      let t45 = (t46 + after/18) in
      (t45 + ")")
    },
    Tag_2 => {
      "Empty"
    },
  }
}

fn format_total(total/26: int32) -> string {
  let t47 = int32_to_string(total/26) in
  ("total: " + t47)
}

fn increment(value/27: int32) -> int32 {
  (value/27 + 1)
}

fn triple(value/28: int32) -> int32 {
  (value/28 * 3)
}

fn pair_join(parts/29: (string, string)) -> string {
  let mtmp11 = parts/29 in
  let x12 = mtmp11.0 in
  let x13 = mtmp11.1 in
  let right/31 = x13 in
  let left/30 = x12 in
  let t48 = (left/30 + " -> ") in
  (t48 + right/31)
}

fn run_transforms(value/32: int32, transforms/33: [(int32) -> int32; 2]) -> [int32; 2] {
  let first/34 = array_get(transforms/33, 0) in
  let second/35 = array_get(transforms/33, 1) in
  let first_result/36 = first/34(value/32) in
  let second_result/37 = second/35(first_result/36) in
  let t49 = [first_result/36, value/32] in
  array_set(t49, 1, second_result/37)
}

fn gather(record/38: Record__int32) -> Maybe__int32 {
  match record/38 {
    Tag_0 => {
      let x14 = Record__int32::Value._0(record/38) in
      let value/39 = x14 in
      Maybe__int32::Some(value/39)
    },
    Tag_1 => {
      let x15 = Record__int32::Pair._0(record/38) in
      let x16 = Record__int32::Pair._1(record/38) in
      let after/40 = x16 in
      Maybe__int32::Some(after/40)
    },
    Tag_2 => {
      Tag_1
    },
  }
}

fn build_counter(label/41: string, start/42: int32) -> (Tracker, closure_env_snapshot_0, closure_env_bump_1, closure_env_flip_2) {
  let count/43 = ref(start/42) in
  let toggled/44 = ref(false) in
  let tracker/45 = Tracker { label: label/41, count: count/43, toggled: toggled/44 } in
  let snapshot/46 = closure_env_snapshot_0 { count_0: count/43 } in
  let bump/49 = closure_env_bump_1 { count_0: count/43 } in
  let flip/52 = closure_env_flip_2 { toggled_0: toggled/44 } in
  (tracker/45, snapshot/46, bump/49, flip/52)
}

fn main() -> unit {
  let mtmp19 = build_counter("goml", 2) in
  let x20 = mtmp19.0 in
  let x21 = mtmp19.1 in
  let x22 = mtmp19.2 in
  let x23 = mtmp19.3 in
  let flip/56 = x23 in
  let bump/55 = x22 in
  let snapshot/54 = x21 in
  let tracker/53 = x20 in
  let tracker_info/57 = impl_Describe_Tracker_describe(tracker/53) in
  let first_record/58 = impl_inherent_closure_env_snapshot_0_apply(snapshot/54) in
  let bumped_record/59 = impl_inherent_closure_env_bump_1_apply(bump/55, 5) in
  let flipped_record/60 = impl_inherent_closure_env_flip_2_apply(flip/56) in
  let maybe_first/61 = gather(first_record/58) in
  let maybe_second/62 = gather(bumped_record/59) in
  let chosen/63 = choose__T_Maybe_int32(true, maybe_second/62, maybe_first/61) in
  let stringified/64 = map_maybe__T_int32__U_string(chosen/63, format_total) in
  let transforms/65 = [increment, triple] in
  let results/66 = run_transforms(4, transforms/65) in
  let first_result/67 = array_get(results/66, 0) in
  let second_result/68 = array_get(results/66, 1) in
  let t50 = (first_result/67 < second_result/68) in
  let order_check/69 = (t50 && true) in
  let first_text/70 = impl_Describe_Record_int32_describe(first_record/58) in
  let bumped_text/71 = impl_Describe_Record_int32_describe(bumped_record/59) in
  let flipped_text/72 = impl_Describe_Record_string_describe(flipped_record/60) in
  let summary/74 = match stringified/64 {
    Tag_0 => {
      let x24 = Maybe__string::Some._0(stringified/64) in
      let text/73 = x24 in
      ("Snapshot: " + text/73)
    },
    Tag_1 => {
      "Snapshot: none"
    },
  } in
  let t52 = int32_to_string(first_result/67) in
  let t53 = int32_to_string(second_result/68) in
  let t51 = (t52, t53) in
  let pair_text/75 = pair_join(t51) in
  let bool_text/76 = bool_to_string(order_check/69) in
  let mtmp25 = string_println(tracker_info/57) in
  let mtmp26 = string_println(first_text/70) in
  let mtmp27 = string_println(bumped_text/71) in
  let mtmp28 = string_println(flipped_text/72) in
  let mtmp29 = string_println(summary/74) in
  let mtmp30 = string_println(pair_text/75) in
  let mtmp31 = string_println(bool_text/76) in
  ()
}

fn choose__T_Maybe_int32(flag/20: bool, when_true/21: Maybe__int32, when_false/22: Maybe__int32) -> Maybe__int32 {
  if flag/20 {
    when_true/21
  } else {
    when_false/22
  }
}

fn map_maybe__T_int32__U_string(value/23: Maybe__int32, f/24: (int32) -> string) -> Maybe__string {
  match value/23 {
    Tag_0 => {
      let x10 = Maybe__int32::Some._0(value/23) in
      let inner/25 = x10 in
      let t54 = f/24(inner/25) in
      Maybe__string::Some(t54)
    },
    Tag_1 => {
      Tag_1
    },
  }
}

fn impl_inherent_closure_env_snapshot_0_apply(env32: closure_env_snapshot_0) -> Record__int32 {
  let count/43 = closure_env_snapshot_0.count_0(env32) in
  let t55 = ref_get(count/43) in
  Record__int32::Value(t55)
}

fn impl_inherent_closure_env_bump_1_apply(env33: closure_env_bump_1, delta/47: int32) -> Record__int32 {
  let count/43 = closure_env_bump_1.count_0(env33) in
  let before/48 = ref_get(count/43) in
  let t56 = (before/48 + delta/47) in
  let mtmp17 = ref_set(count/43, t56) in
  let t57 = ref_get(count/43) in
  Record__int32::Pair(before/48, t57)
}

fn impl_inherent_closure_env_flip_2_apply(env34: closure_env_flip_2) -> Record__string {
  let toggled/44 = closure_env_flip_2.toggled_0(env34) in
  let before/50 = ref_get(toggled/44) in
  let t58 = (!before/50) in
  let mtmp18 = ref_set(toggled/44, t58) in
  let after/51 = ref_get(toggled/44) in
  let t59 = bool_to_string(before/50) in
  let t60 = bool_to_string(after/51) in
  Record__string::Pair(t59, t60)
}