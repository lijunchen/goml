fn make_counter() -> (closure_env_next_0, closure_env_reset_1) {
  let cell/0 = ref(0) in
  let next/2 = closure_env_next_0 { cell_0: cell/0 } in
  let reset/3 = closure_env_reset_1 { cell_0: cell/0 } in
  (next/2, reset/3)
}

fn main() -> unit {
  let counter/4 = make_counter() in
  let mtmp2 = counter/4 in
  let x3 = mtmp2.0 in
  let x4 = mtmp2.1 in
  let reset/6 = x4 in
  let next/5 = x3 in
  let first/7 = inherent#closure_env_next_0#closure_env_next_0#apply(next/5) in
  let second/8 = inherent#closure_env_next_0#closure_env_next_0#apply(next/5) in
  let mtmp5 = inherent#closure_env_reset_1#closure_env_reset_1#apply(reset/6) in
  let third/9 = inherent#closure_env_next_0#closure_env_next_0#apply(next/5) in
  let new_counter/10 = make_counter() in
  let mtmp6 = new_counter/10 in
  let x7 = mtmp6.0 in
  let x8 = mtmp6.1 in
  let new_next/11 = x7 in
  let fourth/12 = inherent#closure_env_next_0#closure_env_next_0#apply(new_next/11) in
  let t15 = int32_to_string(first/7) in
  let mtmp9 = string_println(t15) in
  let t16 = int32_to_string(second/8) in
  let mtmp10 = string_println(t16) in
  let t17 = int32_to_string(third/9) in
  let mtmp11 = string_println(t17) in
  let t18 = int32_to_string(fourth/12) in
  let mtmp12 = string_println(t18) in
  ()
}

fn inherent#closure_env_next_0#closure_env_next_0#apply(env13: closure_env_next_0) -> int32 {
  let cell/0 = closure_env_next_0.cell_0(env13) in
  let t19 = ref_get(cell/0) in
  let next/1 = (t19 + 1) in
  let mtmp0 = ref_set(cell/0, next/1) in
  next/1
}

fn inherent#closure_env_reset_1#closure_env_reset_1#apply(env14: closure_env_reset_1) -> unit {
  let cell/0 = closure_env_reset_1.cell_0(env14) in
  let mtmp1 = ref_set(cell/0, 0) in
  ()
}