fn double(x: int32) -> int32 {
    x * 2
}

fn increment(x: int32) -> int32 {
    x + 1
}

fn apply_once(f: (int32) -> int32, value: int32) -> int32 {
    f(value)
}

fn compose(f: (int32) -> int32, g: (int32) -> int32, value: int32) -> int32 {
    f(g(value))
}

fn main() {
    let local = double in
    let first = apply_once(local, 4) in
    let composed = compose(double, increment, first) in
    let closure_apply = |value: int32| apply_once(increment, value) in
    let closure_result = closure_apply(composed) in
    let global_invoker = |func_to_call: (int32) -> int32, value: int32| apply_once(func_to_call, value) in
    let invoked_with_global = global_invoker(double, 3) in
    let composer_closure = |value: int32| compose(double, increment, value) in
    let composed_by_closure = composer_closure(5) in
    let printer = string_println in
    let _ = printer(int_to_string(composed)) in
    let _ = printer(int_to_string(closure_result)) in
    let _ = printer(int_to_string(invoked_with_global)) in
    let _ = printer(int_to_string(composed_by_closure)) in
    ()
}

