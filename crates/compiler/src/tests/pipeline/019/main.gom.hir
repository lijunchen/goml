struct Point { x: int32, y: int32 }

struct Wrapper[T0] { value: T0 }

fn make_point() -> Point {
  Point { x: 0, y: 0 }
}

fn flip(local_0: Point) -> Point {
  let Point { x: local_1, y: local_2 } = local_0 in
  Point { y: local_1, x: local_2 }
}

fn wrap_int(local_0: int32) -> Wrapper[int32] {
  Wrapper { value: local_0 }
}

fn x_add_1(local_0: Point) -> Point {
  let Point { x: local_1, y: local_2 } = local_0 in
  Point { x: local_1 + 1, y: local_2 }
}

fn get_x(local_0: Point) -> int32 {
  let Point { x: local_1, y: local_2 } = local_0 in
  local_1
}

fn get_y(local_0: Point) -> int32 {
  let Point { x: local_1, y: local_2 } = local_0 in
  local_2
}

fn point32_to_string(local_0: Point) -> string {
  let Point { x: local_1, y: local_2 } = local_0 in
  "Point { x: " + int32_to_string(local_1) + ", y: " + int32_to_string(local_2) + "}"
}

fn point32_to_string2(local_0: Point) -> string {
  let Point { x: local_1, y: local_2 } = local_0 in
  "Point { x: " + int32_to_string(local_1) + ", y: " + int32_to_string(local_2) + "}"
}

fn point32_to_string3(local_0: Point) -> string {
  let Point { x: local_1, y: local_2 } = local_0 in
  "Point { x: " + int32_to_string(local_1) + ", y: " + int32_to_string(local_2) + "}"
}

fn point32_to_string4(local_0: Point) -> string {
  let Point { x: local_1, y: local_2 } = local_0 in
  "Point { x: " + int32_to_string(local_1) + ", y: " + int32_to_string(local_2) + "}"
}

fn main() -> () {
  let local_0 = make_point() in
  let _ = string_println(point32_to_string(local_0)) in
  let local_1 = flip(Point { y: 2, x: 1 }) in
  let _ = string_println(point32_to_string2(local_1)) in
  let local_2 = wrap_int(3) in
  let local_3 = Wrapper { value: local_1 } in
  let local_4 = x_add_1(local_0) in
  let _ = string_println(point32_to_string3(local_4)) in
  let local_5 = flip(x_add_1(local_0)) in
  let _ = string_println(point32_to_string4(local_5)) in
  ()
}