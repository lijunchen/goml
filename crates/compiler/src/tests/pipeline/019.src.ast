struct Point {
    x: int32,
    y: int32,
}

struct Wrapper[T] {
    value: T,
}

fn make_point() -> Point {
    Point {
        x: 0,
        y: 0
    }
}

fn flip(point: Point) -> Point {
    let Point { x: x, y: y } = point in
    Point {
        y: x,
        x: y
    }
}

fn wrap_int(x: int32) -> Wrapper[int32] {
    Wrapper {
        value: x
    }
}

fn x_add_1(p: Point) -> Point {
    let Point { x: x, y: y } = p in
    Point {
        x: x + 1,
        y: y
    }
}

fn get_x(p: Point) -> int32 {
    let Point { x: x, y: y } = p in
    x
}

fn get_y(p: Point) -> int32 {
    let Point { x: x, y: y } = p in
    y
}

fn point32_to_string(p: Point) -> string {
    let Point { x: x, y: y } = p in
    string_add(string_add(string_add("Point { x: ", int32_to_string(x)), string_add(", y: ", int32_to_string(y))), "}")
}

fn point32_to_string2(p: Point) -> string {
    let Point { x: x, y: y } = p in
    string_add(string_add(string_add("Point { x: ", int32_to_string(x)), string_add(", y: ", int32_to_string(y))), "}")
}

fn point32_to_string3(p: Point) -> string {
    let Point { x: x, y: y } = p in
    string_add(string_add(string_add("Point { x: ", int32_to_string(x)), string_add(", y: ", int32_to_string(y))), "}")
}

fn point32_to_string4(p: Point) -> string {
    let Point { x: x, y: y } = p in
    string_add(string_add(string_add("Point { x: ", int32_to_string(x)), string_add(", y: ", int32_to_string(y))), "}")
}

fn main() {
    let start = make_point() in
    let _ = string_println(point32_to_string(start)) in
    let swapped = flip(Point {
          y: 2,
          x: 1
      }) in
    let _ = string_println(point32_to_string2(swapped)) in
    let boxed = wrap_int(3) in
    let point_box = Wrapper {
        value: swapped
    } in
    let a = x_add_1(start) in
    let _ = string_println(point32_to_string3(a)) in
    let a = flip(x_add_1(start)) in
    let _ = string_println(point32_to_string4(a)) in
    ()
}

