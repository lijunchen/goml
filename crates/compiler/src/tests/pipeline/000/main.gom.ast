package Main
#[derive(ToString)]
enum Color {
    Red,
    Green,
    Blue
}

impl Color {
  fn to_string(self: Color) -> string {
    match self {
        Color::Red => "Color::Red",
        Color::Green => "Color::Green",
        Color::Blue => "Color::Blue",
    }
  }
}

#[derive(ToString)]
struct Point {
    x: int32,
    y: int32,
    color: Color,
}

impl Point {
  fn to_string(self: Point) -> string {
    let Point { x: x, y: y, color: color } = self;
    "Point { " + "x: " + x.to_string() + ", " + "y: " + y.to_string() + ", " + "color: " + color.to_string() + " }";
  }
}

impl Point {
  fn new(x: int32, y: int32, color: Color) -> Point {
    Point {
        x: x,
        y: y,
        color: color
    };
  }
}

#[derive(ToString)]
struct Line {
    from: Point,
    to: Point,
    color: Color,
}

impl Line {
  fn to_string(self: Line) -> string {
    let Line { from: from, to: to, color: color } = self;
    "Line { " + "from: " + from.to_string() + ", " + "to: " + to.to_string() + ", " + "color: " + color.to_string() + " }";
  }
}

impl Line {
  fn new(from: Point, to: Point, color: Color) -> Line {
    Line {
        from: from,
        to: to,
        color: color
    };
  }
}

#[derive(ToString)]
enum LineList {
    Nil,
    Cons(Line, LineList)
}

impl LineList {
  fn to_string(self: LineList) -> string {
    match self {
        LineList::Nil => "LineList::Nil",
        LineList::Cons(__field0, __field1) => "LineList::Cons(" + __field0.to_string() + ", " + __field1.to_string() + ")",
    }
  }
}

fn main() {
  let from = Point::new(10, 20, Color::Red);
  let to = Point::new(30, 40, Color::Green);
  let line = Line::new(from, to, Color::Blue);
  let lines = LineList::Cons(line, LineList::Nil);
  string_println(lines.to_string());
  ();
}

