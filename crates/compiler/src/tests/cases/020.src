struct Point {
    x: Int,
    y: Int,
}

struct Wrapper[T] {
    value: T,
}

enum Shape[T] {
    Dot(Point),
    Wrapped(Wrapper[T]),
    Origin,
}

fn bounce_int(shape: Shape[Int]) -> Shape[Int] {
    match shape {
        Dot(point) => Dot(point),
        Wrapped(inner) => Wrapped(inner),
        Origin => Origin,
    }
}

fn wrap_unit(value: Wrapper[Unit]) -> Shape[Unit] {
    Wrapped(value)
}

fn pick(flag: Bool, point: Point, wrapper: Wrapper[Int]) -> Shape[Int] {
    match flag {
        true => Dot(point),
        false => Wrapped(wrapper),
    }
}

fn describe[T](shape: Shape[T]) -> Int {
    match shape {
        Dot(_) => 1,
        Wrapped(_) => 2,
        Origin => 0,
    }
}

fn point_to_string() -> String {
    "Point { x: Int, y: Int }"
}

fn wrapper_int_to_string() -> String {
    "Wrapper[Int]"
}

fn wrapper_unit_to_string() -> String {
    "Wrapper[Unit]"
}

fn shape_int_to_string(shape: Shape[Int]) -> String {
    match shape {
        Dot(_) => "Shape::Dot",
        Wrapped(_) => "Shape::Wrapped",
        Origin => "Shape::Origin",
    }
}

fn shape_unit_to_string(shape: Shape[Unit]) -> String {
    match shape {
        Dot(_) => "Shape::Dot",
        Wrapped(_) => "Shape::Wrapped",
        Origin => "Shape::Origin",
    }
}

fn main() {
    let _ = string_println(point_to_string()) in
    let _ = string_println(wrapper_int_to_string()) in
    let _ = string_println(wrapper_unit_to_string()) in

    let bounced_origin = bounce_int(Origin) in
    let _ = string_println(shape_int_to_string(bounced_origin)) in
    let _ = string_println(shape_int_to_string(Origin)) in
    let _ = string_println(shape_unit_to_string(Origin)) in

    let _ = describe(bounce_int(Origin)) in
    string_println("struct enums!")
}
