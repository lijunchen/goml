fn bounce_int(shape/0: Shape[Int]) -> Shape[Int] {
  match (shape/0 : Shape[Int]) {
      Shape::Dot(point/1: Point) => Shape::Dot((point/1 : Point)),
      Shape::Wrapped(inner/2: Wrapper[Int]) => Shape::Wrapped((inner/2 : Wrapper[Int])),
      Shape::Origin => Shape::Origin,
  }
}

fn wrap_unit(value/3: Wrapper[Unit]) -> Shape[Unit] {
  Shape::Wrapped((value/3 : Wrapper[Unit]))
}

fn pick(flag/4: Bool, point/5: Point, wrapper/6: Wrapper[Int]) -> Shape[Int] {
  match (flag/4 : Bool) {
      true => Shape::Dot((point/5 : Point)),
      false => Shape::Wrapped((wrapper/6 : Wrapper[Int])),
  }
}

fn describe(shape/7: Shape[T]) -> Int {
  match (shape/7 : Shape[T]) {
      Shape::Dot(_ : Point) => 1,
      Shape::Wrapped(_ : Wrapper[T]) => 2,
      Shape::Origin => 0,
  }
}

fn point_to_string() -> String {
  "Point { x: Int, y: Int }"
}

fn wrapper_int_to_string() -> String {
  "Wrapper[Int]"
}

fn wrapper_unit_to_string() -> String {
  "Wrapper[Unit]"
}

fn shape_int_to_string(shape/8: Shape[Int]) -> String {
  match (shape/8 : Shape[Int]) {
      Shape::Dot(_ : Point) => "Shape::Dot",
      Shape::Wrapped(_ : Wrapper[Int]) => "Shape::Wrapped",
      Shape::Origin => "Shape::Origin",
  }
}

fn shape_unit_to_string(shape/9: Shape[Unit]) -> String {
  match (shape/9 : Shape[Unit]) {
      Shape::Dot(_ : Point) => "Shape::Dot",
      Shape::Wrapped(_ : Wrapper[Unit]) => "Shape::Wrapped",
      Shape::Origin => "Shape::Origin",
  }
}

fn main() -> Unit {
  let _ : Unit = string_println(point_to_string()) in
  let _ : Unit = string_println(wrapper_int_to_string()) in
  let _ : Unit = string_println(wrapper_unit_to_string()) in
  let bounced_origin/10: Shape[Int] = bounce_int(Shape::Origin) in
  let _ : Unit = string_println(shape_int_to_string((bounced_origin/10 : Shape[Int]))) in
  let _ : Unit = string_println(shape_int_to_string(Shape::Origin)) in
  let _ : Unit = string_println(shape_unit_to_string(Shape::Origin)) in
  let _ : Int = describe(bounce_int(Shape::Origin)) in
  string_println("struct enums!")
}