fn make_point() -> Point {
  Point { x: 0, y: 0 }
}

fn flip(point/0: Point) -> Point {
  let Point { x: x/1: int, y: y/2: int } = (point/0 : Point) in
  Point { x: (y/2 : int), y: (x/1 : int) }
}

fn wrap_int(x/3: int) -> Wrapper[int] {
  Wrapper { value: (x/3 : int) }
}

fn x_add_1(p/4: Point) -> Point {
  let Point { x: x/5: int, y: y/6: int } = (p/4 : Point) in
  Point { x: int_add((x/5 : int), 1), y: (y/6 : int) }
}

fn get_x(p/7: Point) -> int {
  let Point { x: x/8: int, y: y/9: int } = (p/7 : Point) in
  (x/8 : int)
}

fn get_y(p/10: Point) -> int {
  let Point { x: x/11: int, y: y/12: int } = (p/10 : Point) in
  (y/12 : int)
}

fn point_to_string(p/13: Point) -> string {
  let Point { x: x/14: int, y: y/15: int } = (p/13 : Point) in
  string_add(string_add(string_add("Point { x: ", int_to_string((x/14 : int))), string_add(", y: ", int_to_string((y/15 : int)))), "}")
}

fn main() -> unit {
  let start/16: Point = make_point() in
  let _ : unit = string_println(point_to_string((start/16 : Point))) in
  let swapped/17: Point = flip(Point { x: 1, y: 2 }) in
  let _ : unit = string_println(point_to_string((swapped/17 : Point))) in
  let boxed/18: Wrapper[int] = wrap_int(3) in
  let point_box/19: Wrapper[Point] = Wrapper { value: (swapped/17 : Point) } in
  let a/20: Point = x_add_1((start/16 : Point)) in
  let _ : unit = string_println(point_to_string((a/20 : Point))) in
  let a/21: Point = flip(x_add_1((start/16 : Point))) in
  let _ : unit = string_println(point_to_string((a/21 : Point))) in
  ()
}