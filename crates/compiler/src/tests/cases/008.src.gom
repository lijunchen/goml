package main

import (
    "fmt"
)

func unit_to_string(x struct{}) string {
    return "()"
}

func bool_to_string(x bool) string {
    if x {
        return "true"
    } else {
        return "false"
    }
}

func int_to_string(x int) string {
    return fmt.Sprintf("%d", x)
}

func int_add(x int, y int) int {
    return x + y
}

func int_sub(x int, y int) int {
    return x - y
}

func int_mul(x int, y int) int {
    return x * y
}

func int_div(x int, y int) int {
    return x / y
}

func int_less(x int, y int) bool {
    return x < y
}

func string_add(a string, b string) string {
    return a + b
}

func string_print(s string) struct{} {
    fmt.Print(s)
    return struct{}{}
}

func string_println(s string) struct{} {
    fmt.Println(s)
    return struct{}{}
}

func missing(s string) struct{} {
    println("missing: " + s)
    panic("")
    return struct{}{}
}

type T interface {
    isT()
}

type A struct {}

func (_ A) isT() {}

type B struct {
    _0 bool
    _1 struct{}
}

func (_ B) isT() {}

func main0() struct{} {
    var ret5 struct{}
    var t__0 T = B{
        _0: true,
        _1: struct{}{},
    }
    switch t__0 := t__0.(type) {
    case A:
        var t2 string = int_to_string(1)
        ret5 = string_print(t2)
    case B:
        var x0 bool = t__0._0
        switch x0 {
        case true:
            var t3 string = int_to_string(2)
            ret5 = string_print(t3)
        case false:
            var t4 string = int_to_string(3)
            ret5 = string_print(t4)
        }
    }
    return ret5
}

func main() {
    main0()
}
